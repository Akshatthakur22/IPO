
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model IPO
 * 
 */
export type IPO = $Result.DefaultSelection<Prisma.$IPOPayload>
/**
 * Model GMP
 * 
 */
export type GMP = $Result.DefaultSelection<Prisma.$GMPPayload>
/**
 * Model SubscriptionData
 * 
 */
export type SubscriptionData = $Result.DefaultSelection<Prisma.$SubscriptionDataPayload>
/**
 * Model AllotmentData
 * 
 */
export type AllotmentData = $Result.DefaultSelection<Prisma.$AllotmentDataPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model IPOAnalytics
 * 
 */
export type IPOAnalytics = $Result.DefaultSelection<Prisma.$IPOAnalyticsPayload>
/**
 * Model UserWatchlist
 * 
 */
export type UserWatchlist = $Result.DefaultSelection<Prisma.$UserWatchlistPayload>
/**
 * Model UserAlert
 * 
 */
export type UserAlert = $Result.DefaultSelection<Prisma.$UserAlertPayload>
/**
 * Model SystemConfig
 * 
 */
export type SystemConfig = $Result.DefaultSelection<Prisma.$SystemConfigPayload>
/**
 * Model ApiLog
 * 
 */
export type ApiLog = $Result.DefaultSelection<Prisma.$ApiLogPayload>
/**
 * Model MarketStatus
 * 
 */
export type MarketStatus = $Result.DefaultSelection<Prisma.$MarketStatusPayload>
/**
 * Model CacheEntry
 * 
 */
export type CacheEntry = $Result.DefaultSelection<Prisma.$CacheEntryPayload>
/**
 * Model SyncLog
 * 
 */
export type SyncLog = $Result.DefaultSelection<Prisma.$SyncLogPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more IPOS
 * const iPOS = await prisma.iPO.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more IPOS
   * const iPOS = await prisma.iPO.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.iPO`: Exposes CRUD operations for the **IPO** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more IPOS
    * const iPOS = await prisma.iPO.findMany()
    * ```
    */
  get iPO(): Prisma.IPODelegate<ExtArgs>;

  /**
   * `prisma.gMP`: Exposes CRUD operations for the **GMP** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GMPS
    * const gMPS = await prisma.gMP.findMany()
    * ```
    */
  get gMP(): Prisma.GMPDelegate<ExtArgs>;

  /**
   * `prisma.subscriptionData`: Exposes CRUD operations for the **SubscriptionData** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SubscriptionData
    * const subscriptionData = await prisma.subscriptionData.findMany()
    * ```
    */
  get subscriptionData(): Prisma.SubscriptionDataDelegate<ExtArgs>;

  /**
   * `prisma.allotmentData`: Exposes CRUD operations for the **AllotmentData** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AllotmentData
    * const allotmentData = await prisma.allotmentData.findMany()
    * ```
    */
  get allotmentData(): Prisma.AllotmentDataDelegate<ExtArgs>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs>;

  /**
   * `prisma.iPOAnalytics`: Exposes CRUD operations for the **IPOAnalytics** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more IPOAnalytics
    * const iPOAnalytics = await prisma.iPOAnalytics.findMany()
    * ```
    */
  get iPOAnalytics(): Prisma.IPOAnalyticsDelegate<ExtArgs>;

  /**
   * `prisma.userWatchlist`: Exposes CRUD operations for the **UserWatchlist** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserWatchlists
    * const userWatchlists = await prisma.userWatchlist.findMany()
    * ```
    */
  get userWatchlist(): Prisma.UserWatchlistDelegate<ExtArgs>;

  /**
   * `prisma.userAlert`: Exposes CRUD operations for the **UserAlert** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserAlerts
    * const userAlerts = await prisma.userAlert.findMany()
    * ```
    */
  get userAlert(): Prisma.UserAlertDelegate<ExtArgs>;

  /**
   * `prisma.systemConfig`: Exposes CRUD operations for the **SystemConfig** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SystemConfigs
    * const systemConfigs = await prisma.systemConfig.findMany()
    * ```
    */
  get systemConfig(): Prisma.SystemConfigDelegate<ExtArgs>;

  /**
   * `prisma.apiLog`: Exposes CRUD operations for the **ApiLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ApiLogs
    * const apiLogs = await prisma.apiLog.findMany()
    * ```
    */
  get apiLog(): Prisma.ApiLogDelegate<ExtArgs>;

  /**
   * `prisma.marketStatus`: Exposes CRUD operations for the **MarketStatus** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MarketStatuses
    * const marketStatuses = await prisma.marketStatus.findMany()
    * ```
    */
  get marketStatus(): Prisma.MarketStatusDelegate<ExtArgs>;

  /**
   * `prisma.cacheEntry`: Exposes CRUD operations for the **CacheEntry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CacheEntries
    * const cacheEntries = await prisma.cacheEntry.findMany()
    * ```
    */
  get cacheEntry(): Prisma.CacheEntryDelegate<ExtArgs>;

  /**
   * `prisma.syncLog`: Exposes CRUD operations for the **SyncLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SyncLogs
    * const syncLogs = await prisma.syncLog.findMany()
    * ```
    */
  get syncLog(): Prisma.SyncLogDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    IPO: 'IPO',
    GMP: 'GMP',
    SubscriptionData: 'SubscriptionData',
    AllotmentData: 'AllotmentData',
    User: 'User',
    Session: 'Session',
    IPOAnalytics: 'IPOAnalytics',
    UserWatchlist: 'UserWatchlist',
    UserAlert: 'UserAlert',
    SystemConfig: 'SystemConfig',
    ApiLog: 'ApiLog',
    MarketStatus: 'MarketStatus',
    CacheEntry: 'CacheEntry',
    SyncLog: 'SyncLog'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "iPO" | "gMP" | "subscriptionData" | "allotmentData" | "user" | "session" | "iPOAnalytics" | "userWatchlist" | "userAlert" | "systemConfig" | "apiLog" | "marketStatus" | "cacheEntry" | "syncLog"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      IPO: {
        payload: Prisma.$IPOPayload<ExtArgs>
        fields: Prisma.IPOFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IPOFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IPOPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IPOFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IPOPayload>
          }
          findFirst: {
            args: Prisma.IPOFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IPOPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IPOFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IPOPayload>
          }
          findMany: {
            args: Prisma.IPOFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IPOPayload>[]
          }
          create: {
            args: Prisma.IPOCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IPOPayload>
          }
          createMany: {
            args: Prisma.IPOCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.IPOCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IPOPayload>[]
          }
          delete: {
            args: Prisma.IPODeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IPOPayload>
          }
          update: {
            args: Prisma.IPOUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IPOPayload>
          }
          deleteMany: {
            args: Prisma.IPODeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IPOUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.IPOUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IPOPayload>
          }
          aggregate: {
            args: Prisma.IPOAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIPO>
          }
          groupBy: {
            args: Prisma.IPOGroupByArgs<ExtArgs>
            result: $Utils.Optional<IPOGroupByOutputType>[]
          }
          count: {
            args: Prisma.IPOCountArgs<ExtArgs>
            result: $Utils.Optional<IPOCountAggregateOutputType> | number
          }
        }
      }
      GMP: {
        payload: Prisma.$GMPPayload<ExtArgs>
        fields: Prisma.GMPFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GMPFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GMPPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GMPFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GMPPayload>
          }
          findFirst: {
            args: Prisma.GMPFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GMPPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GMPFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GMPPayload>
          }
          findMany: {
            args: Prisma.GMPFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GMPPayload>[]
          }
          create: {
            args: Prisma.GMPCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GMPPayload>
          }
          createMany: {
            args: Prisma.GMPCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GMPCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GMPPayload>[]
          }
          delete: {
            args: Prisma.GMPDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GMPPayload>
          }
          update: {
            args: Prisma.GMPUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GMPPayload>
          }
          deleteMany: {
            args: Prisma.GMPDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GMPUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.GMPUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GMPPayload>
          }
          aggregate: {
            args: Prisma.GMPAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGMP>
          }
          groupBy: {
            args: Prisma.GMPGroupByArgs<ExtArgs>
            result: $Utils.Optional<GMPGroupByOutputType>[]
          }
          count: {
            args: Prisma.GMPCountArgs<ExtArgs>
            result: $Utils.Optional<GMPCountAggregateOutputType> | number
          }
        }
      }
      SubscriptionData: {
        payload: Prisma.$SubscriptionDataPayload<ExtArgs>
        fields: Prisma.SubscriptionDataFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubscriptionDataFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionDataPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubscriptionDataFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionDataPayload>
          }
          findFirst: {
            args: Prisma.SubscriptionDataFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionDataPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubscriptionDataFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionDataPayload>
          }
          findMany: {
            args: Prisma.SubscriptionDataFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionDataPayload>[]
          }
          create: {
            args: Prisma.SubscriptionDataCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionDataPayload>
          }
          createMany: {
            args: Prisma.SubscriptionDataCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubscriptionDataCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionDataPayload>[]
          }
          delete: {
            args: Prisma.SubscriptionDataDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionDataPayload>
          }
          update: {
            args: Prisma.SubscriptionDataUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionDataPayload>
          }
          deleteMany: {
            args: Prisma.SubscriptionDataDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubscriptionDataUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SubscriptionDataUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionDataPayload>
          }
          aggregate: {
            args: Prisma.SubscriptionDataAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubscriptionData>
          }
          groupBy: {
            args: Prisma.SubscriptionDataGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionDataGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubscriptionDataCountArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionDataCountAggregateOutputType> | number
          }
        }
      }
      AllotmentData: {
        payload: Prisma.$AllotmentDataPayload<ExtArgs>
        fields: Prisma.AllotmentDataFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AllotmentDataFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AllotmentDataPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AllotmentDataFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AllotmentDataPayload>
          }
          findFirst: {
            args: Prisma.AllotmentDataFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AllotmentDataPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AllotmentDataFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AllotmentDataPayload>
          }
          findMany: {
            args: Prisma.AllotmentDataFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AllotmentDataPayload>[]
          }
          create: {
            args: Prisma.AllotmentDataCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AllotmentDataPayload>
          }
          createMany: {
            args: Prisma.AllotmentDataCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AllotmentDataCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AllotmentDataPayload>[]
          }
          delete: {
            args: Prisma.AllotmentDataDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AllotmentDataPayload>
          }
          update: {
            args: Prisma.AllotmentDataUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AllotmentDataPayload>
          }
          deleteMany: {
            args: Prisma.AllotmentDataDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AllotmentDataUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AllotmentDataUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AllotmentDataPayload>
          }
          aggregate: {
            args: Prisma.AllotmentDataAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAllotmentData>
          }
          groupBy: {
            args: Prisma.AllotmentDataGroupByArgs<ExtArgs>
            result: $Utils.Optional<AllotmentDataGroupByOutputType>[]
          }
          count: {
            args: Prisma.AllotmentDataCountArgs<ExtArgs>
            result: $Utils.Optional<AllotmentDataCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      IPOAnalytics: {
        payload: Prisma.$IPOAnalyticsPayload<ExtArgs>
        fields: Prisma.IPOAnalyticsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IPOAnalyticsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IPOAnalyticsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IPOAnalyticsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IPOAnalyticsPayload>
          }
          findFirst: {
            args: Prisma.IPOAnalyticsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IPOAnalyticsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IPOAnalyticsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IPOAnalyticsPayload>
          }
          findMany: {
            args: Prisma.IPOAnalyticsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IPOAnalyticsPayload>[]
          }
          create: {
            args: Prisma.IPOAnalyticsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IPOAnalyticsPayload>
          }
          createMany: {
            args: Prisma.IPOAnalyticsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.IPOAnalyticsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IPOAnalyticsPayload>[]
          }
          delete: {
            args: Prisma.IPOAnalyticsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IPOAnalyticsPayload>
          }
          update: {
            args: Prisma.IPOAnalyticsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IPOAnalyticsPayload>
          }
          deleteMany: {
            args: Prisma.IPOAnalyticsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IPOAnalyticsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.IPOAnalyticsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IPOAnalyticsPayload>
          }
          aggregate: {
            args: Prisma.IPOAnalyticsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIPOAnalytics>
          }
          groupBy: {
            args: Prisma.IPOAnalyticsGroupByArgs<ExtArgs>
            result: $Utils.Optional<IPOAnalyticsGroupByOutputType>[]
          }
          count: {
            args: Prisma.IPOAnalyticsCountArgs<ExtArgs>
            result: $Utils.Optional<IPOAnalyticsCountAggregateOutputType> | number
          }
        }
      }
      UserWatchlist: {
        payload: Prisma.$UserWatchlistPayload<ExtArgs>
        fields: Prisma.UserWatchlistFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserWatchlistFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserWatchlistPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserWatchlistFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserWatchlistPayload>
          }
          findFirst: {
            args: Prisma.UserWatchlistFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserWatchlistPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserWatchlistFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserWatchlistPayload>
          }
          findMany: {
            args: Prisma.UserWatchlistFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserWatchlistPayload>[]
          }
          create: {
            args: Prisma.UserWatchlistCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserWatchlistPayload>
          }
          createMany: {
            args: Prisma.UserWatchlistCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserWatchlistCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserWatchlistPayload>[]
          }
          delete: {
            args: Prisma.UserWatchlistDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserWatchlistPayload>
          }
          update: {
            args: Prisma.UserWatchlistUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserWatchlistPayload>
          }
          deleteMany: {
            args: Prisma.UserWatchlistDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserWatchlistUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserWatchlistUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserWatchlistPayload>
          }
          aggregate: {
            args: Prisma.UserWatchlistAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserWatchlist>
          }
          groupBy: {
            args: Prisma.UserWatchlistGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserWatchlistGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserWatchlistCountArgs<ExtArgs>
            result: $Utils.Optional<UserWatchlistCountAggregateOutputType> | number
          }
        }
      }
      UserAlert: {
        payload: Prisma.$UserAlertPayload<ExtArgs>
        fields: Prisma.UserAlertFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserAlertFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAlertPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserAlertFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAlertPayload>
          }
          findFirst: {
            args: Prisma.UserAlertFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAlertPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserAlertFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAlertPayload>
          }
          findMany: {
            args: Prisma.UserAlertFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAlertPayload>[]
          }
          create: {
            args: Prisma.UserAlertCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAlertPayload>
          }
          createMany: {
            args: Prisma.UserAlertCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserAlertCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAlertPayload>[]
          }
          delete: {
            args: Prisma.UserAlertDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAlertPayload>
          }
          update: {
            args: Prisma.UserAlertUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAlertPayload>
          }
          deleteMany: {
            args: Prisma.UserAlertDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserAlertUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserAlertUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAlertPayload>
          }
          aggregate: {
            args: Prisma.UserAlertAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserAlert>
          }
          groupBy: {
            args: Prisma.UserAlertGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserAlertGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserAlertCountArgs<ExtArgs>
            result: $Utils.Optional<UserAlertCountAggregateOutputType> | number
          }
        }
      }
      SystemConfig: {
        payload: Prisma.$SystemConfigPayload<ExtArgs>
        fields: Prisma.SystemConfigFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SystemConfigFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SystemConfigFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>
          }
          findFirst: {
            args: Prisma.SystemConfigFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SystemConfigFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>
          }
          findMany: {
            args: Prisma.SystemConfigFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>[]
          }
          create: {
            args: Prisma.SystemConfigCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>
          }
          createMany: {
            args: Prisma.SystemConfigCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SystemConfigCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>[]
          }
          delete: {
            args: Prisma.SystemConfigDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>
          }
          update: {
            args: Prisma.SystemConfigUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>
          }
          deleteMany: {
            args: Prisma.SystemConfigDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SystemConfigUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SystemConfigUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>
          }
          aggregate: {
            args: Prisma.SystemConfigAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSystemConfig>
          }
          groupBy: {
            args: Prisma.SystemConfigGroupByArgs<ExtArgs>
            result: $Utils.Optional<SystemConfigGroupByOutputType>[]
          }
          count: {
            args: Prisma.SystemConfigCountArgs<ExtArgs>
            result: $Utils.Optional<SystemConfigCountAggregateOutputType> | number
          }
        }
      }
      ApiLog: {
        payload: Prisma.$ApiLogPayload<ExtArgs>
        fields: Prisma.ApiLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ApiLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ApiLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiLogPayload>
          }
          findFirst: {
            args: Prisma.ApiLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ApiLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiLogPayload>
          }
          findMany: {
            args: Prisma.ApiLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiLogPayload>[]
          }
          create: {
            args: Prisma.ApiLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiLogPayload>
          }
          createMany: {
            args: Prisma.ApiLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ApiLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiLogPayload>[]
          }
          delete: {
            args: Prisma.ApiLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiLogPayload>
          }
          update: {
            args: Prisma.ApiLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiLogPayload>
          }
          deleteMany: {
            args: Prisma.ApiLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ApiLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ApiLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiLogPayload>
          }
          aggregate: {
            args: Prisma.ApiLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateApiLog>
          }
          groupBy: {
            args: Prisma.ApiLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<ApiLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.ApiLogCountArgs<ExtArgs>
            result: $Utils.Optional<ApiLogCountAggregateOutputType> | number
          }
        }
      }
      MarketStatus: {
        payload: Prisma.$MarketStatusPayload<ExtArgs>
        fields: Prisma.MarketStatusFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MarketStatusFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketStatusPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MarketStatusFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketStatusPayload>
          }
          findFirst: {
            args: Prisma.MarketStatusFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketStatusPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MarketStatusFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketStatusPayload>
          }
          findMany: {
            args: Prisma.MarketStatusFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketStatusPayload>[]
          }
          create: {
            args: Prisma.MarketStatusCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketStatusPayload>
          }
          createMany: {
            args: Prisma.MarketStatusCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MarketStatusCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketStatusPayload>[]
          }
          delete: {
            args: Prisma.MarketStatusDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketStatusPayload>
          }
          update: {
            args: Prisma.MarketStatusUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketStatusPayload>
          }
          deleteMany: {
            args: Prisma.MarketStatusDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MarketStatusUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MarketStatusUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketStatusPayload>
          }
          aggregate: {
            args: Prisma.MarketStatusAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMarketStatus>
          }
          groupBy: {
            args: Prisma.MarketStatusGroupByArgs<ExtArgs>
            result: $Utils.Optional<MarketStatusGroupByOutputType>[]
          }
          count: {
            args: Prisma.MarketStatusCountArgs<ExtArgs>
            result: $Utils.Optional<MarketStatusCountAggregateOutputType> | number
          }
        }
      }
      CacheEntry: {
        payload: Prisma.$CacheEntryPayload<ExtArgs>
        fields: Prisma.CacheEntryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CacheEntryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CacheEntryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CacheEntryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CacheEntryPayload>
          }
          findFirst: {
            args: Prisma.CacheEntryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CacheEntryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CacheEntryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CacheEntryPayload>
          }
          findMany: {
            args: Prisma.CacheEntryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CacheEntryPayload>[]
          }
          create: {
            args: Prisma.CacheEntryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CacheEntryPayload>
          }
          createMany: {
            args: Prisma.CacheEntryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CacheEntryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CacheEntryPayload>[]
          }
          delete: {
            args: Prisma.CacheEntryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CacheEntryPayload>
          }
          update: {
            args: Prisma.CacheEntryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CacheEntryPayload>
          }
          deleteMany: {
            args: Prisma.CacheEntryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CacheEntryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CacheEntryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CacheEntryPayload>
          }
          aggregate: {
            args: Prisma.CacheEntryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCacheEntry>
          }
          groupBy: {
            args: Prisma.CacheEntryGroupByArgs<ExtArgs>
            result: $Utils.Optional<CacheEntryGroupByOutputType>[]
          }
          count: {
            args: Prisma.CacheEntryCountArgs<ExtArgs>
            result: $Utils.Optional<CacheEntryCountAggregateOutputType> | number
          }
        }
      }
      SyncLog: {
        payload: Prisma.$SyncLogPayload<ExtArgs>
        fields: Prisma.SyncLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SyncLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SyncLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncLogPayload>
          }
          findFirst: {
            args: Prisma.SyncLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SyncLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncLogPayload>
          }
          findMany: {
            args: Prisma.SyncLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncLogPayload>[]
          }
          create: {
            args: Prisma.SyncLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncLogPayload>
          }
          createMany: {
            args: Prisma.SyncLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SyncLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncLogPayload>[]
          }
          delete: {
            args: Prisma.SyncLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncLogPayload>
          }
          update: {
            args: Prisma.SyncLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncLogPayload>
          }
          deleteMany: {
            args: Prisma.SyncLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SyncLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SyncLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncLogPayload>
          }
          aggregate: {
            args: Prisma.SyncLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSyncLog>
          }
          groupBy: {
            args: Prisma.SyncLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<SyncLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.SyncLogCountArgs<ExtArgs>
            result: $Utils.Optional<SyncLogCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type IPOCountOutputType
   */

  export type IPOCountOutputType = {
    gmpData: number
    subscriptionData: number
    allotmentData: number
    analytics: number
    watchlists: number
    alerts: number
  }

  export type IPOCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gmpData?: boolean | IPOCountOutputTypeCountGmpDataArgs
    subscriptionData?: boolean | IPOCountOutputTypeCountSubscriptionDataArgs
    allotmentData?: boolean | IPOCountOutputTypeCountAllotmentDataArgs
    analytics?: boolean | IPOCountOutputTypeCountAnalyticsArgs
    watchlists?: boolean | IPOCountOutputTypeCountWatchlistsArgs
    alerts?: boolean | IPOCountOutputTypeCountAlertsArgs
  }

  // Custom InputTypes
  /**
   * IPOCountOutputType without action
   */
  export type IPOCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IPOCountOutputType
     */
    select?: IPOCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * IPOCountOutputType without action
   */
  export type IPOCountOutputTypeCountGmpDataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GMPWhereInput
  }

  /**
   * IPOCountOutputType without action
   */
  export type IPOCountOutputTypeCountSubscriptionDataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionDataWhereInput
  }

  /**
   * IPOCountOutputType without action
   */
  export type IPOCountOutputTypeCountAllotmentDataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AllotmentDataWhereInput
  }

  /**
   * IPOCountOutputType without action
   */
  export type IPOCountOutputTypeCountAnalyticsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IPOAnalyticsWhereInput
  }

  /**
   * IPOCountOutputType without action
   */
  export type IPOCountOutputTypeCountWatchlistsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWatchlistWhereInput
  }

  /**
   * IPOCountOutputType without action
   */
  export type IPOCountOutputTypeCountAlertsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserAlertWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    watchlists: number
    alerts: number
    sessions: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    watchlists?: boolean | UserCountOutputTypeCountWatchlistsArgs
    alerts?: boolean | UserCountOutputTypeCountAlertsArgs
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountWatchlistsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWatchlistWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAlertsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserAlertWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }


  /**
   * Models
   */

  /**
   * Model IPO
   */

  export type AggregateIPO = {
    _count: IPOCountAggregateOutputType | null
    _avg: IPOAvgAggregateOutputType | null
    _sum: IPOSumAggregateOutputType | null
    _min: IPOMinAggregateOutputType | null
    _max: IPOMaxAggregateOutputType | null
  }

  export type IPOAvgAggregateOutputType = {
    minPrice: number | null
    maxPrice: number | null
    finalPrice: number | null
    listingPrice: number | null
    currentPrice: number | null
    issueSize: number | null
    lotSize: number | null
    marketLot: number | null
    faceValue: number | null
    bookValue: number | null
    marketCap: number | null
    peRatio: number | null
    roe: number | null
  }

  export type IPOSumAggregateOutputType = {
    minPrice: number | null
    maxPrice: number | null
    finalPrice: number | null
    listingPrice: number | null
    currentPrice: number | null
    issueSize: bigint | null
    lotSize: number | null
    marketLot: number | null
    faceValue: number | null
    bookValue: number | null
    marketCap: bigint | null
    peRatio: number | null
    roe: number | null
  }

  export type IPOMinAggregateOutputType = {
    id: string | null
    symbol: string | null
    name: string | null
    companyId: string | null
    status: string | null
    sector: string | null
    industry: string | null
    minPrice: number | null
    maxPrice: number | null
    finalPrice: number | null
    listingPrice: number | null
    currentPrice: number | null
    issueSize: bigint | null
    lotSize: number | null
    marketLot: number | null
    openDate: Date | null
    closeDate: Date | null
    listingDate: Date | null
    allotmentDate: Date | null
    refundDate: Date | null
    leadManager: string | null
    registrar: string | null
    faceValue: number | null
    bookValue: number | null
    marketCap: bigint | null
    peRatio: number | null
    roe: number | null
    reservationDetails: string | null
    aboutCompany: string | null
    objectives: string | null
    risks: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IPOMaxAggregateOutputType = {
    id: string | null
    symbol: string | null
    name: string | null
    companyId: string | null
    status: string | null
    sector: string | null
    industry: string | null
    minPrice: number | null
    maxPrice: number | null
    finalPrice: number | null
    listingPrice: number | null
    currentPrice: number | null
    issueSize: bigint | null
    lotSize: number | null
    marketLot: number | null
    openDate: Date | null
    closeDate: Date | null
    listingDate: Date | null
    allotmentDate: Date | null
    refundDate: Date | null
    leadManager: string | null
    registrar: string | null
    faceValue: number | null
    bookValue: number | null
    marketCap: bigint | null
    peRatio: number | null
    roe: number | null
    reservationDetails: string | null
    aboutCompany: string | null
    objectives: string | null
    risks: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IPOCountAggregateOutputType = {
    id: number
    symbol: number
    name: number
    companyId: number
    status: number
    sector: number
    industry: number
    minPrice: number
    maxPrice: number
    finalPrice: number
    listingPrice: number
    currentPrice: number
    issueSize: number
    lotSize: number
    marketLot: number
    openDate: number
    closeDate: number
    listingDate: number
    allotmentDate: number
    refundDate: number
    leadManager: number
    registrar: number
    faceValue: number
    bookValue: number
    marketCap: number
    peRatio: number
    roe: number
    reservationDetails: number
    aboutCompany: number
    objectives: number
    risks: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type IPOAvgAggregateInputType = {
    minPrice?: true
    maxPrice?: true
    finalPrice?: true
    listingPrice?: true
    currentPrice?: true
    issueSize?: true
    lotSize?: true
    marketLot?: true
    faceValue?: true
    bookValue?: true
    marketCap?: true
    peRatio?: true
    roe?: true
  }

  export type IPOSumAggregateInputType = {
    minPrice?: true
    maxPrice?: true
    finalPrice?: true
    listingPrice?: true
    currentPrice?: true
    issueSize?: true
    lotSize?: true
    marketLot?: true
    faceValue?: true
    bookValue?: true
    marketCap?: true
    peRatio?: true
    roe?: true
  }

  export type IPOMinAggregateInputType = {
    id?: true
    symbol?: true
    name?: true
    companyId?: true
    status?: true
    sector?: true
    industry?: true
    minPrice?: true
    maxPrice?: true
    finalPrice?: true
    listingPrice?: true
    currentPrice?: true
    issueSize?: true
    lotSize?: true
    marketLot?: true
    openDate?: true
    closeDate?: true
    listingDate?: true
    allotmentDate?: true
    refundDate?: true
    leadManager?: true
    registrar?: true
    faceValue?: true
    bookValue?: true
    marketCap?: true
    peRatio?: true
    roe?: true
    reservationDetails?: true
    aboutCompany?: true
    objectives?: true
    risks?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IPOMaxAggregateInputType = {
    id?: true
    symbol?: true
    name?: true
    companyId?: true
    status?: true
    sector?: true
    industry?: true
    minPrice?: true
    maxPrice?: true
    finalPrice?: true
    listingPrice?: true
    currentPrice?: true
    issueSize?: true
    lotSize?: true
    marketLot?: true
    openDate?: true
    closeDate?: true
    listingDate?: true
    allotmentDate?: true
    refundDate?: true
    leadManager?: true
    registrar?: true
    faceValue?: true
    bookValue?: true
    marketCap?: true
    peRatio?: true
    roe?: true
    reservationDetails?: true
    aboutCompany?: true
    objectives?: true
    risks?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IPOCountAggregateInputType = {
    id?: true
    symbol?: true
    name?: true
    companyId?: true
    status?: true
    sector?: true
    industry?: true
    minPrice?: true
    maxPrice?: true
    finalPrice?: true
    listingPrice?: true
    currentPrice?: true
    issueSize?: true
    lotSize?: true
    marketLot?: true
    openDate?: true
    closeDate?: true
    listingDate?: true
    allotmentDate?: true
    refundDate?: true
    leadManager?: true
    registrar?: true
    faceValue?: true
    bookValue?: true
    marketCap?: true
    peRatio?: true
    roe?: true
    reservationDetails?: true
    aboutCompany?: true
    objectives?: true
    risks?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type IPOAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IPO to aggregate.
     */
    where?: IPOWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IPOS to fetch.
     */
    orderBy?: IPOOrderByWithRelationInput | IPOOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IPOWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IPOS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IPOS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned IPOS
    **/
    _count?: true | IPOCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: IPOAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: IPOSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IPOMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IPOMaxAggregateInputType
  }

  export type GetIPOAggregateType<T extends IPOAggregateArgs> = {
        [P in keyof T & keyof AggregateIPO]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIPO[P]>
      : GetScalarType<T[P], AggregateIPO[P]>
  }




  export type IPOGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IPOWhereInput
    orderBy?: IPOOrderByWithAggregationInput | IPOOrderByWithAggregationInput[]
    by: IPOScalarFieldEnum[] | IPOScalarFieldEnum
    having?: IPOScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IPOCountAggregateInputType | true
    _avg?: IPOAvgAggregateInputType
    _sum?: IPOSumAggregateInputType
    _min?: IPOMinAggregateInputType
    _max?: IPOMaxAggregateInputType
  }

  export type IPOGroupByOutputType = {
    id: string
    symbol: string
    name: string
    companyId: string | null
    status: string
    sector: string | null
    industry: string | null
    minPrice: number
    maxPrice: number
    finalPrice: number | null
    listingPrice: number | null
    currentPrice: number | null
    issueSize: bigint
    lotSize: number
    marketLot: number
    openDate: Date
    closeDate: Date
    listingDate: Date | null
    allotmentDate: Date | null
    refundDate: Date | null
    leadManager: string | null
    registrar: string | null
    faceValue: number | null
    bookValue: number | null
    marketCap: bigint | null
    peRatio: number | null
    roe: number | null
    reservationDetails: string | null
    aboutCompany: string | null
    objectives: string | null
    risks: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: IPOCountAggregateOutputType | null
    _avg: IPOAvgAggregateOutputType | null
    _sum: IPOSumAggregateOutputType | null
    _min: IPOMinAggregateOutputType | null
    _max: IPOMaxAggregateOutputType | null
  }

  type GetIPOGroupByPayload<T extends IPOGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IPOGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IPOGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IPOGroupByOutputType[P]>
            : GetScalarType<T[P], IPOGroupByOutputType[P]>
        }
      >
    >


  export type IPOSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    symbol?: boolean
    name?: boolean
    companyId?: boolean
    status?: boolean
    sector?: boolean
    industry?: boolean
    minPrice?: boolean
    maxPrice?: boolean
    finalPrice?: boolean
    listingPrice?: boolean
    currentPrice?: boolean
    issueSize?: boolean
    lotSize?: boolean
    marketLot?: boolean
    openDate?: boolean
    closeDate?: boolean
    listingDate?: boolean
    allotmentDate?: boolean
    refundDate?: boolean
    leadManager?: boolean
    registrar?: boolean
    faceValue?: boolean
    bookValue?: boolean
    marketCap?: boolean
    peRatio?: boolean
    roe?: boolean
    reservationDetails?: boolean
    aboutCompany?: boolean
    objectives?: boolean
    risks?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    gmpData?: boolean | IPO$gmpDataArgs<ExtArgs>
    subscriptionData?: boolean | IPO$subscriptionDataArgs<ExtArgs>
    allotmentData?: boolean | IPO$allotmentDataArgs<ExtArgs>
    analytics?: boolean | IPO$analyticsArgs<ExtArgs>
    watchlists?: boolean | IPO$watchlistsArgs<ExtArgs>
    alerts?: boolean | IPO$alertsArgs<ExtArgs>
    _count?: boolean | IPOCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["iPO"]>

  export type IPOSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    symbol?: boolean
    name?: boolean
    companyId?: boolean
    status?: boolean
    sector?: boolean
    industry?: boolean
    minPrice?: boolean
    maxPrice?: boolean
    finalPrice?: boolean
    listingPrice?: boolean
    currentPrice?: boolean
    issueSize?: boolean
    lotSize?: boolean
    marketLot?: boolean
    openDate?: boolean
    closeDate?: boolean
    listingDate?: boolean
    allotmentDate?: boolean
    refundDate?: boolean
    leadManager?: boolean
    registrar?: boolean
    faceValue?: boolean
    bookValue?: boolean
    marketCap?: boolean
    peRatio?: boolean
    roe?: boolean
    reservationDetails?: boolean
    aboutCompany?: boolean
    objectives?: boolean
    risks?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["iPO"]>

  export type IPOSelectScalar = {
    id?: boolean
    symbol?: boolean
    name?: boolean
    companyId?: boolean
    status?: boolean
    sector?: boolean
    industry?: boolean
    minPrice?: boolean
    maxPrice?: boolean
    finalPrice?: boolean
    listingPrice?: boolean
    currentPrice?: boolean
    issueSize?: boolean
    lotSize?: boolean
    marketLot?: boolean
    openDate?: boolean
    closeDate?: boolean
    listingDate?: boolean
    allotmentDate?: boolean
    refundDate?: boolean
    leadManager?: boolean
    registrar?: boolean
    faceValue?: boolean
    bookValue?: boolean
    marketCap?: boolean
    peRatio?: boolean
    roe?: boolean
    reservationDetails?: boolean
    aboutCompany?: boolean
    objectives?: boolean
    risks?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type IPOInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gmpData?: boolean | IPO$gmpDataArgs<ExtArgs>
    subscriptionData?: boolean | IPO$subscriptionDataArgs<ExtArgs>
    allotmentData?: boolean | IPO$allotmentDataArgs<ExtArgs>
    analytics?: boolean | IPO$analyticsArgs<ExtArgs>
    watchlists?: boolean | IPO$watchlistsArgs<ExtArgs>
    alerts?: boolean | IPO$alertsArgs<ExtArgs>
    _count?: boolean | IPOCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type IPOIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $IPOPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "IPO"
    objects: {
      gmpData: Prisma.$GMPPayload<ExtArgs>[]
      subscriptionData: Prisma.$SubscriptionDataPayload<ExtArgs>[]
      allotmentData: Prisma.$AllotmentDataPayload<ExtArgs>[]
      analytics: Prisma.$IPOAnalyticsPayload<ExtArgs>[]
      watchlists: Prisma.$UserWatchlistPayload<ExtArgs>[]
      alerts: Prisma.$UserAlertPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      symbol: string
      name: string
      companyId: string | null
      status: string
      sector: string | null
      industry: string | null
      minPrice: number
      maxPrice: number
      finalPrice: number | null
      listingPrice: number | null
      currentPrice: number | null
      issueSize: bigint
      lotSize: number
      marketLot: number
      openDate: Date
      closeDate: Date
      listingDate: Date | null
      allotmentDate: Date | null
      refundDate: Date | null
      leadManager: string | null
      registrar: string | null
      faceValue: number | null
      bookValue: number | null
      marketCap: bigint | null
      peRatio: number | null
      roe: number | null
      reservationDetails: string | null
      aboutCompany: string | null
      objectives: string | null
      risks: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["iPO"]>
    composites: {}
  }

  type IPOGetPayload<S extends boolean | null | undefined | IPODefaultArgs> = $Result.GetResult<Prisma.$IPOPayload, S>

  type IPOCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<IPOFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: IPOCountAggregateInputType | true
    }

  export interface IPODelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['IPO'], meta: { name: 'IPO' } }
    /**
     * Find zero or one IPO that matches the filter.
     * @param {IPOFindUniqueArgs} args - Arguments to find a IPO
     * @example
     * // Get one IPO
     * const iPO = await prisma.iPO.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IPOFindUniqueArgs>(args: SelectSubset<T, IPOFindUniqueArgs<ExtArgs>>): Prisma__IPOClient<$Result.GetResult<Prisma.$IPOPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one IPO that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {IPOFindUniqueOrThrowArgs} args - Arguments to find a IPO
     * @example
     * // Get one IPO
     * const iPO = await prisma.iPO.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IPOFindUniqueOrThrowArgs>(args: SelectSubset<T, IPOFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IPOClient<$Result.GetResult<Prisma.$IPOPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first IPO that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IPOFindFirstArgs} args - Arguments to find a IPO
     * @example
     * // Get one IPO
     * const iPO = await prisma.iPO.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IPOFindFirstArgs>(args?: SelectSubset<T, IPOFindFirstArgs<ExtArgs>>): Prisma__IPOClient<$Result.GetResult<Prisma.$IPOPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first IPO that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IPOFindFirstOrThrowArgs} args - Arguments to find a IPO
     * @example
     * // Get one IPO
     * const iPO = await prisma.iPO.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IPOFindFirstOrThrowArgs>(args?: SelectSubset<T, IPOFindFirstOrThrowArgs<ExtArgs>>): Prisma__IPOClient<$Result.GetResult<Prisma.$IPOPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more IPOS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IPOFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all IPOS
     * const iPOS = await prisma.iPO.findMany()
     * 
     * // Get first 10 IPOS
     * const iPOS = await prisma.iPO.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const iPOWithIdOnly = await prisma.iPO.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends IPOFindManyArgs>(args?: SelectSubset<T, IPOFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IPOPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a IPO.
     * @param {IPOCreateArgs} args - Arguments to create a IPO.
     * @example
     * // Create one IPO
     * const IPO = await prisma.iPO.create({
     *   data: {
     *     // ... data to create a IPO
     *   }
     * })
     * 
     */
    create<T extends IPOCreateArgs>(args: SelectSubset<T, IPOCreateArgs<ExtArgs>>): Prisma__IPOClient<$Result.GetResult<Prisma.$IPOPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many IPOS.
     * @param {IPOCreateManyArgs} args - Arguments to create many IPOS.
     * @example
     * // Create many IPOS
     * const iPO = await prisma.iPO.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IPOCreateManyArgs>(args?: SelectSubset<T, IPOCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many IPOS and returns the data saved in the database.
     * @param {IPOCreateManyAndReturnArgs} args - Arguments to create many IPOS.
     * @example
     * // Create many IPOS
     * const iPO = await prisma.iPO.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many IPOS and only return the `id`
     * const iPOWithIdOnly = await prisma.iPO.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends IPOCreateManyAndReturnArgs>(args?: SelectSubset<T, IPOCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IPOPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a IPO.
     * @param {IPODeleteArgs} args - Arguments to delete one IPO.
     * @example
     * // Delete one IPO
     * const IPO = await prisma.iPO.delete({
     *   where: {
     *     // ... filter to delete one IPO
     *   }
     * })
     * 
     */
    delete<T extends IPODeleteArgs>(args: SelectSubset<T, IPODeleteArgs<ExtArgs>>): Prisma__IPOClient<$Result.GetResult<Prisma.$IPOPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one IPO.
     * @param {IPOUpdateArgs} args - Arguments to update one IPO.
     * @example
     * // Update one IPO
     * const iPO = await prisma.iPO.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IPOUpdateArgs>(args: SelectSubset<T, IPOUpdateArgs<ExtArgs>>): Prisma__IPOClient<$Result.GetResult<Prisma.$IPOPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more IPOS.
     * @param {IPODeleteManyArgs} args - Arguments to filter IPOS to delete.
     * @example
     * // Delete a few IPOS
     * const { count } = await prisma.iPO.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IPODeleteManyArgs>(args?: SelectSubset<T, IPODeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IPOS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IPOUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many IPOS
     * const iPO = await prisma.iPO.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IPOUpdateManyArgs>(args: SelectSubset<T, IPOUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one IPO.
     * @param {IPOUpsertArgs} args - Arguments to update or create a IPO.
     * @example
     * // Update or create a IPO
     * const iPO = await prisma.iPO.upsert({
     *   create: {
     *     // ... data to create a IPO
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the IPO we want to update
     *   }
     * })
     */
    upsert<T extends IPOUpsertArgs>(args: SelectSubset<T, IPOUpsertArgs<ExtArgs>>): Prisma__IPOClient<$Result.GetResult<Prisma.$IPOPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of IPOS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IPOCountArgs} args - Arguments to filter IPOS to count.
     * @example
     * // Count the number of IPOS
     * const count = await prisma.iPO.count({
     *   where: {
     *     // ... the filter for the IPOS we want to count
     *   }
     * })
    **/
    count<T extends IPOCountArgs>(
      args?: Subset<T, IPOCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IPOCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a IPO.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IPOAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IPOAggregateArgs>(args: Subset<T, IPOAggregateArgs>): Prisma.PrismaPromise<GetIPOAggregateType<T>>

    /**
     * Group by IPO.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IPOGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IPOGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IPOGroupByArgs['orderBy'] }
        : { orderBy?: IPOGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IPOGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIPOGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the IPO model
   */
  readonly fields: IPOFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for IPO.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IPOClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    gmpData<T extends IPO$gmpDataArgs<ExtArgs> = {}>(args?: Subset<T, IPO$gmpDataArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GMPPayload<ExtArgs>, T, "findMany"> | Null>
    subscriptionData<T extends IPO$subscriptionDataArgs<ExtArgs> = {}>(args?: Subset<T, IPO$subscriptionDataArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionDataPayload<ExtArgs>, T, "findMany"> | Null>
    allotmentData<T extends IPO$allotmentDataArgs<ExtArgs> = {}>(args?: Subset<T, IPO$allotmentDataArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AllotmentDataPayload<ExtArgs>, T, "findMany"> | Null>
    analytics<T extends IPO$analyticsArgs<ExtArgs> = {}>(args?: Subset<T, IPO$analyticsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IPOAnalyticsPayload<ExtArgs>, T, "findMany"> | Null>
    watchlists<T extends IPO$watchlistsArgs<ExtArgs> = {}>(args?: Subset<T, IPO$watchlistsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserWatchlistPayload<ExtArgs>, T, "findMany"> | Null>
    alerts<T extends IPO$alertsArgs<ExtArgs> = {}>(args?: Subset<T, IPO$alertsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAlertPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the IPO model
   */ 
  interface IPOFieldRefs {
    readonly id: FieldRef<"IPO", 'String'>
    readonly symbol: FieldRef<"IPO", 'String'>
    readonly name: FieldRef<"IPO", 'String'>
    readonly companyId: FieldRef<"IPO", 'String'>
    readonly status: FieldRef<"IPO", 'String'>
    readonly sector: FieldRef<"IPO", 'String'>
    readonly industry: FieldRef<"IPO", 'String'>
    readonly minPrice: FieldRef<"IPO", 'Float'>
    readonly maxPrice: FieldRef<"IPO", 'Float'>
    readonly finalPrice: FieldRef<"IPO", 'Float'>
    readonly listingPrice: FieldRef<"IPO", 'Float'>
    readonly currentPrice: FieldRef<"IPO", 'Float'>
    readonly issueSize: FieldRef<"IPO", 'BigInt'>
    readonly lotSize: FieldRef<"IPO", 'Int'>
    readonly marketLot: FieldRef<"IPO", 'Int'>
    readonly openDate: FieldRef<"IPO", 'DateTime'>
    readonly closeDate: FieldRef<"IPO", 'DateTime'>
    readonly listingDate: FieldRef<"IPO", 'DateTime'>
    readonly allotmentDate: FieldRef<"IPO", 'DateTime'>
    readonly refundDate: FieldRef<"IPO", 'DateTime'>
    readonly leadManager: FieldRef<"IPO", 'String'>
    readonly registrar: FieldRef<"IPO", 'String'>
    readonly faceValue: FieldRef<"IPO", 'Float'>
    readonly bookValue: FieldRef<"IPO", 'Float'>
    readonly marketCap: FieldRef<"IPO", 'BigInt'>
    readonly peRatio: FieldRef<"IPO", 'Float'>
    readonly roe: FieldRef<"IPO", 'Float'>
    readonly reservationDetails: FieldRef<"IPO", 'String'>
    readonly aboutCompany: FieldRef<"IPO", 'String'>
    readonly objectives: FieldRef<"IPO", 'String'>
    readonly risks: FieldRef<"IPO", 'String'>
    readonly isActive: FieldRef<"IPO", 'Boolean'>
    readonly createdAt: FieldRef<"IPO", 'DateTime'>
    readonly updatedAt: FieldRef<"IPO", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * IPO findUnique
   */
  export type IPOFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IPO
     */
    select?: IPOSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IPOInclude<ExtArgs> | null
    /**
     * Filter, which IPO to fetch.
     */
    where: IPOWhereUniqueInput
  }

  /**
   * IPO findUniqueOrThrow
   */
  export type IPOFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IPO
     */
    select?: IPOSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IPOInclude<ExtArgs> | null
    /**
     * Filter, which IPO to fetch.
     */
    where: IPOWhereUniqueInput
  }

  /**
   * IPO findFirst
   */
  export type IPOFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IPO
     */
    select?: IPOSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IPOInclude<ExtArgs> | null
    /**
     * Filter, which IPO to fetch.
     */
    where?: IPOWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IPOS to fetch.
     */
    orderBy?: IPOOrderByWithRelationInput | IPOOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IPOS.
     */
    cursor?: IPOWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IPOS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IPOS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IPOS.
     */
    distinct?: IPOScalarFieldEnum | IPOScalarFieldEnum[]
  }

  /**
   * IPO findFirstOrThrow
   */
  export type IPOFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IPO
     */
    select?: IPOSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IPOInclude<ExtArgs> | null
    /**
     * Filter, which IPO to fetch.
     */
    where?: IPOWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IPOS to fetch.
     */
    orderBy?: IPOOrderByWithRelationInput | IPOOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IPOS.
     */
    cursor?: IPOWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IPOS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IPOS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IPOS.
     */
    distinct?: IPOScalarFieldEnum | IPOScalarFieldEnum[]
  }

  /**
   * IPO findMany
   */
  export type IPOFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IPO
     */
    select?: IPOSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IPOInclude<ExtArgs> | null
    /**
     * Filter, which IPOS to fetch.
     */
    where?: IPOWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IPOS to fetch.
     */
    orderBy?: IPOOrderByWithRelationInput | IPOOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing IPOS.
     */
    cursor?: IPOWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IPOS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IPOS.
     */
    skip?: number
    distinct?: IPOScalarFieldEnum | IPOScalarFieldEnum[]
  }

  /**
   * IPO create
   */
  export type IPOCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IPO
     */
    select?: IPOSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IPOInclude<ExtArgs> | null
    /**
     * The data needed to create a IPO.
     */
    data: XOR<IPOCreateInput, IPOUncheckedCreateInput>
  }

  /**
   * IPO createMany
   */
  export type IPOCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many IPOS.
     */
    data: IPOCreateManyInput | IPOCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * IPO createManyAndReturn
   */
  export type IPOCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IPO
     */
    select?: IPOSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many IPOS.
     */
    data: IPOCreateManyInput | IPOCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * IPO update
   */
  export type IPOUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IPO
     */
    select?: IPOSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IPOInclude<ExtArgs> | null
    /**
     * The data needed to update a IPO.
     */
    data: XOR<IPOUpdateInput, IPOUncheckedUpdateInput>
    /**
     * Choose, which IPO to update.
     */
    where: IPOWhereUniqueInput
  }

  /**
   * IPO updateMany
   */
  export type IPOUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update IPOS.
     */
    data: XOR<IPOUpdateManyMutationInput, IPOUncheckedUpdateManyInput>
    /**
     * Filter which IPOS to update
     */
    where?: IPOWhereInput
  }

  /**
   * IPO upsert
   */
  export type IPOUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IPO
     */
    select?: IPOSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IPOInclude<ExtArgs> | null
    /**
     * The filter to search for the IPO to update in case it exists.
     */
    where: IPOWhereUniqueInput
    /**
     * In case the IPO found by the `where` argument doesn't exist, create a new IPO with this data.
     */
    create: XOR<IPOCreateInput, IPOUncheckedCreateInput>
    /**
     * In case the IPO was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IPOUpdateInput, IPOUncheckedUpdateInput>
  }

  /**
   * IPO delete
   */
  export type IPODeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IPO
     */
    select?: IPOSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IPOInclude<ExtArgs> | null
    /**
     * Filter which IPO to delete.
     */
    where: IPOWhereUniqueInput
  }

  /**
   * IPO deleteMany
   */
  export type IPODeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IPOS to delete
     */
    where?: IPOWhereInput
  }

  /**
   * IPO.gmpData
   */
  export type IPO$gmpDataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GMP
     */
    select?: GMPSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GMPInclude<ExtArgs> | null
    where?: GMPWhereInput
    orderBy?: GMPOrderByWithRelationInput | GMPOrderByWithRelationInput[]
    cursor?: GMPWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GMPScalarFieldEnum | GMPScalarFieldEnum[]
  }

  /**
   * IPO.subscriptionData
   */
  export type IPO$subscriptionDataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionData
     */
    select?: SubscriptionDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionDataInclude<ExtArgs> | null
    where?: SubscriptionDataWhereInput
    orderBy?: SubscriptionDataOrderByWithRelationInput | SubscriptionDataOrderByWithRelationInput[]
    cursor?: SubscriptionDataWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubscriptionDataScalarFieldEnum | SubscriptionDataScalarFieldEnum[]
  }

  /**
   * IPO.allotmentData
   */
  export type IPO$allotmentDataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AllotmentData
     */
    select?: AllotmentDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllotmentDataInclude<ExtArgs> | null
    where?: AllotmentDataWhereInput
    orderBy?: AllotmentDataOrderByWithRelationInput | AllotmentDataOrderByWithRelationInput[]
    cursor?: AllotmentDataWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AllotmentDataScalarFieldEnum | AllotmentDataScalarFieldEnum[]
  }

  /**
   * IPO.analytics
   */
  export type IPO$analyticsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IPOAnalytics
     */
    select?: IPOAnalyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IPOAnalyticsInclude<ExtArgs> | null
    where?: IPOAnalyticsWhereInput
    orderBy?: IPOAnalyticsOrderByWithRelationInput | IPOAnalyticsOrderByWithRelationInput[]
    cursor?: IPOAnalyticsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IPOAnalyticsScalarFieldEnum | IPOAnalyticsScalarFieldEnum[]
  }

  /**
   * IPO.watchlists
   */
  export type IPO$watchlistsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserWatchlist
     */
    select?: UserWatchlistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserWatchlistInclude<ExtArgs> | null
    where?: UserWatchlistWhereInput
    orderBy?: UserWatchlistOrderByWithRelationInput | UserWatchlistOrderByWithRelationInput[]
    cursor?: UserWatchlistWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserWatchlistScalarFieldEnum | UserWatchlistScalarFieldEnum[]
  }

  /**
   * IPO.alerts
   */
  export type IPO$alertsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAlert
     */
    select?: UserAlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAlertInclude<ExtArgs> | null
    where?: UserAlertWhereInput
    orderBy?: UserAlertOrderByWithRelationInput | UserAlertOrderByWithRelationInput[]
    cursor?: UserAlertWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserAlertScalarFieldEnum | UserAlertScalarFieldEnum[]
  }

  /**
   * IPO without action
   */
  export type IPODefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IPO
     */
    select?: IPOSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IPOInclude<ExtArgs> | null
  }


  /**
   * Model GMP
   */

  export type AggregateGMP = {
    _count: GMPCountAggregateOutputType | null
    _avg: GMPAvgAggregateOutputType | null
    _sum: GMPSumAggregateOutputType | null
    _min: GMPMinAggregateOutputType | null
    _max: GMPMaxAggregateOutputType | null
  }

  export type GMPAvgAggregateOutputType = {
    value: number | null
    percentage: number | null
    volume: number | null
    bidPrice: number | null
    askPrice: number | null
  }

  export type GMPSumAggregateOutputType = {
    value: number | null
    percentage: number | null
    volume: number | null
    bidPrice: number | null
    askPrice: number | null
  }

  export type GMPMinAggregateOutputType = {
    id: string | null
    ipoId: string | null
    value: number | null
    percentage: number | null
    volume: number | null
    bidPrice: number | null
    askPrice: number | null
    timestamp: Date | null
    source: string | null
    metadata: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GMPMaxAggregateOutputType = {
    id: string | null
    ipoId: string | null
    value: number | null
    percentage: number | null
    volume: number | null
    bidPrice: number | null
    askPrice: number | null
    timestamp: Date | null
    source: string | null
    metadata: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GMPCountAggregateOutputType = {
    id: number
    ipoId: number
    value: number
    percentage: number
    volume: number
    bidPrice: number
    askPrice: number
    timestamp: number
    source: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type GMPAvgAggregateInputType = {
    value?: true
    percentage?: true
    volume?: true
    bidPrice?: true
    askPrice?: true
  }

  export type GMPSumAggregateInputType = {
    value?: true
    percentage?: true
    volume?: true
    bidPrice?: true
    askPrice?: true
  }

  export type GMPMinAggregateInputType = {
    id?: true
    ipoId?: true
    value?: true
    percentage?: true
    volume?: true
    bidPrice?: true
    askPrice?: true
    timestamp?: true
    source?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GMPMaxAggregateInputType = {
    id?: true
    ipoId?: true
    value?: true
    percentage?: true
    volume?: true
    bidPrice?: true
    askPrice?: true
    timestamp?: true
    source?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GMPCountAggregateInputType = {
    id?: true
    ipoId?: true
    value?: true
    percentage?: true
    volume?: true
    bidPrice?: true
    askPrice?: true
    timestamp?: true
    source?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type GMPAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GMP to aggregate.
     */
    where?: GMPWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GMPS to fetch.
     */
    orderBy?: GMPOrderByWithRelationInput | GMPOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GMPWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GMPS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GMPS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GMPS
    **/
    _count?: true | GMPCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GMPAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GMPSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GMPMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GMPMaxAggregateInputType
  }

  export type GetGMPAggregateType<T extends GMPAggregateArgs> = {
        [P in keyof T & keyof AggregateGMP]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGMP[P]>
      : GetScalarType<T[P], AggregateGMP[P]>
  }




  export type GMPGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GMPWhereInput
    orderBy?: GMPOrderByWithAggregationInput | GMPOrderByWithAggregationInput[]
    by: GMPScalarFieldEnum[] | GMPScalarFieldEnum
    having?: GMPScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GMPCountAggregateInputType | true
    _avg?: GMPAvgAggregateInputType
    _sum?: GMPSumAggregateInputType
    _min?: GMPMinAggregateInputType
    _max?: GMPMaxAggregateInputType
  }

  export type GMPGroupByOutputType = {
    id: string
    ipoId: string
    value: number
    percentage: number
    volume: number | null
    bidPrice: number | null
    askPrice: number | null
    timestamp: Date
    source: string
    metadata: string | null
    createdAt: Date
    updatedAt: Date
    _count: GMPCountAggregateOutputType | null
    _avg: GMPAvgAggregateOutputType | null
    _sum: GMPSumAggregateOutputType | null
    _min: GMPMinAggregateOutputType | null
    _max: GMPMaxAggregateOutputType | null
  }

  type GetGMPGroupByPayload<T extends GMPGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GMPGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GMPGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GMPGroupByOutputType[P]>
            : GetScalarType<T[P], GMPGroupByOutputType[P]>
        }
      >
    >


  export type GMPSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ipoId?: boolean
    value?: boolean
    percentage?: boolean
    volume?: boolean
    bidPrice?: boolean
    askPrice?: boolean
    timestamp?: boolean
    source?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ipo?: boolean | IPODefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gMP"]>

  export type GMPSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ipoId?: boolean
    value?: boolean
    percentage?: boolean
    volume?: boolean
    bidPrice?: boolean
    askPrice?: boolean
    timestamp?: boolean
    source?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ipo?: boolean | IPODefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gMP"]>

  export type GMPSelectScalar = {
    id?: boolean
    ipoId?: boolean
    value?: boolean
    percentage?: boolean
    volume?: boolean
    bidPrice?: boolean
    askPrice?: boolean
    timestamp?: boolean
    source?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type GMPInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ipo?: boolean | IPODefaultArgs<ExtArgs>
  }
  export type GMPIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ipo?: boolean | IPODefaultArgs<ExtArgs>
  }

  export type $GMPPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GMP"
    objects: {
      ipo: Prisma.$IPOPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      ipoId: string
      value: number
      percentage: number
      volume: number | null
      bidPrice: number | null
      askPrice: number | null
      timestamp: Date
      source: string
      metadata: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["gMP"]>
    composites: {}
  }

  type GMPGetPayload<S extends boolean | null | undefined | GMPDefaultArgs> = $Result.GetResult<Prisma.$GMPPayload, S>

  type GMPCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<GMPFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: GMPCountAggregateInputType | true
    }

  export interface GMPDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GMP'], meta: { name: 'GMP' } }
    /**
     * Find zero or one GMP that matches the filter.
     * @param {GMPFindUniqueArgs} args - Arguments to find a GMP
     * @example
     * // Get one GMP
     * const gMP = await prisma.gMP.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GMPFindUniqueArgs>(args: SelectSubset<T, GMPFindUniqueArgs<ExtArgs>>): Prisma__GMPClient<$Result.GetResult<Prisma.$GMPPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one GMP that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {GMPFindUniqueOrThrowArgs} args - Arguments to find a GMP
     * @example
     * // Get one GMP
     * const gMP = await prisma.gMP.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GMPFindUniqueOrThrowArgs>(args: SelectSubset<T, GMPFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GMPClient<$Result.GetResult<Prisma.$GMPPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first GMP that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GMPFindFirstArgs} args - Arguments to find a GMP
     * @example
     * // Get one GMP
     * const gMP = await prisma.gMP.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GMPFindFirstArgs>(args?: SelectSubset<T, GMPFindFirstArgs<ExtArgs>>): Prisma__GMPClient<$Result.GetResult<Prisma.$GMPPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first GMP that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GMPFindFirstOrThrowArgs} args - Arguments to find a GMP
     * @example
     * // Get one GMP
     * const gMP = await prisma.gMP.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GMPFindFirstOrThrowArgs>(args?: SelectSubset<T, GMPFindFirstOrThrowArgs<ExtArgs>>): Prisma__GMPClient<$Result.GetResult<Prisma.$GMPPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more GMPS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GMPFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GMPS
     * const gMPS = await prisma.gMP.findMany()
     * 
     * // Get first 10 GMPS
     * const gMPS = await prisma.gMP.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gMPWithIdOnly = await prisma.gMP.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GMPFindManyArgs>(args?: SelectSubset<T, GMPFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GMPPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a GMP.
     * @param {GMPCreateArgs} args - Arguments to create a GMP.
     * @example
     * // Create one GMP
     * const GMP = await prisma.gMP.create({
     *   data: {
     *     // ... data to create a GMP
     *   }
     * })
     * 
     */
    create<T extends GMPCreateArgs>(args: SelectSubset<T, GMPCreateArgs<ExtArgs>>): Prisma__GMPClient<$Result.GetResult<Prisma.$GMPPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many GMPS.
     * @param {GMPCreateManyArgs} args - Arguments to create many GMPS.
     * @example
     * // Create many GMPS
     * const gMP = await prisma.gMP.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GMPCreateManyArgs>(args?: SelectSubset<T, GMPCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GMPS and returns the data saved in the database.
     * @param {GMPCreateManyAndReturnArgs} args - Arguments to create many GMPS.
     * @example
     * // Create many GMPS
     * const gMP = await prisma.gMP.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GMPS and only return the `id`
     * const gMPWithIdOnly = await prisma.gMP.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GMPCreateManyAndReturnArgs>(args?: SelectSubset<T, GMPCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GMPPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a GMP.
     * @param {GMPDeleteArgs} args - Arguments to delete one GMP.
     * @example
     * // Delete one GMP
     * const GMP = await prisma.gMP.delete({
     *   where: {
     *     // ... filter to delete one GMP
     *   }
     * })
     * 
     */
    delete<T extends GMPDeleteArgs>(args: SelectSubset<T, GMPDeleteArgs<ExtArgs>>): Prisma__GMPClient<$Result.GetResult<Prisma.$GMPPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one GMP.
     * @param {GMPUpdateArgs} args - Arguments to update one GMP.
     * @example
     * // Update one GMP
     * const gMP = await prisma.gMP.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GMPUpdateArgs>(args: SelectSubset<T, GMPUpdateArgs<ExtArgs>>): Prisma__GMPClient<$Result.GetResult<Prisma.$GMPPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more GMPS.
     * @param {GMPDeleteManyArgs} args - Arguments to filter GMPS to delete.
     * @example
     * // Delete a few GMPS
     * const { count } = await prisma.gMP.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GMPDeleteManyArgs>(args?: SelectSubset<T, GMPDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GMPS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GMPUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GMPS
     * const gMP = await prisma.gMP.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GMPUpdateManyArgs>(args: SelectSubset<T, GMPUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one GMP.
     * @param {GMPUpsertArgs} args - Arguments to update or create a GMP.
     * @example
     * // Update or create a GMP
     * const gMP = await prisma.gMP.upsert({
     *   create: {
     *     // ... data to create a GMP
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GMP we want to update
     *   }
     * })
     */
    upsert<T extends GMPUpsertArgs>(args: SelectSubset<T, GMPUpsertArgs<ExtArgs>>): Prisma__GMPClient<$Result.GetResult<Prisma.$GMPPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of GMPS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GMPCountArgs} args - Arguments to filter GMPS to count.
     * @example
     * // Count the number of GMPS
     * const count = await prisma.gMP.count({
     *   where: {
     *     // ... the filter for the GMPS we want to count
     *   }
     * })
    **/
    count<T extends GMPCountArgs>(
      args?: Subset<T, GMPCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GMPCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GMP.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GMPAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GMPAggregateArgs>(args: Subset<T, GMPAggregateArgs>): Prisma.PrismaPromise<GetGMPAggregateType<T>>

    /**
     * Group by GMP.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GMPGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GMPGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GMPGroupByArgs['orderBy'] }
        : { orderBy?: GMPGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GMPGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGMPGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GMP model
   */
  readonly fields: GMPFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GMP.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GMPClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ipo<T extends IPODefaultArgs<ExtArgs> = {}>(args?: Subset<T, IPODefaultArgs<ExtArgs>>): Prisma__IPOClient<$Result.GetResult<Prisma.$IPOPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GMP model
   */ 
  interface GMPFieldRefs {
    readonly id: FieldRef<"GMP", 'String'>
    readonly ipoId: FieldRef<"GMP", 'String'>
    readonly value: FieldRef<"GMP", 'Float'>
    readonly percentage: FieldRef<"GMP", 'Float'>
    readonly volume: FieldRef<"GMP", 'Int'>
    readonly bidPrice: FieldRef<"GMP", 'Float'>
    readonly askPrice: FieldRef<"GMP", 'Float'>
    readonly timestamp: FieldRef<"GMP", 'DateTime'>
    readonly source: FieldRef<"GMP", 'String'>
    readonly metadata: FieldRef<"GMP", 'String'>
    readonly createdAt: FieldRef<"GMP", 'DateTime'>
    readonly updatedAt: FieldRef<"GMP", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * GMP findUnique
   */
  export type GMPFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GMP
     */
    select?: GMPSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GMPInclude<ExtArgs> | null
    /**
     * Filter, which GMP to fetch.
     */
    where: GMPWhereUniqueInput
  }

  /**
   * GMP findUniqueOrThrow
   */
  export type GMPFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GMP
     */
    select?: GMPSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GMPInclude<ExtArgs> | null
    /**
     * Filter, which GMP to fetch.
     */
    where: GMPWhereUniqueInput
  }

  /**
   * GMP findFirst
   */
  export type GMPFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GMP
     */
    select?: GMPSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GMPInclude<ExtArgs> | null
    /**
     * Filter, which GMP to fetch.
     */
    where?: GMPWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GMPS to fetch.
     */
    orderBy?: GMPOrderByWithRelationInput | GMPOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GMPS.
     */
    cursor?: GMPWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GMPS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GMPS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GMPS.
     */
    distinct?: GMPScalarFieldEnum | GMPScalarFieldEnum[]
  }

  /**
   * GMP findFirstOrThrow
   */
  export type GMPFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GMP
     */
    select?: GMPSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GMPInclude<ExtArgs> | null
    /**
     * Filter, which GMP to fetch.
     */
    where?: GMPWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GMPS to fetch.
     */
    orderBy?: GMPOrderByWithRelationInput | GMPOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GMPS.
     */
    cursor?: GMPWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GMPS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GMPS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GMPS.
     */
    distinct?: GMPScalarFieldEnum | GMPScalarFieldEnum[]
  }

  /**
   * GMP findMany
   */
  export type GMPFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GMP
     */
    select?: GMPSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GMPInclude<ExtArgs> | null
    /**
     * Filter, which GMPS to fetch.
     */
    where?: GMPWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GMPS to fetch.
     */
    orderBy?: GMPOrderByWithRelationInput | GMPOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GMPS.
     */
    cursor?: GMPWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GMPS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GMPS.
     */
    skip?: number
    distinct?: GMPScalarFieldEnum | GMPScalarFieldEnum[]
  }

  /**
   * GMP create
   */
  export type GMPCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GMP
     */
    select?: GMPSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GMPInclude<ExtArgs> | null
    /**
     * The data needed to create a GMP.
     */
    data: XOR<GMPCreateInput, GMPUncheckedCreateInput>
  }

  /**
   * GMP createMany
   */
  export type GMPCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GMPS.
     */
    data: GMPCreateManyInput | GMPCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GMP createManyAndReturn
   */
  export type GMPCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GMP
     */
    select?: GMPSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many GMPS.
     */
    data: GMPCreateManyInput | GMPCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GMPIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GMP update
   */
  export type GMPUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GMP
     */
    select?: GMPSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GMPInclude<ExtArgs> | null
    /**
     * The data needed to update a GMP.
     */
    data: XOR<GMPUpdateInput, GMPUncheckedUpdateInput>
    /**
     * Choose, which GMP to update.
     */
    where: GMPWhereUniqueInput
  }

  /**
   * GMP updateMany
   */
  export type GMPUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GMPS.
     */
    data: XOR<GMPUpdateManyMutationInput, GMPUncheckedUpdateManyInput>
    /**
     * Filter which GMPS to update
     */
    where?: GMPWhereInput
  }

  /**
   * GMP upsert
   */
  export type GMPUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GMP
     */
    select?: GMPSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GMPInclude<ExtArgs> | null
    /**
     * The filter to search for the GMP to update in case it exists.
     */
    where: GMPWhereUniqueInput
    /**
     * In case the GMP found by the `where` argument doesn't exist, create a new GMP with this data.
     */
    create: XOR<GMPCreateInput, GMPUncheckedCreateInput>
    /**
     * In case the GMP was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GMPUpdateInput, GMPUncheckedUpdateInput>
  }

  /**
   * GMP delete
   */
  export type GMPDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GMP
     */
    select?: GMPSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GMPInclude<ExtArgs> | null
    /**
     * Filter which GMP to delete.
     */
    where: GMPWhereUniqueInput
  }

  /**
   * GMP deleteMany
   */
  export type GMPDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GMPS to delete
     */
    where?: GMPWhereInput
  }

  /**
   * GMP without action
   */
  export type GMPDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GMP
     */
    select?: GMPSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GMPInclude<ExtArgs> | null
  }


  /**
   * Model SubscriptionData
   */

  export type AggregateSubscriptionData = {
    _count: SubscriptionDataCountAggregateOutputType | null
    _avg: SubscriptionDataAvgAggregateOutputType | null
    _sum: SubscriptionDataSumAggregateOutputType | null
    _min: SubscriptionDataMinAggregateOutputType | null
    _max: SubscriptionDataMaxAggregateOutputType | null
  }

  export type SubscriptionDataAvgAggregateOutputType = {
    quantity: number | null
    bidCount: number | null
    subscriptionRatio: number | null
  }

  export type SubscriptionDataSumAggregateOutputType = {
    quantity: bigint | null
    bidCount: number | null
    subscriptionRatio: number | null
  }

  export type SubscriptionDataMinAggregateOutputType = {
    id: string | null
    ipoId: string | null
    category: string | null
    subCategory: string | null
    quantity: bigint | null
    bidCount: number | null
    subscriptionRatio: number | null
    timestamp: Date | null
    metadata: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubscriptionDataMaxAggregateOutputType = {
    id: string | null
    ipoId: string | null
    category: string | null
    subCategory: string | null
    quantity: bigint | null
    bidCount: number | null
    subscriptionRatio: number | null
    timestamp: Date | null
    metadata: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubscriptionDataCountAggregateOutputType = {
    id: number
    ipoId: number
    category: number
    subCategory: number
    quantity: number
    bidCount: number
    subscriptionRatio: number
    timestamp: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SubscriptionDataAvgAggregateInputType = {
    quantity?: true
    bidCount?: true
    subscriptionRatio?: true
  }

  export type SubscriptionDataSumAggregateInputType = {
    quantity?: true
    bidCount?: true
    subscriptionRatio?: true
  }

  export type SubscriptionDataMinAggregateInputType = {
    id?: true
    ipoId?: true
    category?: true
    subCategory?: true
    quantity?: true
    bidCount?: true
    subscriptionRatio?: true
    timestamp?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubscriptionDataMaxAggregateInputType = {
    id?: true
    ipoId?: true
    category?: true
    subCategory?: true
    quantity?: true
    bidCount?: true
    subscriptionRatio?: true
    timestamp?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubscriptionDataCountAggregateInputType = {
    id?: true
    ipoId?: true
    category?: true
    subCategory?: true
    quantity?: true
    bidCount?: true
    subscriptionRatio?: true
    timestamp?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SubscriptionDataAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubscriptionData to aggregate.
     */
    where?: SubscriptionDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubscriptionData to fetch.
     */
    orderBy?: SubscriptionDataOrderByWithRelationInput | SubscriptionDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubscriptionDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubscriptionData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubscriptionData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SubscriptionData
    **/
    _count?: true | SubscriptionDataCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubscriptionDataAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubscriptionDataSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubscriptionDataMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubscriptionDataMaxAggregateInputType
  }

  export type GetSubscriptionDataAggregateType<T extends SubscriptionDataAggregateArgs> = {
        [P in keyof T & keyof AggregateSubscriptionData]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubscriptionData[P]>
      : GetScalarType<T[P], AggregateSubscriptionData[P]>
  }




  export type SubscriptionDataGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionDataWhereInput
    orderBy?: SubscriptionDataOrderByWithAggregationInput | SubscriptionDataOrderByWithAggregationInput[]
    by: SubscriptionDataScalarFieldEnum[] | SubscriptionDataScalarFieldEnum
    having?: SubscriptionDataScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubscriptionDataCountAggregateInputType | true
    _avg?: SubscriptionDataAvgAggregateInputType
    _sum?: SubscriptionDataSumAggregateInputType
    _min?: SubscriptionDataMinAggregateInputType
    _max?: SubscriptionDataMaxAggregateInputType
  }

  export type SubscriptionDataGroupByOutputType = {
    id: string
    ipoId: string
    category: string
    subCategory: string | null
    quantity: bigint
    bidCount: number
    subscriptionRatio: number
    timestamp: Date
    metadata: string | null
    createdAt: Date
    updatedAt: Date
    _count: SubscriptionDataCountAggregateOutputType | null
    _avg: SubscriptionDataAvgAggregateOutputType | null
    _sum: SubscriptionDataSumAggregateOutputType | null
    _min: SubscriptionDataMinAggregateOutputType | null
    _max: SubscriptionDataMaxAggregateOutputType | null
  }

  type GetSubscriptionDataGroupByPayload<T extends SubscriptionDataGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubscriptionDataGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubscriptionDataGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubscriptionDataGroupByOutputType[P]>
            : GetScalarType<T[P], SubscriptionDataGroupByOutputType[P]>
        }
      >
    >


  export type SubscriptionDataSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ipoId?: boolean
    category?: boolean
    subCategory?: boolean
    quantity?: boolean
    bidCount?: boolean
    subscriptionRatio?: boolean
    timestamp?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ipo?: boolean | IPODefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscriptionData"]>

  export type SubscriptionDataSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ipoId?: boolean
    category?: boolean
    subCategory?: boolean
    quantity?: boolean
    bidCount?: boolean
    subscriptionRatio?: boolean
    timestamp?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ipo?: boolean | IPODefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscriptionData"]>

  export type SubscriptionDataSelectScalar = {
    id?: boolean
    ipoId?: boolean
    category?: boolean
    subCategory?: boolean
    quantity?: boolean
    bidCount?: boolean
    subscriptionRatio?: boolean
    timestamp?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SubscriptionDataInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ipo?: boolean | IPODefaultArgs<ExtArgs>
  }
  export type SubscriptionDataIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ipo?: boolean | IPODefaultArgs<ExtArgs>
  }

  export type $SubscriptionDataPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SubscriptionData"
    objects: {
      ipo: Prisma.$IPOPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      ipoId: string
      category: string
      subCategory: string | null
      quantity: bigint
      bidCount: number
      subscriptionRatio: number
      timestamp: Date
      metadata: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["subscriptionData"]>
    composites: {}
  }

  type SubscriptionDataGetPayload<S extends boolean | null | undefined | SubscriptionDataDefaultArgs> = $Result.GetResult<Prisma.$SubscriptionDataPayload, S>

  type SubscriptionDataCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SubscriptionDataFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SubscriptionDataCountAggregateInputType | true
    }

  export interface SubscriptionDataDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SubscriptionData'], meta: { name: 'SubscriptionData' } }
    /**
     * Find zero or one SubscriptionData that matches the filter.
     * @param {SubscriptionDataFindUniqueArgs} args - Arguments to find a SubscriptionData
     * @example
     * // Get one SubscriptionData
     * const subscriptionData = await prisma.subscriptionData.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubscriptionDataFindUniqueArgs>(args: SelectSubset<T, SubscriptionDataFindUniqueArgs<ExtArgs>>): Prisma__SubscriptionDataClient<$Result.GetResult<Prisma.$SubscriptionDataPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SubscriptionData that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SubscriptionDataFindUniqueOrThrowArgs} args - Arguments to find a SubscriptionData
     * @example
     * // Get one SubscriptionData
     * const subscriptionData = await prisma.subscriptionData.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubscriptionDataFindUniqueOrThrowArgs>(args: SelectSubset<T, SubscriptionDataFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubscriptionDataClient<$Result.GetResult<Prisma.$SubscriptionDataPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SubscriptionData that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionDataFindFirstArgs} args - Arguments to find a SubscriptionData
     * @example
     * // Get one SubscriptionData
     * const subscriptionData = await prisma.subscriptionData.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubscriptionDataFindFirstArgs>(args?: SelectSubset<T, SubscriptionDataFindFirstArgs<ExtArgs>>): Prisma__SubscriptionDataClient<$Result.GetResult<Prisma.$SubscriptionDataPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SubscriptionData that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionDataFindFirstOrThrowArgs} args - Arguments to find a SubscriptionData
     * @example
     * // Get one SubscriptionData
     * const subscriptionData = await prisma.subscriptionData.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubscriptionDataFindFirstOrThrowArgs>(args?: SelectSubset<T, SubscriptionDataFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubscriptionDataClient<$Result.GetResult<Prisma.$SubscriptionDataPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SubscriptionData that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionDataFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SubscriptionData
     * const subscriptionData = await prisma.subscriptionData.findMany()
     * 
     * // Get first 10 SubscriptionData
     * const subscriptionData = await prisma.subscriptionData.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subscriptionDataWithIdOnly = await prisma.subscriptionData.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubscriptionDataFindManyArgs>(args?: SelectSubset<T, SubscriptionDataFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionDataPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SubscriptionData.
     * @param {SubscriptionDataCreateArgs} args - Arguments to create a SubscriptionData.
     * @example
     * // Create one SubscriptionData
     * const SubscriptionData = await prisma.subscriptionData.create({
     *   data: {
     *     // ... data to create a SubscriptionData
     *   }
     * })
     * 
     */
    create<T extends SubscriptionDataCreateArgs>(args: SelectSubset<T, SubscriptionDataCreateArgs<ExtArgs>>): Prisma__SubscriptionDataClient<$Result.GetResult<Prisma.$SubscriptionDataPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SubscriptionData.
     * @param {SubscriptionDataCreateManyArgs} args - Arguments to create many SubscriptionData.
     * @example
     * // Create many SubscriptionData
     * const subscriptionData = await prisma.subscriptionData.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubscriptionDataCreateManyArgs>(args?: SelectSubset<T, SubscriptionDataCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SubscriptionData and returns the data saved in the database.
     * @param {SubscriptionDataCreateManyAndReturnArgs} args - Arguments to create many SubscriptionData.
     * @example
     * // Create many SubscriptionData
     * const subscriptionData = await prisma.subscriptionData.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SubscriptionData and only return the `id`
     * const subscriptionDataWithIdOnly = await prisma.subscriptionData.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubscriptionDataCreateManyAndReturnArgs>(args?: SelectSubset<T, SubscriptionDataCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionDataPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SubscriptionData.
     * @param {SubscriptionDataDeleteArgs} args - Arguments to delete one SubscriptionData.
     * @example
     * // Delete one SubscriptionData
     * const SubscriptionData = await prisma.subscriptionData.delete({
     *   where: {
     *     // ... filter to delete one SubscriptionData
     *   }
     * })
     * 
     */
    delete<T extends SubscriptionDataDeleteArgs>(args: SelectSubset<T, SubscriptionDataDeleteArgs<ExtArgs>>): Prisma__SubscriptionDataClient<$Result.GetResult<Prisma.$SubscriptionDataPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SubscriptionData.
     * @param {SubscriptionDataUpdateArgs} args - Arguments to update one SubscriptionData.
     * @example
     * // Update one SubscriptionData
     * const subscriptionData = await prisma.subscriptionData.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubscriptionDataUpdateArgs>(args: SelectSubset<T, SubscriptionDataUpdateArgs<ExtArgs>>): Prisma__SubscriptionDataClient<$Result.GetResult<Prisma.$SubscriptionDataPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SubscriptionData.
     * @param {SubscriptionDataDeleteManyArgs} args - Arguments to filter SubscriptionData to delete.
     * @example
     * // Delete a few SubscriptionData
     * const { count } = await prisma.subscriptionData.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubscriptionDataDeleteManyArgs>(args?: SelectSubset<T, SubscriptionDataDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubscriptionData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionDataUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SubscriptionData
     * const subscriptionData = await prisma.subscriptionData.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubscriptionDataUpdateManyArgs>(args: SelectSubset<T, SubscriptionDataUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SubscriptionData.
     * @param {SubscriptionDataUpsertArgs} args - Arguments to update or create a SubscriptionData.
     * @example
     * // Update or create a SubscriptionData
     * const subscriptionData = await prisma.subscriptionData.upsert({
     *   create: {
     *     // ... data to create a SubscriptionData
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SubscriptionData we want to update
     *   }
     * })
     */
    upsert<T extends SubscriptionDataUpsertArgs>(args: SelectSubset<T, SubscriptionDataUpsertArgs<ExtArgs>>): Prisma__SubscriptionDataClient<$Result.GetResult<Prisma.$SubscriptionDataPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SubscriptionData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionDataCountArgs} args - Arguments to filter SubscriptionData to count.
     * @example
     * // Count the number of SubscriptionData
     * const count = await prisma.subscriptionData.count({
     *   where: {
     *     // ... the filter for the SubscriptionData we want to count
     *   }
     * })
    **/
    count<T extends SubscriptionDataCountArgs>(
      args?: Subset<T, SubscriptionDataCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubscriptionDataCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SubscriptionData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionDataAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubscriptionDataAggregateArgs>(args: Subset<T, SubscriptionDataAggregateArgs>): Prisma.PrismaPromise<GetSubscriptionDataAggregateType<T>>

    /**
     * Group by SubscriptionData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionDataGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubscriptionDataGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubscriptionDataGroupByArgs['orderBy'] }
        : { orderBy?: SubscriptionDataGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubscriptionDataGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubscriptionDataGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SubscriptionData model
   */
  readonly fields: SubscriptionDataFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SubscriptionData.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubscriptionDataClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ipo<T extends IPODefaultArgs<ExtArgs> = {}>(args?: Subset<T, IPODefaultArgs<ExtArgs>>): Prisma__IPOClient<$Result.GetResult<Prisma.$IPOPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SubscriptionData model
   */ 
  interface SubscriptionDataFieldRefs {
    readonly id: FieldRef<"SubscriptionData", 'String'>
    readonly ipoId: FieldRef<"SubscriptionData", 'String'>
    readonly category: FieldRef<"SubscriptionData", 'String'>
    readonly subCategory: FieldRef<"SubscriptionData", 'String'>
    readonly quantity: FieldRef<"SubscriptionData", 'BigInt'>
    readonly bidCount: FieldRef<"SubscriptionData", 'Int'>
    readonly subscriptionRatio: FieldRef<"SubscriptionData", 'Float'>
    readonly timestamp: FieldRef<"SubscriptionData", 'DateTime'>
    readonly metadata: FieldRef<"SubscriptionData", 'String'>
    readonly createdAt: FieldRef<"SubscriptionData", 'DateTime'>
    readonly updatedAt: FieldRef<"SubscriptionData", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SubscriptionData findUnique
   */
  export type SubscriptionDataFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionData
     */
    select?: SubscriptionDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionDataInclude<ExtArgs> | null
    /**
     * Filter, which SubscriptionData to fetch.
     */
    where: SubscriptionDataWhereUniqueInput
  }

  /**
   * SubscriptionData findUniqueOrThrow
   */
  export type SubscriptionDataFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionData
     */
    select?: SubscriptionDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionDataInclude<ExtArgs> | null
    /**
     * Filter, which SubscriptionData to fetch.
     */
    where: SubscriptionDataWhereUniqueInput
  }

  /**
   * SubscriptionData findFirst
   */
  export type SubscriptionDataFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionData
     */
    select?: SubscriptionDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionDataInclude<ExtArgs> | null
    /**
     * Filter, which SubscriptionData to fetch.
     */
    where?: SubscriptionDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubscriptionData to fetch.
     */
    orderBy?: SubscriptionDataOrderByWithRelationInput | SubscriptionDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubscriptionData.
     */
    cursor?: SubscriptionDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubscriptionData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubscriptionData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubscriptionData.
     */
    distinct?: SubscriptionDataScalarFieldEnum | SubscriptionDataScalarFieldEnum[]
  }

  /**
   * SubscriptionData findFirstOrThrow
   */
  export type SubscriptionDataFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionData
     */
    select?: SubscriptionDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionDataInclude<ExtArgs> | null
    /**
     * Filter, which SubscriptionData to fetch.
     */
    where?: SubscriptionDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubscriptionData to fetch.
     */
    orderBy?: SubscriptionDataOrderByWithRelationInput | SubscriptionDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubscriptionData.
     */
    cursor?: SubscriptionDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubscriptionData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubscriptionData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubscriptionData.
     */
    distinct?: SubscriptionDataScalarFieldEnum | SubscriptionDataScalarFieldEnum[]
  }

  /**
   * SubscriptionData findMany
   */
  export type SubscriptionDataFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionData
     */
    select?: SubscriptionDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionDataInclude<ExtArgs> | null
    /**
     * Filter, which SubscriptionData to fetch.
     */
    where?: SubscriptionDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubscriptionData to fetch.
     */
    orderBy?: SubscriptionDataOrderByWithRelationInput | SubscriptionDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SubscriptionData.
     */
    cursor?: SubscriptionDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubscriptionData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubscriptionData.
     */
    skip?: number
    distinct?: SubscriptionDataScalarFieldEnum | SubscriptionDataScalarFieldEnum[]
  }

  /**
   * SubscriptionData create
   */
  export type SubscriptionDataCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionData
     */
    select?: SubscriptionDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionDataInclude<ExtArgs> | null
    /**
     * The data needed to create a SubscriptionData.
     */
    data: XOR<SubscriptionDataCreateInput, SubscriptionDataUncheckedCreateInput>
  }

  /**
   * SubscriptionData createMany
   */
  export type SubscriptionDataCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SubscriptionData.
     */
    data: SubscriptionDataCreateManyInput | SubscriptionDataCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SubscriptionData createManyAndReturn
   */
  export type SubscriptionDataCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionData
     */
    select?: SubscriptionDataSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SubscriptionData.
     */
    data: SubscriptionDataCreateManyInput | SubscriptionDataCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionDataIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SubscriptionData update
   */
  export type SubscriptionDataUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionData
     */
    select?: SubscriptionDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionDataInclude<ExtArgs> | null
    /**
     * The data needed to update a SubscriptionData.
     */
    data: XOR<SubscriptionDataUpdateInput, SubscriptionDataUncheckedUpdateInput>
    /**
     * Choose, which SubscriptionData to update.
     */
    where: SubscriptionDataWhereUniqueInput
  }

  /**
   * SubscriptionData updateMany
   */
  export type SubscriptionDataUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SubscriptionData.
     */
    data: XOR<SubscriptionDataUpdateManyMutationInput, SubscriptionDataUncheckedUpdateManyInput>
    /**
     * Filter which SubscriptionData to update
     */
    where?: SubscriptionDataWhereInput
  }

  /**
   * SubscriptionData upsert
   */
  export type SubscriptionDataUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionData
     */
    select?: SubscriptionDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionDataInclude<ExtArgs> | null
    /**
     * The filter to search for the SubscriptionData to update in case it exists.
     */
    where: SubscriptionDataWhereUniqueInput
    /**
     * In case the SubscriptionData found by the `where` argument doesn't exist, create a new SubscriptionData with this data.
     */
    create: XOR<SubscriptionDataCreateInput, SubscriptionDataUncheckedCreateInput>
    /**
     * In case the SubscriptionData was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubscriptionDataUpdateInput, SubscriptionDataUncheckedUpdateInput>
  }

  /**
   * SubscriptionData delete
   */
  export type SubscriptionDataDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionData
     */
    select?: SubscriptionDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionDataInclude<ExtArgs> | null
    /**
     * Filter which SubscriptionData to delete.
     */
    where: SubscriptionDataWhereUniqueInput
  }

  /**
   * SubscriptionData deleteMany
   */
  export type SubscriptionDataDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubscriptionData to delete
     */
    where?: SubscriptionDataWhereInput
  }

  /**
   * SubscriptionData without action
   */
  export type SubscriptionDataDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionData
     */
    select?: SubscriptionDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionDataInclude<ExtArgs> | null
  }


  /**
   * Model AllotmentData
   */

  export type AggregateAllotmentData = {
    _count: AllotmentDataCountAggregateOutputType | null
    _avg: AllotmentDataAvgAggregateOutputType | null
    _sum: AllotmentDataSumAggregateOutputType | null
    _min: AllotmentDataMinAggregateOutputType | null
    _max: AllotmentDataMaxAggregateOutputType | null
  }

  export type AllotmentDataAvgAggregateOutputType = {
    appliedQuantity: number | null
    allottedQuantity: number | null
    allottedAmount: number | null
    refundAmount: number | null
  }

  export type AllotmentDataSumAggregateOutputType = {
    appliedQuantity: number | null
    allottedQuantity: number | null
    allottedAmount: number | null
    refundAmount: number | null
  }

  export type AllotmentDataMinAggregateOutputType = {
    id: string | null
    ipoId: string | null
    pan: string | null
    applicationNumber: string | null
    category: string | null
    appliedQuantity: number | null
    allottedQuantity: number | null
    allottedAmount: number | null
    refundAmount: number | null
    allotmentStatus: string | null
    timestamp: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AllotmentDataMaxAggregateOutputType = {
    id: string | null
    ipoId: string | null
    pan: string | null
    applicationNumber: string | null
    category: string | null
    appliedQuantity: number | null
    allottedQuantity: number | null
    allottedAmount: number | null
    refundAmount: number | null
    allotmentStatus: string | null
    timestamp: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AllotmentDataCountAggregateOutputType = {
    id: number
    ipoId: number
    pan: number
    applicationNumber: number
    category: number
    appliedQuantity: number
    allottedQuantity: number
    allottedAmount: number
    refundAmount: number
    allotmentStatus: number
    timestamp: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AllotmentDataAvgAggregateInputType = {
    appliedQuantity?: true
    allottedQuantity?: true
    allottedAmount?: true
    refundAmount?: true
  }

  export type AllotmentDataSumAggregateInputType = {
    appliedQuantity?: true
    allottedQuantity?: true
    allottedAmount?: true
    refundAmount?: true
  }

  export type AllotmentDataMinAggregateInputType = {
    id?: true
    ipoId?: true
    pan?: true
    applicationNumber?: true
    category?: true
    appliedQuantity?: true
    allottedQuantity?: true
    allottedAmount?: true
    refundAmount?: true
    allotmentStatus?: true
    timestamp?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AllotmentDataMaxAggregateInputType = {
    id?: true
    ipoId?: true
    pan?: true
    applicationNumber?: true
    category?: true
    appliedQuantity?: true
    allottedQuantity?: true
    allottedAmount?: true
    refundAmount?: true
    allotmentStatus?: true
    timestamp?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AllotmentDataCountAggregateInputType = {
    id?: true
    ipoId?: true
    pan?: true
    applicationNumber?: true
    category?: true
    appliedQuantity?: true
    allottedQuantity?: true
    allottedAmount?: true
    refundAmount?: true
    allotmentStatus?: true
    timestamp?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AllotmentDataAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AllotmentData to aggregate.
     */
    where?: AllotmentDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AllotmentData to fetch.
     */
    orderBy?: AllotmentDataOrderByWithRelationInput | AllotmentDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AllotmentDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AllotmentData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AllotmentData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AllotmentData
    **/
    _count?: true | AllotmentDataCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AllotmentDataAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AllotmentDataSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AllotmentDataMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AllotmentDataMaxAggregateInputType
  }

  export type GetAllotmentDataAggregateType<T extends AllotmentDataAggregateArgs> = {
        [P in keyof T & keyof AggregateAllotmentData]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAllotmentData[P]>
      : GetScalarType<T[P], AggregateAllotmentData[P]>
  }




  export type AllotmentDataGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AllotmentDataWhereInput
    orderBy?: AllotmentDataOrderByWithAggregationInput | AllotmentDataOrderByWithAggregationInput[]
    by: AllotmentDataScalarFieldEnum[] | AllotmentDataScalarFieldEnum
    having?: AllotmentDataScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AllotmentDataCountAggregateInputType | true
    _avg?: AllotmentDataAvgAggregateInputType
    _sum?: AllotmentDataSumAggregateInputType
    _min?: AllotmentDataMinAggregateInputType
    _max?: AllotmentDataMaxAggregateInputType
  }

  export type AllotmentDataGroupByOutputType = {
    id: string
    ipoId: string
    pan: string
    applicationNumber: string | null
    category: string
    appliedQuantity: number
    allottedQuantity: number
    allottedAmount: number
    refundAmount: number
    allotmentStatus: string
    timestamp: Date
    createdAt: Date
    updatedAt: Date
    _count: AllotmentDataCountAggregateOutputType | null
    _avg: AllotmentDataAvgAggregateOutputType | null
    _sum: AllotmentDataSumAggregateOutputType | null
    _min: AllotmentDataMinAggregateOutputType | null
    _max: AllotmentDataMaxAggregateOutputType | null
  }

  type GetAllotmentDataGroupByPayload<T extends AllotmentDataGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AllotmentDataGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AllotmentDataGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AllotmentDataGroupByOutputType[P]>
            : GetScalarType<T[P], AllotmentDataGroupByOutputType[P]>
        }
      >
    >


  export type AllotmentDataSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ipoId?: boolean
    pan?: boolean
    applicationNumber?: boolean
    category?: boolean
    appliedQuantity?: boolean
    allottedQuantity?: boolean
    allottedAmount?: boolean
    refundAmount?: boolean
    allotmentStatus?: boolean
    timestamp?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ipo?: boolean | IPODefaultArgs<ExtArgs>
  }, ExtArgs["result"]["allotmentData"]>

  export type AllotmentDataSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ipoId?: boolean
    pan?: boolean
    applicationNumber?: boolean
    category?: boolean
    appliedQuantity?: boolean
    allottedQuantity?: boolean
    allottedAmount?: boolean
    refundAmount?: boolean
    allotmentStatus?: boolean
    timestamp?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ipo?: boolean | IPODefaultArgs<ExtArgs>
  }, ExtArgs["result"]["allotmentData"]>

  export type AllotmentDataSelectScalar = {
    id?: boolean
    ipoId?: boolean
    pan?: boolean
    applicationNumber?: boolean
    category?: boolean
    appliedQuantity?: boolean
    allottedQuantity?: boolean
    allottedAmount?: boolean
    refundAmount?: boolean
    allotmentStatus?: boolean
    timestamp?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AllotmentDataInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ipo?: boolean | IPODefaultArgs<ExtArgs>
  }
  export type AllotmentDataIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ipo?: boolean | IPODefaultArgs<ExtArgs>
  }

  export type $AllotmentDataPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AllotmentData"
    objects: {
      ipo: Prisma.$IPOPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      ipoId: string
      pan: string
      applicationNumber: string | null
      category: string
      appliedQuantity: number
      allottedQuantity: number
      allottedAmount: number
      refundAmount: number
      allotmentStatus: string
      timestamp: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["allotmentData"]>
    composites: {}
  }

  type AllotmentDataGetPayload<S extends boolean | null | undefined | AllotmentDataDefaultArgs> = $Result.GetResult<Prisma.$AllotmentDataPayload, S>

  type AllotmentDataCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AllotmentDataFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AllotmentDataCountAggregateInputType | true
    }

  export interface AllotmentDataDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AllotmentData'], meta: { name: 'AllotmentData' } }
    /**
     * Find zero or one AllotmentData that matches the filter.
     * @param {AllotmentDataFindUniqueArgs} args - Arguments to find a AllotmentData
     * @example
     * // Get one AllotmentData
     * const allotmentData = await prisma.allotmentData.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AllotmentDataFindUniqueArgs>(args: SelectSubset<T, AllotmentDataFindUniqueArgs<ExtArgs>>): Prisma__AllotmentDataClient<$Result.GetResult<Prisma.$AllotmentDataPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AllotmentData that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AllotmentDataFindUniqueOrThrowArgs} args - Arguments to find a AllotmentData
     * @example
     * // Get one AllotmentData
     * const allotmentData = await prisma.allotmentData.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AllotmentDataFindUniqueOrThrowArgs>(args: SelectSubset<T, AllotmentDataFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AllotmentDataClient<$Result.GetResult<Prisma.$AllotmentDataPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AllotmentData that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AllotmentDataFindFirstArgs} args - Arguments to find a AllotmentData
     * @example
     * // Get one AllotmentData
     * const allotmentData = await prisma.allotmentData.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AllotmentDataFindFirstArgs>(args?: SelectSubset<T, AllotmentDataFindFirstArgs<ExtArgs>>): Prisma__AllotmentDataClient<$Result.GetResult<Prisma.$AllotmentDataPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AllotmentData that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AllotmentDataFindFirstOrThrowArgs} args - Arguments to find a AllotmentData
     * @example
     * // Get one AllotmentData
     * const allotmentData = await prisma.allotmentData.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AllotmentDataFindFirstOrThrowArgs>(args?: SelectSubset<T, AllotmentDataFindFirstOrThrowArgs<ExtArgs>>): Prisma__AllotmentDataClient<$Result.GetResult<Prisma.$AllotmentDataPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AllotmentData that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AllotmentDataFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AllotmentData
     * const allotmentData = await prisma.allotmentData.findMany()
     * 
     * // Get first 10 AllotmentData
     * const allotmentData = await prisma.allotmentData.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const allotmentDataWithIdOnly = await prisma.allotmentData.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AllotmentDataFindManyArgs>(args?: SelectSubset<T, AllotmentDataFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AllotmentDataPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AllotmentData.
     * @param {AllotmentDataCreateArgs} args - Arguments to create a AllotmentData.
     * @example
     * // Create one AllotmentData
     * const AllotmentData = await prisma.allotmentData.create({
     *   data: {
     *     // ... data to create a AllotmentData
     *   }
     * })
     * 
     */
    create<T extends AllotmentDataCreateArgs>(args: SelectSubset<T, AllotmentDataCreateArgs<ExtArgs>>): Prisma__AllotmentDataClient<$Result.GetResult<Prisma.$AllotmentDataPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AllotmentData.
     * @param {AllotmentDataCreateManyArgs} args - Arguments to create many AllotmentData.
     * @example
     * // Create many AllotmentData
     * const allotmentData = await prisma.allotmentData.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AllotmentDataCreateManyArgs>(args?: SelectSubset<T, AllotmentDataCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AllotmentData and returns the data saved in the database.
     * @param {AllotmentDataCreateManyAndReturnArgs} args - Arguments to create many AllotmentData.
     * @example
     * // Create many AllotmentData
     * const allotmentData = await prisma.allotmentData.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AllotmentData and only return the `id`
     * const allotmentDataWithIdOnly = await prisma.allotmentData.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AllotmentDataCreateManyAndReturnArgs>(args?: SelectSubset<T, AllotmentDataCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AllotmentDataPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AllotmentData.
     * @param {AllotmentDataDeleteArgs} args - Arguments to delete one AllotmentData.
     * @example
     * // Delete one AllotmentData
     * const AllotmentData = await prisma.allotmentData.delete({
     *   where: {
     *     // ... filter to delete one AllotmentData
     *   }
     * })
     * 
     */
    delete<T extends AllotmentDataDeleteArgs>(args: SelectSubset<T, AllotmentDataDeleteArgs<ExtArgs>>): Prisma__AllotmentDataClient<$Result.GetResult<Prisma.$AllotmentDataPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AllotmentData.
     * @param {AllotmentDataUpdateArgs} args - Arguments to update one AllotmentData.
     * @example
     * // Update one AllotmentData
     * const allotmentData = await prisma.allotmentData.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AllotmentDataUpdateArgs>(args: SelectSubset<T, AllotmentDataUpdateArgs<ExtArgs>>): Prisma__AllotmentDataClient<$Result.GetResult<Prisma.$AllotmentDataPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AllotmentData.
     * @param {AllotmentDataDeleteManyArgs} args - Arguments to filter AllotmentData to delete.
     * @example
     * // Delete a few AllotmentData
     * const { count } = await prisma.allotmentData.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AllotmentDataDeleteManyArgs>(args?: SelectSubset<T, AllotmentDataDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AllotmentData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AllotmentDataUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AllotmentData
     * const allotmentData = await prisma.allotmentData.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AllotmentDataUpdateManyArgs>(args: SelectSubset<T, AllotmentDataUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AllotmentData.
     * @param {AllotmentDataUpsertArgs} args - Arguments to update or create a AllotmentData.
     * @example
     * // Update or create a AllotmentData
     * const allotmentData = await prisma.allotmentData.upsert({
     *   create: {
     *     // ... data to create a AllotmentData
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AllotmentData we want to update
     *   }
     * })
     */
    upsert<T extends AllotmentDataUpsertArgs>(args: SelectSubset<T, AllotmentDataUpsertArgs<ExtArgs>>): Prisma__AllotmentDataClient<$Result.GetResult<Prisma.$AllotmentDataPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AllotmentData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AllotmentDataCountArgs} args - Arguments to filter AllotmentData to count.
     * @example
     * // Count the number of AllotmentData
     * const count = await prisma.allotmentData.count({
     *   where: {
     *     // ... the filter for the AllotmentData we want to count
     *   }
     * })
    **/
    count<T extends AllotmentDataCountArgs>(
      args?: Subset<T, AllotmentDataCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AllotmentDataCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AllotmentData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AllotmentDataAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AllotmentDataAggregateArgs>(args: Subset<T, AllotmentDataAggregateArgs>): Prisma.PrismaPromise<GetAllotmentDataAggregateType<T>>

    /**
     * Group by AllotmentData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AllotmentDataGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AllotmentDataGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AllotmentDataGroupByArgs['orderBy'] }
        : { orderBy?: AllotmentDataGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AllotmentDataGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAllotmentDataGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AllotmentData model
   */
  readonly fields: AllotmentDataFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AllotmentData.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AllotmentDataClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ipo<T extends IPODefaultArgs<ExtArgs> = {}>(args?: Subset<T, IPODefaultArgs<ExtArgs>>): Prisma__IPOClient<$Result.GetResult<Prisma.$IPOPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AllotmentData model
   */ 
  interface AllotmentDataFieldRefs {
    readonly id: FieldRef<"AllotmentData", 'String'>
    readonly ipoId: FieldRef<"AllotmentData", 'String'>
    readonly pan: FieldRef<"AllotmentData", 'String'>
    readonly applicationNumber: FieldRef<"AllotmentData", 'String'>
    readonly category: FieldRef<"AllotmentData", 'String'>
    readonly appliedQuantity: FieldRef<"AllotmentData", 'Int'>
    readonly allottedQuantity: FieldRef<"AllotmentData", 'Int'>
    readonly allottedAmount: FieldRef<"AllotmentData", 'Float'>
    readonly refundAmount: FieldRef<"AllotmentData", 'Float'>
    readonly allotmentStatus: FieldRef<"AllotmentData", 'String'>
    readonly timestamp: FieldRef<"AllotmentData", 'DateTime'>
    readonly createdAt: FieldRef<"AllotmentData", 'DateTime'>
    readonly updatedAt: FieldRef<"AllotmentData", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AllotmentData findUnique
   */
  export type AllotmentDataFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AllotmentData
     */
    select?: AllotmentDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllotmentDataInclude<ExtArgs> | null
    /**
     * Filter, which AllotmentData to fetch.
     */
    where: AllotmentDataWhereUniqueInput
  }

  /**
   * AllotmentData findUniqueOrThrow
   */
  export type AllotmentDataFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AllotmentData
     */
    select?: AllotmentDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllotmentDataInclude<ExtArgs> | null
    /**
     * Filter, which AllotmentData to fetch.
     */
    where: AllotmentDataWhereUniqueInput
  }

  /**
   * AllotmentData findFirst
   */
  export type AllotmentDataFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AllotmentData
     */
    select?: AllotmentDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllotmentDataInclude<ExtArgs> | null
    /**
     * Filter, which AllotmentData to fetch.
     */
    where?: AllotmentDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AllotmentData to fetch.
     */
    orderBy?: AllotmentDataOrderByWithRelationInput | AllotmentDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AllotmentData.
     */
    cursor?: AllotmentDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AllotmentData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AllotmentData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AllotmentData.
     */
    distinct?: AllotmentDataScalarFieldEnum | AllotmentDataScalarFieldEnum[]
  }

  /**
   * AllotmentData findFirstOrThrow
   */
  export type AllotmentDataFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AllotmentData
     */
    select?: AllotmentDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllotmentDataInclude<ExtArgs> | null
    /**
     * Filter, which AllotmentData to fetch.
     */
    where?: AllotmentDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AllotmentData to fetch.
     */
    orderBy?: AllotmentDataOrderByWithRelationInput | AllotmentDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AllotmentData.
     */
    cursor?: AllotmentDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AllotmentData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AllotmentData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AllotmentData.
     */
    distinct?: AllotmentDataScalarFieldEnum | AllotmentDataScalarFieldEnum[]
  }

  /**
   * AllotmentData findMany
   */
  export type AllotmentDataFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AllotmentData
     */
    select?: AllotmentDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllotmentDataInclude<ExtArgs> | null
    /**
     * Filter, which AllotmentData to fetch.
     */
    where?: AllotmentDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AllotmentData to fetch.
     */
    orderBy?: AllotmentDataOrderByWithRelationInput | AllotmentDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AllotmentData.
     */
    cursor?: AllotmentDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AllotmentData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AllotmentData.
     */
    skip?: number
    distinct?: AllotmentDataScalarFieldEnum | AllotmentDataScalarFieldEnum[]
  }

  /**
   * AllotmentData create
   */
  export type AllotmentDataCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AllotmentData
     */
    select?: AllotmentDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllotmentDataInclude<ExtArgs> | null
    /**
     * The data needed to create a AllotmentData.
     */
    data: XOR<AllotmentDataCreateInput, AllotmentDataUncheckedCreateInput>
  }

  /**
   * AllotmentData createMany
   */
  export type AllotmentDataCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AllotmentData.
     */
    data: AllotmentDataCreateManyInput | AllotmentDataCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AllotmentData createManyAndReturn
   */
  export type AllotmentDataCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AllotmentData
     */
    select?: AllotmentDataSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AllotmentData.
     */
    data: AllotmentDataCreateManyInput | AllotmentDataCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllotmentDataIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AllotmentData update
   */
  export type AllotmentDataUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AllotmentData
     */
    select?: AllotmentDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllotmentDataInclude<ExtArgs> | null
    /**
     * The data needed to update a AllotmentData.
     */
    data: XOR<AllotmentDataUpdateInput, AllotmentDataUncheckedUpdateInput>
    /**
     * Choose, which AllotmentData to update.
     */
    where: AllotmentDataWhereUniqueInput
  }

  /**
   * AllotmentData updateMany
   */
  export type AllotmentDataUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AllotmentData.
     */
    data: XOR<AllotmentDataUpdateManyMutationInput, AllotmentDataUncheckedUpdateManyInput>
    /**
     * Filter which AllotmentData to update
     */
    where?: AllotmentDataWhereInput
  }

  /**
   * AllotmentData upsert
   */
  export type AllotmentDataUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AllotmentData
     */
    select?: AllotmentDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllotmentDataInclude<ExtArgs> | null
    /**
     * The filter to search for the AllotmentData to update in case it exists.
     */
    where: AllotmentDataWhereUniqueInput
    /**
     * In case the AllotmentData found by the `where` argument doesn't exist, create a new AllotmentData with this data.
     */
    create: XOR<AllotmentDataCreateInput, AllotmentDataUncheckedCreateInput>
    /**
     * In case the AllotmentData was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AllotmentDataUpdateInput, AllotmentDataUncheckedUpdateInput>
  }

  /**
   * AllotmentData delete
   */
  export type AllotmentDataDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AllotmentData
     */
    select?: AllotmentDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllotmentDataInclude<ExtArgs> | null
    /**
     * Filter which AllotmentData to delete.
     */
    where: AllotmentDataWhereUniqueInput
  }

  /**
   * AllotmentData deleteMany
   */
  export type AllotmentDataDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AllotmentData to delete
     */
    where?: AllotmentDataWhereInput
  }

  /**
   * AllotmentData without action
   */
  export type AllotmentDataDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AllotmentData
     */
    select?: AllotmentDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllotmentDataInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    phone: string | null
    pan: string | null
    role: string | null
    isActive: boolean | null
    isEmailVerified: boolean | null
    kycCompleted: boolean | null
    preferences: string | null
    lastLoginAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    phone: string | null
    pan: string | null
    role: string | null
    isActive: boolean | null
    isEmailVerified: boolean | null
    kycCompleted: boolean | null
    preferences: string | null
    lastLoginAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    name: number
    phone: number
    pan: number
    role: number
    isActive: number
    isEmailVerified: number
    kycCompleted: number
    preferences: number
    lastLoginAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    name?: true
    phone?: true
    pan?: true
    role?: true
    isActive?: true
    isEmailVerified?: true
    kycCompleted?: true
    preferences?: true
    lastLoginAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    name?: true
    phone?: true
    pan?: true
    role?: true
    isActive?: true
    isEmailVerified?: true
    kycCompleted?: true
    preferences?: true
    lastLoginAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    name?: true
    phone?: true
    pan?: true
    role?: true
    isActive?: true
    isEmailVerified?: true
    kycCompleted?: true
    preferences?: true
    lastLoginAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    name: string | null
    phone: string | null
    pan: string | null
    role: string
    isActive: boolean
    isEmailVerified: boolean
    kycCompleted: boolean
    preferences: string | null
    lastLoginAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    phone?: boolean
    pan?: boolean
    role?: boolean
    isActive?: boolean
    isEmailVerified?: boolean
    kycCompleted?: boolean
    preferences?: boolean
    lastLoginAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    watchlists?: boolean | User$watchlistsArgs<ExtArgs>
    alerts?: boolean | User$alertsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    phone?: boolean
    pan?: boolean
    role?: boolean
    isActive?: boolean
    isEmailVerified?: boolean
    kycCompleted?: boolean
    preferences?: boolean
    lastLoginAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    name?: boolean
    phone?: boolean
    pan?: boolean
    role?: boolean
    isActive?: boolean
    isEmailVerified?: boolean
    kycCompleted?: boolean
    preferences?: boolean
    lastLoginAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    watchlists?: boolean | User$watchlistsArgs<ExtArgs>
    alerts?: boolean | User$alertsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      watchlists: Prisma.$UserWatchlistPayload<ExtArgs>[]
      alerts: Prisma.$UserAlertPayload<ExtArgs>[]
      sessions: Prisma.$SessionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      name: string | null
      phone: string | null
      pan: string | null
      role: string
      isActive: boolean
      isEmailVerified: boolean
      kycCompleted: boolean
      preferences: string | null
      lastLoginAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    watchlists<T extends User$watchlistsArgs<ExtArgs> = {}>(args?: Subset<T, User$watchlistsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserWatchlistPayload<ExtArgs>, T, "findMany"> | Null>
    alerts<T extends User$alertsArgs<ExtArgs> = {}>(args?: Subset<T, User$alertsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAlertPayload<ExtArgs>, T, "findMany"> | Null>
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly pan: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'String'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly isEmailVerified: FieldRef<"User", 'Boolean'>
    readonly kycCompleted: FieldRef<"User", 'Boolean'>
    readonly preferences: FieldRef<"User", 'String'>
    readonly lastLoginAt: FieldRef<"User", 'DateTime'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.watchlists
   */
  export type User$watchlistsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserWatchlist
     */
    select?: UserWatchlistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserWatchlistInclude<ExtArgs> | null
    where?: UserWatchlistWhereInput
    orderBy?: UserWatchlistOrderByWithRelationInput | UserWatchlistOrderByWithRelationInput[]
    cursor?: UserWatchlistWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserWatchlistScalarFieldEnum | UserWatchlistScalarFieldEnum[]
  }

  /**
   * User.alerts
   */
  export type User$alertsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAlert
     */
    select?: UserAlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAlertInclude<ExtArgs> | null
    where?: UserAlertWhereInput
    orderBy?: UserAlertOrderByWithRelationInput | UserAlertOrderByWithRelationInput[]
    cursor?: UserAlertWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserAlertScalarFieldEnum | UserAlertScalarFieldEnum[]
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    token: string | null
    refreshToken: string | null
    expiresAt: Date | null
    isActive: boolean | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    token: string | null
    refreshToken: string | null
    expiresAt: Date | null
    isActive: boolean | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    userId: number
    token: number
    refreshToken: number
    expiresAt: number
    isActive: number
    ipAddress: number
    userAgent: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    refreshToken?: true
    expiresAt?: true
    isActive?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    refreshToken?: true
    expiresAt?: true
    isActive?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    refreshToken?: true
    expiresAt?: true
    isActive?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    userId: string
    token: string
    refreshToken: string
    expiresAt: Date
    isActive: boolean
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date
    updatedAt: Date
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    refreshToken?: boolean
    expiresAt?: boolean
    isActive?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    refreshToken?: boolean
    expiresAt?: boolean
    isActive?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectScalar = {
    id?: boolean
    userId?: boolean
    token?: boolean
    refreshToken?: boolean
    expiresAt?: boolean
    isActive?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      token: string
      refreshToken: string
      expiresAt: Date
      isActive: boolean
      ipAddress: string | null
      userAgent: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */ 
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly userId: FieldRef<"Session", 'String'>
    readonly token: FieldRef<"Session", 'String'>
    readonly refreshToken: FieldRef<"Session", 'String'>
    readonly expiresAt: FieldRef<"Session", 'DateTime'>
    readonly isActive: FieldRef<"Session", 'Boolean'>
    readonly ipAddress: FieldRef<"Session", 'String'>
    readonly userAgent: FieldRef<"Session", 'String'>
    readonly createdAt: FieldRef<"Session", 'DateTime'>
    readonly updatedAt: FieldRef<"Session", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model IPOAnalytics
   */

  export type AggregateIPOAnalytics = {
    _count: IPOAnalyticsCountAggregateOutputType | null
    _avg: IPOAnalyticsAvgAggregateOutputType | null
    _sum: IPOAnalyticsSumAggregateOutputType | null
    _min: IPOAnalyticsMinAggregateOutputType | null
    _max: IPOAnalyticsMaxAggregateOutputType | null
  }

  export type IPOAnalyticsAvgAggregateOutputType = {
    avgGMP: number | null
    maxGMP: number | null
    minGMP: number | null
    gmpVolume: number | null
    overallSubscription: number | null
    retailSubscription: number | null
    qibSubscription: number | null
    hniSubscription: number | null
    sentimentScore: number | null
    listingGain: number | null
    currentReturn: number | null
    volatilityIndex: number | null
    totalGMPChanges: number | null
    totalSubscriptions: number | null
    oversubscribedCount: number | null
  }

  export type IPOAnalyticsSumAggregateOutputType = {
    avgGMP: number | null
    maxGMP: number | null
    minGMP: number | null
    gmpVolume: number | null
    overallSubscription: number | null
    retailSubscription: number | null
    qibSubscription: number | null
    hniSubscription: number | null
    sentimentScore: number | null
    listingGain: number | null
    currentReturn: number | null
    volatilityIndex: number | null
    totalGMPChanges: number | null
    totalSubscriptions: number | null
    oversubscribedCount: number | null
  }

  export type IPOAnalyticsMinAggregateOutputType = {
    id: string | null
    ipoId: string | null
    symbol: string | null
    date: Date | null
    avgGMP: number | null
    maxGMP: number | null
    minGMP: number | null
    gmpVolume: number | null
    gmpTrend: string | null
    overallSubscription: number | null
    retailSubscription: number | null
    qibSubscription: number | null
    hniSubscription: number | null
    marketSentiment: string | null
    sentimentScore: number | null
    listingGain: number | null
    currentReturn: number | null
    volatilityIndex: number | null
    totalGMPChanges: number | null
    totalSubscriptions: number | null
    oversubscribedCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IPOAnalyticsMaxAggregateOutputType = {
    id: string | null
    ipoId: string | null
    symbol: string | null
    date: Date | null
    avgGMP: number | null
    maxGMP: number | null
    minGMP: number | null
    gmpVolume: number | null
    gmpTrend: string | null
    overallSubscription: number | null
    retailSubscription: number | null
    qibSubscription: number | null
    hniSubscription: number | null
    marketSentiment: string | null
    sentimentScore: number | null
    listingGain: number | null
    currentReturn: number | null
    volatilityIndex: number | null
    totalGMPChanges: number | null
    totalSubscriptions: number | null
    oversubscribedCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IPOAnalyticsCountAggregateOutputType = {
    id: number
    ipoId: number
    symbol: number
    date: number
    avgGMP: number
    maxGMP: number
    minGMP: number
    gmpVolume: number
    gmpTrend: number
    overallSubscription: number
    retailSubscription: number
    qibSubscription: number
    hniSubscription: number
    marketSentiment: number
    sentimentScore: number
    listingGain: number
    currentReturn: number
    volatilityIndex: number
    totalGMPChanges: number
    totalSubscriptions: number
    oversubscribedCount: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type IPOAnalyticsAvgAggregateInputType = {
    avgGMP?: true
    maxGMP?: true
    minGMP?: true
    gmpVolume?: true
    overallSubscription?: true
    retailSubscription?: true
    qibSubscription?: true
    hniSubscription?: true
    sentimentScore?: true
    listingGain?: true
    currentReturn?: true
    volatilityIndex?: true
    totalGMPChanges?: true
    totalSubscriptions?: true
    oversubscribedCount?: true
  }

  export type IPOAnalyticsSumAggregateInputType = {
    avgGMP?: true
    maxGMP?: true
    minGMP?: true
    gmpVolume?: true
    overallSubscription?: true
    retailSubscription?: true
    qibSubscription?: true
    hniSubscription?: true
    sentimentScore?: true
    listingGain?: true
    currentReturn?: true
    volatilityIndex?: true
    totalGMPChanges?: true
    totalSubscriptions?: true
    oversubscribedCount?: true
  }

  export type IPOAnalyticsMinAggregateInputType = {
    id?: true
    ipoId?: true
    symbol?: true
    date?: true
    avgGMP?: true
    maxGMP?: true
    minGMP?: true
    gmpVolume?: true
    gmpTrend?: true
    overallSubscription?: true
    retailSubscription?: true
    qibSubscription?: true
    hniSubscription?: true
    marketSentiment?: true
    sentimentScore?: true
    listingGain?: true
    currentReturn?: true
    volatilityIndex?: true
    totalGMPChanges?: true
    totalSubscriptions?: true
    oversubscribedCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IPOAnalyticsMaxAggregateInputType = {
    id?: true
    ipoId?: true
    symbol?: true
    date?: true
    avgGMP?: true
    maxGMP?: true
    minGMP?: true
    gmpVolume?: true
    gmpTrend?: true
    overallSubscription?: true
    retailSubscription?: true
    qibSubscription?: true
    hniSubscription?: true
    marketSentiment?: true
    sentimentScore?: true
    listingGain?: true
    currentReturn?: true
    volatilityIndex?: true
    totalGMPChanges?: true
    totalSubscriptions?: true
    oversubscribedCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IPOAnalyticsCountAggregateInputType = {
    id?: true
    ipoId?: true
    symbol?: true
    date?: true
    avgGMP?: true
    maxGMP?: true
    minGMP?: true
    gmpVolume?: true
    gmpTrend?: true
    overallSubscription?: true
    retailSubscription?: true
    qibSubscription?: true
    hniSubscription?: true
    marketSentiment?: true
    sentimentScore?: true
    listingGain?: true
    currentReturn?: true
    volatilityIndex?: true
    totalGMPChanges?: true
    totalSubscriptions?: true
    oversubscribedCount?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type IPOAnalyticsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IPOAnalytics to aggregate.
     */
    where?: IPOAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IPOAnalytics to fetch.
     */
    orderBy?: IPOAnalyticsOrderByWithRelationInput | IPOAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IPOAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IPOAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IPOAnalytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned IPOAnalytics
    **/
    _count?: true | IPOAnalyticsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: IPOAnalyticsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: IPOAnalyticsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IPOAnalyticsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IPOAnalyticsMaxAggregateInputType
  }

  export type GetIPOAnalyticsAggregateType<T extends IPOAnalyticsAggregateArgs> = {
        [P in keyof T & keyof AggregateIPOAnalytics]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIPOAnalytics[P]>
      : GetScalarType<T[P], AggregateIPOAnalytics[P]>
  }




  export type IPOAnalyticsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IPOAnalyticsWhereInput
    orderBy?: IPOAnalyticsOrderByWithAggregationInput | IPOAnalyticsOrderByWithAggregationInput[]
    by: IPOAnalyticsScalarFieldEnum[] | IPOAnalyticsScalarFieldEnum
    having?: IPOAnalyticsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IPOAnalyticsCountAggregateInputType | true
    _avg?: IPOAnalyticsAvgAggregateInputType
    _sum?: IPOAnalyticsSumAggregateInputType
    _min?: IPOAnalyticsMinAggregateInputType
    _max?: IPOAnalyticsMaxAggregateInputType
  }

  export type IPOAnalyticsGroupByOutputType = {
    id: string
    ipoId: string
    symbol: string | null
    date: Date
    avgGMP: number | null
    maxGMP: number | null
    minGMP: number | null
    gmpVolume: number | null
    gmpTrend: string | null
    overallSubscription: number | null
    retailSubscription: number | null
    qibSubscription: number | null
    hniSubscription: number | null
    marketSentiment: string | null
    sentimentScore: number | null
    listingGain: number | null
    currentReturn: number | null
    volatilityIndex: number | null
    totalGMPChanges: number
    totalSubscriptions: number
    oversubscribedCount: number
    createdAt: Date
    updatedAt: Date
    _count: IPOAnalyticsCountAggregateOutputType | null
    _avg: IPOAnalyticsAvgAggregateOutputType | null
    _sum: IPOAnalyticsSumAggregateOutputType | null
    _min: IPOAnalyticsMinAggregateOutputType | null
    _max: IPOAnalyticsMaxAggregateOutputType | null
  }

  type GetIPOAnalyticsGroupByPayload<T extends IPOAnalyticsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IPOAnalyticsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IPOAnalyticsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IPOAnalyticsGroupByOutputType[P]>
            : GetScalarType<T[P], IPOAnalyticsGroupByOutputType[P]>
        }
      >
    >


  export type IPOAnalyticsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ipoId?: boolean
    symbol?: boolean
    date?: boolean
    avgGMP?: boolean
    maxGMP?: boolean
    minGMP?: boolean
    gmpVolume?: boolean
    gmpTrend?: boolean
    overallSubscription?: boolean
    retailSubscription?: boolean
    qibSubscription?: boolean
    hniSubscription?: boolean
    marketSentiment?: boolean
    sentimentScore?: boolean
    listingGain?: boolean
    currentReturn?: boolean
    volatilityIndex?: boolean
    totalGMPChanges?: boolean
    totalSubscriptions?: boolean
    oversubscribedCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ipo?: boolean | IPODefaultArgs<ExtArgs>
  }, ExtArgs["result"]["iPOAnalytics"]>

  export type IPOAnalyticsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ipoId?: boolean
    symbol?: boolean
    date?: boolean
    avgGMP?: boolean
    maxGMP?: boolean
    minGMP?: boolean
    gmpVolume?: boolean
    gmpTrend?: boolean
    overallSubscription?: boolean
    retailSubscription?: boolean
    qibSubscription?: boolean
    hniSubscription?: boolean
    marketSentiment?: boolean
    sentimentScore?: boolean
    listingGain?: boolean
    currentReturn?: boolean
    volatilityIndex?: boolean
    totalGMPChanges?: boolean
    totalSubscriptions?: boolean
    oversubscribedCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ipo?: boolean | IPODefaultArgs<ExtArgs>
  }, ExtArgs["result"]["iPOAnalytics"]>

  export type IPOAnalyticsSelectScalar = {
    id?: boolean
    ipoId?: boolean
    symbol?: boolean
    date?: boolean
    avgGMP?: boolean
    maxGMP?: boolean
    minGMP?: boolean
    gmpVolume?: boolean
    gmpTrend?: boolean
    overallSubscription?: boolean
    retailSubscription?: boolean
    qibSubscription?: boolean
    hniSubscription?: boolean
    marketSentiment?: boolean
    sentimentScore?: boolean
    listingGain?: boolean
    currentReturn?: boolean
    volatilityIndex?: boolean
    totalGMPChanges?: boolean
    totalSubscriptions?: boolean
    oversubscribedCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type IPOAnalyticsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ipo?: boolean | IPODefaultArgs<ExtArgs>
  }
  export type IPOAnalyticsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ipo?: boolean | IPODefaultArgs<ExtArgs>
  }

  export type $IPOAnalyticsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "IPOAnalytics"
    objects: {
      ipo: Prisma.$IPOPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      ipoId: string
      symbol: string | null
      date: Date
      avgGMP: number | null
      maxGMP: number | null
      minGMP: number | null
      gmpVolume: number | null
      gmpTrend: string | null
      overallSubscription: number | null
      retailSubscription: number | null
      qibSubscription: number | null
      hniSubscription: number | null
      marketSentiment: string | null
      sentimentScore: number | null
      listingGain: number | null
      currentReturn: number | null
      volatilityIndex: number | null
      totalGMPChanges: number
      totalSubscriptions: number
      oversubscribedCount: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["iPOAnalytics"]>
    composites: {}
  }

  type IPOAnalyticsGetPayload<S extends boolean | null | undefined | IPOAnalyticsDefaultArgs> = $Result.GetResult<Prisma.$IPOAnalyticsPayload, S>

  type IPOAnalyticsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<IPOAnalyticsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: IPOAnalyticsCountAggregateInputType | true
    }

  export interface IPOAnalyticsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['IPOAnalytics'], meta: { name: 'IPOAnalytics' } }
    /**
     * Find zero or one IPOAnalytics that matches the filter.
     * @param {IPOAnalyticsFindUniqueArgs} args - Arguments to find a IPOAnalytics
     * @example
     * // Get one IPOAnalytics
     * const iPOAnalytics = await prisma.iPOAnalytics.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IPOAnalyticsFindUniqueArgs>(args: SelectSubset<T, IPOAnalyticsFindUniqueArgs<ExtArgs>>): Prisma__IPOAnalyticsClient<$Result.GetResult<Prisma.$IPOAnalyticsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one IPOAnalytics that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {IPOAnalyticsFindUniqueOrThrowArgs} args - Arguments to find a IPOAnalytics
     * @example
     * // Get one IPOAnalytics
     * const iPOAnalytics = await prisma.iPOAnalytics.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IPOAnalyticsFindUniqueOrThrowArgs>(args: SelectSubset<T, IPOAnalyticsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IPOAnalyticsClient<$Result.GetResult<Prisma.$IPOAnalyticsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first IPOAnalytics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IPOAnalyticsFindFirstArgs} args - Arguments to find a IPOAnalytics
     * @example
     * // Get one IPOAnalytics
     * const iPOAnalytics = await prisma.iPOAnalytics.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IPOAnalyticsFindFirstArgs>(args?: SelectSubset<T, IPOAnalyticsFindFirstArgs<ExtArgs>>): Prisma__IPOAnalyticsClient<$Result.GetResult<Prisma.$IPOAnalyticsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first IPOAnalytics that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IPOAnalyticsFindFirstOrThrowArgs} args - Arguments to find a IPOAnalytics
     * @example
     * // Get one IPOAnalytics
     * const iPOAnalytics = await prisma.iPOAnalytics.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IPOAnalyticsFindFirstOrThrowArgs>(args?: SelectSubset<T, IPOAnalyticsFindFirstOrThrowArgs<ExtArgs>>): Prisma__IPOAnalyticsClient<$Result.GetResult<Prisma.$IPOAnalyticsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more IPOAnalytics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IPOAnalyticsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all IPOAnalytics
     * const iPOAnalytics = await prisma.iPOAnalytics.findMany()
     * 
     * // Get first 10 IPOAnalytics
     * const iPOAnalytics = await prisma.iPOAnalytics.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const iPOAnalyticsWithIdOnly = await prisma.iPOAnalytics.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends IPOAnalyticsFindManyArgs>(args?: SelectSubset<T, IPOAnalyticsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IPOAnalyticsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a IPOAnalytics.
     * @param {IPOAnalyticsCreateArgs} args - Arguments to create a IPOAnalytics.
     * @example
     * // Create one IPOAnalytics
     * const IPOAnalytics = await prisma.iPOAnalytics.create({
     *   data: {
     *     // ... data to create a IPOAnalytics
     *   }
     * })
     * 
     */
    create<T extends IPOAnalyticsCreateArgs>(args: SelectSubset<T, IPOAnalyticsCreateArgs<ExtArgs>>): Prisma__IPOAnalyticsClient<$Result.GetResult<Prisma.$IPOAnalyticsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many IPOAnalytics.
     * @param {IPOAnalyticsCreateManyArgs} args - Arguments to create many IPOAnalytics.
     * @example
     * // Create many IPOAnalytics
     * const iPOAnalytics = await prisma.iPOAnalytics.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IPOAnalyticsCreateManyArgs>(args?: SelectSubset<T, IPOAnalyticsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many IPOAnalytics and returns the data saved in the database.
     * @param {IPOAnalyticsCreateManyAndReturnArgs} args - Arguments to create many IPOAnalytics.
     * @example
     * // Create many IPOAnalytics
     * const iPOAnalytics = await prisma.iPOAnalytics.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many IPOAnalytics and only return the `id`
     * const iPOAnalyticsWithIdOnly = await prisma.iPOAnalytics.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends IPOAnalyticsCreateManyAndReturnArgs>(args?: SelectSubset<T, IPOAnalyticsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IPOAnalyticsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a IPOAnalytics.
     * @param {IPOAnalyticsDeleteArgs} args - Arguments to delete one IPOAnalytics.
     * @example
     * // Delete one IPOAnalytics
     * const IPOAnalytics = await prisma.iPOAnalytics.delete({
     *   where: {
     *     // ... filter to delete one IPOAnalytics
     *   }
     * })
     * 
     */
    delete<T extends IPOAnalyticsDeleteArgs>(args: SelectSubset<T, IPOAnalyticsDeleteArgs<ExtArgs>>): Prisma__IPOAnalyticsClient<$Result.GetResult<Prisma.$IPOAnalyticsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one IPOAnalytics.
     * @param {IPOAnalyticsUpdateArgs} args - Arguments to update one IPOAnalytics.
     * @example
     * // Update one IPOAnalytics
     * const iPOAnalytics = await prisma.iPOAnalytics.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IPOAnalyticsUpdateArgs>(args: SelectSubset<T, IPOAnalyticsUpdateArgs<ExtArgs>>): Prisma__IPOAnalyticsClient<$Result.GetResult<Prisma.$IPOAnalyticsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more IPOAnalytics.
     * @param {IPOAnalyticsDeleteManyArgs} args - Arguments to filter IPOAnalytics to delete.
     * @example
     * // Delete a few IPOAnalytics
     * const { count } = await prisma.iPOAnalytics.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IPOAnalyticsDeleteManyArgs>(args?: SelectSubset<T, IPOAnalyticsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IPOAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IPOAnalyticsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many IPOAnalytics
     * const iPOAnalytics = await prisma.iPOAnalytics.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IPOAnalyticsUpdateManyArgs>(args: SelectSubset<T, IPOAnalyticsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one IPOAnalytics.
     * @param {IPOAnalyticsUpsertArgs} args - Arguments to update or create a IPOAnalytics.
     * @example
     * // Update or create a IPOAnalytics
     * const iPOAnalytics = await prisma.iPOAnalytics.upsert({
     *   create: {
     *     // ... data to create a IPOAnalytics
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the IPOAnalytics we want to update
     *   }
     * })
     */
    upsert<T extends IPOAnalyticsUpsertArgs>(args: SelectSubset<T, IPOAnalyticsUpsertArgs<ExtArgs>>): Prisma__IPOAnalyticsClient<$Result.GetResult<Prisma.$IPOAnalyticsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of IPOAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IPOAnalyticsCountArgs} args - Arguments to filter IPOAnalytics to count.
     * @example
     * // Count the number of IPOAnalytics
     * const count = await prisma.iPOAnalytics.count({
     *   where: {
     *     // ... the filter for the IPOAnalytics we want to count
     *   }
     * })
    **/
    count<T extends IPOAnalyticsCountArgs>(
      args?: Subset<T, IPOAnalyticsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IPOAnalyticsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a IPOAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IPOAnalyticsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IPOAnalyticsAggregateArgs>(args: Subset<T, IPOAnalyticsAggregateArgs>): Prisma.PrismaPromise<GetIPOAnalyticsAggregateType<T>>

    /**
     * Group by IPOAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IPOAnalyticsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IPOAnalyticsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IPOAnalyticsGroupByArgs['orderBy'] }
        : { orderBy?: IPOAnalyticsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IPOAnalyticsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIPOAnalyticsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the IPOAnalytics model
   */
  readonly fields: IPOAnalyticsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for IPOAnalytics.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IPOAnalyticsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ipo<T extends IPODefaultArgs<ExtArgs> = {}>(args?: Subset<T, IPODefaultArgs<ExtArgs>>): Prisma__IPOClient<$Result.GetResult<Prisma.$IPOPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the IPOAnalytics model
   */ 
  interface IPOAnalyticsFieldRefs {
    readonly id: FieldRef<"IPOAnalytics", 'String'>
    readonly ipoId: FieldRef<"IPOAnalytics", 'String'>
    readonly symbol: FieldRef<"IPOAnalytics", 'String'>
    readonly date: FieldRef<"IPOAnalytics", 'DateTime'>
    readonly avgGMP: FieldRef<"IPOAnalytics", 'Float'>
    readonly maxGMP: FieldRef<"IPOAnalytics", 'Float'>
    readonly minGMP: FieldRef<"IPOAnalytics", 'Float'>
    readonly gmpVolume: FieldRef<"IPOAnalytics", 'Int'>
    readonly gmpTrend: FieldRef<"IPOAnalytics", 'String'>
    readonly overallSubscription: FieldRef<"IPOAnalytics", 'Float'>
    readonly retailSubscription: FieldRef<"IPOAnalytics", 'Float'>
    readonly qibSubscription: FieldRef<"IPOAnalytics", 'Float'>
    readonly hniSubscription: FieldRef<"IPOAnalytics", 'Float'>
    readonly marketSentiment: FieldRef<"IPOAnalytics", 'String'>
    readonly sentimentScore: FieldRef<"IPOAnalytics", 'Float'>
    readonly listingGain: FieldRef<"IPOAnalytics", 'Float'>
    readonly currentReturn: FieldRef<"IPOAnalytics", 'Float'>
    readonly volatilityIndex: FieldRef<"IPOAnalytics", 'Float'>
    readonly totalGMPChanges: FieldRef<"IPOAnalytics", 'Int'>
    readonly totalSubscriptions: FieldRef<"IPOAnalytics", 'Int'>
    readonly oversubscribedCount: FieldRef<"IPOAnalytics", 'Int'>
    readonly createdAt: FieldRef<"IPOAnalytics", 'DateTime'>
    readonly updatedAt: FieldRef<"IPOAnalytics", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * IPOAnalytics findUnique
   */
  export type IPOAnalyticsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IPOAnalytics
     */
    select?: IPOAnalyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IPOAnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which IPOAnalytics to fetch.
     */
    where: IPOAnalyticsWhereUniqueInput
  }

  /**
   * IPOAnalytics findUniqueOrThrow
   */
  export type IPOAnalyticsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IPOAnalytics
     */
    select?: IPOAnalyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IPOAnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which IPOAnalytics to fetch.
     */
    where: IPOAnalyticsWhereUniqueInput
  }

  /**
   * IPOAnalytics findFirst
   */
  export type IPOAnalyticsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IPOAnalytics
     */
    select?: IPOAnalyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IPOAnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which IPOAnalytics to fetch.
     */
    where?: IPOAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IPOAnalytics to fetch.
     */
    orderBy?: IPOAnalyticsOrderByWithRelationInput | IPOAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IPOAnalytics.
     */
    cursor?: IPOAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IPOAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IPOAnalytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IPOAnalytics.
     */
    distinct?: IPOAnalyticsScalarFieldEnum | IPOAnalyticsScalarFieldEnum[]
  }

  /**
   * IPOAnalytics findFirstOrThrow
   */
  export type IPOAnalyticsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IPOAnalytics
     */
    select?: IPOAnalyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IPOAnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which IPOAnalytics to fetch.
     */
    where?: IPOAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IPOAnalytics to fetch.
     */
    orderBy?: IPOAnalyticsOrderByWithRelationInput | IPOAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IPOAnalytics.
     */
    cursor?: IPOAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IPOAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IPOAnalytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IPOAnalytics.
     */
    distinct?: IPOAnalyticsScalarFieldEnum | IPOAnalyticsScalarFieldEnum[]
  }

  /**
   * IPOAnalytics findMany
   */
  export type IPOAnalyticsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IPOAnalytics
     */
    select?: IPOAnalyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IPOAnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which IPOAnalytics to fetch.
     */
    where?: IPOAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IPOAnalytics to fetch.
     */
    orderBy?: IPOAnalyticsOrderByWithRelationInput | IPOAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing IPOAnalytics.
     */
    cursor?: IPOAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IPOAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IPOAnalytics.
     */
    skip?: number
    distinct?: IPOAnalyticsScalarFieldEnum | IPOAnalyticsScalarFieldEnum[]
  }

  /**
   * IPOAnalytics create
   */
  export type IPOAnalyticsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IPOAnalytics
     */
    select?: IPOAnalyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IPOAnalyticsInclude<ExtArgs> | null
    /**
     * The data needed to create a IPOAnalytics.
     */
    data: XOR<IPOAnalyticsCreateInput, IPOAnalyticsUncheckedCreateInput>
  }

  /**
   * IPOAnalytics createMany
   */
  export type IPOAnalyticsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many IPOAnalytics.
     */
    data: IPOAnalyticsCreateManyInput | IPOAnalyticsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * IPOAnalytics createManyAndReturn
   */
  export type IPOAnalyticsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IPOAnalytics
     */
    select?: IPOAnalyticsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many IPOAnalytics.
     */
    data: IPOAnalyticsCreateManyInput | IPOAnalyticsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IPOAnalyticsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * IPOAnalytics update
   */
  export type IPOAnalyticsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IPOAnalytics
     */
    select?: IPOAnalyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IPOAnalyticsInclude<ExtArgs> | null
    /**
     * The data needed to update a IPOAnalytics.
     */
    data: XOR<IPOAnalyticsUpdateInput, IPOAnalyticsUncheckedUpdateInput>
    /**
     * Choose, which IPOAnalytics to update.
     */
    where: IPOAnalyticsWhereUniqueInput
  }

  /**
   * IPOAnalytics updateMany
   */
  export type IPOAnalyticsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update IPOAnalytics.
     */
    data: XOR<IPOAnalyticsUpdateManyMutationInput, IPOAnalyticsUncheckedUpdateManyInput>
    /**
     * Filter which IPOAnalytics to update
     */
    where?: IPOAnalyticsWhereInput
  }

  /**
   * IPOAnalytics upsert
   */
  export type IPOAnalyticsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IPOAnalytics
     */
    select?: IPOAnalyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IPOAnalyticsInclude<ExtArgs> | null
    /**
     * The filter to search for the IPOAnalytics to update in case it exists.
     */
    where: IPOAnalyticsWhereUniqueInput
    /**
     * In case the IPOAnalytics found by the `where` argument doesn't exist, create a new IPOAnalytics with this data.
     */
    create: XOR<IPOAnalyticsCreateInput, IPOAnalyticsUncheckedCreateInput>
    /**
     * In case the IPOAnalytics was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IPOAnalyticsUpdateInput, IPOAnalyticsUncheckedUpdateInput>
  }

  /**
   * IPOAnalytics delete
   */
  export type IPOAnalyticsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IPOAnalytics
     */
    select?: IPOAnalyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IPOAnalyticsInclude<ExtArgs> | null
    /**
     * Filter which IPOAnalytics to delete.
     */
    where: IPOAnalyticsWhereUniqueInput
  }

  /**
   * IPOAnalytics deleteMany
   */
  export type IPOAnalyticsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IPOAnalytics to delete
     */
    where?: IPOAnalyticsWhereInput
  }

  /**
   * IPOAnalytics without action
   */
  export type IPOAnalyticsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IPOAnalytics
     */
    select?: IPOAnalyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IPOAnalyticsInclude<ExtArgs> | null
  }


  /**
   * Model UserWatchlist
   */

  export type AggregateUserWatchlist = {
    _count: UserWatchlistCountAggregateOutputType | null
    _min: UserWatchlistMinAggregateOutputType | null
    _max: UserWatchlistMaxAggregateOutputType | null
  }

  export type UserWatchlistMinAggregateOutputType = {
    id: string | null
    userId: string | null
    ipoId: string | null
    notes: string | null
    alertPreferences: string | null
    addedAt: Date | null
  }

  export type UserWatchlistMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    ipoId: string | null
    notes: string | null
    alertPreferences: string | null
    addedAt: Date | null
  }

  export type UserWatchlistCountAggregateOutputType = {
    id: number
    userId: number
    ipoId: number
    notes: number
    alertPreferences: number
    addedAt: number
    _all: number
  }


  export type UserWatchlistMinAggregateInputType = {
    id?: true
    userId?: true
    ipoId?: true
    notes?: true
    alertPreferences?: true
    addedAt?: true
  }

  export type UserWatchlistMaxAggregateInputType = {
    id?: true
    userId?: true
    ipoId?: true
    notes?: true
    alertPreferences?: true
    addedAt?: true
  }

  export type UserWatchlistCountAggregateInputType = {
    id?: true
    userId?: true
    ipoId?: true
    notes?: true
    alertPreferences?: true
    addedAt?: true
    _all?: true
  }

  export type UserWatchlistAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserWatchlist to aggregate.
     */
    where?: UserWatchlistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserWatchlists to fetch.
     */
    orderBy?: UserWatchlistOrderByWithRelationInput | UserWatchlistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWatchlistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserWatchlists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserWatchlists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserWatchlists
    **/
    _count?: true | UserWatchlistCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserWatchlistMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserWatchlistMaxAggregateInputType
  }

  export type GetUserWatchlistAggregateType<T extends UserWatchlistAggregateArgs> = {
        [P in keyof T & keyof AggregateUserWatchlist]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserWatchlist[P]>
      : GetScalarType<T[P], AggregateUserWatchlist[P]>
  }




  export type UserWatchlistGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWatchlistWhereInput
    orderBy?: UserWatchlistOrderByWithAggregationInput | UserWatchlistOrderByWithAggregationInput[]
    by: UserWatchlistScalarFieldEnum[] | UserWatchlistScalarFieldEnum
    having?: UserWatchlistScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserWatchlistCountAggregateInputType | true
    _min?: UserWatchlistMinAggregateInputType
    _max?: UserWatchlistMaxAggregateInputType
  }

  export type UserWatchlistGroupByOutputType = {
    id: string
    userId: string
    ipoId: string
    notes: string | null
    alertPreferences: string | null
    addedAt: Date
    _count: UserWatchlistCountAggregateOutputType | null
    _min: UserWatchlistMinAggregateOutputType | null
    _max: UserWatchlistMaxAggregateOutputType | null
  }

  type GetUserWatchlistGroupByPayload<T extends UserWatchlistGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserWatchlistGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserWatchlistGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserWatchlistGroupByOutputType[P]>
            : GetScalarType<T[P], UserWatchlistGroupByOutputType[P]>
        }
      >
    >


  export type UserWatchlistSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    ipoId?: boolean
    notes?: boolean
    alertPreferences?: boolean
    addedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    ipo?: boolean | IPODefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userWatchlist"]>

  export type UserWatchlistSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    ipoId?: boolean
    notes?: boolean
    alertPreferences?: boolean
    addedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    ipo?: boolean | IPODefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userWatchlist"]>

  export type UserWatchlistSelectScalar = {
    id?: boolean
    userId?: boolean
    ipoId?: boolean
    notes?: boolean
    alertPreferences?: boolean
    addedAt?: boolean
  }

  export type UserWatchlistInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    ipo?: boolean | IPODefaultArgs<ExtArgs>
  }
  export type UserWatchlistIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    ipo?: boolean | IPODefaultArgs<ExtArgs>
  }

  export type $UserWatchlistPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserWatchlist"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      ipo: Prisma.$IPOPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      ipoId: string
      notes: string | null
      alertPreferences: string | null
      addedAt: Date
    }, ExtArgs["result"]["userWatchlist"]>
    composites: {}
  }

  type UserWatchlistGetPayload<S extends boolean | null | undefined | UserWatchlistDefaultArgs> = $Result.GetResult<Prisma.$UserWatchlistPayload, S>

  type UserWatchlistCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserWatchlistFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserWatchlistCountAggregateInputType | true
    }

  export interface UserWatchlistDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserWatchlist'], meta: { name: 'UserWatchlist' } }
    /**
     * Find zero or one UserWatchlist that matches the filter.
     * @param {UserWatchlistFindUniqueArgs} args - Arguments to find a UserWatchlist
     * @example
     * // Get one UserWatchlist
     * const userWatchlist = await prisma.userWatchlist.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserWatchlistFindUniqueArgs>(args: SelectSubset<T, UserWatchlistFindUniqueArgs<ExtArgs>>): Prisma__UserWatchlistClient<$Result.GetResult<Prisma.$UserWatchlistPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserWatchlist that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserWatchlistFindUniqueOrThrowArgs} args - Arguments to find a UserWatchlist
     * @example
     * // Get one UserWatchlist
     * const userWatchlist = await prisma.userWatchlist.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserWatchlistFindUniqueOrThrowArgs>(args: SelectSubset<T, UserWatchlistFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserWatchlistClient<$Result.GetResult<Prisma.$UserWatchlistPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserWatchlist that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserWatchlistFindFirstArgs} args - Arguments to find a UserWatchlist
     * @example
     * // Get one UserWatchlist
     * const userWatchlist = await prisma.userWatchlist.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserWatchlistFindFirstArgs>(args?: SelectSubset<T, UserWatchlistFindFirstArgs<ExtArgs>>): Prisma__UserWatchlistClient<$Result.GetResult<Prisma.$UserWatchlistPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserWatchlist that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserWatchlistFindFirstOrThrowArgs} args - Arguments to find a UserWatchlist
     * @example
     * // Get one UserWatchlist
     * const userWatchlist = await prisma.userWatchlist.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserWatchlistFindFirstOrThrowArgs>(args?: SelectSubset<T, UserWatchlistFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserWatchlistClient<$Result.GetResult<Prisma.$UserWatchlistPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserWatchlists that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserWatchlistFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserWatchlists
     * const userWatchlists = await prisma.userWatchlist.findMany()
     * 
     * // Get first 10 UserWatchlists
     * const userWatchlists = await prisma.userWatchlist.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWatchlistWithIdOnly = await prisma.userWatchlist.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserWatchlistFindManyArgs>(args?: SelectSubset<T, UserWatchlistFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserWatchlistPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserWatchlist.
     * @param {UserWatchlistCreateArgs} args - Arguments to create a UserWatchlist.
     * @example
     * // Create one UserWatchlist
     * const UserWatchlist = await prisma.userWatchlist.create({
     *   data: {
     *     // ... data to create a UserWatchlist
     *   }
     * })
     * 
     */
    create<T extends UserWatchlistCreateArgs>(args: SelectSubset<T, UserWatchlistCreateArgs<ExtArgs>>): Prisma__UserWatchlistClient<$Result.GetResult<Prisma.$UserWatchlistPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserWatchlists.
     * @param {UserWatchlistCreateManyArgs} args - Arguments to create many UserWatchlists.
     * @example
     * // Create many UserWatchlists
     * const userWatchlist = await prisma.userWatchlist.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserWatchlistCreateManyArgs>(args?: SelectSubset<T, UserWatchlistCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserWatchlists and returns the data saved in the database.
     * @param {UserWatchlistCreateManyAndReturnArgs} args - Arguments to create many UserWatchlists.
     * @example
     * // Create many UserWatchlists
     * const userWatchlist = await prisma.userWatchlist.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserWatchlists and only return the `id`
     * const userWatchlistWithIdOnly = await prisma.userWatchlist.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserWatchlistCreateManyAndReturnArgs>(args?: SelectSubset<T, UserWatchlistCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserWatchlistPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UserWatchlist.
     * @param {UserWatchlistDeleteArgs} args - Arguments to delete one UserWatchlist.
     * @example
     * // Delete one UserWatchlist
     * const UserWatchlist = await prisma.userWatchlist.delete({
     *   where: {
     *     // ... filter to delete one UserWatchlist
     *   }
     * })
     * 
     */
    delete<T extends UserWatchlistDeleteArgs>(args: SelectSubset<T, UserWatchlistDeleteArgs<ExtArgs>>): Prisma__UserWatchlistClient<$Result.GetResult<Prisma.$UserWatchlistPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserWatchlist.
     * @param {UserWatchlistUpdateArgs} args - Arguments to update one UserWatchlist.
     * @example
     * // Update one UserWatchlist
     * const userWatchlist = await prisma.userWatchlist.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserWatchlistUpdateArgs>(args: SelectSubset<T, UserWatchlistUpdateArgs<ExtArgs>>): Prisma__UserWatchlistClient<$Result.GetResult<Prisma.$UserWatchlistPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserWatchlists.
     * @param {UserWatchlistDeleteManyArgs} args - Arguments to filter UserWatchlists to delete.
     * @example
     * // Delete a few UserWatchlists
     * const { count } = await prisma.userWatchlist.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserWatchlistDeleteManyArgs>(args?: SelectSubset<T, UserWatchlistDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserWatchlists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserWatchlistUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserWatchlists
     * const userWatchlist = await prisma.userWatchlist.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserWatchlistUpdateManyArgs>(args: SelectSubset<T, UserWatchlistUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserWatchlist.
     * @param {UserWatchlistUpsertArgs} args - Arguments to update or create a UserWatchlist.
     * @example
     * // Update or create a UserWatchlist
     * const userWatchlist = await prisma.userWatchlist.upsert({
     *   create: {
     *     // ... data to create a UserWatchlist
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserWatchlist we want to update
     *   }
     * })
     */
    upsert<T extends UserWatchlistUpsertArgs>(args: SelectSubset<T, UserWatchlistUpsertArgs<ExtArgs>>): Prisma__UserWatchlistClient<$Result.GetResult<Prisma.$UserWatchlistPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserWatchlists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserWatchlistCountArgs} args - Arguments to filter UserWatchlists to count.
     * @example
     * // Count the number of UserWatchlists
     * const count = await prisma.userWatchlist.count({
     *   where: {
     *     // ... the filter for the UserWatchlists we want to count
     *   }
     * })
    **/
    count<T extends UserWatchlistCountArgs>(
      args?: Subset<T, UserWatchlistCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserWatchlistCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserWatchlist.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserWatchlistAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserWatchlistAggregateArgs>(args: Subset<T, UserWatchlistAggregateArgs>): Prisma.PrismaPromise<GetUserWatchlistAggregateType<T>>

    /**
     * Group by UserWatchlist.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserWatchlistGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserWatchlistGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserWatchlistGroupByArgs['orderBy'] }
        : { orderBy?: UserWatchlistGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserWatchlistGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserWatchlistGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserWatchlist model
   */
  readonly fields: UserWatchlistFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserWatchlist.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserWatchlistClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    ipo<T extends IPODefaultArgs<ExtArgs> = {}>(args?: Subset<T, IPODefaultArgs<ExtArgs>>): Prisma__IPOClient<$Result.GetResult<Prisma.$IPOPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserWatchlist model
   */ 
  interface UserWatchlistFieldRefs {
    readonly id: FieldRef<"UserWatchlist", 'String'>
    readonly userId: FieldRef<"UserWatchlist", 'String'>
    readonly ipoId: FieldRef<"UserWatchlist", 'String'>
    readonly notes: FieldRef<"UserWatchlist", 'String'>
    readonly alertPreferences: FieldRef<"UserWatchlist", 'String'>
    readonly addedAt: FieldRef<"UserWatchlist", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserWatchlist findUnique
   */
  export type UserWatchlistFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserWatchlist
     */
    select?: UserWatchlistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserWatchlistInclude<ExtArgs> | null
    /**
     * Filter, which UserWatchlist to fetch.
     */
    where: UserWatchlistWhereUniqueInput
  }

  /**
   * UserWatchlist findUniqueOrThrow
   */
  export type UserWatchlistFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserWatchlist
     */
    select?: UserWatchlistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserWatchlistInclude<ExtArgs> | null
    /**
     * Filter, which UserWatchlist to fetch.
     */
    where: UserWatchlistWhereUniqueInput
  }

  /**
   * UserWatchlist findFirst
   */
  export type UserWatchlistFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserWatchlist
     */
    select?: UserWatchlistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserWatchlistInclude<ExtArgs> | null
    /**
     * Filter, which UserWatchlist to fetch.
     */
    where?: UserWatchlistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserWatchlists to fetch.
     */
    orderBy?: UserWatchlistOrderByWithRelationInput | UserWatchlistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserWatchlists.
     */
    cursor?: UserWatchlistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserWatchlists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserWatchlists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserWatchlists.
     */
    distinct?: UserWatchlistScalarFieldEnum | UserWatchlistScalarFieldEnum[]
  }

  /**
   * UserWatchlist findFirstOrThrow
   */
  export type UserWatchlistFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserWatchlist
     */
    select?: UserWatchlistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserWatchlistInclude<ExtArgs> | null
    /**
     * Filter, which UserWatchlist to fetch.
     */
    where?: UserWatchlistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserWatchlists to fetch.
     */
    orderBy?: UserWatchlistOrderByWithRelationInput | UserWatchlistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserWatchlists.
     */
    cursor?: UserWatchlistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserWatchlists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserWatchlists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserWatchlists.
     */
    distinct?: UserWatchlistScalarFieldEnum | UserWatchlistScalarFieldEnum[]
  }

  /**
   * UserWatchlist findMany
   */
  export type UserWatchlistFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserWatchlist
     */
    select?: UserWatchlistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserWatchlistInclude<ExtArgs> | null
    /**
     * Filter, which UserWatchlists to fetch.
     */
    where?: UserWatchlistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserWatchlists to fetch.
     */
    orderBy?: UserWatchlistOrderByWithRelationInput | UserWatchlistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserWatchlists.
     */
    cursor?: UserWatchlistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserWatchlists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserWatchlists.
     */
    skip?: number
    distinct?: UserWatchlistScalarFieldEnum | UserWatchlistScalarFieldEnum[]
  }

  /**
   * UserWatchlist create
   */
  export type UserWatchlistCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserWatchlist
     */
    select?: UserWatchlistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserWatchlistInclude<ExtArgs> | null
    /**
     * The data needed to create a UserWatchlist.
     */
    data: XOR<UserWatchlistCreateInput, UserWatchlistUncheckedCreateInput>
  }

  /**
   * UserWatchlist createMany
   */
  export type UserWatchlistCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserWatchlists.
     */
    data: UserWatchlistCreateManyInput | UserWatchlistCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserWatchlist createManyAndReturn
   */
  export type UserWatchlistCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserWatchlist
     */
    select?: UserWatchlistSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UserWatchlists.
     */
    data: UserWatchlistCreateManyInput | UserWatchlistCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserWatchlistIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserWatchlist update
   */
  export type UserWatchlistUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserWatchlist
     */
    select?: UserWatchlistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserWatchlistInclude<ExtArgs> | null
    /**
     * The data needed to update a UserWatchlist.
     */
    data: XOR<UserWatchlistUpdateInput, UserWatchlistUncheckedUpdateInput>
    /**
     * Choose, which UserWatchlist to update.
     */
    where: UserWatchlistWhereUniqueInput
  }

  /**
   * UserWatchlist updateMany
   */
  export type UserWatchlistUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserWatchlists.
     */
    data: XOR<UserWatchlistUpdateManyMutationInput, UserWatchlistUncheckedUpdateManyInput>
    /**
     * Filter which UserWatchlists to update
     */
    where?: UserWatchlistWhereInput
  }

  /**
   * UserWatchlist upsert
   */
  export type UserWatchlistUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserWatchlist
     */
    select?: UserWatchlistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserWatchlistInclude<ExtArgs> | null
    /**
     * The filter to search for the UserWatchlist to update in case it exists.
     */
    where: UserWatchlistWhereUniqueInput
    /**
     * In case the UserWatchlist found by the `where` argument doesn't exist, create a new UserWatchlist with this data.
     */
    create: XOR<UserWatchlistCreateInput, UserWatchlistUncheckedCreateInput>
    /**
     * In case the UserWatchlist was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserWatchlistUpdateInput, UserWatchlistUncheckedUpdateInput>
  }

  /**
   * UserWatchlist delete
   */
  export type UserWatchlistDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserWatchlist
     */
    select?: UserWatchlistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserWatchlistInclude<ExtArgs> | null
    /**
     * Filter which UserWatchlist to delete.
     */
    where: UserWatchlistWhereUniqueInput
  }

  /**
   * UserWatchlist deleteMany
   */
  export type UserWatchlistDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserWatchlists to delete
     */
    where?: UserWatchlistWhereInput
  }

  /**
   * UserWatchlist without action
   */
  export type UserWatchlistDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserWatchlist
     */
    select?: UserWatchlistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserWatchlistInclude<ExtArgs> | null
  }


  /**
   * Model UserAlert
   */

  export type AggregateUserAlert = {
    _count: UserAlertCountAggregateOutputType | null
    _avg: UserAlertAvgAggregateOutputType | null
    _sum: UserAlertSumAggregateOutputType | null
    _min: UserAlertMinAggregateOutputType | null
    _max: UserAlertMaxAggregateOutputType | null
  }

  export type UserAlertAvgAggregateOutputType = {
    triggerValue: number | null
    triggerCount: number | null
  }

  export type UserAlertSumAggregateOutputType = {
    triggerValue: number | null
    triggerCount: number | null
  }

  export type UserAlertMinAggregateOutputType = {
    id: string | null
    userId: string | null
    ipoId: string | null
    symbol: string | null
    alertType: string | null
    triggerType: string | null
    triggerValue: number | null
    triggerCondition: string | null
    message: string | null
    isActive: boolean | null
    lastTriggered: Date | null
    triggerCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserAlertMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    ipoId: string | null
    symbol: string | null
    alertType: string | null
    triggerType: string | null
    triggerValue: number | null
    triggerCondition: string | null
    message: string | null
    isActive: boolean | null
    lastTriggered: Date | null
    triggerCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserAlertCountAggregateOutputType = {
    id: number
    userId: number
    ipoId: number
    symbol: number
    alertType: number
    triggerType: number
    triggerValue: number
    triggerCondition: number
    message: number
    isActive: number
    lastTriggered: number
    triggerCount: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserAlertAvgAggregateInputType = {
    triggerValue?: true
    triggerCount?: true
  }

  export type UserAlertSumAggregateInputType = {
    triggerValue?: true
    triggerCount?: true
  }

  export type UserAlertMinAggregateInputType = {
    id?: true
    userId?: true
    ipoId?: true
    symbol?: true
    alertType?: true
    triggerType?: true
    triggerValue?: true
    triggerCondition?: true
    message?: true
    isActive?: true
    lastTriggered?: true
    triggerCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserAlertMaxAggregateInputType = {
    id?: true
    userId?: true
    ipoId?: true
    symbol?: true
    alertType?: true
    triggerType?: true
    triggerValue?: true
    triggerCondition?: true
    message?: true
    isActive?: true
    lastTriggered?: true
    triggerCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserAlertCountAggregateInputType = {
    id?: true
    userId?: true
    ipoId?: true
    symbol?: true
    alertType?: true
    triggerType?: true
    triggerValue?: true
    triggerCondition?: true
    message?: true
    isActive?: true
    lastTriggered?: true
    triggerCount?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAlertAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserAlert to aggregate.
     */
    where?: UserAlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAlerts to fetch.
     */
    orderBy?: UserAlertOrderByWithRelationInput | UserAlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserAlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAlerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAlerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserAlerts
    **/
    _count?: true | UserAlertCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAlertAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserAlertSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserAlertMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserAlertMaxAggregateInputType
  }

  export type GetUserAlertAggregateType<T extends UserAlertAggregateArgs> = {
        [P in keyof T & keyof AggregateUserAlert]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserAlert[P]>
      : GetScalarType<T[P], AggregateUserAlert[P]>
  }




  export type UserAlertGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserAlertWhereInput
    orderBy?: UserAlertOrderByWithAggregationInput | UserAlertOrderByWithAggregationInput[]
    by: UserAlertScalarFieldEnum[] | UserAlertScalarFieldEnum
    having?: UserAlertScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserAlertCountAggregateInputType | true
    _avg?: UserAlertAvgAggregateInputType
    _sum?: UserAlertSumAggregateInputType
    _min?: UserAlertMinAggregateInputType
    _max?: UserAlertMaxAggregateInputType
  }

  export type UserAlertGroupByOutputType = {
    id: string
    userId: string
    ipoId: string | null
    symbol: string | null
    alertType: string
    triggerType: string
    triggerValue: number | null
    triggerCondition: string | null
    message: string | null
    isActive: boolean
    lastTriggered: Date | null
    triggerCount: number
    createdAt: Date
    updatedAt: Date
    _count: UserAlertCountAggregateOutputType | null
    _avg: UserAlertAvgAggregateOutputType | null
    _sum: UserAlertSumAggregateOutputType | null
    _min: UserAlertMinAggregateOutputType | null
    _max: UserAlertMaxAggregateOutputType | null
  }

  type GetUserAlertGroupByPayload<T extends UserAlertGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserAlertGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserAlertGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserAlertGroupByOutputType[P]>
            : GetScalarType<T[P], UserAlertGroupByOutputType[P]>
        }
      >
    >


  export type UserAlertSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    ipoId?: boolean
    symbol?: boolean
    alertType?: boolean
    triggerType?: boolean
    triggerValue?: boolean
    triggerCondition?: boolean
    message?: boolean
    isActive?: boolean
    lastTriggered?: boolean
    triggerCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    ipo?: boolean | UserAlert$ipoArgs<ExtArgs>
  }, ExtArgs["result"]["userAlert"]>

  export type UserAlertSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    ipoId?: boolean
    symbol?: boolean
    alertType?: boolean
    triggerType?: boolean
    triggerValue?: boolean
    triggerCondition?: boolean
    message?: boolean
    isActive?: boolean
    lastTriggered?: boolean
    triggerCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    ipo?: boolean | UserAlert$ipoArgs<ExtArgs>
  }, ExtArgs["result"]["userAlert"]>

  export type UserAlertSelectScalar = {
    id?: boolean
    userId?: boolean
    ipoId?: boolean
    symbol?: boolean
    alertType?: boolean
    triggerType?: boolean
    triggerValue?: boolean
    triggerCondition?: boolean
    message?: boolean
    isActive?: boolean
    lastTriggered?: boolean
    triggerCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserAlertInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    ipo?: boolean | UserAlert$ipoArgs<ExtArgs>
  }
  export type UserAlertIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    ipo?: boolean | UserAlert$ipoArgs<ExtArgs>
  }

  export type $UserAlertPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserAlert"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      ipo: Prisma.$IPOPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      ipoId: string | null
      symbol: string | null
      alertType: string
      triggerType: string
      triggerValue: number | null
      triggerCondition: string | null
      message: string | null
      isActive: boolean
      lastTriggered: Date | null
      triggerCount: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userAlert"]>
    composites: {}
  }

  type UserAlertGetPayload<S extends boolean | null | undefined | UserAlertDefaultArgs> = $Result.GetResult<Prisma.$UserAlertPayload, S>

  type UserAlertCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserAlertFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserAlertCountAggregateInputType | true
    }

  export interface UserAlertDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserAlert'], meta: { name: 'UserAlert' } }
    /**
     * Find zero or one UserAlert that matches the filter.
     * @param {UserAlertFindUniqueArgs} args - Arguments to find a UserAlert
     * @example
     * // Get one UserAlert
     * const userAlert = await prisma.userAlert.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserAlertFindUniqueArgs>(args: SelectSubset<T, UserAlertFindUniqueArgs<ExtArgs>>): Prisma__UserAlertClient<$Result.GetResult<Prisma.$UserAlertPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserAlert that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserAlertFindUniqueOrThrowArgs} args - Arguments to find a UserAlert
     * @example
     * // Get one UserAlert
     * const userAlert = await prisma.userAlert.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserAlertFindUniqueOrThrowArgs>(args: SelectSubset<T, UserAlertFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserAlertClient<$Result.GetResult<Prisma.$UserAlertPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserAlert that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAlertFindFirstArgs} args - Arguments to find a UserAlert
     * @example
     * // Get one UserAlert
     * const userAlert = await prisma.userAlert.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserAlertFindFirstArgs>(args?: SelectSubset<T, UserAlertFindFirstArgs<ExtArgs>>): Prisma__UserAlertClient<$Result.GetResult<Prisma.$UserAlertPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserAlert that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAlertFindFirstOrThrowArgs} args - Arguments to find a UserAlert
     * @example
     * // Get one UserAlert
     * const userAlert = await prisma.userAlert.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserAlertFindFirstOrThrowArgs>(args?: SelectSubset<T, UserAlertFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserAlertClient<$Result.GetResult<Prisma.$UserAlertPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserAlerts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAlertFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserAlerts
     * const userAlerts = await prisma.userAlert.findMany()
     * 
     * // Get first 10 UserAlerts
     * const userAlerts = await prisma.userAlert.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userAlertWithIdOnly = await prisma.userAlert.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserAlertFindManyArgs>(args?: SelectSubset<T, UserAlertFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAlertPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserAlert.
     * @param {UserAlertCreateArgs} args - Arguments to create a UserAlert.
     * @example
     * // Create one UserAlert
     * const UserAlert = await prisma.userAlert.create({
     *   data: {
     *     // ... data to create a UserAlert
     *   }
     * })
     * 
     */
    create<T extends UserAlertCreateArgs>(args: SelectSubset<T, UserAlertCreateArgs<ExtArgs>>): Prisma__UserAlertClient<$Result.GetResult<Prisma.$UserAlertPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserAlerts.
     * @param {UserAlertCreateManyArgs} args - Arguments to create many UserAlerts.
     * @example
     * // Create many UserAlerts
     * const userAlert = await prisma.userAlert.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserAlertCreateManyArgs>(args?: SelectSubset<T, UserAlertCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserAlerts and returns the data saved in the database.
     * @param {UserAlertCreateManyAndReturnArgs} args - Arguments to create many UserAlerts.
     * @example
     * // Create many UserAlerts
     * const userAlert = await prisma.userAlert.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserAlerts and only return the `id`
     * const userAlertWithIdOnly = await prisma.userAlert.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserAlertCreateManyAndReturnArgs>(args?: SelectSubset<T, UserAlertCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAlertPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UserAlert.
     * @param {UserAlertDeleteArgs} args - Arguments to delete one UserAlert.
     * @example
     * // Delete one UserAlert
     * const UserAlert = await prisma.userAlert.delete({
     *   where: {
     *     // ... filter to delete one UserAlert
     *   }
     * })
     * 
     */
    delete<T extends UserAlertDeleteArgs>(args: SelectSubset<T, UserAlertDeleteArgs<ExtArgs>>): Prisma__UserAlertClient<$Result.GetResult<Prisma.$UserAlertPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserAlert.
     * @param {UserAlertUpdateArgs} args - Arguments to update one UserAlert.
     * @example
     * // Update one UserAlert
     * const userAlert = await prisma.userAlert.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserAlertUpdateArgs>(args: SelectSubset<T, UserAlertUpdateArgs<ExtArgs>>): Prisma__UserAlertClient<$Result.GetResult<Prisma.$UserAlertPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserAlerts.
     * @param {UserAlertDeleteManyArgs} args - Arguments to filter UserAlerts to delete.
     * @example
     * // Delete a few UserAlerts
     * const { count } = await prisma.userAlert.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserAlertDeleteManyArgs>(args?: SelectSubset<T, UserAlertDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserAlerts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAlertUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserAlerts
     * const userAlert = await prisma.userAlert.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserAlertUpdateManyArgs>(args: SelectSubset<T, UserAlertUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserAlert.
     * @param {UserAlertUpsertArgs} args - Arguments to update or create a UserAlert.
     * @example
     * // Update or create a UserAlert
     * const userAlert = await prisma.userAlert.upsert({
     *   create: {
     *     // ... data to create a UserAlert
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserAlert we want to update
     *   }
     * })
     */
    upsert<T extends UserAlertUpsertArgs>(args: SelectSubset<T, UserAlertUpsertArgs<ExtArgs>>): Prisma__UserAlertClient<$Result.GetResult<Prisma.$UserAlertPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserAlerts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAlertCountArgs} args - Arguments to filter UserAlerts to count.
     * @example
     * // Count the number of UserAlerts
     * const count = await prisma.userAlert.count({
     *   where: {
     *     // ... the filter for the UserAlerts we want to count
     *   }
     * })
    **/
    count<T extends UserAlertCountArgs>(
      args?: Subset<T, UserAlertCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserAlertCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserAlert.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAlertAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAlertAggregateArgs>(args: Subset<T, UserAlertAggregateArgs>): Prisma.PrismaPromise<GetUserAlertAggregateType<T>>

    /**
     * Group by UserAlert.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAlertGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserAlertGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserAlertGroupByArgs['orderBy'] }
        : { orderBy?: UserAlertGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserAlertGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserAlertGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserAlert model
   */
  readonly fields: UserAlertFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserAlert.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserAlertClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    ipo<T extends UserAlert$ipoArgs<ExtArgs> = {}>(args?: Subset<T, UserAlert$ipoArgs<ExtArgs>>): Prisma__IPOClient<$Result.GetResult<Prisma.$IPOPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserAlert model
   */ 
  interface UserAlertFieldRefs {
    readonly id: FieldRef<"UserAlert", 'String'>
    readonly userId: FieldRef<"UserAlert", 'String'>
    readonly ipoId: FieldRef<"UserAlert", 'String'>
    readonly symbol: FieldRef<"UserAlert", 'String'>
    readonly alertType: FieldRef<"UserAlert", 'String'>
    readonly triggerType: FieldRef<"UserAlert", 'String'>
    readonly triggerValue: FieldRef<"UserAlert", 'Float'>
    readonly triggerCondition: FieldRef<"UserAlert", 'String'>
    readonly message: FieldRef<"UserAlert", 'String'>
    readonly isActive: FieldRef<"UserAlert", 'Boolean'>
    readonly lastTriggered: FieldRef<"UserAlert", 'DateTime'>
    readonly triggerCount: FieldRef<"UserAlert", 'Int'>
    readonly createdAt: FieldRef<"UserAlert", 'DateTime'>
    readonly updatedAt: FieldRef<"UserAlert", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserAlert findUnique
   */
  export type UserAlertFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAlert
     */
    select?: UserAlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAlertInclude<ExtArgs> | null
    /**
     * Filter, which UserAlert to fetch.
     */
    where: UserAlertWhereUniqueInput
  }

  /**
   * UserAlert findUniqueOrThrow
   */
  export type UserAlertFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAlert
     */
    select?: UserAlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAlertInclude<ExtArgs> | null
    /**
     * Filter, which UserAlert to fetch.
     */
    where: UserAlertWhereUniqueInput
  }

  /**
   * UserAlert findFirst
   */
  export type UserAlertFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAlert
     */
    select?: UserAlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAlertInclude<ExtArgs> | null
    /**
     * Filter, which UserAlert to fetch.
     */
    where?: UserAlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAlerts to fetch.
     */
    orderBy?: UserAlertOrderByWithRelationInput | UserAlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserAlerts.
     */
    cursor?: UserAlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAlerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAlerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserAlerts.
     */
    distinct?: UserAlertScalarFieldEnum | UserAlertScalarFieldEnum[]
  }

  /**
   * UserAlert findFirstOrThrow
   */
  export type UserAlertFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAlert
     */
    select?: UserAlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAlertInclude<ExtArgs> | null
    /**
     * Filter, which UserAlert to fetch.
     */
    where?: UserAlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAlerts to fetch.
     */
    orderBy?: UserAlertOrderByWithRelationInput | UserAlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserAlerts.
     */
    cursor?: UserAlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAlerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAlerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserAlerts.
     */
    distinct?: UserAlertScalarFieldEnum | UserAlertScalarFieldEnum[]
  }

  /**
   * UserAlert findMany
   */
  export type UserAlertFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAlert
     */
    select?: UserAlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAlertInclude<ExtArgs> | null
    /**
     * Filter, which UserAlerts to fetch.
     */
    where?: UserAlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAlerts to fetch.
     */
    orderBy?: UserAlertOrderByWithRelationInput | UserAlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserAlerts.
     */
    cursor?: UserAlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAlerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAlerts.
     */
    skip?: number
    distinct?: UserAlertScalarFieldEnum | UserAlertScalarFieldEnum[]
  }

  /**
   * UserAlert create
   */
  export type UserAlertCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAlert
     */
    select?: UserAlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAlertInclude<ExtArgs> | null
    /**
     * The data needed to create a UserAlert.
     */
    data: XOR<UserAlertCreateInput, UserAlertUncheckedCreateInput>
  }

  /**
   * UserAlert createMany
   */
  export type UserAlertCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserAlerts.
     */
    data: UserAlertCreateManyInput | UserAlertCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserAlert createManyAndReturn
   */
  export type UserAlertCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAlert
     */
    select?: UserAlertSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UserAlerts.
     */
    data: UserAlertCreateManyInput | UserAlertCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAlertIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserAlert update
   */
  export type UserAlertUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAlert
     */
    select?: UserAlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAlertInclude<ExtArgs> | null
    /**
     * The data needed to update a UserAlert.
     */
    data: XOR<UserAlertUpdateInput, UserAlertUncheckedUpdateInput>
    /**
     * Choose, which UserAlert to update.
     */
    where: UserAlertWhereUniqueInput
  }

  /**
   * UserAlert updateMany
   */
  export type UserAlertUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserAlerts.
     */
    data: XOR<UserAlertUpdateManyMutationInput, UserAlertUncheckedUpdateManyInput>
    /**
     * Filter which UserAlerts to update
     */
    where?: UserAlertWhereInput
  }

  /**
   * UserAlert upsert
   */
  export type UserAlertUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAlert
     */
    select?: UserAlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAlertInclude<ExtArgs> | null
    /**
     * The filter to search for the UserAlert to update in case it exists.
     */
    where: UserAlertWhereUniqueInput
    /**
     * In case the UserAlert found by the `where` argument doesn't exist, create a new UserAlert with this data.
     */
    create: XOR<UserAlertCreateInput, UserAlertUncheckedCreateInput>
    /**
     * In case the UserAlert was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserAlertUpdateInput, UserAlertUncheckedUpdateInput>
  }

  /**
   * UserAlert delete
   */
  export type UserAlertDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAlert
     */
    select?: UserAlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAlertInclude<ExtArgs> | null
    /**
     * Filter which UserAlert to delete.
     */
    where: UserAlertWhereUniqueInput
  }

  /**
   * UserAlert deleteMany
   */
  export type UserAlertDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserAlerts to delete
     */
    where?: UserAlertWhereInput
  }

  /**
   * UserAlert.ipo
   */
  export type UserAlert$ipoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IPO
     */
    select?: IPOSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IPOInclude<ExtArgs> | null
    where?: IPOWhereInput
  }

  /**
   * UserAlert without action
   */
  export type UserAlertDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAlert
     */
    select?: UserAlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAlertInclude<ExtArgs> | null
  }


  /**
   * Model SystemConfig
   */

  export type AggregateSystemConfig = {
    _count: SystemConfigCountAggregateOutputType | null
    _min: SystemConfigMinAggregateOutputType | null
    _max: SystemConfigMaxAggregateOutputType | null
  }

  export type SystemConfigMinAggregateOutputType = {
    id: string | null
    key: string | null
    value: string | null
    description: string | null
    category: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SystemConfigMaxAggregateOutputType = {
    id: string | null
    key: string | null
    value: string | null
    description: string | null
    category: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SystemConfigCountAggregateOutputType = {
    id: number
    key: number
    value: number
    description: number
    category: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SystemConfigMinAggregateInputType = {
    id?: true
    key?: true
    value?: true
    description?: true
    category?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SystemConfigMaxAggregateInputType = {
    id?: true
    key?: true
    value?: true
    description?: true
    category?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SystemConfigCountAggregateInputType = {
    id?: true
    key?: true
    value?: true
    description?: true
    category?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SystemConfigAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemConfig to aggregate.
     */
    where?: SystemConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemConfigs to fetch.
     */
    orderBy?: SystemConfigOrderByWithRelationInput | SystemConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SystemConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SystemConfigs
    **/
    _count?: true | SystemConfigCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SystemConfigMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SystemConfigMaxAggregateInputType
  }

  export type GetSystemConfigAggregateType<T extends SystemConfigAggregateArgs> = {
        [P in keyof T & keyof AggregateSystemConfig]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSystemConfig[P]>
      : GetScalarType<T[P], AggregateSystemConfig[P]>
  }




  export type SystemConfigGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SystemConfigWhereInput
    orderBy?: SystemConfigOrderByWithAggregationInput | SystemConfigOrderByWithAggregationInput[]
    by: SystemConfigScalarFieldEnum[] | SystemConfigScalarFieldEnum
    having?: SystemConfigScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SystemConfigCountAggregateInputType | true
    _min?: SystemConfigMinAggregateInputType
    _max?: SystemConfigMaxAggregateInputType
  }

  export type SystemConfigGroupByOutputType = {
    id: string
    key: string
    value: string
    description: string | null
    category: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: SystemConfigCountAggregateOutputType | null
    _min: SystemConfigMinAggregateOutputType | null
    _max: SystemConfigMaxAggregateOutputType | null
  }

  type GetSystemConfigGroupByPayload<T extends SystemConfigGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SystemConfigGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SystemConfigGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SystemConfigGroupByOutputType[P]>
            : GetScalarType<T[P], SystemConfigGroupByOutputType[P]>
        }
      >
    >


  export type SystemConfigSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    description?: boolean
    category?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["systemConfig"]>

  export type SystemConfigSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    description?: boolean
    category?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["systemConfig"]>

  export type SystemConfigSelectScalar = {
    id?: boolean
    key?: boolean
    value?: boolean
    description?: boolean
    category?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $SystemConfigPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SystemConfig"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      key: string
      value: string
      description: string | null
      category: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["systemConfig"]>
    composites: {}
  }

  type SystemConfigGetPayload<S extends boolean | null | undefined | SystemConfigDefaultArgs> = $Result.GetResult<Prisma.$SystemConfigPayload, S>

  type SystemConfigCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SystemConfigFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SystemConfigCountAggregateInputType | true
    }

  export interface SystemConfigDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SystemConfig'], meta: { name: 'SystemConfig' } }
    /**
     * Find zero or one SystemConfig that matches the filter.
     * @param {SystemConfigFindUniqueArgs} args - Arguments to find a SystemConfig
     * @example
     * // Get one SystemConfig
     * const systemConfig = await prisma.systemConfig.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SystemConfigFindUniqueArgs>(args: SelectSubset<T, SystemConfigFindUniqueArgs<ExtArgs>>): Prisma__SystemConfigClient<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SystemConfig that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SystemConfigFindUniqueOrThrowArgs} args - Arguments to find a SystemConfig
     * @example
     * // Get one SystemConfig
     * const systemConfig = await prisma.systemConfig.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SystemConfigFindUniqueOrThrowArgs>(args: SelectSubset<T, SystemConfigFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SystemConfigClient<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SystemConfig that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemConfigFindFirstArgs} args - Arguments to find a SystemConfig
     * @example
     * // Get one SystemConfig
     * const systemConfig = await prisma.systemConfig.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SystemConfigFindFirstArgs>(args?: SelectSubset<T, SystemConfigFindFirstArgs<ExtArgs>>): Prisma__SystemConfigClient<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SystemConfig that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemConfigFindFirstOrThrowArgs} args - Arguments to find a SystemConfig
     * @example
     * // Get one SystemConfig
     * const systemConfig = await prisma.systemConfig.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SystemConfigFindFirstOrThrowArgs>(args?: SelectSubset<T, SystemConfigFindFirstOrThrowArgs<ExtArgs>>): Prisma__SystemConfigClient<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SystemConfigs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemConfigFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SystemConfigs
     * const systemConfigs = await prisma.systemConfig.findMany()
     * 
     * // Get first 10 SystemConfigs
     * const systemConfigs = await prisma.systemConfig.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const systemConfigWithIdOnly = await prisma.systemConfig.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SystemConfigFindManyArgs>(args?: SelectSubset<T, SystemConfigFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SystemConfig.
     * @param {SystemConfigCreateArgs} args - Arguments to create a SystemConfig.
     * @example
     * // Create one SystemConfig
     * const SystemConfig = await prisma.systemConfig.create({
     *   data: {
     *     // ... data to create a SystemConfig
     *   }
     * })
     * 
     */
    create<T extends SystemConfigCreateArgs>(args: SelectSubset<T, SystemConfigCreateArgs<ExtArgs>>): Prisma__SystemConfigClient<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SystemConfigs.
     * @param {SystemConfigCreateManyArgs} args - Arguments to create many SystemConfigs.
     * @example
     * // Create many SystemConfigs
     * const systemConfig = await prisma.systemConfig.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SystemConfigCreateManyArgs>(args?: SelectSubset<T, SystemConfigCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SystemConfigs and returns the data saved in the database.
     * @param {SystemConfigCreateManyAndReturnArgs} args - Arguments to create many SystemConfigs.
     * @example
     * // Create many SystemConfigs
     * const systemConfig = await prisma.systemConfig.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SystemConfigs and only return the `id`
     * const systemConfigWithIdOnly = await prisma.systemConfig.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SystemConfigCreateManyAndReturnArgs>(args?: SelectSubset<T, SystemConfigCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SystemConfig.
     * @param {SystemConfigDeleteArgs} args - Arguments to delete one SystemConfig.
     * @example
     * // Delete one SystemConfig
     * const SystemConfig = await prisma.systemConfig.delete({
     *   where: {
     *     // ... filter to delete one SystemConfig
     *   }
     * })
     * 
     */
    delete<T extends SystemConfigDeleteArgs>(args: SelectSubset<T, SystemConfigDeleteArgs<ExtArgs>>): Prisma__SystemConfigClient<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SystemConfig.
     * @param {SystemConfigUpdateArgs} args - Arguments to update one SystemConfig.
     * @example
     * // Update one SystemConfig
     * const systemConfig = await prisma.systemConfig.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SystemConfigUpdateArgs>(args: SelectSubset<T, SystemConfigUpdateArgs<ExtArgs>>): Prisma__SystemConfigClient<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SystemConfigs.
     * @param {SystemConfigDeleteManyArgs} args - Arguments to filter SystemConfigs to delete.
     * @example
     * // Delete a few SystemConfigs
     * const { count } = await prisma.systemConfig.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SystemConfigDeleteManyArgs>(args?: SelectSubset<T, SystemConfigDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemConfigUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SystemConfigs
     * const systemConfig = await prisma.systemConfig.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SystemConfigUpdateManyArgs>(args: SelectSubset<T, SystemConfigUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SystemConfig.
     * @param {SystemConfigUpsertArgs} args - Arguments to update or create a SystemConfig.
     * @example
     * // Update or create a SystemConfig
     * const systemConfig = await prisma.systemConfig.upsert({
     *   create: {
     *     // ... data to create a SystemConfig
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SystemConfig we want to update
     *   }
     * })
     */
    upsert<T extends SystemConfigUpsertArgs>(args: SelectSubset<T, SystemConfigUpsertArgs<ExtArgs>>): Prisma__SystemConfigClient<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SystemConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemConfigCountArgs} args - Arguments to filter SystemConfigs to count.
     * @example
     * // Count the number of SystemConfigs
     * const count = await prisma.systemConfig.count({
     *   where: {
     *     // ... the filter for the SystemConfigs we want to count
     *   }
     * })
    **/
    count<T extends SystemConfigCountArgs>(
      args?: Subset<T, SystemConfigCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SystemConfigCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SystemConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemConfigAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SystemConfigAggregateArgs>(args: Subset<T, SystemConfigAggregateArgs>): Prisma.PrismaPromise<GetSystemConfigAggregateType<T>>

    /**
     * Group by SystemConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemConfigGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SystemConfigGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SystemConfigGroupByArgs['orderBy'] }
        : { orderBy?: SystemConfigGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SystemConfigGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSystemConfigGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SystemConfig model
   */
  readonly fields: SystemConfigFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SystemConfig.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SystemConfigClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SystemConfig model
   */ 
  interface SystemConfigFieldRefs {
    readonly id: FieldRef<"SystemConfig", 'String'>
    readonly key: FieldRef<"SystemConfig", 'String'>
    readonly value: FieldRef<"SystemConfig", 'String'>
    readonly description: FieldRef<"SystemConfig", 'String'>
    readonly category: FieldRef<"SystemConfig", 'String'>
    readonly isActive: FieldRef<"SystemConfig", 'Boolean'>
    readonly createdAt: FieldRef<"SystemConfig", 'DateTime'>
    readonly updatedAt: FieldRef<"SystemConfig", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SystemConfig findUnique
   */
  export type SystemConfigFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * Filter, which SystemConfig to fetch.
     */
    where: SystemConfigWhereUniqueInput
  }

  /**
   * SystemConfig findUniqueOrThrow
   */
  export type SystemConfigFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * Filter, which SystemConfig to fetch.
     */
    where: SystemConfigWhereUniqueInput
  }

  /**
   * SystemConfig findFirst
   */
  export type SystemConfigFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * Filter, which SystemConfig to fetch.
     */
    where?: SystemConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemConfigs to fetch.
     */
    orderBy?: SystemConfigOrderByWithRelationInput | SystemConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemConfigs.
     */
    cursor?: SystemConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemConfigs.
     */
    distinct?: SystemConfigScalarFieldEnum | SystemConfigScalarFieldEnum[]
  }

  /**
   * SystemConfig findFirstOrThrow
   */
  export type SystemConfigFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * Filter, which SystemConfig to fetch.
     */
    where?: SystemConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemConfigs to fetch.
     */
    orderBy?: SystemConfigOrderByWithRelationInput | SystemConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemConfigs.
     */
    cursor?: SystemConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemConfigs.
     */
    distinct?: SystemConfigScalarFieldEnum | SystemConfigScalarFieldEnum[]
  }

  /**
   * SystemConfig findMany
   */
  export type SystemConfigFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * Filter, which SystemConfigs to fetch.
     */
    where?: SystemConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemConfigs to fetch.
     */
    orderBy?: SystemConfigOrderByWithRelationInput | SystemConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SystemConfigs.
     */
    cursor?: SystemConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemConfigs.
     */
    skip?: number
    distinct?: SystemConfigScalarFieldEnum | SystemConfigScalarFieldEnum[]
  }

  /**
   * SystemConfig create
   */
  export type SystemConfigCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * The data needed to create a SystemConfig.
     */
    data: XOR<SystemConfigCreateInput, SystemConfigUncheckedCreateInput>
  }

  /**
   * SystemConfig createMany
   */
  export type SystemConfigCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SystemConfigs.
     */
    data: SystemConfigCreateManyInput | SystemConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SystemConfig createManyAndReturn
   */
  export type SystemConfigCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SystemConfigs.
     */
    data: SystemConfigCreateManyInput | SystemConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SystemConfig update
   */
  export type SystemConfigUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * The data needed to update a SystemConfig.
     */
    data: XOR<SystemConfigUpdateInput, SystemConfigUncheckedUpdateInput>
    /**
     * Choose, which SystemConfig to update.
     */
    where: SystemConfigWhereUniqueInput
  }

  /**
   * SystemConfig updateMany
   */
  export type SystemConfigUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SystemConfigs.
     */
    data: XOR<SystemConfigUpdateManyMutationInput, SystemConfigUncheckedUpdateManyInput>
    /**
     * Filter which SystemConfigs to update
     */
    where?: SystemConfigWhereInput
  }

  /**
   * SystemConfig upsert
   */
  export type SystemConfigUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * The filter to search for the SystemConfig to update in case it exists.
     */
    where: SystemConfigWhereUniqueInput
    /**
     * In case the SystemConfig found by the `where` argument doesn't exist, create a new SystemConfig with this data.
     */
    create: XOR<SystemConfigCreateInput, SystemConfigUncheckedCreateInput>
    /**
     * In case the SystemConfig was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SystemConfigUpdateInput, SystemConfigUncheckedUpdateInput>
  }

  /**
   * SystemConfig delete
   */
  export type SystemConfigDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * Filter which SystemConfig to delete.
     */
    where: SystemConfigWhereUniqueInput
  }

  /**
   * SystemConfig deleteMany
   */
  export type SystemConfigDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemConfigs to delete
     */
    where?: SystemConfigWhereInput
  }

  /**
   * SystemConfig without action
   */
  export type SystemConfigDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
  }


  /**
   * Model ApiLog
   */

  export type AggregateApiLog = {
    _count: ApiLogCountAggregateOutputType | null
    _avg: ApiLogAvgAggregateOutputType | null
    _sum: ApiLogSumAggregateOutputType | null
    _min: ApiLogMinAggregateOutputType | null
    _max: ApiLogMaxAggregateOutputType | null
  }

  export type ApiLogAvgAggregateOutputType = {
    statusCode: number | null
    responseTime: number | null
  }

  export type ApiLogSumAggregateOutputType = {
    statusCode: number | null
    responseTime: number | null
  }

  export type ApiLogMinAggregateOutputType = {
    id: string | null
    endpoint: string | null
    method: string | null
    statusCode: number | null
    responseTime: number | null
    ipAddress: string | null
    userAgent: string | null
    userId: string | null
    errorMessage: string | null
    requestData: string | null
    responseData: string | null
    timestamp: Date | null
  }

  export type ApiLogMaxAggregateOutputType = {
    id: string | null
    endpoint: string | null
    method: string | null
    statusCode: number | null
    responseTime: number | null
    ipAddress: string | null
    userAgent: string | null
    userId: string | null
    errorMessage: string | null
    requestData: string | null
    responseData: string | null
    timestamp: Date | null
  }

  export type ApiLogCountAggregateOutputType = {
    id: number
    endpoint: number
    method: number
    statusCode: number
    responseTime: number
    ipAddress: number
    userAgent: number
    userId: number
    errorMessage: number
    requestData: number
    responseData: number
    timestamp: number
    _all: number
  }


  export type ApiLogAvgAggregateInputType = {
    statusCode?: true
    responseTime?: true
  }

  export type ApiLogSumAggregateInputType = {
    statusCode?: true
    responseTime?: true
  }

  export type ApiLogMinAggregateInputType = {
    id?: true
    endpoint?: true
    method?: true
    statusCode?: true
    responseTime?: true
    ipAddress?: true
    userAgent?: true
    userId?: true
    errorMessage?: true
    requestData?: true
    responseData?: true
    timestamp?: true
  }

  export type ApiLogMaxAggregateInputType = {
    id?: true
    endpoint?: true
    method?: true
    statusCode?: true
    responseTime?: true
    ipAddress?: true
    userAgent?: true
    userId?: true
    errorMessage?: true
    requestData?: true
    responseData?: true
    timestamp?: true
  }

  export type ApiLogCountAggregateInputType = {
    id?: true
    endpoint?: true
    method?: true
    statusCode?: true
    responseTime?: true
    ipAddress?: true
    userAgent?: true
    userId?: true
    errorMessage?: true
    requestData?: true
    responseData?: true
    timestamp?: true
    _all?: true
  }

  export type ApiLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApiLog to aggregate.
     */
    where?: ApiLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiLogs to fetch.
     */
    orderBy?: ApiLogOrderByWithRelationInput | ApiLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ApiLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ApiLogs
    **/
    _count?: true | ApiLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ApiLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ApiLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ApiLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ApiLogMaxAggregateInputType
  }

  export type GetApiLogAggregateType<T extends ApiLogAggregateArgs> = {
        [P in keyof T & keyof AggregateApiLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApiLog[P]>
      : GetScalarType<T[P], AggregateApiLog[P]>
  }




  export type ApiLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApiLogWhereInput
    orderBy?: ApiLogOrderByWithAggregationInput | ApiLogOrderByWithAggregationInput[]
    by: ApiLogScalarFieldEnum[] | ApiLogScalarFieldEnum
    having?: ApiLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ApiLogCountAggregateInputType | true
    _avg?: ApiLogAvgAggregateInputType
    _sum?: ApiLogSumAggregateInputType
    _min?: ApiLogMinAggregateInputType
    _max?: ApiLogMaxAggregateInputType
  }

  export type ApiLogGroupByOutputType = {
    id: string
    endpoint: string
    method: string
    statusCode: number
    responseTime: number
    ipAddress: string | null
    userAgent: string | null
    userId: string | null
    errorMessage: string | null
    requestData: string | null
    responseData: string | null
    timestamp: Date
    _count: ApiLogCountAggregateOutputType | null
    _avg: ApiLogAvgAggregateOutputType | null
    _sum: ApiLogSumAggregateOutputType | null
    _min: ApiLogMinAggregateOutputType | null
    _max: ApiLogMaxAggregateOutputType | null
  }

  type GetApiLogGroupByPayload<T extends ApiLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ApiLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ApiLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ApiLogGroupByOutputType[P]>
            : GetScalarType<T[P], ApiLogGroupByOutputType[P]>
        }
      >
    >


  export type ApiLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    endpoint?: boolean
    method?: boolean
    statusCode?: boolean
    responseTime?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    userId?: boolean
    errorMessage?: boolean
    requestData?: boolean
    responseData?: boolean
    timestamp?: boolean
  }, ExtArgs["result"]["apiLog"]>

  export type ApiLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    endpoint?: boolean
    method?: boolean
    statusCode?: boolean
    responseTime?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    userId?: boolean
    errorMessage?: boolean
    requestData?: boolean
    responseData?: boolean
    timestamp?: boolean
  }, ExtArgs["result"]["apiLog"]>

  export type ApiLogSelectScalar = {
    id?: boolean
    endpoint?: boolean
    method?: boolean
    statusCode?: boolean
    responseTime?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    userId?: boolean
    errorMessage?: boolean
    requestData?: boolean
    responseData?: boolean
    timestamp?: boolean
  }


  export type $ApiLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ApiLog"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      endpoint: string
      method: string
      statusCode: number
      responseTime: number
      ipAddress: string | null
      userAgent: string | null
      userId: string | null
      errorMessage: string | null
      requestData: string | null
      responseData: string | null
      timestamp: Date
    }, ExtArgs["result"]["apiLog"]>
    composites: {}
  }

  type ApiLogGetPayload<S extends boolean | null | undefined | ApiLogDefaultArgs> = $Result.GetResult<Prisma.$ApiLogPayload, S>

  type ApiLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ApiLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ApiLogCountAggregateInputType | true
    }

  export interface ApiLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ApiLog'], meta: { name: 'ApiLog' } }
    /**
     * Find zero or one ApiLog that matches the filter.
     * @param {ApiLogFindUniqueArgs} args - Arguments to find a ApiLog
     * @example
     * // Get one ApiLog
     * const apiLog = await prisma.apiLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ApiLogFindUniqueArgs>(args: SelectSubset<T, ApiLogFindUniqueArgs<ExtArgs>>): Prisma__ApiLogClient<$Result.GetResult<Prisma.$ApiLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ApiLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ApiLogFindUniqueOrThrowArgs} args - Arguments to find a ApiLog
     * @example
     * // Get one ApiLog
     * const apiLog = await prisma.apiLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ApiLogFindUniqueOrThrowArgs>(args: SelectSubset<T, ApiLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ApiLogClient<$Result.GetResult<Prisma.$ApiLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ApiLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiLogFindFirstArgs} args - Arguments to find a ApiLog
     * @example
     * // Get one ApiLog
     * const apiLog = await prisma.apiLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ApiLogFindFirstArgs>(args?: SelectSubset<T, ApiLogFindFirstArgs<ExtArgs>>): Prisma__ApiLogClient<$Result.GetResult<Prisma.$ApiLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ApiLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiLogFindFirstOrThrowArgs} args - Arguments to find a ApiLog
     * @example
     * // Get one ApiLog
     * const apiLog = await prisma.apiLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ApiLogFindFirstOrThrowArgs>(args?: SelectSubset<T, ApiLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__ApiLogClient<$Result.GetResult<Prisma.$ApiLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ApiLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ApiLogs
     * const apiLogs = await prisma.apiLog.findMany()
     * 
     * // Get first 10 ApiLogs
     * const apiLogs = await prisma.apiLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const apiLogWithIdOnly = await prisma.apiLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ApiLogFindManyArgs>(args?: SelectSubset<T, ApiLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ApiLog.
     * @param {ApiLogCreateArgs} args - Arguments to create a ApiLog.
     * @example
     * // Create one ApiLog
     * const ApiLog = await prisma.apiLog.create({
     *   data: {
     *     // ... data to create a ApiLog
     *   }
     * })
     * 
     */
    create<T extends ApiLogCreateArgs>(args: SelectSubset<T, ApiLogCreateArgs<ExtArgs>>): Prisma__ApiLogClient<$Result.GetResult<Prisma.$ApiLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ApiLogs.
     * @param {ApiLogCreateManyArgs} args - Arguments to create many ApiLogs.
     * @example
     * // Create many ApiLogs
     * const apiLog = await prisma.apiLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ApiLogCreateManyArgs>(args?: SelectSubset<T, ApiLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ApiLogs and returns the data saved in the database.
     * @param {ApiLogCreateManyAndReturnArgs} args - Arguments to create many ApiLogs.
     * @example
     * // Create many ApiLogs
     * const apiLog = await prisma.apiLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ApiLogs and only return the `id`
     * const apiLogWithIdOnly = await prisma.apiLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ApiLogCreateManyAndReturnArgs>(args?: SelectSubset<T, ApiLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ApiLog.
     * @param {ApiLogDeleteArgs} args - Arguments to delete one ApiLog.
     * @example
     * // Delete one ApiLog
     * const ApiLog = await prisma.apiLog.delete({
     *   where: {
     *     // ... filter to delete one ApiLog
     *   }
     * })
     * 
     */
    delete<T extends ApiLogDeleteArgs>(args: SelectSubset<T, ApiLogDeleteArgs<ExtArgs>>): Prisma__ApiLogClient<$Result.GetResult<Prisma.$ApiLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ApiLog.
     * @param {ApiLogUpdateArgs} args - Arguments to update one ApiLog.
     * @example
     * // Update one ApiLog
     * const apiLog = await prisma.apiLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ApiLogUpdateArgs>(args: SelectSubset<T, ApiLogUpdateArgs<ExtArgs>>): Prisma__ApiLogClient<$Result.GetResult<Prisma.$ApiLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ApiLogs.
     * @param {ApiLogDeleteManyArgs} args - Arguments to filter ApiLogs to delete.
     * @example
     * // Delete a few ApiLogs
     * const { count } = await prisma.apiLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ApiLogDeleteManyArgs>(args?: SelectSubset<T, ApiLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ApiLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ApiLogs
     * const apiLog = await prisma.apiLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ApiLogUpdateManyArgs>(args: SelectSubset<T, ApiLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ApiLog.
     * @param {ApiLogUpsertArgs} args - Arguments to update or create a ApiLog.
     * @example
     * // Update or create a ApiLog
     * const apiLog = await prisma.apiLog.upsert({
     *   create: {
     *     // ... data to create a ApiLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ApiLog we want to update
     *   }
     * })
     */
    upsert<T extends ApiLogUpsertArgs>(args: SelectSubset<T, ApiLogUpsertArgs<ExtArgs>>): Prisma__ApiLogClient<$Result.GetResult<Prisma.$ApiLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ApiLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiLogCountArgs} args - Arguments to filter ApiLogs to count.
     * @example
     * // Count the number of ApiLogs
     * const count = await prisma.apiLog.count({
     *   where: {
     *     // ... the filter for the ApiLogs we want to count
     *   }
     * })
    **/
    count<T extends ApiLogCountArgs>(
      args?: Subset<T, ApiLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ApiLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ApiLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ApiLogAggregateArgs>(args: Subset<T, ApiLogAggregateArgs>): Prisma.PrismaPromise<GetApiLogAggregateType<T>>

    /**
     * Group by ApiLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ApiLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ApiLogGroupByArgs['orderBy'] }
        : { orderBy?: ApiLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ApiLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApiLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ApiLog model
   */
  readonly fields: ApiLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ApiLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ApiLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ApiLog model
   */ 
  interface ApiLogFieldRefs {
    readonly id: FieldRef<"ApiLog", 'String'>
    readonly endpoint: FieldRef<"ApiLog", 'String'>
    readonly method: FieldRef<"ApiLog", 'String'>
    readonly statusCode: FieldRef<"ApiLog", 'Int'>
    readonly responseTime: FieldRef<"ApiLog", 'Int'>
    readonly ipAddress: FieldRef<"ApiLog", 'String'>
    readonly userAgent: FieldRef<"ApiLog", 'String'>
    readonly userId: FieldRef<"ApiLog", 'String'>
    readonly errorMessage: FieldRef<"ApiLog", 'String'>
    readonly requestData: FieldRef<"ApiLog", 'String'>
    readonly responseData: FieldRef<"ApiLog", 'String'>
    readonly timestamp: FieldRef<"ApiLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ApiLog findUnique
   */
  export type ApiLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiLog
     */
    select?: ApiLogSelect<ExtArgs> | null
    /**
     * Filter, which ApiLog to fetch.
     */
    where: ApiLogWhereUniqueInput
  }

  /**
   * ApiLog findUniqueOrThrow
   */
  export type ApiLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiLog
     */
    select?: ApiLogSelect<ExtArgs> | null
    /**
     * Filter, which ApiLog to fetch.
     */
    where: ApiLogWhereUniqueInput
  }

  /**
   * ApiLog findFirst
   */
  export type ApiLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiLog
     */
    select?: ApiLogSelect<ExtArgs> | null
    /**
     * Filter, which ApiLog to fetch.
     */
    where?: ApiLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiLogs to fetch.
     */
    orderBy?: ApiLogOrderByWithRelationInput | ApiLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApiLogs.
     */
    cursor?: ApiLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApiLogs.
     */
    distinct?: ApiLogScalarFieldEnum | ApiLogScalarFieldEnum[]
  }

  /**
   * ApiLog findFirstOrThrow
   */
  export type ApiLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiLog
     */
    select?: ApiLogSelect<ExtArgs> | null
    /**
     * Filter, which ApiLog to fetch.
     */
    where?: ApiLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiLogs to fetch.
     */
    orderBy?: ApiLogOrderByWithRelationInput | ApiLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApiLogs.
     */
    cursor?: ApiLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApiLogs.
     */
    distinct?: ApiLogScalarFieldEnum | ApiLogScalarFieldEnum[]
  }

  /**
   * ApiLog findMany
   */
  export type ApiLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiLog
     */
    select?: ApiLogSelect<ExtArgs> | null
    /**
     * Filter, which ApiLogs to fetch.
     */
    where?: ApiLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiLogs to fetch.
     */
    orderBy?: ApiLogOrderByWithRelationInput | ApiLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ApiLogs.
     */
    cursor?: ApiLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiLogs.
     */
    skip?: number
    distinct?: ApiLogScalarFieldEnum | ApiLogScalarFieldEnum[]
  }

  /**
   * ApiLog create
   */
  export type ApiLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiLog
     */
    select?: ApiLogSelect<ExtArgs> | null
    /**
     * The data needed to create a ApiLog.
     */
    data: XOR<ApiLogCreateInput, ApiLogUncheckedCreateInput>
  }

  /**
   * ApiLog createMany
   */
  export type ApiLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ApiLogs.
     */
    data: ApiLogCreateManyInput | ApiLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ApiLog createManyAndReturn
   */
  export type ApiLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiLog
     */
    select?: ApiLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ApiLogs.
     */
    data: ApiLogCreateManyInput | ApiLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ApiLog update
   */
  export type ApiLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiLog
     */
    select?: ApiLogSelect<ExtArgs> | null
    /**
     * The data needed to update a ApiLog.
     */
    data: XOR<ApiLogUpdateInput, ApiLogUncheckedUpdateInput>
    /**
     * Choose, which ApiLog to update.
     */
    where: ApiLogWhereUniqueInput
  }

  /**
   * ApiLog updateMany
   */
  export type ApiLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ApiLogs.
     */
    data: XOR<ApiLogUpdateManyMutationInput, ApiLogUncheckedUpdateManyInput>
    /**
     * Filter which ApiLogs to update
     */
    where?: ApiLogWhereInput
  }

  /**
   * ApiLog upsert
   */
  export type ApiLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiLog
     */
    select?: ApiLogSelect<ExtArgs> | null
    /**
     * The filter to search for the ApiLog to update in case it exists.
     */
    where: ApiLogWhereUniqueInput
    /**
     * In case the ApiLog found by the `where` argument doesn't exist, create a new ApiLog with this data.
     */
    create: XOR<ApiLogCreateInput, ApiLogUncheckedCreateInput>
    /**
     * In case the ApiLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ApiLogUpdateInput, ApiLogUncheckedUpdateInput>
  }

  /**
   * ApiLog delete
   */
  export type ApiLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiLog
     */
    select?: ApiLogSelect<ExtArgs> | null
    /**
     * Filter which ApiLog to delete.
     */
    where: ApiLogWhereUniqueInput
  }

  /**
   * ApiLog deleteMany
   */
  export type ApiLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApiLogs to delete
     */
    where?: ApiLogWhereInput
  }

  /**
   * ApiLog without action
   */
  export type ApiLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiLog
     */
    select?: ApiLogSelect<ExtArgs> | null
  }


  /**
   * Model MarketStatus
   */

  export type AggregateMarketStatus = {
    _count: MarketStatusCountAggregateOutputType | null
    _min: MarketStatusMinAggregateOutputType | null
    _max: MarketStatusMaxAggregateOutputType | null
  }

  export type MarketStatusMinAggregateOutputType = {
    id: string | null
    exchange: string | null
    isOpen: boolean | null
    openTime: Date | null
    closeTime: Date | null
    timezone: string | null
    holidays: string | null
    lastUpdated: Date | null
  }

  export type MarketStatusMaxAggregateOutputType = {
    id: string | null
    exchange: string | null
    isOpen: boolean | null
    openTime: Date | null
    closeTime: Date | null
    timezone: string | null
    holidays: string | null
    lastUpdated: Date | null
  }

  export type MarketStatusCountAggregateOutputType = {
    id: number
    exchange: number
    isOpen: number
    openTime: number
    closeTime: number
    timezone: number
    holidays: number
    lastUpdated: number
    _all: number
  }


  export type MarketStatusMinAggregateInputType = {
    id?: true
    exchange?: true
    isOpen?: true
    openTime?: true
    closeTime?: true
    timezone?: true
    holidays?: true
    lastUpdated?: true
  }

  export type MarketStatusMaxAggregateInputType = {
    id?: true
    exchange?: true
    isOpen?: true
    openTime?: true
    closeTime?: true
    timezone?: true
    holidays?: true
    lastUpdated?: true
  }

  export type MarketStatusCountAggregateInputType = {
    id?: true
    exchange?: true
    isOpen?: true
    openTime?: true
    closeTime?: true
    timezone?: true
    holidays?: true
    lastUpdated?: true
    _all?: true
  }

  export type MarketStatusAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MarketStatus to aggregate.
     */
    where?: MarketStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketStatuses to fetch.
     */
    orderBy?: MarketStatusOrderByWithRelationInput | MarketStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MarketStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MarketStatuses
    **/
    _count?: true | MarketStatusCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MarketStatusMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MarketStatusMaxAggregateInputType
  }

  export type GetMarketStatusAggregateType<T extends MarketStatusAggregateArgs> = {
        [P in keyof T & keyof AggregateMarketStatus]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMarketStatus[P]>
      : GetScalarType<T[P], AggregateMarketStatus[P]>
  }




  export type MarketStatusGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MarketStatusWhereInput
    orderBy?: MarketStatusOrderByWithAggregationInput | MarketStatusOrderByWithAggregationInput[]
    by: MarketStatusScalarFieldEnum[] | MarketStatusScalarFieldEnum
    having?: MarketStatusScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MarketStatusCountAggregateInputType | true
    _min?: MarketStatusMinAggregateInputType
    _max?: MarketStatusMaxAggregateInputType
  }

  export type MarketStatusGroupByOutputType = {
    id: string
    exchange: string
    isOpen: boolean
    openTime: Date | null
    closeTime: Date | null
    timezone: string
    holidays: string | null
    lastUpdated: Date
    _count: MarketStatusCountAggregateOutputType | null
    _min: MarketStatusMinAggregateOutputType | null
    _max: MarketStatusMaxAggregateOutputType | null
  }

  type GetMarketStatusGroupByPayload<T extends MarketStatusGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MarketStatusGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MarketStatusGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MarketStatusGroupByOutputType[P]>
            : GetScalarType<T[P], MarketStatusGroupByOutputType[P]>
        }
      >
    >


  export type MarketStatusSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    exchange?: boolean
    isOpen?: boolean
    openTime?: boolean
    closeTime?: boolean
    timezone?: boolean
    holidays?: boolean
    lastUpdated?: boolean
  }, ExtArgs["result"]["marketStatus"]>

  export type MarketStatusSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    exchange?: boolean
    isOpen?: boolean
    openTime?: boolean
    closeTime?: boolean
    timezone?: boolean
    holidays?: boolean
    lastUpdated?: boolean
  }, ExtArgs["result"]["marketStatus"]>

  export type MarketStatusSelectScalar = {
    id?: boolean
    exchange?: boolean
    isOpen?: boolean
    openTime?: boolean
    closeTime?: boolean
    timezone?: boolean
    holidays?: boolean
    lastUpdated?: boolean
  }


  export type $MarketStatusPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MarketStatus"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      exchange: string
      isOpen: boolean
      openTime: Date | null
      closeTime: Date | null
      timezone: string
      holidays: string | null
      lastUpdated: Date
    }, ExtArgs["result"]["marketStatus"]>
    composites: {}
  }

  type MarketStatusGetPayload<S extends boolean | null | undefined | MarketStatusDefaultArgs> = $Result.GetResult<Prisma.$MarketStatusPayload, S>

  type MarketStatusCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MarketStatusFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MarketStatusCountAggregateInputType | true
    }

  export interface MarketStatusDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MarketStatus'], meta: { name: 'MarketStatus' } }
    /**
     * Find zero or one MarketStatus that matches the filter.
     * @param {MarketStatusFindUniqueArgs} args - Arguments to find a MarketStatus
     * @example
     * // Get one MarketStatus
     * const marketStatus = await prisma.marketStatus.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MarketStatusFindUniqueArgs>(args: SelectSubset<T, MarketStatusFindUniqueArgs<ExtArgs>>): Prisma__MarketStatusClient<$Result.GetResult<Prisma.$MarketStatusPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MarketStatus that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MarketStatusFindUniqueOrThrowArgs} args - Arguments to find a MarketStatus
     * @example
     * // Get one MarketStatus
     * const marketStatus = await prisma.marketStatus.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MarketStatusFindUniqueOrThrowArgs>(args: SelectSubset<T, MarketStatusFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MarketStatusClient<$Result.GetResult<Prisma.$MarketStatusPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MarketStatus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketStatusFindFirstArgs} args - Arguments to find a MarketStatus
     * @example
     * // Get one MarketStatus
     * const marketStatus = await prisma.marketStatus.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MarketStatusFindFirstArgs>(args?: SelectSubset<T, MarketStatusFindFirstArgs<ExtArgs>>): Prisma__MarketStatusClient<$Result.GetResult<Prisma.$MarketStatusPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MarketStatus that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketStatusFindFirstOrThrowArgs} args - Arguments to find a MarketStatus
     * @example
     * // Get one MarketStatus
     * const marketStatus = await prisma.marketStatus.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MarketStatusFindFirstOrThrowArgs>(args?: SelectSubset<T, MarketStatusFindFirstOrThrowArgs<ExtArgs>>): Prisma__MarketStatusClient<$Result.GetResult<Prisma.$MarketStatusPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MarketStatuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketStatusFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MarketStatuses
     * const marketStatuses = await prisma.marketStatus.findMany()
     * 
     * // Get first 10 MarketStatuses
     * const marketStatuses = await prisma.marketStatus.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const marketStatusWithIdOnly = await prisma.marketStatus.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MarketStatusFindManyArgs>(args?: SelectSubset<T, MarketStatusFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MarketStatusPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MarketStatus.
     * @param {MarketStatusCreateArgs} args - Arguments to create a MarketStatus.
     * @example
     * // Create one MarketStatus
     * const MarketStatus = await prisma.marketStatus.create({
     *   data: {
     *     // ... data to create a MarketStatus
     *   }
     * })
     * 
     */
    create<T extends MarketStatusCreateArgs>(args: SelectSubset<T, MarketStatusCreateArgs<ExtArgs>>): Prisma__MarketStatusClient<$Result.GetResult<Prisma.$MarketStatusPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MarketStatuses.
     * @param {MarketStatusCreateManyArgs} args - Arguments to create many MarketStatuses.
     * @example
     * // Create many MarketStatuses
     * const marketStatus = await prisma.marketStatus.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MarketStatusCreateManyArgs>(args?: SelectSubset<T, MarketStatusCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MarketStatuses and returns the data saved in the database.
     * @param {MarketStatusCreateManyAndReturnArgs} args - Arguments to create many MarketStatuses.
     * @example
     * // Create many MarketStatuses
     * const marketStatus = await prisma.marketStatus.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MarketStatuses and only return the `id`
     * const marketStatusWithIdOnly = await prisma.marketStatus.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MarketStatusCreateManyAndReturnArgs>(args?: SelectSubset<T, MarketStatusCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MarketStatusPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a MarketStatus.
     * @param {MarketStatusDeleteArgs} args - Arguments to delete one MarketStatus.
     * @example
     * // Delete one MarketStatus
     * const MarketStatus = await prisma.marketStatus.delete({
     *   where: {
     *     // ... filter to delete one MarketStatus
     *   }
     * })
     * 
     */
    delete<T extends MarketStatusDeleteArgs>(args: SelectSubset<T, MarketStatusDeleteArgs<ExtArgs>>): Prisma__MarketStatusClient<$Result.GetResult<Prisma.$MarketStatusPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MarketStatus.
     * @param {MarketStatusUpdateArgs} args - Arguments to update one MarketStatus.
     * @example
     * // Update one MarketStatus
     * const marketStatus = await prisma.marketStatus.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MarketStatusUpdateArgs>(args: SelectSubset<T, MarketStatusUpdateArgs<ExtArgs>>): Prisma__MarketStatusClient<$Result.GetResult<Prisma.$MarketStatusPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MarketStatuses.
     * @param {MarketStatusDeleteManyArgs} args - Arguments to filter MarketStatuses to delete.
     * @example
     * // Delete a few MarketStatuses
     * const { count } = await prisma.marketStatus.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MarketStatusDeleteManyArgs>(args?: SelectSubset<T, MarketStatusDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MarketStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketStatusUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MarketStatuses
     * const marketStatus = await prisma.marketStatus.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MarketStatusUpdateManyArgs>(args: SelectSubset<T, MarketStatusUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MarketStatus.
     * @param {MarketStatusUpsertArgs} args - Arguments to update or create a MarketStatus.
     * @example
     * // Update or create a MarketStatus
     * const marketStatus = await prisma.marketStatus.upsert({
     *   create: {
     *     // ... data to create a MarketStatus
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MarketStatus we want to update
     *   }
     * })
     */
    upsert<T extends MarketStatusUpsertArgs>(args: SelectSubset<T, MarketStatusUpsertArgs<ExtArgs>>): Prisma__MarketStatusClient<$Result.GetResult<Prisma.$MarketStatusPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MarketStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketStatusCountArgs} args - Arguments to filter MarketStatuses to count.
     * @example
     * // Count the number of MarketStatuses
     * const count = await prisma.marketStatus.count({
     *   where: {
     *     // ... the filter for the MarketStatuses we want to count
     *   }
     * })
    **/
    count<T extends MarketStatusCountArgs>(
      args?: Subset<T, MarketStatusCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MarketStatusCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MarketStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketStatusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MarketStatusAggregateArgs>(args: Subset<T, MarketStatusAggregateArgs>): Prisma.PrismaPromise<GetMarketStatusAggregateType<T>>

    /**
     * Group by MarketStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketStatusGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MarketStatusGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MarketStatusGroupByArgs['orderBy'] }
        : { orderBy?: MarketStatusGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MarketStatusGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMarketStatusGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MarketStatus model
   */
  readonly fields: MarketStatusFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MarketStatus.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MarketStatusClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MarketStatus model
   */ 
  interface MarketStatusFieldRefs {
    readonly id: FieldRef<"MarketStatus", 'String'>
    readonly exchange: FieldRef<"MarketStatus", 'String'>
    readonly isOpen: FieldRef<"MarketStatus", 'Boolean'>
    readonly openTime: FieldRef<"MarketStatus", 'DateTime'>
    readonly closeTime: FieldRef<"MarketStatus", 'DateTime'>
    readonly timezone: FieldRef<"MarketStatus", 'String'>
    readonly holidays: FieldRef<"MarketStatus", 'String'>
    readonly lastUpdated: FieldRef<"MarketStatus", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MarketStatus findUnique
   */
  export type MarketStatusFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketStatus
     */
    select?: MarketStatusSelect<ExtArgs> | null
    /**
     * Filter, which MarketStatus to fetch.
     */
    where: MarketStatusWhereUniqueInput
  }

  /**
   * MarketStatus findUniqueOrThrow
   */
  export type MarketStatusFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketStatus
     */
    select?: MarketStatusSelect<ExtArgs> | null
    /**
     * Filter, which MarketStatus to fetch.
     */
    where: MarketStatusWhereUniqueInput
  }

  /**
   * MarketStatus findFirst
   */
  export type MarketStatusFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketStatus
     */
    select?: MarketStatusSelect<ExtArgs> | null
    /**
     * Filter, which MarketStatus to fetch.
     */
    where?: MarketStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketStatuses to fetch.
     */
    orderBy?: MarketStatusOrderByWithRelationInput | MarketStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MarketStatuses.
     */
    cursor?: MarketStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MarketStatuses.
     */
    distinct?: MarketStatusScalarFieldEnum | MarketStatusScalarFieldEnum[]
  }

  /**
   * MarketStatus findFirstOrThrow
   */
  export type MarketStatusFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketStatus
     */
    select?: MarketStatusSelect<ExtArgs> | null
    /**
     * Filter, which MarketStatus to fetch.
     */
    where?: MarketStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketStatuses to fetch.
     */
    orderBy?: MarketStatusOrderByWithRelationInput | MarketStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MarketStatuses.
     */
    cursor?: MarketStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MarketStatuses.
     */
    distinct?: MarketStatusScalarFieldEnum | MarketStatusScalarFieldEnum[]
  }

  /**
   * MarketStatus findMany
   */
  export type MarketStatusFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketStatus
     */
    select?: MarketStatusSelect<ExtArgs> | null
    /**
     * Filter, which MarketStatuses to fetch.
     */
    where?: MarketStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketStatuses to fetch.
     */
    orderBy?: MarketStatusOrderByWithRelationInput | MarketStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MarketStatuses.
     */
    cursor?: MarketStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketStatuses.
     */
    skip?: number
    distinct?: MarketStatusScalarFieldEnum | MarketStatusScalarFieldEnum[]
  }

  /**
   * MarketStatus create
   */
  export type MarketStatusCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketStatus
     */
    select?: MarketStatusSelect<ExtArgs> | null
    /**
     * The data needed to create a MarketStatus.
     */
    data: XOR<MarketStatusCreateInput, MarketStatusUncheckedCreateInput>
  }

  /**
   * MarketStatus createMany
   */
  export type MarketStatusCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MarketStatuses.
     */
    data: MarketStatusCreateManyInput | MarketStatusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MarketStatus createManyAndReturn
   */
  export type MarketStatusCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketStatus
     */
    select?: MarketStatusSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many MarketStatuses.
     */
    data: MarketStatusCreateManyInput | MarketStatusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MarketStatus update
   */
  export type MarketStatusUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketStatus
     */
    select?: MarketStatusSelect<ExtArgs> | null
    /**
     * The data needed to update a MarketStatus.
     */
    data: XOR<MarketStatusUpdateInput, MarketStatusUncheckedUpdateInput>
    /**
     * Choose, which MarketStatus to update.
     */
    where: MarketStatusWhereUniqueInput
  }

  /**
   * MarketStatus updateMany
   */
  export type MarketStatusUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MarketStatuses.
     */
    data: XOR<MarketStatusUpdateManyMutationInput, MarketStatusUncheckedUpdateManyInput>
    /**
     * Filter which MarketStatuses to update
     */
    where?: MarketStatusWhereInput
  }

  /**
   * MarketStatus upsert
   */
  export type MarketStatusUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketStatus
     */
    select?: MarketStatusSelect<ExtArgs> | null
    /**
     * The filter to search for the MarketStatus to update in case it exists.
     */
    where: MarketStatusWhereUniqueInput
    /**
     * In case the MarketStatus found by the `where` argument doesn't exist, create a new MarketStatus with this data.
     */
    create: XOR<MarketStatusCreateInput, MarketStatusUncheckedCreateInput>
    /**
     * In case the MarketStatus was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MarketStatusUpdateInput, MarketStatusUncheckedUpdateInput>
  }

  /**
   * MarketStatus delete
   */
  export type MarketStatusDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketStatus
     */
    select?: MarketStatusSelect<ExtArgs> | null
    /**
     * Filter which MarketStatus to delete.
     */
    where: MarketStatusWhereUniqueInput
  }

  /**
   * MarketStatus deleteMany
   */
  export type MarketStatusDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MarketStatuses to delete
     */
    where?: MarketStatusWhereInput
  }

  /**
   * MarketStatus without action
   */
  export type MarketStatusDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketStatus
     */
    select?: MarketStatusSelect<ExtArgs> | null
  }


  /**
   * Model CacheEntry
   */

  export type AggregateCacheEntry = {
    _count: CacheEntryCountAggregateOutputType | null
    _min: CacheEntryMinAggregateOutputType | null
    _max: CacheEntryMaxAggregateOutputType | null
  }

  export type CacheEntryMinAggregateOutputType = {
    id: string | null
    key: string | null
    value: string | null
    expiresAt: Date | null
    tags: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CacheEntryMaxAggregateOutputType = {
    id: string | null
    key: string | null
    value: string | null
    expiresAt: Date | null
    tags: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CacheEntryCountAggregateOutputType = {
    id: number
    key: number
    value: number
    expiresAt: number
    tags: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CacheEntryMinAggregateInputType = {
    id?: true
    key?: true
    value?: true
    expiresAt?: true
    tags?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CacheEntryMaxAggregateInputType = {
    id?: true
    key?: true
    value?: true
    expiresAt?: true
    tags?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CacheEntryCountAggregateInputType = {
    id?: true
    key?: true
    value?: true
    expiresAt?: true
    tags?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CacheEntryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CacheEntry to aggregate.
     */
    where?: CacheEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CacheEntries to fetch.
     */
    orderBy?: CacheEntryOrderByWithRelationInput | CacheEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CacheEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CacheEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CacheEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CacheEntries
    **/
    _count?: true | CacheEntryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CacheEntryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CacheEntryMaxAggregateInputType
  }

  export type GetCacheEntryAggregateType<T extends CacheEntryAggregateArgs> = {
        [P in keyof T & keyof AggregateCacheEntry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCacheEntry[P]>
      : GetScalarType<T[P], AggregateCacheEntry[P]>
  }




  export type CacheEntryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CacheEntryWhereInput
    orderBy?: CacheEntryOrderByWithAggregationInput | CacheEntryOrderByWithAggregationInput[]
    by: CacheEntryScalarFieldEnum[] | CacheEntryScalarFieldEnum
    having?: CacheEntryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CacheEntryCountAggregateInputType | true
    _min?: CacheEntryMinAggregateInputType
    _max?: CacheEntryMaxAggregateInputType
  }

  export type CacheEntryGroupByOutputType = {
    id: string
    key: string
    value: string
    expiresAt: Date
    tags: string | null
    createdAt: Date
    updatedAt: Date
    _count: CacheEntryCountAggregateOutputType | null
    _min: CacheEntryMinAggregateOutputType | null
    _max: CacheEntryMaxAggregateOutputType | null
  }

  type GetCacheEntryGroupByPayload<T extends CacheEntryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CacheEntryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CacheEntryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CacheEntryGroupByOutputType[P]>
            : GetScalarType<T[P], CacheEntryGroupByOutputType[P]>
        }
      >
    >


  export type CacheEntrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    expiresAt?: boolean
    tags?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["cacheEntry"]>

  export type CacheEntrySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    expiresAt?: boolean
    tags?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["cacheEntry"]>

  export type CacheEntrySelectScalar = {
    id?: boolean
    key?: boolean
    value?: boolean
    expiresAt?: boolean
    tags?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $CacheEntryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CacheEntry"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      key: string
      value: string
      expiresAt: Date
      tags: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["cacheEntry"]>
    composites: {}
  }

  type CacheEntryGetPayload<S extends boolean | null | undefined | CacheEntryDefaultArgs> = $Result.GetResult<Prisma.$CacheEntryPayload, S>

  type CacheEntryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CacheEntryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CacheEntryCountAggregateInputType | true
    }

  export interface CacheEntryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CacheEntry'], meta: { name: 'CacheEntry' } }
    /**
     * Find zero or one CacheEntry that matches the filter.
     * @param {CacheEntryFindUniqueArgs} args - Arguments to find a CacheEntry
     * @example
     * // Get one CacheEntry
     * const cacheEntry = await prisma.cacheEntry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CacheEntryFindUniqueArgs>(args: SelectSubset<T, CacheEntryFindUniqueArgs<ExtArgs>>): Prisma__CacheEntryClient<$Result.GetResult<Prisma.$CacheEntryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CacheEntry that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CacheEntryFindUniqueOrThrowArgs} args - Arguments to find a CacheEntry
     * @example
     * // Get one CacheEntry
     * const cacheEntry = await prisma.cacheEntry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CacheEntryFindUniqueOrThrowArgs>(args: SelectSubset<T, CacheEntryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CacheEntryClient<$Result.GetResult<Prisma.$CacheEntryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CacheEntry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CacheEntryFindFirstArgs} args - Arguments to find a CacheEntry
     * @example
     * // Get one CacheEntry
     * const cacheEntry = await prisma.cacheEntry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CacheEntryFindFirstArgs>(args?: SelectSubset<T, CacheEntryFindFirstArgs<ExtArgs>>): Prisma__CacheEntryClient<$Result.GetResult<Prisma.$CacheEntryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CacheEntry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CacheEntryFindFirstOrThrowArgs} args - Arguments to find a CacheEntry
     * @example
     * // Get one CacheEntry
     * const cacheEntry = await prisma.cacheEntry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CacheEntryFindFirstOrThrowArgs>(args?: SelectSubset<T, CacheEntryFindFirstOrThrowArgs<ExtArgs>>): Prisma__CacheEntryClient<$Result.GetResult<Prisma.$CacheEntryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CacheEntries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CacheEntryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CacheEntries
     * const cacheEntries = await prisma.cacheEntry.findMany()
     * 
     * // Get first 10 CacheEntries
     * const cacheEntries = await prisma.cacheEntry.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cacheEntryWithIdOnly = await prisma.cacheEntry.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CacheEntryFindManyArgs>(args?: SelectSubset<T, CacheEntryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CacheEntryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CacheEntry.
     * @param {CacheEntryCreateArgs} args - Arguments to create a CacheEntry.
     * @example
     * // Create one CacheEntry
     * const CacheEntry = await prisma.cacheEntry.create({
     *   data: {
     *     // ... data to create a CacheEntry
     *   }
     * })
     * 
     */
    create<T extends CacheEntryCreateArgs>(args: SelectSubset<T, CacheEntryCreateArgs<ExtArgs>>): Prisma__CacheEntryClient<$Result.GetResult<Prisma.$CacheEntryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CacheEntries.
     * @param {CacheEntryCreateManyArgs} args - Arguments to create many CacheEntries.
     * @example
     * // Create many CacheEntries
     * const cacheEntry = await prisma.cacheEntry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CacheEntryCreateManyArgs>(args?: SelectSubset<T, CacheEntryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CacheEntries and returns the data saved in the database.
     * @param {CacheEntryCreateManyAndReturnArgs} args - Arguments to create many CacheEntries.
     * @example
     * // Create many CacheEntries
     * const cacheEntry = await prisma.cacheEntry.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CacheEntries and only return the `id`
     * const cacheEntryWithIdOnly = await prisma.cacheEntry.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CacheEntryCreateManyAndReturnArgs>(args?: SelectSubset<T, CacheEntryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CacheEntryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CacheEntry.
     * @param {CacheEntryDeleteArgs} args - Arguments to delete one CacheEntry.
     * @example
     * // Delete one CacheEntry
     * const CacheEntry = await prisma.cacheEntry.delete({
     *   where: {
     *     // ... filter to delete one CacheEntry
     *   }
     * })
     * 
     */
    delete<T extends CacheEntryDeleteArgs>(args: SelectSubset<T, CacheEntryDeleteArgs<ExtArgs>>): Prisma__CacheEntryClient<$Result.GetResult<Prisma.$CacheEntryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CacheEntry.
     * @param {CacheEntryUpdateArgs} args - Arguments to update one CacheEntry.
     * @example
     * // Update one CacheEntry
     * const cacheEntry = await prisma.cacheEntry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CacheEntryUpdateArgs>(args: SelectSubset<T, CacheEntryUpdateArgs<ExtArgs>>): Prisma__CacheEntryClient<$Result.GetResult<Prisma.$CacheEntryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CacheEntries.
     * @param {CacheEntryDeleteManyArgs} args - Arguments to filter CacheEntries to delete.
     * @example
     * // Delete a few CacheEntries
     * const { count } = await prisma.cacheEntry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CacheEntryDeleteManyArgs>(args?: SelectSubset<T, CacheEntryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CacheEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CacheEntryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CacheEntries
     * const cacheEntry = await prisma.cacheEntry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CacheEntryUpdateManyArgs>(args: SelectSubset<T, CacheEntryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CacheEntry.
     * @param {CacheEntryUpsertArgs} args - Arguments to update or create a CacheEntry.
     * @example
     * // Update or create a CacheEntry
     * const cacheEntry = await prisma.cacheEntry.upsert({
     *   create: {
     *     // ... data to create a CacheEntry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CacheEntry we want to update
     *   }
     * })
     */
    upsert<T extends CacheEntryUpsertArgs>(args: SelectSubset<T, CacheEntryUpsertArgs<ExtArgs>>): Prisma__CacheEntryClient<$Result.GetResult<Prisma.$CacheEntryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CacheEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CacheEntryCountArgs} args - Arguments to filter CacheEntries to count.
     * @example
     * // Count the number of CacheEntries
     * const count = await prisma.cacheEntry.count({
     *   where: {
     *     // ... the filter for the CacheEntries we want to count
     *   }
     * })
    **/
    count<T extends CacheEntryCountArgs>(
      args?: Subset<T, CacheEntryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CacheEntryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CacheEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CacheEntryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CacheEntryAggregateArgs>(args: Subset<T, CacheEntryAggregateArgs>): Prisma.PrismaPromise<GetCacheEntryAggregateType<T>>

    /**
     * Group by CacheEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CacheEntryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CacheEntryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CacheEntryGroupByArgs['orderBy'] }
        : { orderBy?: CacheEntryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CacheEntryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCacheEntryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CacheEntry model
   */
  readonly fields: CacheEntryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CacheEntry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CacheEntryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CacheEntry model
   */ 
  interface CacheEntryFieldRefs {
    readonly id: FieldRef<"CacheEntry", 'String'>
    readonly key: FieldRef<"CacheEntry", 'String'>
    readonly value: FieldRef<"CacheEntry", 'String'>
    readonly expiresAt: FieldRef<"CacheEntry", 'DateTime'>
    readonly tags: FieldRef<"CacheEntry", 'String'>
    readonly createdAt: FieldRef<"CacheEntry", 'DateTime'>
    readonly updatedAt: FieldRef<"CacheEntry", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CacheEntry findUnique
   */
  export type CacheEntryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CacheEntry
     */
    select?: CacheEntrySelect<ExtArgs> | null
    /**
     * Filter, which CacheEntry to fetch.
     */
    where: CacheEntryWhereUniqueInput
  }

  /**
   * CacheEntry findUniqueOrThrow
   */
  export type CacheEntryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CacheEntry
     */
    select?: CacheEntrySelect<ExtArgs> | null
    /**
     * Filter, which CacheEntry to fetch.
     */
    where: CacheEntryWhereUniqueInput
  }

  /**
   * CacheEntry findFirst
   */
  export type CacheEntryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CacheEntry
     */
    select?: CacheEntrySelect<ExtArgs> | null
    /**
     * Filter, which CacheEntry to fetch.
     */
    where?: CacheEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CacheEntries to fetch.
     */
    orderBy?: CacheEntryOrderByWithRelationInput | CacheEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CacheEntries.
     */
    cursor?: CacheEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CacheEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CacheEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CacheEntries.
     */
    distinct?: CacheEntryScalarFieldEnum | CacheEntryScalarFieldEnum[]
  }

  /**
   * CacheEntry findFirstOrThrow
   */
  export type CacheEntryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CacheEntry
     */
    select?: CacheEntrySelect<ExtArgs> | null
    /**
     * Filter, which CacheEntry to fetch.
     */
    where?: CacheEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CacheEntries to fetch.
     */
    orderBy?: CacheEntryOrderByWithRelationInput | CacheEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CacheEntries.
     */
    cursor?: CacheEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CacheEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CacheEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CacheEntries.
     */
    distinct?: CacheEntryScalarFieldEnum | CacheEntryScalarFieldEnum[]
  }

  /**
   * CacheEntry findMany
   */
  export type CacheEntryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CacheEntry
     */
    select?: CacheEntrySelect<ExtArgs> | null
    /**
     * Filter, which CacheEntries to fetch.
     */
    where?: CacheEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CacheEntries to fetch.
     */
    orderBy?: CacheEntryOrderByWithRelationInput | CacheEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CacheEntries.
     */
    cursor?: CacheEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CacheEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CacheEntries.
     */
    skip?: number
    distinct?: CacheEntryScalarFieldEnum | CacheEntryScalarFieldEnum[]
  }

  /**
   * CacheEntry create
   */
  export type CacheEntryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CacheEntry
     */
    select?: CacheEntrySelect<ExtArgs> | null
    /**
     * The data needed to create a CacheEntry.
     */
    data: XOR<CacheEntryCreateInput, CacheEntryUncheckedCreateInput>
  }

  /**
   * CacheEntry createMany
   */
  export type CacheEntryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CacheEntries.
     */
    data: CacheEntryCreateManyInput | CacheEntryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CacheEntry createManyAndReturn
   */
  export type CacheEntryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CacheEntry
     */
    select?: CacheEntrySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CacheEntries.
     */
    data: CacheEntryCreateManyInput | CacheEntryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CacheEntry update
   */
  export type CacheEntryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CacheEntry
     */
    select?: CacheEntrySelect<ExtArgs> | null
    /**
     * The data needed to update a CacheEntry.
     */
    data: XOR<CacheEntryUpdateInput, CacheEntryUncheckedUpdateInput>
    /**
     * Choose, which CacheEntry to update.
     */
    where: CacheEntryWhereUniqueInput
  }

  /**
   * CacheEntry updateMany
   */
  export type CacheEntryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CacheEntries.
     */
    data: XOR<CacheEntryUpdateManyMutationInput, CacheEntryUncheckedUpdateManyInput>
    /**
     * Filter which CacheEntries to update
     */
    where?: CacheEntryWhereInput
  }

  /**
   * CacheEntry upsert
   */
  export type CacheEntryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CacheEntry
     */
    select?: CacheEntrySelect<ExtArgs> | null
    /**
     * The filter to search for the CacheEntry to update in case it exists.
     */
    where: CacheEntryWhereUniqueInput
    /**
     * In case the CacheEntry found by the `where` argument doesn't exist, create a new CacheEntry with this data.
     */
    create: XOR<CacheEntryCreateInput, CacheEntryUncheckedCreateInput>
    /**
     * In case the CacheEntry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CacheEntryUpdateInput, CacheEntryUncheckedUpdateInput>
  }

  /**
   * CacheEntry delete
   */
  export type CacheEntryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CacheEntry
     */
    select?: CacheEntrySelect<ExtArgs> | null
    /**
     * Filter which CacheEntry to delete.
     */
    where: CacheEntryWhereUniqueInput
  }

  /**
   * CacheEntry deleteMany
   */
  export type CacheEntryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CacheEntries to delete
     */
    where?: CacheEntryWhereInput
  }

  /**
   * CacheEntry without action
   */
  export type CacheEntryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CacheEntry
     */
    select?: CacheEntrySelect<ExtArgs> | null
  }


  /**
   * Model SyncLog
   */

  export type AggregateSyncLog = {
    _count: SyncLogCountAggregateOutputType | null
    _avg: SyncLogAvgAggregateOutputType | null
    _sum: SyncLogSumAggregateOutputType | null
    _min: SyncLogMinAggregateOutputType | null
    _max: SyncLogMaxAggregateOutputType | null
  }

  export type SyncLogAvgAggregateOutputType = {
    recordsProcessed: number | null
    recordsSuccess: number | null
    recordsError: number | null
    duration: number | null
  }

  export type SyncLogSumAggregateOutputType = {
    recordsProcessed: number | null
    recordsSuccess: number | null
    recordsError: number | null
    duration: number | null
  }

  export type SyncLogMinAggregateOutputType = {
    id: string | null
    source: string | null
    type: string | null
    status: string | null
    recordsProcessed: number | null
    recordsSuccess: number | null
    recordsError: number | null
    errorDetails: string | null
    startedAt: Date | null
    completedAt: Date | null
    duration: number | null
    metadata: string | null
  }

  export type SyncLogMaxAggregateOutputType = {
    id: string | null
    source: string | null
    type: string | null
    status: string | null
    recordsProcessed: number | null
    recordsSuccess: number | null
    recordsError: number | null
    errorDetails: string | null
    startedAt: Date | null
    completedAt: Date | null
    duration: number | null
    metadata: string | null
  }

  export type SyncLogCountAggregateOutputType = {
    id: number
    source: number
    type: number
    status: number
    recordsProcessed: number
    recordsSuccess: number
    recordsError: number
    errorDetails: number
    startedAt: number
    completedAt: number
    duration: number
    metadata: number
    _all: number
  }


  export type SyncLogAvgAggregateInputType = {
    recordsProcessed?: true
    recordsSuccess?: true
    recordsError?: true
    duration?: true
  }

  export type SyncLogSumAggregateInputType = {
    recordsProcessed?: true
    recordsSuccess?: true
    recordsError?: true
    duration?: true
  }

  export type SyncLogMinAggregateInputType = {
    id?: true
    source?: true
    type?: true
    status?: true
    recordsProcessed?: true
    recordsSuccess?: true
    recordsError?: true
    errorDetails?: true
    startedAt?: true
    completedAt?: true
    duration?: true
    metadata?: true
  }

  export type SyncLogMaxAggregateInputType = {
    id?: true
    source?: true
    type?: true
    status?: true
    recordsProcessed?: true
    recordsSuccess?: true
    recordsError?: true
    errorDetails?: true
    startedAt?: true
    completedAt?: true
    duration?: true
    metadata?: true
  }

  export type SyncLogCountAggregateInputType = {
    id?: true
    source?: true
    type?: true
    status?: true
    recordsProcessed?: true
    recordsSuccess?: true
    recordsError?: true
    errorDetails?: true
    startedAt?: true
    completedAt?: true
    duration?: true
    metadata?: true
    _all?: true
  }

  export type SyncLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SyncLog to aggregate.
     */
    where?: SyncLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SyncLogs to fetch.
     */
    orderBy?: SyncLogOrderByWithRelationInput | SyncLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SyncLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SyncLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SyncLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SyncLogs
    **/
    _count?: true | SyncLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SyncLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SyncLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SyncLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SyncLogMaxAggregateInputType
  }

  export type GetSyncLogAggregateType<T extends SyncLogAggregateArgs> = {
        [P in keyof T & keyof AggregateSyncLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSyncLog[P]>
      : GetScalarType<T[P], AggregateSyncLog[P]>
  }




  export type SyncLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SyncLogWhereInput
    orderBy?: SyncLogOrderByWithAggregationInput | SyncLogOrderByWithAggregationInput[]
    by: SyncLogScalarFieldEnum[] | SyncLogScalarFieldEnum
    having?: SyncLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SyncLogCountAggregateInputType | true
    _avg?: SyncLogAvgAggregateInputType
    _sum?: SyncLogSumAggregateInputType
    _min?: SyncLogMinAggregateInputType
    _max?: SyncLogMaxAggregateInputType
  }

  export type SyncLogGroupByOutputType = {
    id: string
    source: string
    type: string
    status: string
    recordsProcessed: number
    recordsSuccess: number
    recordsError: number
    errorDetails: string | null
    startedAt: Date
    completedAt: Date | null
    duration: number | null
    metadata: string | null
    _count: SyncLogCountAggregateOutputType | null
    _avg: SyncLogAvgAggregateOutputType | null
    _sum: SyncLogSumAggregateOutputType | null
    _min: SyncLogMinAggregateOutputType | null
    _max: SyncLogMaxAggregateOutputType | null
  }

  type GetSyncLogGroupByPayload<T extends SyncLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SyncLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SyncLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SyncLogGroupByOutputType[P]>
            : GetScalarType<T[P], SyncLogGroupByOutputType[P]>
        }
      >
    >


  export type SyncLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    source?: boolean
    type?: boolean
    status?: boolean
    recordsProcessed?: boolean
    recordsSuccess?: boolean
    recordsError?: boolean
    errorDetails?: boolean
    startedAt?: boolean
    completedAt?: boolean
    duration?: boolean
    metadata?: boolean
  }, ExtArgs["result"]["syncLog"]>

  export type SyncLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    source?: boolean
    type?: boolean
    status?: boolean
    recordsProcessed?: boolean
    recordsSuccess?: boolean
    recordsError?: boolean
    errorDetails?: boolean
    startedAt?: boolean
    completedAt?: boolean
    duration?: boolean
    metadata?: boolean
  }, ExtArgs["result"]["syncLog"]>

  export type SyncLogSelectScalar = {
    id?: boolean
    source?: boolean
    type?: boolean
    status?: boolean
    recordsProcessed?: boolean
    recordsSuccess?: boolean
    recordsError?: boolean
    errorDetails?: boolean
    startedAt?: boolean
    completedAt?: boolean
    duration?: boolean
    metadata?: boolean
  }


  export type $SyncLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SyncLog"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      source: string
      type: string
      status: string
      recordsProcessed: number
      recordsSuccess: number
      recordsError: number
      errorDetails: string | null
      startedAt: Date
      completedAt: Date | null
      duration: number | null
      metadata: string | null
    }, ExtArgs["result"]["syncLog"]>
    composites: {}
  }

  type SyncLogGetPayload<S extends boolean | null | undefined | SyncLogDefaultArgs> = $Result.GetResult<Prisma.$SyncLogPayload, S>

  type SyncLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SyncLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SyncLogCountAggregateInputType | true
    }

  export interface SyncLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SyncLog'], meta: { name: 'SyncLog' } }
    /**
     * Find zero or one SyncLog that matches the filter.
     * @param {SyncLogFindUniqueArgs} args - Arguments to find a SyncLog
     * @example
     * // Get one SyncLog
     * const syncLog = await prisma.syncLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SyncLogFindUniqueArgs>(args: SelectSubset<T, SyncLogFindUniqueArgs<ExtArgs>>): Prisma__SyncLogClient<$Result.GetResult<Prisma.$SyncLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SyncLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SyncLogFindUniqueOrThrowArgs} args - Arguments to find a SyncLog
     * @example
     * // Get one SyncLog
     * const syncLog = await prisma.syncLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SyncLogFindUniqueOrThrowArgs>(args: SelectSubset<T, SyncLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SyncLogClient<$Result.GetResult<Prisma.$SyncLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SyncLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncLogFindFirstArgs} args - Arguments to find a SyncLog
     * @example
     * // Get one SyncLog
     * const syncLog = await prisma.syncLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SyncLogFindFirstArgs>(args?: SelectSubset<T, SyncLogFindFirstArgs<ExtArgs>>): Prisma__SyncLogClient<$Result.GetResult<Prisma.$SyncLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SyncLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncLogFindFirstOrThrowArgs} args - Arguments to find a SyncLog
     * @example
     * // Get one SyncLog
     * const syncLog = await prisma.syncLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SyncLogFindFirstOrThrowArgs>(args?: SelectSubset<T, SyncLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__SyncLogClient<$Result.GetResult<Prisma.$SyncLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SyncLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SyncLogs
     * const syncLogs = await prisma.syncLog.findMany()
     * 
     * // Get first 10 SyncLogs
     * const syncLogs = await prisma.syncLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const syncLogWithIdOnly = await prisma.syncLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SyncLogFindManyArgs>(args?: SelectSubset<T, SyncLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SyncLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SyncLog.
     * @param {SyncLogCreateArgs} args - Arguments to create a SyncLog.
     * @example
     * // Create one SyncLog
     * const SyncLog = await prisma.syncLog.create({
     *   data: {
     *     // ... data to create a SyncLog
     *   }
     * })
     * 
     */
    create<T extends SyncLogCreateArgs>(args: SelectSubset<T, SyncLogCreateArgs<ExtArgs>>): Prisma__SyncLogClient<$Result.GetResult<Prisma.$SyncLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SyncLogs.
     * @param {SyncLogCreateManyArgs} args - Arguments to create many SyncLogs.
     * @example
     * // Create many SyncLogs
     * const syncLog = await prisma.syncLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SyncLogCreateManyArgs>(args?: SelectSubset<T, SyncLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SyncLogs and returns the data saved in the database.
     * @param {SyncLogCreateManyAndReturnArgs} args - Arguments to create many SyncLogs.
     * @example
     * // Create many SyncLogs
     * const syncLog = await prisma.syncLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SyncLogs and only return the `id`
     * const syncLogWithIdOnly = await prisma.syncLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SyncLogCreateManyAndReturnArgs>(args?: SelectSubset<T, SyncLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SyncLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SyncLog.
     * @param {SyncLogDeleteArgs} args - Arguments to delete one SyncLog.
     * @example
     * // Delete one SyncLog
     * const SyncLog = await prisma.syncLog.delete({
     *   where: {
     *     // ... filter to delete one SyncLog
     *   }
     * })
     * 
     */
    delete<T extends SyncLogDeleteArgs>(args: SelectSubset<T, SyncLogDeleteArgs<ExtArgs>>): Prisma__SyncLogClient<$Result.GetResult<Prisma.$SyncLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SyncLog.
     * @param {SyncLogUpdateArgs} args - Arguments to update one SyncLog.
     * @example
     * // Update one SyncLog
     * const syncLog = await prisma.syncLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SyncLogUpdateArgs>(args: SelectSubset<T, SyncLogUpdateArgs<ExtArgs>>): Prisma__SyncLogClient<$Result.GetResult<Prisma.$SyncLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SyncLogs.
     * @param {SyncLogDeleteManyArgs} args - Arguments to filter SyncLogs to delete.
     * @example
     * // Delete a few SyncLogs
     * const { count } = await prisma.syncLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SyncLogDeleteManyArgs>(args?: SelectSubset<T, SyncLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SyncLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SyncLogs
     * const syncLog = await prisma.syncLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SyncLogUpdateManyArgs>(args: SelectSubset<T, SyncLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SyncLog.
     * @param {SyncLogUpsertArgs} args - Arguments to update or create a SyncLog.
     * @example
     * // Update or create a SyncLog
     * const syncLog = await prisma.syncLog.upsert({
     *   create: {
     *     // ... data to create a SyncLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SyncLog we want to update
     *   }
     * })
     */
    upsert<T extends SyncLogUpsertArgs>(args: SelectSubset<T, SyncLogUpsertArgs<ExtArgs>>): Prisma__SyncLogClient<$Result.GetResult<Prisma.$SyncLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SyncLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncLogCountArgs} args - Arguments to filter SyncLogs to count.
     * @example
     * // Count the number of SyncLogs
     * const count = await prisma.syncLog.count({
     *   where: {
     *     // ... the filter for the SyncLogs we want to count
     *   }
     * })
    **/
    count<T extends SyncLogCountArgs>(
      args?: Subset<T, SyncLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SyncLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SyncLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SyncLogAggregateArgs>(args: Subset<T, SyncLogAggregateArgs>): Prisma.PrismaPromise<GetSyncLogAggregateType<T>>

    /**
     * Group by SyncLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SyncLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SyncLogGroupByArgs['orderBy'] }
        : { orderBy?: SyncLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SyncLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSyncLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SyncLog model
   */
  readonly fields: SyncLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SyncLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SyncLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SyncLog model
   */ 
  interface SyncLogFieldRefs {
    readonly id: FieldRef<"SyncLog", 'String'>
    readonly source: FieldRef<"SyncLog", 'String'>
    readonly type: FieldRef<"SyncLog", 'String'>
    readonly status: FieldRef<"SyncLog", 'String'>
    readonly recordsProcessed: FieldRef<"SyncLog", 'Int'>
    readonly recordsSuccess: FieldRef<"SyncLog", 'Int'>
    readonly recordsError: FieldRef<"SyncLog", 'Int'>
    readonly errorDetails: FieldRef<"SyncLog", 'String'>
    readonly startedAt: FieldRef<"SyncLog", 'DateTime'>
    readonly completedAt: FieldRef<"SyncLog", 'DateTime'>
    readonly duration: FieldRef<"SyncLog", 'Int'>
    readonly metadata: FieldRef<"SyncLog", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SyncLog findUnique
   */
  export type SyncLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncLog
     */
    select?: SyncLogSelect<ExtArgs> | null
    /**
     * Filter, which SyncLog to fetch.
     */
    where: SyncLogWhereUniqueInput
  }

  /**
   * SyncLog findUniqueOrThrow
   */
  export type SyncLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncLog
     */
    select?: SyncLogSelect<ExtArgs> | null
    /**
     * Filter, which SyncLog to fetch.
     */
    where: SyncLogWhereUniqueInput
  }

  /**
   * SyncLog findFirst
   */
  export type SyncLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncLog
     */
    select?: SyncLogSelect<ExtArgs> | null
    /**
     * Filter, which SyncLog to fetch.
     */
    where?: SyncLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SyncLogs to fetch.
     */
    orderBy?: SyncLogOrderByWithRelationInput | SyncLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SyncLogs.
     */
    cursor?: SyncLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SyncLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SyncLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SyncLogs.
     */
    distinct?: SyncLogScalarFieldEnum | SyncLogScalarFieldEnum[]
  }

  /**
   * SyncLog findFirstOrThrow
   */
  export type SyncLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncLog
     */
    select?: SyncLogSelect<ExtArgs> | null
    /**
     * Filter, which SyncLog to fetch.
     */
    where?: SyncLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SyncLogs to fetch.
     */
    orderBy?: SyncLogOrderByWithRelationInput | SyncLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SyncLogs.
     */
    cursor?: SyncLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SyncLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SyncLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SyncLogs.
     */
    distinct?: SyncLogScalarFieldEnum | SyncLogScalarFieldEnum[]
  }

  /**
   * SyncLog findMany
   */
  export type SyncLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncLog
     */
    select?: SyncLogSelect<ExtArgs> | null
    /**
     * Filter, which SyncLogs to fetch.
     */
    where?: SyncLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SyncLogs to fetch.
     */
    orderBy?: SyncLogOrderByWithRelationInput | SyncLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SyncLogs.
     */
    cursor?: SyncLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SyncLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SyncLogs.
     */
    skip?: number
    distinct?: SyncLogScalarFieldEnum | SyncLogScalarFieldEnum[]
  }

  /**
   * SyncLog create
   */
  export type SyncLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncLog
     */
    select?: SyncLogSelect<ExtArgs> | null
    /**
     * The data needed to create a SyncLog.
     */
    data: XOR<SyncLogCreateInput, SyncLogUncheckedCreateInput>
  }

  /**
   * SyncLog createMany
   */
  export type SyncLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SyncLogs.
     */
    data: SyncLogCreateManyInput | SyncLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SyncLog createManyAndReturn
   */
  export type SyncLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncLog
     */
    select?: SyncLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SyncLogs.
     */
    data: SyncLogCreateManyInput | SyncLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SyncLog update
   */
  export type SyncLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncLog
     */
    select?: SyncLogSelect<ExtArgs> | null
    /**
     * The data needed to update a SyncLog.
     */
    data: XOR<SyncLogUpdateInput, SyncLogUncheckedUpdateInput>
    /**
     * Choose, which SyncLog to update.
     */
    where: SyncLogWhereUniqueInput
  }

  /**
   * SyncLog updateMany
   */
  export type SyncLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SyncLogs.
     */
    data: XOR<SyncLogUpdateManyMutationInput, SyncLogUncheckedUpdateManyInput>
    /**
     * Filter which SyncLogs to update
     */
    where?: SyncLogWhereInput
  }

  /**
   * SyncLog upsert
   */
  export type SyncLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncLog
     */
    select?: SyncLogSelect<ExtArgs> | null
    /**
     * The filter to search for the SyncLog to update in case it exists.
     */
    where: SyncLogWhereUniqueInput
    /**
     * In case the SyncLog found by the `where` argument doesn't exist, create a new SyncLog with this data.
     */
    create: XOR<SyncLogCreateInput, SyncLogUncheckedCreateInput>
    /**
     * In case the SyncLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SyncLogUpdateInput, SyncLogUncheckedUpdateInput>
  }

  /**
   * SyncLog delete
   */
  export type SyncLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncLog
     */
    select?: SyncLogSelect<ExtArgs> | null
    /**
     * Filter which SyncLog to delete.
     */
    where: SyncLogWhereUniqueInput
  }

  /**
   * SyncLog deleteMany
   */
  export type SyncLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SyncLogs to delete
     */
    where?: SyncLogWhereInput
  }

  /**
   * SyncLog without action
   */
  export type SyncLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncLog
     */
    select?: SyncLogSelect<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const IPOScalarFieldEnum: {
    id: 'id',
    symbol: 'symbol',
    name: 'name',
    companyId: 'companyId',
    status: 'status',
    sector: 'sector',
    industry: 'industry',
    minPrice: 'minPrice',
    maxPrice: 'maxPrice',
    finalPrice: 'finalPrice',
    listingPrice: 'listingPrice',
    currentPrice: 'currentPrice',
    issueSize: 'issueSize',
    lotSize: 'lotSize',
    marketLot: 'marketLot',
    openDate: 'openDate',
    closeDate: 'closeDate',
    listingDate: 'listingDate',
    allotmentDate: 'allotmentDate',
    refundDate: 'refundDate',
    leadManager: 'leadManager',
    registrar: 'registrar',
    faceValue: 'faceValue',
    bookValue: 'bookValue',
    marketCap: 'marketCap',
    peRatio: 'peRatio',
    roe: 'roe',
    reservationDetails: 'reservationDetails',
    aboutCompany: 'aboutCompany',
    objectives: 'objectives',
    risks: 'risks',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type IPOScalarFieldEnum = (typeof IPOScalarFieldEnum)[keyof typeof IPOScalarFieldEnum]


  export const GMPScalarFieldEnum: {
    id: 'id',
    ipoId: 'ipoId',
    value: 'value',
    percentage: 'percentage',
    volume: 'volume',
    bidPrice: 'bidPrice',
    askPrice: 'askPrice',
    timestamp: 'timestamp',
    source: 'source',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type GMPScalarFieldEnum = (typeof GMPScalarFieldEnum)[keyof typeof GMPScalarFieldEnum]


  export const SubscriptionDataScalarFieldEnum: {
    id: 'id',
    ipoId: 'ipoId',
    category: 'category',
    subCategory: 'subCategory',
    quantity: 'quantity',
    bidCount: 'bidCount',
    subscriptionRatio: 'subscriptionRatio',
    timestamp: 'timestamp',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SubscriptionDataScalarFieldEnum = (typeof SubscriptionDataScalarFieldEnum)[keyof typeof SubscriptionDataScalarFieldEnum]


  export const AllotmentDataScalarFieldEnum: {
    id: 'id',
    ipoId: 'ipoId',
    pan: 'pan',
    applicationNumber: 'applicationNumber',
    category: 'category',
    appliedQuantity: 'appliedQuantity',
    allottedQuantity: 'allottedQuantity',
    allottedAmount: 'allottedAmount',
    refundAmount: 'refundAmount',
    allotmentStatus: 'allotmentStatus',
    timestamp: 'timestamp',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AllotmentDataScalarFieldEnum = (typeof AllotmentDataScalarFieldEnum)[keyof typeof AllotmentDataScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    name: 'name',
    phone: 'phone',
    pan: 'pan',
    role: 'role',
    isActive: 'isActive',
    isEmailVerified: 'isEmailVerified',
    kycCompleted: 'kycCompleted',
    preferences: 'preferences',
    lastLoginAt: 'lastLoginAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    token: 'token',
    refreshToken: 'refreshToken',
    expiresAt: 'expiresAt',
    isActive: 'isActive',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const IPOAnalyticsScalarFieldEnum: {
    id: 'id',
    ipoId: 'ipoId',
    symbol: 'symbol',
    date: 'date',
    avgGMP: 'avgGMP',
    maxGMP: 'maxGMP',
    minGMP: 'minGMP',
    gmpVolume: 'gmpVolume',
    gmpTrend: 'gmpTrend',
    overallSubscription: 'overallSubscription',
    retailSubscription: 'retailSubscription',
    qibSubscription: 'qibSubscription',
    hniSubscription: 'hniSubscription',
    marketSentiment: 'marketSentiment',
    sentimentScore: 'sentimentScore',
    listingGain: 'listingGain',
    currentReturn: 'currentReturn',
    volatilityIndex: 'volatilityIndex',
    totalGMPChanges: 'totalGMPChanges',
    totalSubscriptions: 'totalSubscriptions',
    oversubscribedCount: 'oversubscribedCount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type IPOAnalyticsScalarFieldEnum = (typeof IPOAnalyticsScalarFieldEnum)[keyof typeof IPOAnalyticsScalarFieldEnum]


  export const UserWatchlistScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    ipoId: 'ipoId',
    notes: 'notes',
    alertPreferences: 'alertPreferences',
    addedAt: 'addedAt'
  };

  export type UserWatchlistScalarFieldEnum = (typeof UserWatchlistScalarFieldEnum)[keyof typeof UserWatchlistScalarFieldEnum]


  export const UserAlertScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    ipoId: 'ipoId',
    symbol: 'symbol',
    alertType: 'alertType',
    triggerType: 'triggerType',
    triggerValue: 'triggerValue',
    triggerCondition: 'triggerCondition',
    message: 'message',
    isActive: 'isActive',
    lastTriggered: 'lastTriggered',
    triggerCount: 'triggerCount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserAlertScalarFieldEnum = (typeof UserAlertScalarFieldEnum)[keyof typeof UserAlertScalarFieldEnum]


  export const SystemConfigScalarFieldEnum: {
    id: 'id',
    key: 'key',
    value: 'value',
    description: 'description',
    category: 'category',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SystemConfigScalarFieldEnum = (typeof SystemConfigScalarFieldEnum)[keyof typeof SystemConfigScalarFieldEnum]


  export const ApiLogScalarFieldEnum: {
    id: 'id',
    endpoint: 'endpoint',
    method: 'method',
    statusCode: 'statusCode',
    responseTime: 'responseTime',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    userId: 'userId',
    errorMessage: 'errorMessage',
    requestData: 'requestData',
    responseData: 'responseData',
    timestamp: 'timestamp'
  };

  export type ApiLogScalarFieldEnum = (typeof ApiLogScalarFieldEnum)[keyof typeof ApiLogScalarFieldEnum]


  export const MarketStatusScalarFieldEnum: {
    id: 'id',
    exchange: 'exchange',
    isOpen: 'isOpen',
    openTime: 'openTime',
    closeTime: 'closeTime',
    timezone: 'timezone',
    holidays: 'holidays',
    lastUpdated: 'lastUpdated'
  };

  export type MarketStatusScalarFieldEnum = (typeof MarketStatusScalarFieldEnum)[keyof typeof MarketStatusScalarFieldEnum]


  export const CacheEntryScalarFieldEnum: {
    id: 'id',
    key: 'key',
    value: 'value',
    expiresAt: 'expiresAt',
    tags: 'tags',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CacheEntryScalarFieldEnum = (typeof CacheEntryScalarFieldEnum)[keyof typeof CacheEntryScalarFieldEnum]


  export const SyncLogScalarFieldEnum: {
    id: 'id',
    source: 'source',
    type: 'type',
    status: 'status',
    recordsProcessed: 'recordsProcessed',
    recordsSuccess: 'recordsSuccess',
    recordsError: 'recordsError',
    errorDetails: 'errorDetails',
    startedAt: 'startedAt',
    completedAt: 'completedAt',
    duration: 'duration',
    metadata: 'metadata'
  };

  export type SyncLogScalarFieldEnum = (typeof SyncLogScalarFieldEnum)[keyof typeof SyncLogScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'BigInt[]'
   */
  export type ListBigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    
  /**
   * Deep Input Types
   */


  export type IPOWhereInput = {
    AND?: IPOWhereInput | IPOWhereInput[]
    OR?: IPOWhereInput[]
    NOT?: IPOWhereInput | IPOWhereInput[]
    id?: StringFilter<"IPO"> | string
    symbol?: StringFilter<"IPO"> | string
    name?: StringFilter<"IPO"> | string
    companyId?: StringNullableFilter<"IPO"> | string | null
    status?: StringFilter<"IPO"> | string
    sector?: StringNullableFilter<"IPO"> | string | null
    industry?: StringNullableFilter<"IPO"> | string | null
    minPrice?: FloatFilter<"IPO"> | number
    maxPrice?: FloatFilter<"IPO"> | number
    finalPrice?: FloatNullableFilter<"IPO"> | number | null
    listingPrice?: FloatNullableFilter<"IPO"> | number | null
    currentPrice?: FloatNullableFilter<"IPO"> | number | null
    issueSize?: BigIntFilter<"IPO"> | bigint | number
    lotSize?: IntFilter<"IPO"> | number
    marketLot?: IntFilter<"IPO"> | number
    openDate?: DateTimeFilter<"IPO"> | Date | string
    closeDate?: DateTimeFilter<"IPO"> | Date | string
    listingDate?: DateTimeNullableFilter<"IPO"> | Date | string | null
    allotmentDate?: DateTimeNullableFilter<"IPO"> | Date | string | null
    refundDate?: DateTimeNullableFilter<"IPO"> | Date | string | null
    leadManager?: StringNullableFilter<"IPO"> | string | null
    registrar?: StringNullableFilter<"IPO"> | string | null
    faceValue?: FloatNullableFilter<"IPO"> | number | null
    bookValue?: FloatNullableFilter<"IPO"> | number | null
    marketCap?: BigIntNullableFilter<"IPO"> | bigint | number | null
    peRatio?: FloatNullableFilter<"IPO"> | number | null
    roe?: FloatNullableFilter<"IPO"> | number | null
    reservationDetails?: StringNullableFilter<"IPO"> | string | null
    aboutCompany?: StringNullableFilter<"IPO"> | string | null
    objectives?: StringNullableFilter<"IPO"> | string | null
    risks?: StringNullableFilter<"IPO"> | string | null
    isActive?: BoolFilter<"IPO"> | boolean
    createdAt?: DateTimeFilter<"IPO"> | Date | string
    updatedAt?: DateTimeFilter<"IPO"> | Date | string
    gmpData?: GMPListRelationFilter
    subscriptionData?: SubscriptionDataListRelationFilter
    allotmentData?: AllotmentDataListRelationFilter
    analytics?: IPOAnalyticsListRelationFilter
    watchlists?: UserWatchlistListRelationFilter
    alerts?: UserAlertListRelationFilter
  }

  export type IPOOrderByWithRelationInput = {
    id?: SortOrder
    symbol?: SortOrder
    name?: SortOrder
    companyId?: SortOrderInput | SortOrder
    status?: SortOrder
    sector?: SortOrderInput | SortOrder
    industry?: SortOrderInput | SortOrder
    minPrice?: SortOrder
    maxPrice?: SortOrder
    finalPrice?: SortOrderInput | SortOrder
    listingPrice?: SortOrderInput | SortOrder
    currentPrice?: SortOrderInput | SortOrder
    issueSize?: SortOrder
    lotSize?: SortOrder
    marketLot?: SortOrder
    openDate?: SortOrder
    closeDate?: SortOrder
    listingDate?: SortOrderInput | SortOrder
    allotmentDate?: SortOrderInput | SortOrder
    refundDate?: SortOrderInput | SortOrder
    leadManager?: SortOrderInput | SortOrder
    registrar?: SortOrderInput | SortOrder
    faceValue?: SortOrderInput | SortOrder
    bookValue?: SortOrderInput | SortOrder
    marketCap?: SortOrderInput | SortOrder
    peRatio?: SortOrderInput | SortOrder
    roe?: SortOrderInput | SortOrder
    reservationDetails?: SortOrderInput | SortOrder
    aboutCompany?: SortOrderInput | SortOrder
    objectives?: SortOrderInput | SortOrder
    risks?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    gmpData?: GMPOrderByRelationAggregateInput
    subscriptionData?: SubscriptionDataOrderByRelationAggregateInput
    allotmentData?: AllotmentDataOrderByRelationAggregateInput
    analytics?: IPOAnalyticsOrderByRelationAggregateInput
    watchlists?: UserWatchlistOrderByRelationAggregateInput
    alerts?: UserAlertOrderByRelationAggregateInput
  }

  export type IPOWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    symbol?: string
    AND?: IPOWhereInput | IPOWhereInput[]
    OR?: IPOWhereInput[]
    NOT?: IPOWhereInput | IPOWhereInput[]
    name?: StringFilter<"IPO"> | string
    companyId?: StringNullableFilter<"IPO"> | string | null
    status?: StringFilter<"IPO"> | string
    sector?: StringNullableFilter<"IPO"> | string | null
    industry?: StringNullableFilter<"IPO"> | string | null
    minPrice?: FloatFilter<"IPO"> | number
    maxPrice?: FloatFilter<"IPO"> | number
    finalPrice?: FloatNullableFilter<"IPO"> | number | null
    listingPrice?: FloatNullableFilter<"IPO"> | number | null
    currentPrice?: FloatNullableFilter<"IPO"> | number | null
    issueSize?: BigIntFilter<"IPO"> | bigint | number
    lotSize?: IntFilter<"IPO"> | number
    marketLot?: IntFilter<"IPO"> | number
    openDate?: DateTimeFilter<"IPO"> | Date | string
    closeDate?: DateTimeFilter<"IPO"> | Date | string
    listingDate?: DateTimeNullableFilter<"IPO"> | Date | string | null
    allotmentDate?: DateTimeNullableFilter<"IPO"> | Date | string | null
    refundDate?: DateTimeNullableFilter<"IPO"> | Date | string | null
    leadManager?: StringNullableFilter<"IPO"> | string | null
    registrar?: StringNullableFilter<"IPO"> | string | null
    faceValue?: FloatNullableFilter<"IPO"> | number | null
    bookValue?: FloatNullableFilter<"IPO"> | number | null
    marketCap?: BigIntNullableFilter<"IPO"> | bigint | number | null
    peRatio?: FloatNullableFilter<"IPO"> | number | null
    roe?: FloatNullableFilter<"IPO"> | number | null
    reservationDetails?: StringNullableFilter<"IPO"> | string | null
    aboutCompany?: StringNullableFilter<"IPO"> | string | null
    objectives?: StringNullableFilter<"IPO"> | string | null
    risks?: StringNullableFilter<"IPO"> | string | null
    isActive?: BoolFilter<"IPO"> | boolean
    createdAt?: DateTimeFilter<"IPO"> | Date | string
    updatedAt?: DateTimeFilter<"IPO"> | Date | string
    gmpData?: GMPListRelationFilter
    subscriptionData?: SubscriptionDataListRelationFilter
    allotmentData?: AllotmentDataListRelationFilter
    analytics?: IPOAnalyticsListRelationFilter
    watchlists?: UserWatchlistListRelationFilter
    alerts?: UserAlertListRelationFilter
  }, "id" | "symbol">

  export type IPOOrderByWithAggregationInput = {
    id?: SortOrder
    symbol?: SortOrder
    name?: SortOrder
    companyId?: SortOrderInput | SortOrder
    status?: SortOrder
    sector?: SortOrderInput | SortOrder
    industry?: SortOrderInput | SortOrder
    minPrice?: SortOrder
    maxPrice?: SortOrder
    finalPrice?: SortOrderInput | SortOrder
    listingPrice?: SortOrderInput | SortOrder
    currentPrice?: SortOrderInput | SortOrder
    issueSize?: SortOrder
    lotSize?: SortOrder
    marketLot?: SortOrder
    openDate?: SortOrder
    closeDate?: SortOrder
    listingDate?: SortOrderInput | SortOrder
    allotmentDate?: SortOrderInput | SortOrder
    refundDate?: SortOrderInput | SortOrder
    leadManager?: SortOrderInput | SortOrder
    registrar?: SortOrderInput | SortOrder
    faceValue?: SortOrderInput | SortOrder
    bookValue?: SortOrderInput | SortOrder
    marketCap?: SortOrderInput | SortOrder
    peRatio?: SortOrderInput | SortOrder
    roe?: SortOrderInput | SortOrder
    reservationDetails?: SortOrderInput | SortOrder
    aboutCompany?: SortOrderInput | SortOrder
    objectives?: SortOrderInput | SortOrder
    risks?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: IPOCountOrderByAggregateInput
    _avg?: IPOAvgOrderByAggregateInput
    _max?: IPOMaxOrderByAggregateInput
    _min?: IPOMinOrderByAggregateInput
    _sum?: IPOSumOrderByAggregateInput
  }

  export type IPOScalarWhereWithAggregatesInput = {
    AND?: IPOScalarWhereWithAggregatesInput | IPOScalarWhereWithAggregatesInput[]
    OR?: IPOScalarWhereWithAggregatesInput[]
    NOT?: IPOScalarWhereWithAggregatesInput | IPOScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"IPO"> | string
    symbol?: StringWithAggregatesFilter<"IPO"> | string
    name?: StringWithAggregatesFilter<"IPO"> | string
    companyId?: StringNullableWithAggregatesFilter<"IPO"> | string | null
    status?: StringWithAggregatesFilter<"IPO"> | string
    sector?: StringNullableWithAggregatesFilter<"IPO"> | string | null
    industry?: StringNullableWithAggregatesFilter<"IPO"> | string | null
    minPrice?: FloatWithAggregatesFilter<"IPO"> | number
    maxPrice?: FloatWithAggregatesFilter<"IPO"> | number
    finalPrice?: FloatNullableWithAggregatesFilter<"IPO"> | number | null
    listingPrice?: FloatNullableWithAggregatesFilter<"IPO"> | number | null
    currentPrice?: FloatNullableWithAggregatesFilter<"IPO"> | number | null
    issueSize?: BigIntWithAggregatesFilter<"IPO"> | bigint | number
    lotSize?: IntWithAggregatesFilter<"IPO"> | number
    marketLot?: IntWithAggregatesFilter<"IPO"> | number
    openDate?: DateTimeWithAggregatesFilter<"IPO"> | Date | string
    closeDate?: DateTimeWithAggregatesFilter<"IPO"> | Date | string
    listingDate?: DateTimeNullableWithAggregatesFilter<"IPO"> | Date | string | null
    allotmentDate?: DateTimeNullableWithAggregatesFilter<"IPO"> | Date | string | null
    refundDate?: DateTimeNullableWithAggregatesFilter<"IPO"> | Date | string | null
    leadManager?: StringNullableWithAggregatesFilter<"IPO"> | string | null
    registrar?: StringNullableWithAggregatesFilter<"IPO"> | string | null
    faceValue?: FloatNullableWithAggregatesFilter<"IPO"> | number | null
    bookValue?: FloatNullableWithAggregatesFilter<"IPO"> | number | null
    marketCap?: BigIntNullableWithAggregatesFilter<"IPO"> | bigint | number | null
    peRatio?: FloatNullableWithAggregatesFilter<"IPO"> | number | null
    roe?: FloatNullableWithAggregatesFilter<"IPO"> | number | null
    reservationDetails?: StringNullableWithAggregatesFilter<"IPO"> | string | null
    aboutCompany?: StringNullableWithAggregatesFilter<"IPO"> | string | null
    objectives?: StringNullableWithAggregatesFilter<"IPO"> | string | null
    risks?: StringNullableWithAggregatesFilter<"IPO"> | string | null
    isActive?: BoolWithAggregatesFilter<"IPO"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"IPO"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"IPO"> | Date | string
  }

  export type GMPWhereInput = {
    AND?: GMPWhereInput | GMPWhereInput[]
    OR?: GMPWhereInput[]
    NOT?: GMPWhereInput | GMPWhereInput[]
    id?: StringFilter<"GMP"> | string
    ipoId?: StringFilter<"GMP"> | string
    value?: FloatFilter<"GMP"> | number
    percentage?: FloatFilter<"GMP"> | number
    volume?: IntNullableFilter<"GMP"> | number | null
    bidPrice?: FloatNullableFilter<"GMP"> | number | null
    askPrice?: FloatNullableFilter<"GMP"> | number | null
    timestamp?: DateTimeFilter<"GMP"> | Date | string
    source?: StringFilter<"GMP"> | string
    metadata?: StringNullableFilter<"GMP"> | string | null
    createdAt?: DateTimeFilter<"GMP"> | Date | string
    updatedAt?: DateTimeFilter<"GMP"> | Date | string
    ipo?: XOR<IPORelationFilter, IPOWhereInput>
  }

  export type GMPOrderByWithRelationInput = {
    id?: SortOrder
    ipoId?: SortOrder
    value?: SortOrder
    percentage?: SortOrder
    volume?: SortOrderInput | SortOrder
    bidPrice?: SortOrderInput | SortOrder
    askPrice?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    source?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ipo?: IPOOrderByWithRelationInput
  }

  export type GMPWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: GMPWhereInput | GMPWhereInput[]
    OR?: GMPWhereInput[]
    NOT?: GMPWhereInput | GMPWhereInput[]
    ipoId?: StringFilter<"GMP"> | string
    value?: FloatFilter<"GMP"> | number
    percentage?: FloatFilter<"GMP"> | number
    volume?: IntNullableFilter<"GMP"> | number | null
    bidPrice?: FloatNullableFilter<"GMP"> | number | null
    askPrice?: FloatNullableFilter<"GMP"> | number | null
    timestamp?: DateTimeFilter<"GMP"> | Date | string
    source?: StringFilter<"GMP"> | string
    metadata?: StringNullableFilter<"GMP"> | string | null
    createdAt?: DateTimeFilter<"GMP"> | Date | string
    updatedAt?: DateTimeFilter<"GMP"> | Date | string
    ipo?: XOR<IPORelationFilter, IPOWhereInput>
  }, "id">

  export type GMPOrderByWithAggregationInput = {
    id?: SortOrder
    ipoId?: SortOrder
    value?: SortOrder
    percentage?: SortOrder
    volume?: SortOrderInput | SortOrder
    bidPrice?: SortOrderInput | SortOrder
    askPrice?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    source?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: GMPCountOrderByAggregateInput
    _avg?: GMPAvgOrderByAggregateInput
    _max?: GMPMaxOrderByAggregateInput
    _min?: GMPMinOrderByAggregateInput
    _sum?: GMPSumOrderByAggregateInput
  }

  export type GMPScalarWhereWithAggregatesInput = {
    AND?: GMPScalarWhereWithAggregatesInput | GMPScalarWhereWithAggregatesInput[]
    OR?: GMPScalarWhereWithAggregatesInput[]
    NOT?: GMPScalarWhereWithAggregatesInput | GMPScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GMP"> | string
    ipoId?: StringWithAggregatesFilter<"GMP"> | string
    value?: FloatWithAggregatesFilter<"GMP"> | number
    percentage?: FloatWithAggregatesFilter<"GMP"> | number
    volume?: IntNullableWithAggregatesFilter<"GMP"> | number | null
    bidPrice?: FloatNullableWithAggregatesFilter<"GMP"> | number | null
    askPrice?: FloatNullableWithAggregatesFilter<"GMP"> | number | null
    timestamp?: DateTimeWithAggregatesFilter<"GMP"> | Date | string
    source?: StringWithAggregatesFilter<"GMP"> | string
    metadata?: StringNullableWithAggregatesFilter<"GMP"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"GMP"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"GMP"> | Date | string
  }

  export type SubscriptionDataWhereInput = {
    AND?: SubscriptionDataWhereInput | SubscriptionDataWhereInput[]
    OR?: SubscriptionDataWhereInput[]
    NOT?: SubscriptionDataWhereInput | SubscriptionDataWhereInput[]
    id?: StringFilter<"SubscriptionData"> | string
    ipoId?: StringFilter<"SubscriptionData"> | string
    category?: StringFilter<"SubscriptionData"> | string
    subCategory?: StringNullableFilter<"SubscriptionData"> | string | null
    quantity?: BigIntFilter<"SubscriptionData"> | bigint | number
    bidCount?: IntFilter<"SubscriptionData"> | number
    subscriptionRatio?: FloatFilter<"SubscriptionData"> | number
    timestamp?: DateTimeFilter<"SubscriptionData"> | Date | string
    metadata?: StringNullableFilter<"SubscriptionData"> | string | null
    createdAt?: DateTimeFilter<"SubscriptionData"> | Date | string
    updatedAt?: DateTimeFilter<"SubscriptionData"> | Date | string
    ipo?: XOR<IPORelationFilter, IPOWhereInput>
  }

  export type SubscriptionDataOrderByWithRelationInput = {
    id?: SortOrder
    ipoId?: SortOrder
    category?: SortOrder
    subCategory?: SortOrderInput | SortOrder
    quantity?: SortOrder
    bidCount?: SortOrder
    subscriptionRatio?: SortOrder
    timestamp?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ipo?: IPOOrderByWithRelationInput
  }

  export type SubscriptionDataWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SubscriptionDataWhereInput | SubscriptionDataWhereInput[]
    OR?: SubscriptionDataWhereInput[]
    NOT?: SubscriptionDataWhereInput | SubscriptionDataWhereInput[]
    ipoId?: StringFilter<"SubscriptionData"> | string
    category?: StringFilter<"SubscriptionData"> | string
    subCategory?: StringNullableFilter<"SubscriptionData"> | string | null
    quantity?: BigIntFilter<"SubscriptionData"> | bigint | number
    bidCount?: IntFilter<"SubscriptionData"> | number
    subscriptionRatio?: FloatFilter<"SubscriptionData"> | number
    timestamp?: DateTimeFilter<"SubscriptionData"> | Date | string
    metadata?: StringNullableFilter<"SubscriptionData"> | string | null
    createdAt?: DateTimeFilter<"SubscriptionData"> | Date | string
    updatedAt?: DateTimeFilter<"SubscriptionData"> | Date | string
    ipo?: XOR<IPORelationFilter, IPOWhereInput>
  }, "id">

  export type SubscriptionDataOrderByWithAggregationInput = {
    id?: SortOrder
    ipoId?: SortOrder
    category?: SortOrder
    subCategory?: SortOrderInput | SortOrder
    quantity?: SortOrder
    bidCount?: SortOrder
    subscriptionRatio?: SortOrder
    timestamp?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SubscriptionDataCountOrderByAggregateInput
    _avg?: SubscriptionDataAvgOrderByAggregateInput
    _max?: SubscriptionDataMaxOrderByAggregateInput
    _min?: SubscriptionDataMinOrderByAggregateInput
    _sum?: SubscriptionDataSumOrderByAggregateInput
  }

  export type SubscriptionDataScalarWhereWithAggregatesInput = {
    AND?: SubscriptionDataScalarWhereWithAggregatesInput | SubscriptionDataScalarWhereWithAggregatesInput[]
    OR?: SubscriptionDataScalarWhereWithAggregatesInput[]
    NOT?: SubscriptionDataScalarWhereWithAggregatesInput | SubscriptionDataScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SubscriptionData"> | string
    ipoId?: StringWithAggregatesFilter<"SubscriptionData"> | string
    category?: StringWithAggregatesFilter<"SubscriptionData"> | string
    subCategory?: StringNullableWithAggregatesFilter<"SubscriptionData"> | string | null
    quantity?: BigIntWithAggregatesFilter<"SubscriptionData"> | bigint | number
    bidCount?: IntWithAggregatesFilter<"SubscriptionData"> | number
    subscriptionRatio?: FloatWithAggregatesFilter<"SubscriptionData"> | number
    timestamp?: DateTimeWithAggregatesFilter<"SubscriptionData"> | Date | string
    metadata?: StringNullableWithAggregatesFilter<"SubscriptionData"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SubscriptionData"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SubscriptionData"> | Date | string
  }

  export type AllotmentDataWhereInput = {
    AND?: AllotmentDataWhereInput | AllotmentDataWhereInput[]
    OR?: AllotmentDataWhereInput[]
    NOT?: AllotmentDataWhereInput | AllotmentDataWhereInput[]
    id?: StringFilter<"AllotmentData"> | string
    ipoId?: StringFilter<"AllotmentData"> | string
    pan?: StringFilter<"AllotmentData"> | string
    applicationNumber?: StringNullableFilter<"AllotmentData"> | string | null
    category?: StringFilter<"AllotmentData"> | string
    appliedQuantity?: IntFilter<"AllotmentData"> | number
    allottedQuantity?: IntFilter<"AllotmentData"> | number
    allottedAmount?: FloatFilter<"AllotmentData"> | number
    refundAmount?: FloatFilter<"AllotmentData"> | number
    allotmentStatus?: StringFilter<"AllotmentData"> | string
    timestamp?: DateTimeFilter<"AllotmentData"> | Date | string
    createdAt?: DateTimeFilter<"AllotmentData"> | Date | string
    updatedAt?: DateTimeFilter<"AllotmentData"> | Date | string
    ipo?: XOR<IPORelationFilter, IPOWhereInput>
  }

  export type AllotmentDataOrderByWithRelationInput = {
    id?: SortOrder
    ipoId?: SortOrder
    pan?: SortOrder
    applicationNumber?: SortOrderInput | SortOrder
    category?: SortOrder
    appliedQuantity?: SortOrder
    allottedQuantity?: SortOrder
    allottedAmount?: SortOrder
    refundAmount?: SortOrder
    allotmentStatus?: SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ipo?: IPOOrderByWithRelationInput
  }

  export type AllotmentDataWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AllotmentDataWhereInput | AllotmentDataWhereInput[]
    OR?: AllotmentDataWhereInput[]
    NOT?: AllotmentDataWhereInput | AllotmentDataWhereInput[]
    ipoId?: StringFilter<"AllotmentData"> | string
    pan?: StringFilter<"AllotmentData"> | string
    applicationNumber?: StringNullableFilter<"AllotmentData"> | string | null
    category?: StringFilter<"AllotmentData"> | string
    appliedQuantity?: IntFilter<"AllotmentData"> | number
    allottedQuantity?: IntFilter<"AllotmentData"> | number
    allottedAmount?: FloatFilter<"AllotmentData"> | number
    refundAmount?: FloatFilter<"AllotmentData"> | number
    allotmentStatus?: StringFilter<"AllotmentData"> | string
    timestamp?: DateTimeFilter<"AllotmentData"> | Date | string
    createdAt?: DateTimeFilter<"AllotmentData"> | Date | string
    updatedAt?: DateTimeFilter<"AllotmentData"> | Date | string
    ipo?: XOR<IPORelationFilter, IPOWhereInput>
  }, "id">

  export type AllotmentDataOrderByWithAggregationInput = {
    id?: SortOrder
    ipoId?: SortOrder
    pan?: SortOrder
    applicationNumber?: SortOrderInput | SortOrder
    category?: SortOrder
    appliedQuantity?: SortOrder
    allottedQuantity?: SortOrder
    allottedAmount?: SortOrder
    refundAmount?: SortOrder
    allotmentStatus?: SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AllotmentDataCountOrderByAggregateInput
    _avg?: AllotmentDataAvgOrderByAggregateInput
    _max?: AllotmentDataMaxOrderByAggregateInput
    _min?: AllotmentDataMinOrderByAggregateInput
    _sum?: AllotmentDataSumOrderByAggregateInput
  }

  export type AllotmentDataScalarWhereWithAggregatesInput = {
    AND?: AllotmentDataScalarWhereWithAggregatesInput | AllotmentDataScalarWhereWithAggregatesInput[]
    OR?: AllotmentDataScalarWhereWithAggregatesInput[]
    NOT?: AllotmentDataScalarWhereWithAggregatesInput | AllotmentDataScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AllotmentData"> | string
    ipoId?: StringWithAggregatesFilter<"AllotmentData"> | string
    pan?: StringWithAggregatesFilter<"AllotmentData"> | string
    applicationNumber?: StringNullableWithAggregatesFilter<"AllotmentData"> | string | null
    category?: StringWithAggregatesFilter<"AllotmentData"> | string
    appliedQuantity?: IntWithAggregatesFilter<"AllotmentData"> | number
    allottedQuantity?: IntWithAggregatesFilter<"AllotmentData"> | number
    allottedAmount?: FloatWithAggregatesFilter<"AllotmentData"> | number
    refundAmount?: FloatWithAggregatesFilter<"AllotmentData"> | number
    allotmentStatus?: StringWithAggregatesFilter<"AllotmentData"> | string
    timestamp?: DateTimeWithAggregatesFilter<"AllotmentData"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"AllotmentData"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AllotmentData"> | Date | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    pan?: StringNullableFilter<"User"> | string | null
    role?: StringFilter<"User"> | string
    isActive?: BoolFilter<"User"> | boolean
    isEmailVerified?: BoolFilter<"User"> | boolean
    kycCompleted?: BoolFilter<"User"> | boolean
    preferences?: StringNullableFilter<"User"> | string | null
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    watchlists?: UserWatchlistListRelationFilter
    alerts?: UserAlertListRelationFilter
    sessions?: SessionListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    pan?: SortOrderInput | SortOrder
    role?: SortOrder
    isActive?: SortOrder
    isEmailVerified?: SortOrder
    kycCompleted?: SortOrder
    preferences?: SortOrderInput | SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    watchlists?: UserWatchlistOrderByRelationAggregateInput
    alerts?: UserAlertOrderByRelationAggregateInput
    sessions?: SessionOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    pan?: StringNullableFilter<"User"> | string | null
    role?: StringFilter<"User"> | string
    isActive?: BoolFilter<"User"> | boolean
    isEmailVerified?: BoolFilter<"User"> | boolean
    kycCompleted?: BoolFilter<"User"> | boolean
    preferences?: StringNullableFilter<"User"> | string | null
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    watchlists?: UserWatchlistListRelationFilter
    alerts?: UserAlertListRelationFilter
    sessions?: SessionListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    pan?: SortOrderInput | SortOrder
    role?: SortOrder
    isActive?: SortOrder
    isEmailVerified?: SortOrder
    kycCompleted?: SortOrder
    preferences?: SortOrderInput | SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null
    pan?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: StringWithAggregatesFilter<"User"> | string
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    isEmailVerified?: BoolWithAggregatesFilter<"User"> | boolean
    kycCompleted?: BoolWithAggregatesFilter<"User"> | boolean
    preferences?: StringNullableWithAggregatesFilter<"User"> | string | null
    lastLoginAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    token?: StringFilter<"Session"> | string
    refreshToken?: StringFilter<"Session"> | string
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    isActive?: BoolFilter<"Session"> | boolean
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    refreshToken?: SortOrder
    expiresAt?: SortOrder
    isActive?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    refreshToken?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    userId?: StringFilter<"Session"> | string
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    isActive?: BoolFilter<"Session"> | boolean
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "token" | "refreshToken">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    refreshToken?: SortOrder
    expiresAt?: SortOrder
    isActive?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Session"> | string
    userId?: StringWithAggregatesFilter<"Session"> | string
    token?: StringWithAggregatesFilter<"Session"> | string
    refreshToken?: StringWithAggregatesFilter<"Session"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    isActive?: BoolWithAggregatesFilter<"Session"> | boolean
    ipAddress?: StringNullableWithAggregatesFilter<"Session"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"Session"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
  }

  export type IPOAnalyticsWhereInput = {
    AND?: IPOAnalyticsWhereInput | IPOAnalyticsWhereInput[]
    OR?: IPOAnalyticsWhereInput[]
    NOT?: IPOAnalyticsWhereInput | IPOAnalyticsWhereInput[]
    id?: StringFilter<"IPOAnalytics"> | string
    ipoId?: StringFilter<"IPOAnalytics"> | string
    symbol?: StringNullableFilter<"IPOAnalytics"> | string | null
    date?: DateTimeFilter<"IPOAnalytics"> | Date | string
    avgGMP?: FloatNullableFilter<"IPOAnalytics"> | number | null
    maxGMP?: FloatNullableFilter<"IPOAnalytics"> | number | null
    minGMP?: FloatNullableFilter<"IPOAnalytics"> | number | null
    gmpVolume?: IntNullableFilter<"IPOAnalytics"> | number | null
    gmpTrend?: StringNullableFilter<"IPOAnalytics"> | string | null
    overallSubscription?: FloatNullableFilter<"IPOAnalytics"> | number | null
    retailSubscription?: FloatNullableFilter<"IPOAnalytics"> | number | null
    qibSubscription?: FloatNullableFilter<"IPOAnalytics"> | number | null
    hniSubscription?: FloatNullableFilter<"IPOAnalytics"> | number | null
    marketSentiment?: StringNullableFilter<"IPOAnalytics"> | string | null
    sentimentScore?: FloatNullableFilter<"IPOAnalytics"> | number | null
    listingGain?: FloatNullableFilter<"IPOAnalytics"> | number | null
    currentReturn?: FloatNullableFilter<"IPOAnalytics"> | number | null
    volatilityIndex?: FloatNullableFilter<"IPOAnalytics"> | number | null
    totalGMPChanges?: IntFilter<"IPOAnalytics"> | number
    totalSubscriptions?: IntFilter<"IPOAnalytics"> | number
    oversubscribedCount?: IntFilter<"IPOAnalytics"> | number
    createdAt?: DateTimeFilter<"IPOAnalytics"> | Date | string
    updatedAt?: DateTimeFilter<"IPOAnalytics"> | Date | string
    ipo?: XOR<IPORelationFilter, IPOWhereInput>
  }

  export type IPOAnalyticsOrderByWithRelationInput = {
    id?: SortOrder
    ipoId?: SortOrder
    symbol?: SortOrderInput | SortOrder
    date?: SortOrder
    avgGMP?: SortOrderInput | SortOrder
    maxGMP?: SortOrderInput | SortOrder
    minGMP?: SortOrderInput | SortOrder
    gmpVolume?: SortOrderInput | SortOrder
    gmpTrend?: SortOrderInput | SortOrder
    overallSubscription?: SortOrderInput | SortOrder
    retailSubscription?: SortOrderInput | SortOrder
    qibSubscription?: SortOrderInput | SortOrder
    hniSubscription?: SortOrderInput | SortOrder
    marketSentiment?: SortOrderInput | SortOrder
    sentimentScore?: SortOrderInput | SortOrder
    listingGain?: SortOrderInput | SortOrder
    currentReturn?: SortOrderInput | SortOrder
    volatilityIndex?: SortOrderInput | SortOrder
    totalGMPChanges?: SortOrder
    totalSubscriptions?: SortOrder
    oversubscribedCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ipo?: IPOOrderByWithRelationInput
  }

  export type IPOAnalyticsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: IPOAnalyticsWhereInput | IPOAnalyticsWhereInput[]
    OR?: IPOAnalyticsWhereInput[]
    NOT?: IPOAnalyticsWhereInput | IPOAnalyticsWhereInput[]
    ipoId?: StringFilter<"IPOAnalytics"> | string
    symbol?: StringNullableFilter<"IPOAnalytics"> | string | null
    date?: DateTimeFilter<"IPOAnalytics"> | Date | string
    avgGMP?: FloatNullableFilter<"IPOAnalytics"> | number | null
    maxGMP?: FloatNullableFilter<"IPOAnalytics"> | number | null
    minGMP?: FloatNullableFilter<"IPOAnalytics"> | number | null
    gmpVolume?: IntNullableFilter<"IPOAnalytics"> | number | null
    gmpTrend?: StringNullableFilter<"IPOAnalytics"> | string | null
    overallSubscription?: FloatNullableFilter<"IPOAnalytics"> | number | null
    retailSubscription?: FloatNullableFilter<"IPOAnalytics"> | number | null
    qibSubscription?: FloatNullableFilter<"IPOAnalytics"> | number | null
    hniSubscription?: FloatNullableFilter<"IPOAnalytics"> | number | null
    marketSentiment?: StringNullableFilter<"IPOAnalytics"> | string | null
    sentimentScore?: FloatNullableFilter<"IPOAnalytics"> | number | null
    listingGain?: FloatNullableFilter<"IPOAnalytics"> | number | null
    currentReturn?: FloatNullableFilter<"IPOAnalytics"> | number | null
    volatilityIndex?: FloatNullableFilter<"IPOAnalytics"> | number | null
    totalGMPChanges?: IntFilter<"IPOAnalytics"> | number
    totalSubscriptions?: IntFilter<"IPOAnalytics"> | number
    oversubscribedCount?: IntFilter<"IPOAnalytics"> | number
    createdAt?: DateTimeFilter<"IPOAnalytics"> | Date | string
    updatedAt?: DateTimeFilter<"IPOAnalytics"> | Date | string
    ipo?: XOR<IPORelationFilter, IPOWhereInput>
  }, "id">

  export type IPOAnalyticsOrderByWithAggregationInput = {
    id?: SortOrder
    ipoId?: SortOrder
    symbol?: SortOrderInput | SortOrder
    date?: SortOrder
    avgGMP?: SortOrderInput | SortOrder
    maxGMP?: SortOrderInput | SortOrder
    minGMP?: SortOrderInput | SortOrder
    gmpVolume?: SortOrderInput | SortOrder
    gmpTrend?: SortOrderInput | SortOrder
    overallSubscription?: SortOrderInput | SortOrder
    retailSubscription?: SortOrderInput | SortOrder
    qibSubscription?: SortOrderInput | SortOrder
    hniSubscription?: SortOrderInput | SortOrder
    marketSentiment?: SortOrderInput | SortOrder
    sentimentScore?: SortOrderInput | SortOrder
    listingGain?: SortOrderInput | SortOrder
    currentReturn?: SortOrderInput | SortOrder
    volatilityIndex?: SortOrderInput | SortOrder
    totalGMPChanges?: SortOrder
    totalSubscriptions?: SortOrder
    oversubscribedCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: IPOAnalyticsCountOrderByAggregateInput
    _avg?: IPOAnalyticsAvgOrderByAggregateInput
    _max?: IPOAnalyticsMaxOrderByAggregateInput
    _min?: IPOAnalyticsMinOrderByAggregateInput
    _sum?: IPOAnalyticsSumOrderByAggregateInput
  }

  export type IPOAnalyticsScalarWhereWithAggregatesInput = {
    AND?: IPOAnalyticsScalarWhereWithAggregatesInput | IPOAnalyticsScalarWhereWithAggregatesInput[]
    OR?: IPOAnalyticsScalarWhereWithAggregatesInput[]
    NOT?: IPOAnalyticsScalarWhereWithAggregatesInput | IPOAnalyticsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"IPOAnalytics"> | string
    ipoId?: StringWithAggregatesFilter<"IPOAnalytics"> | string
    symbol?: StringNullableWithAggregatesFilter<"IPOAnalytics"> | string | null
    date?: DateTimeWithAggregatesFilter<"IPOAnalytics"> | Date | string
    avgGMP?: FloatNullableWithAggregatesFilter<"IPOAnalytics"> | number | null
    maxGMP?: FloatNullableWithAggregatesFilter<"IPOAnalytics"> | number | null
    minGMP?: FloatNullableWithAggregatesFilter<"IPOAnalytics"> | number | null
    gmpVolume?: IntNullableWithAggregatesFilter<"IPOAnalytics"> | number | null
    gmpTrend?: StringNullableWithAggregatesFilter<"IPOAnalytics"> | string | null
    overallSubscription?: FloatNullableWithAggregatesFilter<"IPOAnalytics"> | number | null
    retailSubscription?: FloatNullableWithAggregatesFilter<"IPOAnalytics"> | number | null
    qibSubscription?: FloatNullableWithAggregatesFilter<"IPOAnalytics"> | number | null
    hniSubscription?: FloatNullableWithAggregatesFilter<"IPOAnalytics"> | number | null
    marketSentiment?: StringNullableWithAggregatesFilter<"IPOAnalytics"> | string | null
    sentimentScore?: FloatNullableWithAggregatesFilter<"IPOAnalytics"> | number | null
    listingGain?: FloatNullableWithAggregatesFilter<"IPOAnalytics"> | number | null
    currentReturn?: FloatNullableWithAggregatesFilter<"IPOAnalytics"> | number | null
    volatilityIndex?: FloatNullableWithAggregatesFilter<"IPOAnalytics"> | number | null
    totalGMPChanges?: IntWithAggregatesFilter<"IPOAnalytics"> | number
    totalSubscriptions?: IntWithAggregatesFilter<"IPOAnalytics"> | number
    oversubscribedCount?: IntWithAggregatesFilter<"IPOAnalytics"> | number
    createdAt?: DateTimeWithAggregatesFilter<"IPOAnalytics"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"IPOAnalytics"> | Date | string
  }

  export type UserWatchlistWhereInput = {
    AND?: UserWatchlistWhereInput | UserWatchlistWhereInput[]
    OR?: UserWatchlistWhereInput[]
    NOT?: UserWatchlistWhereInput | UserWatchlistWhereInput[]
    id?: StringFilter<"UserWatchlist"> | string
    userId?: StringFilter<"UserWatchlist"> | string
    ipoId?: StringFilter<"UserWatchlist"> | string
    notes?: StringNullableFilter<"UserWatchlist"> | string | null
    alertPreferences?: StringNullableFilter<"UserWatchlist"> | string | null
    addedAt?: DateTimeFilter<"UserWatchlist"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    ipo?: XOR<IPORelationFilter, IPOWhereInput>
  }

  export type UserWatchlistOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    ipoId?: SortOrder
    notes?: SortOrderInput | SortOrder
    alertPreferences?: SortOrderInput | SortOrder
    addedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    ipo?: IPOOrderByWithRelationInput
  }

  export type UserWatchlistWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_ipoId?: UserWatchlistUserIdIpoIdCompoundUniqueInput
    AND?: UserWatchlistWhereInput | UserWatchlistWhereInput[]
    OR?: UserWatchlistWhereInput[]
    NOT?: UserWatchlistWhereInput | UserWatchlistWhereInput[]
    userId?: StringFilter<"UserWatchlist"> | string
    ipoId?: StringFilter<"UserWatchlist"> | string
    notes?: StringNullableFilter<"UserWatchlist"> | string | null
    alertPreferences?: StringNullableFilter<"UserWatchlist"> | string | null
    addedAt?: DateTimeFilter<"UserWatchlist"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    ipo?: XOR<IPORelationFilter, IPOWhereInput>
  }, "id" | "userId_ipoId">

  export type UserWatchlistOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    ipoId?: SortOrder
    notes?: SortOrderInput | SortOrder
    alertPreferences?: SortOrderInput | SortOrder
    addedAt?: SortOrder
    _count?: UserWatchlistCountOrderByAggregateInput
    _max?: UserWatchlistMaxOrderByAggregateInput
    _min?: UserWatchlistMinOrderByAggregateInput
  }

  export type UserWatchlistScalarWhereWithAggregatesInput = {
    AND?: UserWatchlistScalarWhereWithAggregatesInput | UserWatchlistScalarWhereWithAggregatesInput[]
    OR?: UserWatchlistScalarWhereWithAggregatesInput[]
    NOT?: UserWatchlistScalarWhereWithAggregatesInput | UserWatchlistScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserWatchlist"> | string
    userId?: StringWithAggregatesFilter<"UserWatchlist"> | string
    ipoId?: StringWithAggregatesFilter<"UserWatchlist"> | string
    notes?: StringNullableWithAggregatesFilter<"UserWatchlist"> | string | null
    alertPreferences?: StringNullableWithAggregatesFilter<"UserWatchlist"> | string | null
    addedAt?: DateTimeWithAggregatesFilter<"UserWatchlist"> | Date | string
  }

  export type UserAlertWhereInput = {
    AND?: UserAlertWhereInput | UserAlertWhereInput[]
    OR?: UserAlertWhereInput[]
    NOT?: UserAlertWhereInput | UserAlertWhereInput[]
    id?: StringFilter<"UserAlert"> | string
    userId?: StringFilter<"UserAlert"> | string
    ipoId?: StringNullableFilter<"UserAlert"> | string | null
    symbol?: StringNullableFilter<"UserAlert"> | string | null
    alertType?: StringFilter<"UserAlert"> | string
    triggerType?: StringFilter<"UserAlert"> | string
    triggerValue?: FloatNullableFilter<"UserAlert"> | number | null
    triggerCondition?: StringNullableFilter<"UserAlert"> | string | null
    message?: StringNullableFilter<"UserAlert"> | string | null
    isActive?: BoolFilter<"UserAlert"> | boolean
    lastTriggered?: DateTimeNullableFilter<"UserAlert"> | Date | string | null
    triggerCount?: IntFilter<"UserAlert"> | number
    createdAt?: DateTimeFilter<"UserAlert"> | Date | string
    updatedAt?: DateTimeFilter<"UserAlert"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    ipo?: XOR<IPONullableRelationFilter, IPOWhereInput> | null
  }

  export type UserAlertOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    ipoId?: SortOrderInput | SortOrder
    symbol?: SortOrderInput | SortOrder
    alertType?: SortOrder
    triggerType?: SortOrder
    triggerValue?: SortOrderInput | SortOrder
    triggerCondition?: SortOrderInput | SortOrder
    message?: SortOrderInput | SortOrder
    isActive?: SortOrder
    lastTriggered?: SortOrderInput | SortOrder
    triggerCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    ipo?: IPOOrderByWithRelationInput
  }

  export type UserAlertWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UserAlertWhereInput | UserAlertWhereInput[]
    OR?: UserAlertWhereInput[]
    NOT?: UserAlertWhereInput | UserAlertWhereInput[]
    userId?: StringFilter<"UserAlert"> | string
    ipoId?: StringNullableFilter<"UserAlert"> | string | null
    symbol?: StringNullableFilter<"UserAlert"> | string | null
    alertType?: StringFilter<"UserAlert"> | string
    triggerType?: StringFilter<"UserAlert"> | string
    triggerValue?: FloatNullableFilter<"UserAlert"> | number | null
    triggerCondition?: StringNullableFilter<"UserAlert"> | string | null
    message?: StringNullableFilter<"UserAlert"> | string | null
    isActive?: BoolFilter<"UserAlert"> | boolean
    lastTriggered?: DateTimeNullableFilter<"UserAlert"> | Date | string | null
    triggerCount?: IntFilter<"UserAlert"> | number
    createdAt?: DateTimeFilter<"UserAlert"> | Date | string
    updatedAt?: DateTimeFilter<"UserAlert"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    ipo?: XOR<IPONullableRelationFilter, IPOWhereInput> | null
  }, "id">

  export type UserAlertOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    ipoId?: SortOrderInput | SortOrder
    symbol?: SortOrderInput | SortOrder
    alertType?: SortOrder
    triggerType?: SortOrder
    triggerValue?: SortOrderInput | SortOrder
    triggerCondition?: SortOrderInput | SortOrder
    message?: SortOrderInput | SortOrder
    isActive?: SortOrder
    lastTriggered?: SortOrderInput | SortOrder
    triggerCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserAlertCountOrderByAggregateInput
    _avg?: UserAlertAvgOrderByAggregateInput
    _max?: UserAlertMaxOrderByAggregateInput
    _min?: UserAlertMinOrderByAggregateInput
    _sum?: UserAlertSumOrderByAggregateInput
  }

  export type UserAlertScalarWhereWithAggregatesInput = {
    AND?: UserAlertScalarWhereWithAggregatesInput | UserAlertScalarWhereWithAggregatesInput[]
    OR?: UserAlertScalarWhereWithAggregatesInput[]
    NOT?: UserAlertScalarWhereWithAggregatesInput | UserAlertScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserAlert"> | string
    userId?: StringWithAggregatesFilter<"UserAlert"> | string
    ipoId?: StringNullableWithAggregatesFilter<"UserAlert"> | string | null
    symbol?: StringNullableWithAggregatesFilter<"UserAlert"> | string | null
    alertType?: StringWithAggregatesFilter<"UserAlert"> | string
    triggerType?: StringWithAggregatesFilter<"UserAlert"> | string
    triggerValue?: FloatNullableWithAggregatesFilter<"UserAlert"> | number | null
    triggerCondition?: StringNullableWithAggregatesFilter<"UserAlert"> | string | null
    message?: StringNullableWithAggregatesFilter<"UserAlert"> | string | null
    isActive?: BoolWithAggregatesFilter<"UserAlert"> | boolean
    lastTriggered?: DateTimeNullableWithAggregatesFilter<"UserAlert"> | Date | string | null
    triggerCount?: IntWithAggregatesFilter<"UserAlert"> | number
    createdAt?: DateTimeWithAggregatesFilter<"UserAlert"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserAlert"> | Date | string
  }

  export type SystemConfigWhereInput = {
    AND?: SystemConfigWhereInput | SystemConfigWhereInput[]
    OR?: SystemConfigWhereInput[]
    NOT?: SystemConfigWhereInput | SystemConfigWhereInput[]
    id?: StringFilter<"SystemConfig"> | string
    key?: StringFilter<"SystemConfig"> | string
    value?: StringFilter<"SystemConfig"> | string
    description?: StringNullableFilter<"SystemConfig"> | string | null
    category?: StringNullableFilter<"SystemConfig"> | string | null
    isActive?: BoolFilter<"SystemConfig"> | boolean
    createdAt?: DateTimeFilter<"SystemConfig"> | Date | string
    updatedAt?: DateTimeFilter<"SystemConfig"> | Date | string
  }

  export type SystemConfigOrderByWithRelationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemConfigWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    key?: string
    AND?: SystemConfigWhereInput | SystemConfigWhereInput[]
    OR?: SystemConfigWhereInput[]
    NOT?: SystemConfigWhereInput | SystemConfigWhereInput[]
    value?: StringFilter<"SystemConfig"> | string
    description?: StringNullableFilter<"SystemConfig"> | string | null
    category?: StringNullableFilter<"SystemConfig"> | string | null
    isActive?: BoolFilter<"SystemConfig"> | boolean
    createdAt?: DateTimeFilter<"SystemConfig"> | Date | string
    updatedAt?: DateTimeFilter<"SystemConfig"> | Date | string
  }, "id" | "key">

  export type SystemConfigOrderByWithAggregationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SystemConfigCountOrderByAggregateInput
    _max?: SystemConfigMaxOrderByAggregateInput
    _min?: SystemConfigMinOrderByAggregateInput
  }

  export type SystemConfigScalarWhereWithAggregatesInput = {
    AND?: SystemConfigScalarWhereWithAggregatesInput | SystemConfigScalarWhereWithAggregatesInput[]
    OR?: SystemConfigScalarWhereWithAggregatesInput[]
    NOT?: SystemConfigScalarWhereWithAggregatesInput | SystemConfigScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SystemConfig"> | string
    key?: StringWithAggregatesFilter<"SystemConfig"> | string
    value?: StringWithAggregatesFilter<"SystemConfig"> | string
    description?: StringNullableWithAggregatesFilter<"SystemConfig"> | string | null
    category?: StringNullableWithAggregatesFilter<"SystemConfig"> | string | null
    isActive?: BoolWithAggregatesFilter<"SystemConfig"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"SystemConfig"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SystemConfig"> | Date | string
  }

  export type ApiLogWhereInput = {
    AND?: ApiLogWhereInput | ApiLogWhereInput[]
    OR?: ApiLogWhereInput[]
    NOT?: ApiLogWhereInput | ApiLogWhereInput[]
    id?: StringFilter<"ApiLog"> | string
    endpoint?: StringFilter<"ApiLog"> | string
    method?: StringFilter<"ApiLog"> | string
    statusCode?: IntFilter<"ApiLog"> | number
    responseTime?: IntFilter<"ApiLog"> | number
    ipAddress?: StringNullableFilter<"ApiLog"> | string | null
    userAgent?: StringNullableFilter<"ApiLog"> | string | null
    userId?: StringNullableFilter<"ApiLog"> | string | null
    errorMessage?: StringNullableFilter<"ApiLog"> | string | null
    requestData?: StringNullableFilter<"ApiLog"> | string | null
    responseData?: StringNullableFilter<"ApiLog"> | string | null
    timestamp?: DateTimeFilter<"ApiLog"> | Date | string
  }

  export type ApiLogOrderByWithRelationInput = {
    id?: SortOrder
    endpoint?: SortOrder
    method?: SortOrder
    statusCode?: SortOrder
    responseTime?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    requestData?: SortOrderInput | SortOrder
    responseData?: SortOrderInput | SortOrder
    timestamp?: SortOrder
  }

  export type ApiLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ApiLogWhereInput | ApiLogWhereInput[]
    OR?: ApiLogWhereInput[]
    NOT?: ApiLogWhereInput | ApiLogWhereInput[]
    endpoint?: StringFilter<"ApiLog"> | string
    method?: StringFilter<"ApiLog"> | string
    statusCode?: IntFilter<"ApiLog"> | number
    responseTime?: IntFilter<"ApiLog"> | number
    ipAddress?: StringNullableFilter<"ApiLog"> | string | null
    userAgent?: StringNullableFilter<"ApiLog"> | string | null
    userId?: StringNullableFilter<"ApiLog"> | string | null
    errorMessage?: StringNullableFilter<"ApiLog"> | string | null
    requestData?: StringNullableFilter<"ApiLog"> | string | null
    responseData?: StringNullableFilter<"ApiLog"> | string | null
    timestamp?: DateTimeFilter<"ApiLog"> | Date | string
  }, "id">

  export type ApiLogOrderByWithAggregationInput = {
    id?: SortOrder
    endpoint?: SortOrder
    method?: SortOrder
    statusCode?: SortOrder
    responseTime?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    requestData?: SortOrderInput | SortOrder
    responseData?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    _count?: ApiLogCountOrderByAggregateInput
    _avg?: ApiLogAvgOrderByAggregateInput
    _max?: ApiLogMaxOrderByAggregateInput
    _min?: ApiLogMinOrderByAggregateInput
    _sum?: ApiLogSumOrderByAggregateInput
  }

  export type ApiLogScalarWhereWithAggregatesInput = {
    AND?: ApiLogScalarWhereWithAggregatesInput | ApiLogScalarWhereWithAggregatesInput[]
    OR?: ApiLogScalarWhereWithAggregatesInput[]
    NOT?: ApiLogScalarWhereWithAggregatesInput | ApiLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ApiLog"> | string
    endpoint?: StringWithAggregatesFilter<"ApiLog"> | string
    method?: StringWithAggregatesFilter<"ApiLog"> | string
    statusCode?: IntWithAggregatesFilter<"ApiLog"> | number
    responseTime?: IntWithAggregatesFilter<"ApiLog"> | number
    ipAddress?: StringNullableWithAggregatesFilter<"ApiLog"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"ApiLog"> | string | null
    userId?: StringNullableWithAggregatesFilter<"ApiLog"> | string | null
    errorMessage?: StringNullableWithAggregatesFilter<"ApiLog"> | string | null
    requestData?: StringNullableWithAggregatesFilter<"ApiLog"> | string | null
    responseData?: StringNullableWithAggregatesFilter<"ApiLog"> | string | null
    timestamp?: DateTimeWithAggregatesFilter<"ApiLog"> | Date | string
  }

  export type MarketStatusWhereInput = {
    AND?: MarketStatusWhereInput | MarketStatusWhereInput[]
    OR?: MarketStatusWhereInput[]
    NOT?: MarketStatusWhereInput | MarketStatusWhereInput[]
    id?: StringFilter<"MarketStatus"> | string
    exchange?: StringFilter<"MarketStatus"> | string
    isOpen?: BoolFilter<"MarketStatus"> | boolean
    openTime?: DateTimeNullableFilter<"MarketStatus"> | Date | string | null
    closeTime?: DateTimeNullableFilter<"MarketStatus"> | Date | string | null
    timezone?: StringFilter<"MarketStatus"> | string
    holidays?: StringNullableFilter<"MarketStatus"> | string | null
    lastUpdated?: DateTimeFilter<"MarketStatus"> | Date | string
  }

  export type MarketStatusOrderByWithRelationInput = {
    id?: SortOrder
    exchange?: SortOrder
    isOpen?: SortOrder
    openTime?: SortOrderInput | SortOrder
    closeTime?: SortOrderInput | SortOrder
    timezone?: SortOrder
    holidays?: SortOrderInput | SortOrder
    lastUpdated?: SortOrder
  }

  export type MarketStatusWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    exchange?: string
    AND?: MarketStatusWhereInput | MarketStatusWhereInput[]
    OR?: MarketStatusWhereInput[]
    NOT?: MarketStatusWhereInput | MarketStatusWhereInput[]
    isOpen?: BoolFilter<"MarketStatus"> | boolean
    openTime?: DateTimeNullableFilter<"MarketStatus"> | Date | string | null
    closeTime?: DateTimeNullableFilter<"MarketStatus"> | Date | string | null
    timezone?: StringFilter<"MarketStatus"> | string
    holidays?: StringNullableFilter<"MarketStatus"> | string | null
    lastUpdated?: DateTimeFilter<"MarketStatus"> | Date | string
  }, "id" | "exchange">

  export type MarketStatusOrderByWithAggregationInput = {
    id?: SortOrder
    exchange?: SortOrder
    isOpen?: SortOrder
    openTime?: SortOrderInput | SortOrder
    closeTime?: SortOrderInput | SortOrder
    timezone?: SortOrder
    holidays?: SortOrderInput | SortOrder
    lastUpdated?: SortOrder
    _count?: MarketStatusCountOrderByAggregateInput
    _max?: MarketStatusMaxOrderByAggregateInput
    _min?: MarketStatusMinOrderByAggregateInput
  }

  export type MarketStatusScalarWhereWithAggregatesInput = {
    AND?: MarketStatusScalarWhereWithAggregatesInput | MarketStatusScalarWhereWithAggregatesInput[]
    OR?: MarketStatusScalarWhereWithAggregatesInput[]
    NOT?: MarketStatusScalarWhereWithAggregatesInput | MarketStatusScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MarketStatus"> | string
    exchange?: StringWithAggregatesFilter<"MarketStatus"> | string
    isOpen?: BoolWithAggregatesFilter<"MarketStatus"> | boolean
    openTime?: DateTimeNullableWithAggregatesFilter<"MarketStatus"> | Date | string | null
    closeTime?: DateTimeNullableWithAggregatesFilter<"MarketStatus"> | Date | string | null
    timezone?: StringWithAggregatesFilter<"MarketStatus"> | string
    holidays?: StringNullableWithAggregatesFilter<"MarketStatus"> | string | null
    lastUpdated?: DateTimeWithAggregatesFilter<"MarketStatus"> | Date | string
  }

  export type CacheEntryWhereInput = {
    AND?: CacheEntryWhereInput | CacheEntryWhereInput[]
    OR?: CacheEntryWhereInput[]
    NOT?: CacheEntryWhereInput | CacheEntryWhereInput[]
    id?: StringFilter<"CacheEntry"> | string
    key?: StringFilter<"CacheEntry"> | string
    value?: StringFilter<"CacheEntry"> | string
    expiresAt?: DateTimeFilter<"CacheEntry"> | Date | string
    tags?: StringNullableFilter<"CacheEntry"> | string | null
    createdAt?: DateTimeFilter<"CacheEntry"> | Date | string
    updatedAt?: DateTimeFilter<"CacheEntry"> | Date | string
  }

  export type CacheEntryOrderByWithRelationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    tags?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CacheEntryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    key?: string
    AND?: CacheEntryWhereInput | CacheEntryWhereInput[]
    OR?: CacheEntryWhereInput[]
    NOT?: CacheEntryWhereInput | CacheEntryWhereInput[]
    value?: StringFilter<"CacheEntry"> | string
    expiresAt?: DateTimeFilter<"CacheEntry"> | Date | string
    tags?: StringNullableFilter<"CacheEntry"> | string | null
    createdAt?: DateTimeFilter<"CacheEntry"> | Date | string
    updatedAt?: DateTimeFilter<"CacheEntry"> | Date | string
  }, "id" | "key">

  export type CacheEntryOrderByWithAggregationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    tags?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CacheEntryCountOrderByAggregateInput
    _max?: CacheEntryMaxOrderByAggregateInput
    _min?: CacheEntryMinOrderByAggregateInput
  }

  export type CacheEntryScalarWhereWithAggregatesInput = {
    AND?: CacheEntryScalarWhereWithAggregatesInput | CacheEntryScalarWhereWithAggregatesInput[]
    OR?: CacheEntryScalarWhereWithAggregatesInput[]
    NOT?: CacheEntryScalarWhereWithAggregatesInput | CacheEntryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CacheEntry"> | string
    key?: StringWithAggregatesFilter<"CacheEntry"> | string
    value?: StringWithAggregatesFilter<"CacheEntry"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"CacheEntry"> | Date | string
    tags?: StringNullableWithAggregatesFilter<"CacheEntry"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CacheEntry"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CacheEntry"> | Date | string
  }

  export type SyncLogWhereInput = {
    AND?: SyncLogWhereInput | SyncLogWhereInput[]
    OR?: SyncLogWhereInput[]
    NOT?: SyncLogWhereInput | SyncLogWhereInput[]
    id?: StringFilter<"SyncLog"> | string
    source?: StringFilter<"SyncLog"> | string
    type?: StringFilter<"SyncLog"> | string
    status?: StringFilter<"SyncLog"> | string
    recordsProcessed?: IntFilter<"SyncLog"> | number
    recordsSuccess?: IntFilter<"SyncLog"> | number
    recordsError?: IntFilter<"SyncLog"> | number
    errorDetails?: StringNullableFilter<"SyncLog"> | string | null
    startedAt?: DateTimeFilter<"SyncLog"> | Date | string
    completedAt?: DateTimeNullableFilter<"SyncLog"> | Date | string | null
    duration?: IntNullableFilter<"SyncLog"> | number | null
    metadata?: StringNullableFilter<"SyncLog"> | string | null
  }

  export type SyncLogOrderByWithRelationInput = {
    id?: SortOrder
    source?: SortOrder
    type?: SortOrder
    status?: SortOrder
    recordsProcessed?: SortOrder
    recordsSuccess?: SortOrder
    recordsError?: SortOrder
    errorDetails?: SortOrderInput | SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
  }

  export type SyncLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SyncLogWhereInput | SyncLogWhereInput[]
    OR?: SyncLogWhereInput[]
    NOT?: SyncLogWhereInput | SyncLogWhereInput[]
    source?: StringFilter<"SyncLog"> | string
    type?: StringFilter<"SyncLog"> | string
    status?: StringFilter<"SyncLog"> | string
    recordsProcessed?: IntFilter<"SyncLog"> | number
    recordsSuccess?: IntFilter<"SyncLog"> | number
    recordsError?: IntFilter<"SyncLog"> | number
    errorDetails?: StringNullableFilter<"SyncLog"> | string | null
    startedAt?: DateTimeFilter<"SyncLog"> | Date | string
    completedAt?: DateTimeNullableFilter<"SyncLog"> | Date | string | null
    duration?: IntNullableFilter<"SyncLog"> | number | null
    metadata?: StringNullableFilter<"SyncLog"> | string | null
  }, "id">

  export type SyncLogOrderByWithAggregationInput = {
    id?: SortOrder
    source?: SortOrder
    type?: SortOrder
    status?: SortOrder
    recordsProcessed?: SortOrder
    recordsSuccess?: SortOrder
    recordsError?: SortOrder
    errorDetails?: SortOrderInput | SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    _count?: SyncLogCountOrderByAggregateInput
    _avg?: SyncLogAvgOrderByAggregateInput
    _max?: SyncLogMaxOrderByAggregateInput
    _min?: SyncLogMinOrderByAggregateInput
    _sum?: SyncLogSumOrderByAggregateInput
  }

  export type SyncLogScalarWhereWithAggregatesInput = {
    AND?: SyncLogScalarWhereWithAggregatesInput | SyncLogScalarWhereWithAggregatesInput[]
    OR?: SyncLogScalarWhereWithAggregatesInput[]
    NOT?: SyncLogScalarWhereWithAggregatesInput | SyncLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SyncLog"> | string
    source?: StringWithAggregatesFilter<"SyncLog"> | string
    type?: StringWithAggregatesFilter<"SyncLog"> | string
    status?: StringWithAggregatesFilter<"SyncLog"> | string
    recordsProcessed?: IntWithAggregatesFilter<"SyncLog"> | number
    recordsSuccess?: IntWithAggregatesFilter<"SyncLog"> | number
    recordsError?: IntWithAggregatesFilter<"SyncLog"> | number
    errorDetails?: StringNullableWithAggregatesFilter<"SyncLog"> | string | null
    startedAt?: DateTimeWithAggregatesFilter<"SyncLog"> | Date | string
    completedAt?: DateTimeNullableWithAggregatesFilter<"SyncLog"> | Date | string | null
    duration?: IntNullableWithAggregatesFilter<"SyncLog"> | number | null
    metadata?: StringNullableWithAggregatesFilter<"SyncLog"> | string | null
  }

  export type IPOCreateInput = {
    id?: string
    symbol: string
    name: string
    companyId?: string | null
    status: string
    sector?: string | null
    industry?: string | null
    minPrice: number
    maxPrice: number
    finalPrice?: number | null
    listingPrice?: number | null
    currentPrice?: number | null
    issueSize: bigint | number
    lotSize: number
    marketLot: number
    openDate: Date | string
    closeDate: Date | string
    listingDate?: Date | string | null
    allotmentDate?: Date | string | null
    refundDate?: Date | string | null
    leadManager?: string | null
    registrar?: string | null
    faceValue?: number | null
    bookValue?: number | null
    marketCap?: bigint | number | null
    peRatio?: number | null
    roe?: number | null
    reservationDetails?: string | null
    aboutCompany?: string | null
    objectives?: string | null
    risks?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    gmpData?: GMPCreateNestedManyWithoutIpoInput
    subscriptionData?: SubscriptionDataCreateNestedManyWithoutIpoInput
    allotmentData?: AllotmentDataCreateNestedManyWithoutIpoInput
    analytics?: IPOAnalyticsCreateNestedManyWithoutIpoInput
    watchlists?: UserWatchlistCreateNestedManyWithoutIpoInput
    alerts?: UserAlertCreateNestedManyWithoutIpoInput
  }

  export type IPOUncheckedCreateInput = {
    id?: string
    symbol: string
    name: string
    companyId?: string | null
    status: string
    sector?: string | null
    industry?: string | null
    minPrice: number
    maxPrice: number
    finalPrice?: number | null
    listingPrice?: number | null
    currentPrice?: number | null
    issueSize: bigint | number
    lotSize: number
    marketLot: number
    openDate: Date | string
    closeDate: Date | string
    listingDate?: Date | string | null
    allotmentDate?: Date | string | null
    refundDate?: Date | string | null
    leadManager?: string | null
    registrar?: string | null
    faceValue?: number | null
    bookValue?: number | null
    marketCap?: bigint | number | null
    peRatio?: number | null
    roe?: number | null
    reservationDetails?: string | null
    aboutCompany?: string | null
    objectives?: string | null
    risks?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    gmpData?: GMPUncheckedCreateNestedManyWithoutIpoInput
    subscriptionData?: SubscriptionDataUncheckedCreateNestedManyWithoutIpoInput
    allotmentData?: AllotmentDataUncheckedCreateNestedManyWithoutIpoInput
    analytics?: IPOAnalyticsUncheckedCreateNestedManyWithoutIpoInput
    watchlists?: UserWatchlistUncheckedCreateNestedManyWithoutIpoInput
    alerts?: UserAlertUncheckedCreateNestedManyWithoutIpoInput
  }

  export type IPOUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    minPrice?: FloatFieldUpdateOperationsInput | number
    maxPrice?: FloatFieldUpdateOperationsInput | number
    finalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    listingPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    currentPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    issueSize?: BigIntFieldUpdateOperationsInput | bigint | number
    lotSize?: IntFieldUpdateOperationsInput | number
    marketLot?: IntFieldUpdateOperationsInput | number
    openDate?: DateTimeFieldUpdateOperationsInput | Date | string
    closeDate?: DateTimeFieldUpdateOperationsInput | Date | string
    listingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    allotmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refundDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    leadManager?: NullableStringFieldUpdateOperationsInput | string | null
    registrar?: NullableStringFieldUpdateOperationsInput | string | null
    faceValue?: NullableFloatFieldUpdateOperationsInput | number | null
    bookValue?: NullableFloatFieldUpdateOperationsInput | number | null
    marketCap?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    peRatio?: NullableFloatFieldUpdateOperationsInput | number | null
    roe?: NullableFloatFieldUpdateOperationsInput | number | null
    reservationDetails?: NullableStringFieldUpdateOperationsInput | string | null
    aboutCompany?: NullableStringFieldUpdateOperationsInput | string | null
    objectives?: NullableStringFieldUpdateOperationsInput | string | null
    risks?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gmpData?: GMPUpdateManyWithoutIpoNestedInput
    subscriptionData?: SubscriptionDataUpdateManyWithoutIpoNestedInput
    allotmentData?: AllotmentDataUpdateManyWithoutIpoNestedInput
    analytics?: IPOAnalyticsUpdateManyWithoutIpoNestedInput
    watchlists?: UserWatchlistUpdateManyWithoutIpoNestedInput
    alerts?: UserAlertUpdateManyWithoutIpoNestedInput
  }

  export type IPOUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    minPrice?: FloatFieldUpdateOperationsInput | number
    maxPrice?: FloatFieldUpdateOperationsInput | number
    finalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    listingPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    currentPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    issueSize?: BigIntFieldUpdateOperationsInput | bigint | number
    lotSize?: IntFieldUpdateOperationsInput | number
    marketLot?: IntFieldUpdateOperationsInput | number
    openDate?: DateTimeFieldUpdateOperationsInput | Date | string
    closeDate?: DateTimeFieldUpdateOperationsInput | Date | string
    listingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    allotmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refundDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    leadManager?: NullableStringFieldUpdateOperationsInput | string | null
    registrar?: NullableStringFieldUpdateOperationsInput | string | null
    faceValue?: NullableFloatFieldUpdateOperationsInput | number | null
    bookValue?: NullableFloatFieldUpdateOperationsInput | number | null
    marketCap?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    peRatio?: NullableFloatFieldUpdateOperationsInput | number | null
    roe?: NullableFloatFieldUpdateOperationsInput | number | null
    reservationDetails?: NullableStringFieldUpdateOperationsInput | string | null
    aboutCompany?: NullableStringFieldUpdateOperationsInput | string | null
    objectives?: NullableStringFieldUpdateOperationsInput | string | null
    risks?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gmpData?: GMPUncheckedUpdateManyWithoutIpoNestedInput
    subscriptionData?: SubscriptionDataUncheckedUpdateManyWithoutIpoNestedInput
    allotmentData?: AllotmentDataUncheckedUpdateManyWithoutIpoNestedInput
    analytics?: IPOAnalyticsUncheckedUpdateManyWithoutIpoNestedInput
    watchlists?: UserWatchlistUncheckedUpdateManyWithoutIpoNestedInput
    alerts?: UserAlertUncheckedUpdateManyWithoutIpoNestedInput
  }

  export type IPOCreateManyInput = {
    id?: string
    symbol: string
    name: string
    companyId?: string | null
    status: string
    sector?: string | null
    industry?: string | null
    minPrice: number
    maxPrice: number
    finalPrice?: number | null
    listingPrice?: number | null
    currentPrice?: number | null
    issueSize: bigint | number
    lotSize: number
    marketLot: number
    openDate: Date | string
    closeDate: Date | string
    listingDate?: Date | string | null
    allotmentDate?: Date | string | null
    refundDate?: Date | string | null
    leadManager?: string | null
    registrar?: string | null
    faceValue?: number | null
    bookValue?: number | null
    marketCap?: bigint | number | null
    peRatio?: number | null
    roe?: number | null
    reservationDetails?: string | null
    aboutCompany?: string | null
    objectives?: string | null
    risks?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IPOUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    minPrice?: FloatFieldUpdateOperationsInput | number
    maxPrice?: FloatFieldUpdateOperationsInput | number
    finalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    listingPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    currentPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    issueSize?: BigIntFieldUpdateOperationsInput | bigint | number
    lotSize?: IntFieldUpdateOperationsInput | number
    marketLot?: IntFieldUpdateOperationsInput | number
    openDate?: DateTimeFieldUpdateOperationsInput | Date | string
    closeDate?: DateTimeFieldUpdateOperationsInput | Date | string
    listingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    allotmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refundDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    leadManager?: NullableStringFieldUpdateOperationsInput | string | null
    registrar?: NullableStringFieldUpdateOperationsInput | string | null
    faceValue?: NullableFloatFieldUpdateOperationsInput | number | null
    bookValue?: NullableFloatFieldUpdateOperationsInput | number | null
    marketCap?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    peRatio?: NullableFloatFieldUpdateOperationsInput | number | null
    roe?: NullableFloatFieldUpdateOperationsInput | number | null
    reservationDetails?: NullableStringFieldUpdateOperationsInput | string | null
    aboutCompany?: NullableStringFieldUpdateOperationsInput | string | null
    objectives?: NullableStringFieldUpdateOperationsInput | string | null
    risks?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IPOUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    minPrice?: FloatFieldUpdateOperationsInput | number
    maxPrice?: FloatFieldUpdateOperationsInput | number
    finalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    listingPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    currentPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    issueSize?: BigIntFieldUpdateOperationsInput | bigint | number
    lotSize?: IntFieldUpdateOperationsInput | number
    marketLot?: IntFieldUpdateOperationsInput | number
    openDate?: DateTimeFieldUpdateOperationsInput | Date | string
    closeDate?: DateTimeFieldUpdateOperationsInput | Date | string
    listingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    allotmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refundDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    leadManager?: NullableStringFieldUpdateOperationsInput | string | null
    registrar?: NullableStringFieldUpdateOperationsInput | string | null
    faceValue?: NullableFloatFieldUpdateOperationsInput | number | null
    bookValue?: NullableFloatFieldUpdateOperationsInput | number | null
    marketCap?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    peRatio?: NullableFloatFieldUpdateOperationsInput | number | null
    roe?: NullableFloatFieldUpdateOperationsInput | number | null
    reservationDetails?: NullableStringFieldUpdateOperationsInput | string | null
    aboutCompany?: NullableStringFieldUpdateOperationsInput | string | null
    objectives?: NullableStringFieldUpdateOperationsInput | string | null
    risks?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GMPCreateInput = {
    id?: string
    value: number
    percentage: number
    volume?: number | null
    bidPrice?: number | null
    askPrice?: number | null
    timestamp: Date | string
    source: string
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ipo: IPOCreateNestedOneWithoutGmpDataInput
  }

  export type GMPUncheckedCreateInput = {
    id?: string
    ipoId: string
    value: number
    percentage: number
    volume?: number | null
    bidPrice?: number | null
    askPrice?: number | null
    timestamp: Date | string
    source: string
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GMPUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    percentage?: FloatFieldUpdateOperationsInput | number
    volume?: NullableIntFieldUpdateOperationsInput | number | null
    bidPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    askPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipo?: IPOUpdateOneRequiredWithoutGmpDataNestedInput
  }

  export type GMPUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ipoId?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    percentage?: FloatFieldUpdateOperationsInput | number
    volume?: NullableIntFieldUpdateOperationsInput | number | null
    bidPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    askPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GMPCreateManyInput = {
    id?: string
    ipoId: string
    value: number
    percentage: number
    volume?: number | null
    bidPrice?: number | null
    askPrice?: number | null
    timestamp: Date | string
    source: string
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GMPUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    percentage?: FloatFieldUpdateOperationsInput | number
    volume?: NullableIntFieldUpdateOperationsInput | number | null
    bidPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    askPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GMPUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    ipoId?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    percentage?: FloatFieldUpdateOperationsInput | number
    volume?: NullableIntFieldUpdateOperationsInput | number | null
    bidPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    askPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionDataCreateInput = {
    id?: string
    category: string
    subCategory?: string | null
    quantity: bigint | number
    bidCount: number
    subscriptionRatio: number
    timestamp: Date | string
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ipo: IPOCreateNestedOneWithoutSubscriptionDataInput
  }

  export type SubscriptionDataUncheckedCreateInput = {
    id?: string
    ipoId: string
    category: string
    subCategory?: string | null
    quantity: bigint | number
    bidCount: number
    subscriptionRatio: number
    timestamp: Date | string
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionDataUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    subCategory?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: BigIntFieldUpdateOperationsInput | bigint | number
    bidCount?: IntFieldUpdateOperationsInput | number
    subscriptionRatio?: FloatFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipo?: IPOUpdateOneRequiredWithoutSubscriptionDataNestedInput
  }

  export type SubscriptionDataUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ipoId?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    subCategory?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: BigIntFieldUpdateOperationsInput | bigint | number
    bidCount?: IntFieldUpdateOperationsInput | number
    subscriptionRatio?: FloatFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionDataCreateManyInput = {
    id?: string
    ipoId: string
    category: string
    subCategory?: string | null
    quantity: bigint | number
    bidCount: number
    subscriptionRatio: number
    timestamp: Date | string
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionDataUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    subCategory?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: BigIntFieldUpdateOperationsInput | bigint | number
    bidCount?: IntFieldUpdateOperationsInput | number
    subscriptionRatio?: FloatFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionDataUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    ipoId?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    subCategory?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: BigIntFieldUpdateOperationsInput | bigint | number
    bidCount?: IntFieldUpdateOperationsInput | number
    subscriptionRatio?: FloatFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AllotmentDataCreateInput = {
    id?: string
    pan: string
    applicationNumber?: string | null
    category: string
    appliedQuantity: number
    allottedQuantity?: number
    allottedAmount?: number
    refundAmount?: number
    allotmentStatus: string
    timestamp: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    ipo: IPOCreateNestedOneWithoutAllotmentDataInput
  }

  export type AllotmentDataUncheckedCreateInput = {
    id?: string
    ipoId: string
    pan: string
    applicationNumber?: string | null
    category: string
    appliedQuantity: number
    allottedQuantity?: number
    allottedAmount?: number
    refundAmount?: number
    allotmentStatus: string
    timestamp: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AllotmentDataUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    pan?: StringFieldUpdateOperationsInput | string
    applicationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    appliedQuantity?: IntFieldUpdateOperationsInput | number
    allottedQuantity?: IntFieldUpdateOperationsInput | number
    allottedAmount?: FloatFieldUpdateOperationsInput | number
    refundAmount?: FloatFieldUpdateOperationsInput | number
    allotmentStatus?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipo?: IPOUpdateOneRequiredWithoutAllotmentDataNestedInput
  }

  export type AllotmentDataUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ipoId?: StringFieldUpdateOperationsInput | string
    pan?: StringFieldUpdateOperationsInput | string
    applicationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    appliedQuantity?: IntFieldUpdateOperationsInput | number
    allottedQuantity?: IntFieldUpdateOperationsInput | number
    allottedAmount?: FloatFieldUpdateOperationsInput | number
    refundAmount?: FloatFieldUpdateOperationsInput | number
    allotmentStatus?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AllotmentDataCreateManyInput = {
    id?: string
    ipoId: string
    pan: string
    applicationNumber?: string | null
    category: string
    appliedQuantity: number
    allottedQuantity?: number
    allottedAmount?: number
    refundAmount?: number
    allotmentStatus: string
    timestamp: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AllotmentDataUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    pan?: StringFieldUpdateOperationsInput | string
    applicationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    appliedQuantity?: IntFieldUpdateOperationsInput | number
    allottedQuantity?: IntFieldUpdateOperationsInput | number
    allottedAmount?: FloatFieldUpdateOperationsInput | number
    refundAmount?: FloatFieldUpdateOperationsInput | number
    allotmentStatus?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AllotmentDataUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    ipoId?: StringFieldUpdateOperationsInput | string
    pan?: StringFieldUpdateOperationsInput | string
    applicationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    appliedQuantity?: IntFieldUpdateOperationsInput | number
    allottedQuantity?: IntFieldUpdateOperationsInput | number
    allottedAmount?: FloatFieldUpdateOperationsInput | number
    refundAmount?: FloatFieldUpdateOperationsInput | number
    allotmentStatus?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    name?: string | null
    phone?: string | null
    pan?: string | null
    role?: string
    isActive?: boolean
    isEmailVerified?: boolean
    kycCompleted?: boolean
    preferences?: string | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    watchlists?: UserWatchlistCreateNestedManyWithoutUserInput
    alerts?: UserAlertCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    name?: string | null
    phone?: string | null
    pan?: string | null
    role?: string
    isActive?: boolean
    isEmailVerified?: boolean
    kycCompleted?: boolean
    preferences?: string | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    watchlists?: UserWatchlistUncheckedCreateNestedManyWithoutUserInput
    alerts?: UserAlertUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    pan?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    kycCompleted?: BoolFieldUpdateOperationsInput | boolean
    preferences?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    watchlists?: UserWatchlistUpdateManyWithoutUserNestedInput
    alerts?: UserAlertUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    pan?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    kycCompleted?: BoolFieldUpdateOperationsInput | boolean
    preferences?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    watchlists?: UserWatchlistUncheckedUpdateManyWithoutUserNestedInput
    alerts?: UserAlertUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    name?: string | null
    phone?: string | null
    pan?: string | null
    role?: string
    isActive?: boolean
    isEmailVerified?: boolean
    kycCompleted?: boolean
    preferences?: string | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    pan?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    kycCompleted?: BoolFieldUpdateOperationsInput | boolean
    preferences?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    pan?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    kycCompleted?: BoolFieldUpdateOperationsInput | boolean
    preferences?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateInput = {
    id?: string
    token: string
    refreshToken: string
    expiresAt: Date | string
    isActive?: boolean
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id?: string
    userId: string
    token: string
    refreshToken: string
    expiresAt: Date | string
    isActive?: boolean
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateManyInput = {
    id?: string
    userId: string
    token: string
    refreshToken: string
    expiresAt: Date | string
    isActive?: boolean
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IPOAnalyticsCreateInput = {
    id?: string
    symbol?: string | null
    date: Date | string
    avgGMP?: number | null
    maxGMP?: number | null
    minGMP?: number | null
    gmpVolume?: number | null
    gmpTrend?: string | null
    overallSubscription?: number | null
    retailSubscription?: number | null
    qibSubscription?: number | null
    hniSubscription?: number | null
    marketSentiment?: string | null
    sentimentScore?: number | null
    listingGain?: number | null
    currentReturn?: number | null
    volatilityIndex?: number | null
    totalGMPChanges?: number
    totalSubscriptions?: number
    oversubscribedCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    ipo: IPOCreateNestedOneWithoutAnalyticsInput
  }

  export type IPOAnalyticsUncheckedCreateInput = {
    id?: string
    ipoId: string
    symbol?: string | null
    date: Date | string
    avgGMP?: number | null
    maxGMP?: number | null
    minGMP?: number | null
    gmpVolume?: number | null
    gmpTrend?: string | null
    overallSubscription?: number | null
    retailSubscription?: number | null
    qibSubscription?: number | null
    hniSubscription?: number | null
    marketSentiment?: string | null
    sentimentScore?: number | null
    listingGain?: number | null
    currentReturn?: number | null
    volatilityIndex?: number | null
    totalGMPChanges?: number
    totalSubscriptions?: number
    oversubscribedCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IPOAnalyticsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    avgGMP?: NullableFloatFieldUpdateOperationsInput | number | null
    maxGMP?: NullableFloatFieldUpdateOperationsInput | number | null
    minGMP?: NullableFloatFieldUpdateOperationsInput | number | null
    gmpVolume?: NullableIntFieldUpdateOperationsInput | number | null
    gmpTrend?: NullableStringFieldUpdateOperationsInput | string | null
    overallSubscription?: NullableFloatFieldUpdateOperationsInput | number | null
    retailSubscription?: NullableFloatFieldUpdateOperationsInput | number | null
    qibSubscription?: NullableFloatFieldUpdateOperationsInput | number | null
    hniSubscription?: NullableFloatFieldUpdateOperationsInput | number | null
    marketSentiment?: NullableStringFieldUpdateOperationsInput | string | null
    sentimentScore?: NullableFloatFieldUpdateOperationsInput | number | null
    listingGain?: NullableFloatFieldUpdateOperationsInput | number | null
    currentReturn?: NullableFloatFieldUpdateOperationsInput | number | null
    volatilityIndex?: NullableFloatFieldUpdateOperationsInput | number | null
    totalGMPChanges?: IntFieldUpdateOperationsInput | number
    totalSubscriptions?: IntFieldUpdateOperationsInput | number
    oversubscribedCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipo?: IPOUpdateOneRequiredWithoutAnalyticsNestedInput
  }

  export type IPOAnalyticsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ipoId?: StringFieldUpdateOperationsInput | string
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    avgGMP?: NullableFloatFieldUpdateOperationsInput | number | null
    maxGMP?: NullableFloatFieldUpdateOperationsInput | number | null
    minGMP?: NullableFloatFieldUpdateOperationsInput | number | null
    gmpVolume?: NullableIntFieldUpdateOperationsInput | number | null
    gmpTrend?: NullableStringFieldUpdateOperationsInput | string | null
    overallSubscription?: NullableFloatFieldUpdateOperationsInput | number | null
    retailSubscription?: NullableFloatFieldUpdateOperationsInput | number | null
    qibSubscription?: NullableFloatFieldUpdateOperationsInput | number | null
    hniSubscription?: NullableFloatFieldUpdateOperationsInput | number | null
    marketSentiment?: NullableStringFieldUpdateOperationsInput | string | null
    sentimentScore?: NullableFloatFieldUpdateOperationsInput | number | null
    listingGain?: NullableFloatFieldUpdateOperationsInput | number | null
    currentReturn?: NullableFloatFieldUpdateOperationsInput | number | null
    volatilityIndex?: NullableFloatFieldUpdateOperationsInput | number | null
    totalGMPChanges?: IntFieldUpdateOperationsInput | number
    totalSubscriptions?: IntFieldUpdateOperationsInput | number
    oversubscribedCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IPOAnalyticsCreateManyInput = {
    id?: string
    ipoId: string
    symbol?: string | null
    date: Date | string
    avgGMP?: number | null
    maxGMP?: number | null
    minGMP?: number | null
    gmpVolume?: number | null
    gmpTrend?: string | null
    overallSubscription?: number | null
    retailSubscription?: number | null
    qibSubscription?: number | null
    hniSubscription?: number | null
    marketSentiment?: string | null
    sentimentScore?: number | null
    listingGain?: number | null
    currentReturn?: number | null
    volatilityIndex?: number | null
    totalGMPChanges?: number
    totalSubscriptions?: number
    oversubscribedCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IPOAnalyticsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    avgGMP?: NullableFloatFieldUpdateOperationsInput | number | null
    maxGMP?: NullableFloatFieldUpdateOperationsInput | number | null
    minGMP?: NullableFloatFieldUpdateOperationsInput | number | null
    gmpVolume?: NullableIntFieldUpdateOperationsInput | number | null
    gmpTrend?: NullableStringFieldUpdateOperationsInput | string | null
    overallSubscription?: NullableFloatFieldUpdateOperationsInput | number | null
    retailSubscription?: NullableFloatFieldUpdateOperationsInput | number | null
    qibSubscription?: NullableFloatFieldUpdateOperationsInput | number | null
    hniSubscription?: NullableFloatFieldUpdateOperationsInput | number | null
    marketSentiment?: NullableStringFieldUpdateOperationsInput | string | null
    sentimentScore?: NullableFloatFieldUpdateOperationsInput | number | null
    listingGain?: NullableFloatFieldUpdateOperationsInput | number | null
    currentReturn?: NullableFloatFieldUpdateOperationsInput | number | null
    volatilityIndex?: NullableFloatFieldUpdateOperationsInput | number | null
    totalGMPChanges?: IntFieldUpdateOperationsInput | number
    totalSubscriptions?: IntFieldUpdateOperationsInput | number
    oversubscribedCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IPOAnalyticsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    ipoId?: StringFieldUpdateOperationsInput | string
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    avgGMP?: NullableFloatFieldUpdateOperationsInput | number | null
    maxGMP?: NullableFloatFieldUpdateOperationsInput | number | null
    minGMP?: NullableFloatFieldUpdateOperationsInput | number | null
    gmpVolume?: NullableIntFieldUpdateOperationsInput | number | null
    gmpTrend?: NullableStringFieldUpdateOperationsInput | string | null
    overallSubscription?: NullableFloatFieldUpdateOperationsInput | number | null
    retailSubscription?: NullableFloatFieldUpdateOperationsInput | number | null
    qibSubscription?: NullableFloatFieldUpdateOperationsInput | number | null
    hniSubscription?: NullableFloatFieldUpdateOperationsInput | number | null
    marketSentiment?: NullableStringFieldUpdateOperationsInput | string | null
    sentimentScore?: NullableFloatFieldUpdateOperationsInput | number | null
    listingGain?: NullableFloatFieldUpdateOperationsInput | number | null
    currentReturn?: NullableFloatFieldUpdateOperationsInput | number | null
    volatilityIndex?: NullableFloatFieldUpdateOperationsInput | number | null
    totalGMPChanges?: IntFieldUpdateOperationsInput | number
    totalSubscriptions?: IntFieldUpdateOperationsInput | number
    oversubscribedCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserWatchlistCreateInput = {
    id?: string
    notes?: string | null
    alertPreferences?: string | null
    addedAt?: Date | string
    user: UserCreateNestedOneWithoutWatchlistsInput
    ipo: IPOCreateNestedOneWithoutWatchlistsInput
  }

  export type UserWatchlistUncheckedCreateInput = {
    id?: string
    userId: string
    ipoId: string
    notes?: string | null
    alertPreferences?: string | null
    addedAt?: Date | string
  }

  export type UserWatchlistUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    alertPreferences?: NullableStringFieldUpdateOperationsInput | string | null
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutWatchlistsNestedInput
    ipo?: IPOUpdateOneRequiredWithoutWatchlistsNestedInput
  }

  export type UserWatchlistUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    ipoId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    alertPreferences?: NullableStringFieldUpdateOperationsInput | string | null
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserWatchlistCreateManyInput = {
    id?: string
    userId: string
    ipoId: string
    notes?: string | null
    alertPreferences?: string | null
    addedAt?: Date | string
  }

  export type UserWatchlistUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    alertPreferences?: NullableStringFieldUpdateOperationsInput | string | null
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserWatchlistUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    ipoId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    alertPreferences?: NullableStringFieldUpdateOperationsInput | string | null
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAlertCreateInput = {
    id?: string
    symbol?: string | null
    alertType: string
    triggerType: string
    triggerValue?: number | null
    triggerCondition?: string | null
    message?: string | null
    isActive?: boolean
    lastTriggered?: Date | string | null
    triggerCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAlertsInput
    ipo?: IPOCreateNestedOneWithoutAlertsInput
  }

  export type UserAlertUncheckedCreateInput = {
    id?: string
    userId: string
    ipoId?: string | null
    symbol?: string | null
    alertType: string
    triggerType: string
    triggerValue?: number | null
    triggerCondition?: string | null
    message?: string | null
    isActive?: boolean
    lastTriggered?: Date | string | null
    triggerCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserAlertUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    alertType?: StringFieldUpdateOperationsInput | string
    triggerType?: StringFieldUpdateOperationsInput | string
    triggerValue?: NullableFloatFieldUpdateOperationsInput | number | null
    triggerCondition?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastTriggered?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    triggerCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAlertsNestedInput
    ipo?: IPOUpdateOneWithoutAlertsNestedInput
  }

  export type UserAlertUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    ipoId?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    alertType?: StringFieldUpdateOperationsInput | string
    triggerType?: StringFieldUpdateOperationsInput | string
    triggerValue?: NullableFloatFieldUpdateOperationsInput | number | null
    triggerCondition?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastTriggered?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    triggerCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAlertCreateManyInput = {
    id?: string
    userId: string
    ipoId?: string | null
    symbol?: string | null
    alertType: string
    triggerType: string
    triggerValue?: number | null
    triggerCondition?: string | null
    message?: string | null
    isActive?: boolean
    lastTriggered?: Date | string | null
    triggerCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserAlertUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    alertType?: StringFieldUpdateOperationsInput | string
    triggerType?: StringFieldUpdateOperationsInput | string
    triggerValue?: NullableFloatFieldUpdateOperationsInput | number | null
    triggerCondition?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastTriggered?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    triggerCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAlertUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    ipoId?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    alertType?: StringFieldUpdateOperationsInput | string
    triggerType?: StringFieldUpdateOperationsInput | string
    triggerValue?: NullableFloatFieldUpdateOperationsInput | number | null
    triggerCondition?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastTriggered?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    triggerCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemConfigCreateInput = {
    id?: string
    key: string
    value: string
    description?: string | null
    category?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SystemConfigUncheckedCreateInput = {
    id?: string
    key: string
    value: string
    description?: string | null
    category?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SystemConfigUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemConfigUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemConfigCreateManyInput = {
    id?: string
    key: string
    value: string
    description?: string | null
    category?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SystemConfigUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemConfigUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiLogCreateInput = {
    id?: string
    endpoint: string
    method: string
    statusCode: number
    responseTime: number
    ipAddress?: string | null
    userAgent?: string | null
    userId?: string | null
    errorMessage?: string | null
    requestData?: string | null
    responseData?: string | null
    timestamp?: Date | string
  }

  export type ApiLogUncheckedCreateInput = {
    id?: string
    endpoint: string
    method: string
    statusCode: number
    responseTime: number
    ipAddress?: string | null
    userAgent?: string | null
    userId?: string | null
    errorMessage?: string | null
    requestData?: string | null
    responseData?: string | null
    timestamp?: Date | string
  }

  export type ApiLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    statusCode?: IntFieldUpdateOperationsInput | number
    responseTime?: IntFieldUpdateOperationsInput | number
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    requestData?: NullableStringFieldUpdateOperationsInput | string | null
    responseData?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    statusCode?: IntFieldUpdateOperationsInput | number
    responseTime?: IntFieldUpdateOperationsInput | number
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    requestData?: NullableStringFieldUpdateOperationsInput | string | null
    responseData?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiLogCreateManyInput = {
    id?: string
    endpoint: string
    method: string
    statusCode: number
    responseTime: number
    ipAddress?: string | null
    userAgent?: string | null
    userId?: string | null
    errorMessage?: string | null
    requestData?: string | null
    responseData?: string | null
    timestamp?: Date | string
  }

  export type ApiLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    statusCode?: IntFieldUpdateOperationsInput | number
    responseTime?: IntFieldUpdateOperationsInput | number
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    requestData?: NullableStringFieldUpdateOperationsInput | string | null
    responseData?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    statusCode?: IntFieldUpdateOperationsInput | number
    responseTime?: IntFieldUpdateOperationsInput | number
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    requestData?: NullableStringFieldUpdateOperationsInput | string | null
    responseData?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketStatusCreateInput = {
    id?: string
    exchange: string
    isOpen: boolean
    openTime?: Date | string | null
    closeTime?: Date | string | null
    timezone?: string
    holidays?: string | null
    lastUpdated?: Date | string
  }

  export type MarketStatusUncheckedCreateInput = {
    id?: string
    exchange: string
    isOpen: boolean
    openTime?: Date | string | null
    closeTime?: Date | string | null
    timezone?: string
    holidays?: string | null
    lastUpdated?: Date | string
  }

  export type MarketStatusUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    exchange?: StringFieldUpdateOperationsInput | string
    isOpen?: BoolFieldUpdateOperationsInput | boolean
    openTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closeTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    holidays?: NullableStringFieldUpdateOperationsInput | string | null
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketStatusUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    exchange?: StringFieldUpdateOperationsInput | string
    isOpen?: BoolFieldUpdateOperationsInput | boolean
    openTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closeTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    holidays?: NullableStringFieldUpdateOperationsInput | string | null
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketStatusCreateManyInput = {
    id?: string
    exchange: string
    isOpen: boolean
    openTime?: Date | string | null
    closeTime?: Date | string | null
    timezone?: string
    holidays?: string | null
    lastUpdated?: Date | string
  }

  export type MarketStatusUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    exchange?: StringFieldUpdateOperationsInput | string
    isOpen?: BoolFieldUpdateOperationsInput | boolean
    openTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closeTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    holidays?: NullableStringFieldUpdateOperationsInput | string | null
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketStatusUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    exchange?: StringFieldUpdateOperationsInput | string
    isOpen?: BoolFieldUpdateOperationsInput | boolean
    openTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closeTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    holidays?: NullableStringFieldUpdateOperationsInput | string | null
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CacheEntryCreateInput = {
    id?: string
    key: string
    value: string
    expiresAt: Date | string
    tags?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CacheEntryUncheckedCreateInput = {
    id?: string
    key: string
    value: string
    expiresAt: Date | string
    tags?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CacheEntryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CacheEntryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CacheEntryCreateManyInput = {
    id?: string
    key: string
    value: string
    expiresAt: Date | string
    tags?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CacheEntryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CacheEntryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SyncLogCreateInput = {
    id?: string
    source: string
    type: string
    status: string
    recordsProcessed?: number
    recordsSuccess?: number
    recordsError?: number
    errorDetails?: string | null
    startedAt?: Date | string
    completedAt?: Date | string | null
    duration?: number | null
    metadata?: string | null
  }

  export type SyncLogUncheckedCreateInput = {
    id?: string
    source: string
    type: string
    status: string
    recordsProcessed?: number
    recordsSuccess?: number
    recordsError?: number
    errorDetails?: string | null
    startedAt?: Date | string
    completedAt?: Date | string | null
    duration?: number | null
    metadata?: string | null
  }

  export type SyncLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    recordsProcessed?: IntFieldUpdateOperationsInput | number
    recordsSuccess?: IntFieldUpdateOperationsInput | number
    recordsError?: IntFieldUpdateOperationsInput | number
    errorDetails?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SyncLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    recordsProcessed?: IntFieldUpdateOperationsInput | number
    recordsSuccess?: IntFieldUpdateOperationsInput | number
    recordsError?: IntFieldUpdateOperationsInput | number
    errorDetails?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SyncLogCreateManyInput = {
    id?: string
    source: string
    type: string
    status: string
    recordsProcessed?: number
    recordsSuccess?: number
    recordsError?: number
    errorDetails?: string | null
    startedAt?: Date | string
    completedAt?: Date | string | null
    duration?: number | null
    metadata?: string | null
  }

  export type SyncLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    recordsProcessed?: IntFieldUpdateOperationsInput | number
    recordsSuccess?: IntFieldUpdateOperationsInput | number
    recordsError?: IntFieldUpdateOperationsInput | number
    errorDetails?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SyncLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    recordsProcessed?: IntFieldUpdateOperationsInput | number
    recordsSuccess?: IntFieldUpdateOperationsInput | number
    recordsError?: IntFieldUpdateOperationsInput | number
    errorDetails?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type BigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type BigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type GMPListRelationFilter = {
    every?: GMPWhereInput
    some?: GMPWhereInput
    none?: GMPWhereInput
  }

  export type SubscriptionDataListRelationFilter = {
    every?: SubscriptionDataWhereInput
    some?: SubscriptionDataWhereInput
    none?: SubscriptionDataWhereInput
  }

  export type AllotmentDataListRelationFilter = {
    every?: AllotmentDataWhereInput
    some?: AllotmentDataWhereInput
    none?: AllotmentDataWhereInput
  }

  export type IPOAnalyticsListRelationFilter = {
    every?: IPOAnalyticsWhereInput
    some?: IPOAnalyticsWhereInput
    none?: IPOAnalyticsWhereInput
  }

  export type UserWatchlistListRelationFilter = {
    every?: UserWatchlistWhereInput
    some?: UserWatchlistWhereInput
    none?: UserWatchlistWhereInput
  }

  export type UserAlertListRelationFilter = {
    every?: UserAlertWhereInput
    some?: UserAlertWhereInput
    none?: UserAlertWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type GMPOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubscriptionDataOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AllotmentDataOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type IPOAnalyticsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserWatchlistOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserAlertOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type IPOCountOrderByAggregateInput = {
    id?: SortOrder
    symbol?: SortOrder
    name?: SortOrder
    companyId?: SortOrder
    status?: SortOrder
    sector?: SortOrder
    industry?: SortOrder
    minPrice?: SortOrder
    maxPrice?: SortOrder
    finalPrice?: SortOrder
    listingPrice?: SortOrder
    currentPrice?: SortOrder
    issueSize?: SortOrder
    lotSize?: SortOrder
    marketLot?: SortOrder
    openDate?: SortOrder
    closeDate?: SortOrder
    listingDate?: SortOrder
    allotmentDate?: SortOrder
    refundDate?: SortOrder
    leadManager?: SortOrder
    registrar?: SortOrder
    faceValue?: SortOrder
    bookValue?: SortOrder
    marketCap?: SortOrder
    peRatio?: SortOrder
    roe?: SortOrder
    reservationDetails?: SortOrder
    aboutCompany?: SortOrder
    objectives?: SortOrder
    risks?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IPOAvgOrderByAggregateInput = {
    minPrice?: SortOrder
    maxPrice?: SortOrder
    finalPrice?: SortOrder
    listingPrice?: SortOrder
    currentPrice?: SortOrder
    issueSize?: SortOrder
    lotSize?: SortOrder
    marketLot?: SortOrder
    faceValue?: SortOrder
    bookValue?: SortOrder
    marketCap?: SortOrder
    peRatio?: SortOrder
    roe?: SortOrder
  }

  export type IPOMaxOrderByAggregateInput = {
    id?: SortOrder
    symbol?: SortOrder
    name?: SortOrder
    companyId?: SortOrder
    status?: SortOrder
    sector?: SortOrder
    industry?: SortOrder
    minPrice?: SortOrder
    maxPrice?: SortOrder
    finalPrice?: SortOrder
    listingPrice?: SortOrder
    currentPrice?: SortOrder
    issueSize?: SortOrder
    lotSize?: SortOrder
    marketLot?: SortOrder
    openDate?: SortOrder
    closeDate?: SortOrder
    listingDate?: SortOrder
    allotmentDate?: SortOrder
    refundDate?: SortOrder
    leadManager?: SortOrder
    registrar?: SortOrder
    faceValue?: SortOrder
    bookValue?: SortOrder
    marketCap?: SortOrder
    peRatio?: SortOrder
    roe?: SortOrder
    reservationDetails?: SortOrder
    aboutCompany?: SortOrder
    objectives?: SortOrder
    risks?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IPOMinOrderByAggregateInput = {
    id?: SortOrder
    symbol?: SortOrder
    name?: SortOrder
    companyId?: SortOrder
    status?: SortOrder
    sector?: SortOrder
    industry?: SortOrder
    minPrice?: SortOrder
    maxPrice?: SortOrder
    finalPrice?: SortOrder
    listingPrice?: SortOrder
    currentPrice?: SortOrder
    issueSize?: SortOrder
    lotSize?: SortOrder
    marketLot?: SortOrder
    openDate?: SortOrder
    closeDate?: SortOrder
    listingDate?: SortOrder
    allotmentDate?: SortOrder
    refundDate?: SortOrder
    leadManager?: SortOrder
    registrar?: SortOrder
    faceValue?: SortOrder
    bookValue?: SortOrder
    marketCap?: SortOrder
    peRatio?: SortOrder
    roe?: SortOrder
    reservationDetails?: SortOrder
    aboutCompany?: SortOrder
    objectives?: SortOrder
    risks?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IPOSumOrderByAggregateInput = {
    minPrice?: SortOrder
    maxPrice?: SortOrder
    finalPrice?: SortOrder
    listingPrice?: SortOrder
    currentPrice?: SortOrder
    issueSize?: SortOrder
    lotSize?: SortOrder
    marketLot?: SortOrder
    faceValue?: SortOrder
    bookValue?: SortOrder
    marketCap?: SortOrder
    peRatio?: SortOrder
    roe?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type BigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type BigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type IPORelationFilter = {
    is?: IPOWhereInput
    isNot?: IPOWhereInput
  }

  export type GMPCountOrderByAggregateInput = {
    id?: SortOrder
    ipoId?: SortOrder
    value?: SortOrder
    percentage?: SortOrder
    volume?: SortOrder
    bidPrice?: SortOrder
    askPrice?: SortOrder
    timestamp?: SortOrder
    source?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GMPAvgOrderByAggregateInput = {
    value?: SortOrder
    percentage?: SortOrder
    volume?: SortOrder
    bidPrice?: SortOrder
    askPrice?: SortOrder
  }

  export type GMPMaxOrderByAggregateInput = {
    id?: SortOrder
    ipoId?: SortOrder
    value?: SortOrder
    percentage?: SortOrder
    volume?: SortOrder
    bidPrice?: SortOrder
    askPrice?: SortOrder
    timestamp?: SortOrder
    source?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GMPMinOrderByAggregateInput = {
    id?: SortOrder
    ipoId?: SortOrder
    value?: SortOrder
    percentage?: SortOrder
    volume?: SortOrder
    bidPrice?: SortOrder
    askPrice?: SortOrder
    timestamp?: SortOrder
    source?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GMPSumOrderByAggregateInput = {
    value?: SortOrder
    percentage?: SortOrder
    volume?: SortOrder
    bidPrice?: SortOrder
    askPrice?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type SubscriptionDataCountOrderByAggregateInput = {
    id?: SortOrder
    ipoId?: SortOrder
    category?: SortOrder
    subCategory?: SortOrder
    quantity?: SortOrder
    bidCount?: SortOrder
    subscriptionRatio?: SortOrder
    timestamp?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionDataAvgOrderByAggregateInput = {
    quantity?: SortOrder
    bidCount?: SortOrder
    subscriptionRatio?: SortOrder
  }

  export type SubscriptionDataMaxOrderByAggregateInput = {
    id?: SortOrder
    ipoId?: SortOrder
    category?: SortOrder
    subCategory?: SortOrder
    quantity?: SortOrder
    bidCount?: SortOrder
    subscriptionRatio?: SortOrder
    timestamp?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionDataMinOrderByAggregateInput = {
    id?: SortOrder
    ipoId?: SortOrder
    category?: SortOrder
    subCategory?: SortOrder
    quantity?: SortOrder
    bidCount?: SortOrder
    subscriptionRatio?: SortOrder
    timestamp?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionDataSumOrderByAggregateInput = {
    quantity?: SortOrder
    bidCount?: SortOrder
    subscriptionRatio?: SortOrder
  }

  export type AllotmentDataCountOrderByAggregateInput = {
    id?: SortOrder
    ipoId?: SortOrder
    pan?: SortOrder
    applicationNumber?: SortOrder
    category?: SortOrder
    appliedQuantity?: SortOrder
    allottedQuantity?: SortOrder
    allottedAmount?: SortOrder
    refundAmount?: SortOrder
    allotmentStatus?: SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AllotmentDataAvgOrderByAggregateInput = {
    appliedQuantity?: SortOrder
    allottedQuantity?: SortOrder
    allottedAmount?: SortOrder
    refundAmount?: SortOrder
  }

  export type AllotmentDataMaxOrderByAggregateInput = {
    id?: SortOrder
    ipoId?: SortOrder
    pan?: SortOrder
    applicationNumber?: SortOrder
    category?: SortOrder
    appliedQuantity?: SortOrder
    allottedQuantity?: SortOrder
    allottedAmount?: SortOrder
    refundAmount?: SortOrder
    allotmentStatus?: SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AllotmentDataMinOrderByAggregateInput = {
    id?: SortOrder
    ipoId?: SortOrder
    pan?: SortOrder
    applicationNumber?: SortOrder
    category?: SortOrder
    appliedQuantity?: SortOrder
    allottedQuantity?: SortOrder
    allottedAmount?: SortOrder
    refundAmount?: SortOrder
    allotmentStatus?: SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AllotmentDataSumOrderByAggregateInput = {
    appliedQuantity?: SortOrder
    allottedQuantity?: SortOrder
    allottedAmount?: SortOrder
    refundAmount?: SortOrder
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    pan?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    isEmailVerified?: SortOrder
    kycCompleted?: SortOrder
    preferences?: SortOrder
    lastLoginAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    pan?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    isEmailVerified?: SortOrder
    kycCompleted?: SortOrder
    preferences?: SortOrder
    lastLoginAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    pan?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    isEmailVerified?: SortOrder
    kycCompleted?: SortOrder
    preferences?: SortOrder
    lastLoginAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    refreshToken?: SortOrder
    expiresAt?: SortOrder
    isActive?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    refreshToken?: SortOrder
    expiresAt?: SortOrder
    isActive?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    refreshToken?: SortOrder
    expiresAt?: SortOrder
    isActive?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IPOAnalyticsCountOrderByAggregateInput = {
    id?: SortOrder
    ipoId?: SortOrder
    symbol?: SortOrder
    date?: SortOrder
    avgGMP?: SortOrder
    maxGMP?: SortOrder
    minGMP?: SortOrder
    gmpVolume?: SortOrder
    gmpTrend?: SortOrder
    overallSubscription?: SortOrder
    retailSubscription?: SortOrder
    qibSubscription?: SortOrder
    hniSubscription?: SortOrder
    marketSentiment?: SortOrder
    sentimentScore?: SortOrder
    listingGain?: SortOrder
    currentReturn?: SortOrder
    volatilityIndex?: SortOrder
    totalGMPChanges?: SortOrder
    totalSubscriptions?: SortOrder
    oversubscribedCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IPOAnalyticsAvgOrderByAggregateInput = {
    avgGMP?: SortOrder
    maxGMP?: SortOrder
    minGMP?: SortOrder
    gmpVolume?: SortOrder
    overallSubscription?: SortOrder
    retailSubscription?: SortOrder
    qibSubscription?: SortOrder
    hniSubscription?: SortOrder
    sentimentScore?: SortOrder
    listingGain?: SortOrder
    currentReturn?: SortOrder
    volatilityIndex?: SortOrder
    totalGMPChanges?: SortOrder
    totalSubscriptions?: SortOrder
    oversubscribedCount?: SortOrder
  }

  export type IPOAnalyticsMaxOrderByAggregateInput = {
    id?: SortOrder
    ipoId?: SortOrder
    symbol?: SortOrder
    date?: SortOrder
    avgGMP?: SortOrder
    maxGMP?: SortOrder
    minGMP?: SortOrder
    gmpVolume?: SortOrder
    gmpTrend?: SortOrder
    overallSubscription?: SortOrder
    retailSubscription?: SortOrder
    qibSubscription?: SortOrder
    hniSubscription?: SortOrder
    marketSentiment?: SortOrder
    sentimentScore?: SortOrder
    listingGain?: SortOrder
    currentReturn?: SortOrder
    volatilityIndex?: SortOrder
    totalGMPChanges?: SortOrder
    totalSubscriptions?: SortOrder
    oversubscribedCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IPOAnalyticsMinOrderByAggregateInput = {
    id?: SortOrder
    ipoId?: SortOrder
    symbol?: SortOrder
    date?: SortOrder
    avgGMP?: SortOrder
    maxGMP?: SortOrder
    minGMP?: SortOrder
    gmpVolume?: SortOrder
    gmpTrend?: SortOrder
    overallSubscription?: SortOrder
    retailSubscription?: SortOrder
    qibSubscription?: SortOrder
    hniSubscription?: SortOrder
    marketSentiment?: SortOrder
    sentimentScore?: SortOrder
    listingGain?: SortOrder
    currentReturn?: SortOrder
    volatilityIndex?: SortOrder
    totalGMPChanges?: SortOrder
    totalSubscriptions?: SortOrder
    oversubscribedCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IPOAnalyticsSumOrderByAggregateInput = {
    avgGMP?: SortOrder
    maxGMP?: SortOrder
    minGMP?: SortOrder
    gmpVolume?: SortOrder
    overallSubscription?: SortOrder
    retailSubscription?: SortOrder
    qibSubscription?: SortOrder
    hniSubscription?: SortOrder
    sentimentScore?: SortOrder
    listingGain?: SortOrder
    currentReturn?: SortOrder
    volatilityIndex?: SortOrder
    totalGMPChanges?: SortOrder
    totalSubscriptions?: SortOrder
    oversubscribedCount?: SortOrder
  }

  export type UserWatchlistUserIdIpoIdCompoundUniqueInput = {
    userId: string
    ipoId: string
  }

  export type UserWatchlistCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    ipoId?: SortOrder
    notes?: SortOrder
    alertPreferences?: SortOrder
    addedAt?: SortOrder
  }

  export type UserWatchlistMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    ipoId?: SortOrder
    notes?: SortOrder
    alertPreferences?: SortOrder
    addedAt?: SortOrder
  }

  export type UserWatchlistMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    ipoId?: SortOrder
    notes?: SortOrder
    alertPreferences?: SortOrder
    addedAt?: SortOrder
  }

  export type IPONullableRelationFilter = {
    is?: IPOWhereInput | null
    isNot?: IPOWhereInput | null
  }

  export type UserAlertCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    ipoId?: SortOrder
    symbol?: SortOrder
    alertType?: SortOrder
    triggerType?: SortOrder
    triggerValue?: SortOrder
    triggerCondition?: SortOrder
    message?: SortOrder
    isActive?: SortOrder
    lastTriggered?: SortOrder
    triggerCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAlertAvgOrderByAggregateInput = {
    triggerValue?: SortOrder
    triggerCount?: SortOrder
  }

  export type UserAlertMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    ipoId?: SortOrder
    symbol?: SortOrder
    alertType?: SortOrder
    triggerType?: SortOrder
    triggerValue?: SortOrder
    triggerCondition?: SortOrder
    message?: SortOrder
    isActive?: SortOrder
    lastTriggered?: SortOrder
    triggerCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAlertMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    ipoId?: SortOrder
    symbol?: SortOrder
    alertType?: SortOrder
    triggerType?: SortOrder
    triggerValue?: SortOrder
    triggerCondition?: SortOrder
    message?: SortOrder
    isActive?: SortOrder
    lastTriggered?: SortOrder
    triggerCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAlertSumOrderByAggregateInput = {
    triggerValue?: SortOrder
    triggerCount?: SortOrder
  }

  export type SystemConfigCountOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    description?: SortOrder
    category?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemConfigMaxOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    description?: SortOrder
    category?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemConfigMinOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    description?: SortOrder
    category?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ApiLogCountOrderByAggregateInput = {
    id?: SortOrder
    endpoint?: SortOrder
    method?: SortOrder
    statusCode?: SortOrder
    responseTime?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    userId?: SortOrder
    errorMessage?: SortOrder
    requestData?: SortOrder
    responseData?: SortOrder
    timestamp?: SortOrder
  }

  export type ApiLogAvgOrderByAggregateInput = {
    statusCode?: SortOrder
    responseTime?: SortOrder
  }

  export type ApiLogMaxOrderByAggregateInput = {
    id?: SortOrder
    endpoint?: SortOrder
    method?: SortOrder
    statusCode?: SortOrder
    responseTime?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    userId?: SortOrder
    errorMessage?: SortOrder
    requestData?: SortOrder
    responseData?: SortOrder
    timestamp?: SortOrder
  }

  export type ApiLogMinOrderByAggregateInput = {
    id?: SortOrder
    endpoint?: SortOrder
    method?: SortOrder
    statusCode?: SortOrder
    responseTime?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    userId?: SortOrder
    errorMessage?: SortOrder
    requestData?: SortOrder
    responseData?: SortOrder
    timestamp?: SortOrder
  }

  export type ApiLogSumOrderByAggregateInput = {
    statusCode?: SortOrder
    responseTime?: SortOrder
  }

  export type MarketStatusCountOrderByAggregateInput = {
    id?: SortOrder
    exchange?: SortOrder
    isOpen?: SortOrder
    openTime?: SortOrder
    closeTime?: SortOrder
    timezone?: SortOrder
    holidays?: SortOrder
    lastUpdated?: SortOrder
  }

  export type MarketStatusMaxOrderByAggregateInput = {
    id?: SortOrder
    exchange?: SortOrder
    isOpen?: SortOrder
    openTime?: SortOrder
    closeTime?: SortOrder
    timezone?: SortOrder
    holidays?: SortOrder
    lastUpdated?: SortOrder
  }

  export type MarketStatusMinOrderByAggregateInput = {
    id?: SortOrder
    exchange?: SortOrder
    isOpen?: SortOrder
    openTime?: SortOrder
    closeTime?: SortOrder
    timezone?: SortOrder
    holidays?: SortOrder
    lastUpdated?: SortOrder
  }

  export type CacheEntryCountOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    tags?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CacheEntryMaxOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    tags?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CacheEntryMinOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    tags?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SyncLogCountOrderByAggregateInput = {
    id?: SortOrder
    source?: SortOrder
    type?: SortOrder
    status?: SortOrder
    recordsProcessed?: SortOrder
    recordsSuccess?: SortOrder
    recordsError?: SortOrder
    errorDetails?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    duration?: SortOrder
    metadata?: SortOrder
  }

  export type SyncLogAvgOrderByAggregateInput = {
    recordsProcessed?: SortOrder
    recordsSuccess?: SortOrder
    recordsError?: SortOrder
    duration?: SortOrder
  }

  export type SyncLogMaxOrderByAggregateInput = {
    id?: SortOrder
    source?: SortOrder
    type?: SortOrder
    status?: SortOrder
    recordsProcessed?: SortOrder
    recordsSuccess?: SortOrder
    recordsError?: SortOrder
    errorDetails?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    duration?: SortOrder
    metadata?: SortOrder
  }

  export type SyncLogMinOrderByAggregateInput = {
    id?: SortOrder
    source?: SortOrder
    type?: SortOrder
    status?: SortOrder
    recordsProcessed?: SortOrder
    recordsSuccess?: SortOrder
    recordsError?: SortOrder
    errorDetails?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    duration?: SortOrder
    metadata?: SortOrder
  }

  export type SyncLogSumOrderByAggregateInput = {
    recordsProcessed?: SortOrder
    recordsSuccess?: SortOrder
    recordsError?: SortOrder
    duration?: SortOrder
  }

  export type GMPCreateNestedManyWithoutIpoInput = {
    create?: XOR<GMPCreateWithoutIpoInput, GMPUncheckedCreateWithoutIpoInput> | GMPCreateWithoutIpoInput[] | GMPUncheckedCreateWithoutIpoInput[]
    connectOrCreate?: GMPCreateOrConnectWithoutIpoInput | GMPCreateOrConnectWithoutIpoInput[]
    createMany?: GMPCreateManyIpoInputEnvelope
    connect?: GMPWhereUniqueInput | GMPWhereUniqueInput[]
  }

  export type SubscriptionDataCreateNestedManyWithoutIpoInput = {
    create?: XOR<SubscriptionDataCreateWithoutIpoInput, SubscriptionDataUncheckedCreateWithoutIpoInput> | SubscriptionDataCreateWithoutIpoInput[] | SubscriptionDataUncheckedCreateWithoutIpoInput[]
    connectOrCreate?: SubscriptionDataCreateOrConnectWithoutIpoInput | SubscriptionDataCreateOrConnectWithoutIpoInput[]
    createMany?: SubscriptionDataCreateManyIpoInputEnvelope
    connect?: SubscriptionDataWhereUniqueInput | SubscriptionDataWhereUniqueInput[]
  }

  export type AllotmentDataCreateNestedManyWithoutIpoInput = {
    create?: XOR<AllotmentDataCreateWithoutIpoInput, AllotmentDataUncheckedCreateWithoutIpoInput> | AllotmentDataCreateWithoutIpoInput[] | AllotmentDataUncheckedCreateWithoutIpoInput[]
    connectOrCreate?: AllotmentDataCreateOrConnectWithoutIpoInput | AllotmentDataCreateOrConnectWithoutIpoInput[]
    createMany?: AllotmentDataCreateManyIpoInputEnvelope
    connect?: AllotmentDataWhereUniqueInput | AllotmentDataWhereUniqueInput[]
  }

  export type IPOAnalyticsCreateNestedManyWithoutIpoInput = {
    create?: XOR<IPOAnalyticsCreateWithoutIpoInput, IPOAnalyticsUncheckedCreateWithoutIpoInput> | IPOAnalyticsCreateWithoutIpoInput[] | IPOAnalyticsUncheckedCreateWithoutIpoInput[]
    connectOrCreate?: IPOAnalyticsCreateOrConnectWithoutIpoInput | IPOAnalyticsCreateOrConnectWithoutIpoInput[]
    createMany?: IPOAnalyticsCreateManyIpoInputEnvelope
    connect?: IPOAnalyticsWhereUniqueInput | IPOAnalyticsWhereUniqueInput[]
  }

  export type UserWatchlistCreateNestedManyWithoutIpoInput = {
    create?: XOR<UserWatchlistCreateWithoutIpoInput, UserWatchlistUncheckedCreateWithoutIpoInput> | UserWatchlistCreateWithoutIpoInput[] | UserWatchlistUncheckedCreateWithoutIpoInput[]
    connectOrCreate?: UserWatchlistCreateOrConnectWithoutIpoInput | UserWatchlistCreateOrConnectWithoutIpoInput[]
    createMany?: UserWatchlistCreateManyIpoInputEnvelope
    connect?: UserWatchlistWhereUniqueInput | UserWatchlistWhereUniqueInput[]
  }

  export type UserAlertCreateNestedManyWithoutIpoInput = {
    create?: XOR<UserAlertCreateWithoutIpoInput, UserAlertUncheckedCreateWithoutIpoInput> | UserAlertCreateWithoutIpoInput[] | UserAlertUncheckedCreateWithoutIpoInput[]
    connectOrCreate?: UserAlertCreateOrConnectWithoutIpoInput | UserAlertCreateOrConnectWithoutIpoInput[]
    createMany?: UserAlertCreateManyIpoInputEnvelope
    connect?: UserAlertWhereUniqueInput | UserAlertWhereUniqueInput[]
  }

  export type GMPUncheckedCreateNestedManyWithoutIpoInput = {
    create?: XOR<GMPCreateWithoutIpoInput, GMPUncheckedCreateWithoutIpoInput> | GMPCreateWithoutIpoInput[] | GMPUncheckedCreateWithoutIpoInput[]
    connectOrCreate?: GMPCreateOrConnectWithoutIpoInput | GMPCreateOrConnectWithoutIpoInput[]
    createMany?: GMPCreateManyIpoInputEnvelope
    connect?: GMPWhereUniqueInput | GMPWhereUniqueInput[]
  }

  export type SubscriptionDataUncheckedCreateNestedManyWithoutIpoInput = {
    create?: XOR<SubscriptionDataCreateWithoutIpoInput, SubscriptionDataUncheckedCreateWithoutIpoInput> | SubscriptionDataCreateWithoutIpoInput[] | SubscriptionDataUncheckedCreateWithoutIpoInput[]
    connectOrCreate?: SubscriptionDataCreateOrConnectWithoutIpoInput | SubscriptionDataCreateOrConnectWithoutIpoInput[]
    createMany?: SubscriptionDataCreateManyIpoInputEnvelope
    connect?: SubscriptionDataWhereUniqueInput | SubscriptionDataWhereUniqueInput[]
  }

  export type AllotmentDataUncheckedCreateNestedManyWithoutIpoInput = {
    create?: XOR<AllotmentDataCreateWithoutIpoInput, AllotmentDataUncheckedCreateWithoutIpoInput> | AllotmentDataCreateWithoutIpoInput[] | AllotmentDataUncheckedCreateWithoutIpoInput[]
    connectOrCreate?: AllotmentDataCreateOrConnectWithoutIpoInput | AllotmentDataCreateOrConnectWithoutIpoInput[]
    createMany?: AllotmentDataCreateManyIpoInputEnvelope
    connect?: AllotmentDataWhereUniqueInput | AllotmentDataWhereUniqueInput[]
  }

  export type IPOAnalyticsUncheckedCreateNestedManyWithoutIpoInput = {
    create?: XOR<IPOAnalyticsCreateWithoutIpoInput, IPOAnalyticsUncheckedCreateWithoutIpoInput> | IPOAnalyticsCreateWithoutIpoInput[] | IPOAnalyticsUncheckedCreateWithoutIpoInput[]
    connectOrCreate?: IPOAnalyticsCreateOrConnectWithoutIpoInput | IPOAnalyticsCreateOrConnectWithoutIpoInput[]
    createMany?: IPOAnalyticsCreateManyIpoInputEnvelope
    connect?: IPOAnalyticsWhereUniqueInput | IPOAnalyticsWhereUniqueInput[]
  }

  export type UserWatchlistUncheckedCreateNestedManyWithoutIpoInput = {
    create?: XOR<UserWatchlistCreateWithoutIpoInput, UserWatchlistUncheckedCreateWithoutIpoInput> | UserWatchlistCreateWithoutIpoInput[] | UserWatchlistUncheckedCreateWithoutIpoInput[]
    connectOrCreate?: UserWatchlistCreateOrConnectWithoutIpoInput | UserWatchlistCreateOrConnectWithoutIpoInput[]
    createMany?: UserWatchlistCreateManyIpoInputEnvelope
    connect?: UserWatchlistWhereUniqueInput | UserWatchlistWhereUniqueInput[]
  }

  export type UserAlertUncheckedCreateNestedManyWithoutIpoInput = {
    create?: XOR<UserAlertCreateWithoutIpoInput, UserAlertUncheckedCreateWithoutIpoInput> | UserAlertCreateWithoutIpoInput[] | UserAlertUncheckedCreateWithoutIpoInput[]
    connectOrCreate?: UserAlertCreateOrConnectWithoutIpoInput | UserAlertCreateOrConnectWithoutIpoInput[]
    createMany?: UserAlertCreateManyIpoInputEnvelope
    connect?: UserAlertWhereUniqueInput | UserAlertWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableBigIntFieldUpdateOperationsInput = {
    set?: bigint | number | null
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type GMPUpdateManyWithoutIpoNestedInput = {
    create?: XOR<GMPCreateWithoutIpoInput, GMPUncheckedCreateWithoutIpoInput> | GMPCreateWithoutIpoInput[] | GMPUncheckedCreateWithoutIpoInput[]
    connectOrCreate?: GMPCreateOrConnectWithoutIpoInput | GMPCreateOrConnectWithoutIpoInput[]
    upsert?: GMPUpsertWithWhereUniqueWithoutIpoInput | GMPUpsertWithWhereUniqueWithoutIpoInput[]
    createMany?: GMPCreateManyIpoInputEnvelope
    set?: GMPWhereUniqueInput | GMPWhereUniqueInput[]
    disconnect?: GMPWhereUniqueInput | GMPWhereUniqueInput[]
    delete?: GMPWhereUniqueInput | GMPWhereUniqueInput[]
    connect?: GMPWhereUniqueInput | GMPWhereUniqueInput[]
    update?: GMPUpdateWithWhereUniqueWithoutIpoInput | GMPUpdateWithWhereUniqueWithoutIpoInput[]
    updateMany?: GMPUpdateManyWithWhereWithoutIpoInput | GMPUpdateManyWithWhereWithoutIpoInput[]
    deleteMany?: GMPScalarWhereInput | GMPScalarWhereInput[]
  }

  export type SubscriptionDataUpdateManyWithoutIpoNestedInput = {
    create?: XOR<SubscriptionDataCreateWithoutIpoInput, SubscriptionDataUncheckedCreateWithoutIpoInput> | SubscriptionDataCreateWithoutIpoInput[] | SubscriptionDataUncheckedCreateWithoutIpoInput[]
    connectOrCreate?: SubscriptionDataCreateOrConnectWithoutIpoInput | SubscriptionDataCreateOrConnectWithoutIpoInput[]
    upsert?: SubscriptionDataUpsertWithWhereUniqueWithoutIpoInput | SubscriptionDataUpsertWithWhereUniqueWithoutIpoInput[]
    createMany?: SubscriptionDataCreateManyIpoInputEnvelope
    set?: SubscriptionDataWhereUniqueInput | SubscriptionDataWhereUniqueInput[]
    disconnect?: SubscriptionDataWhereUniqueInput | SubscriptionDataWhereUniqueInput[]
    delete?: SubscriptionDataWhereUniqueInput | SubscriptionDataWhereUniqueInput[]
    connect?: SubscriptionDataWhereUniqueInput | SubscriptionDataWhereUniqueInput[]
    update?: SubscriptionDataUpdateWithWhereUniqueWithoutIpoInput | SubscriptionDataUpdateWithWhereUniqueWithoutIpoInput[]
    updateMany?: SubscriptionDataUpdateManyWithWhereWithoutIpoInput | SubscriptionDataUpdateManyWithWhereWithoutIpoInput[]
    deleteMany?: SubscriptionDataScalarWhereInput | SubscriptionDataScalarWhereInput[]
  }

  export type AllotmentDataUpdateManyWithoutIpoNestedInput = {
    create?: XOR<AllotmentDataCreateWithoutIpoInput, AllotmentDataUncheckedCreateWithoutIpoInput> | AllotmentDataCreateWithoutIpoInput[] | AllotmentDataUncheckedCreateWithoutIpoInput[]
    connectOrCreate?: AllotmentDataCreateOrConnectWithoutIpoInput | AllotmentDataCreateOrConnectWithoutIpoInput[]
    upsert?: AllotmentDataUpsertWithWhereUniqueWithoutIpoInput | AllotmentDataUpsertWithWhereUniqueWithoutIpoInput[]
    createMany?: AllotmentDataCreateManyIpoInputEnvelope
    set?: AllotmentDataWhereUniqueInput | AllotmentDataWhereUniqueInput[]
    disconnect?: AllotmentDataWhereUniqueInput | AllotmentDataWhereUniqueInput[]
    delete?: AllotmentDataWhereUniqueInput | AllotmentDataWhereUniqueInput[]
    connect?: AllotmentDataWhereUniqueInput | AllotmentDataWhereUniqueInput[]
    update?: AllotmentDataUpdateWithWhereUniqueWithoutIpoInput | AllotmentDataUpdateWithWhereUniqueWithoutIpoInput[]
    updateMany?: AllotmentDataUpdateManyWithWhereWithoutIpoInput | AllotmentDataUpdateManyWithWhereWithoutIpoInput[]
    deleteMany?: AllotmentDataScalarWhereInput | AllotmentDataScalarWhereInput[]
  }

  export type IPOAnalyticsUpdateManyWithoutIpoNestedInput = {
    create?: XOR<IPOAnalyticsCreateWithoutIpoInput, IPOAnalyticsUncheckedCreateWithoutIpoInput> | IPOAnalyticsCreateWithoutIpoInput[] | IPOAnalyticsUncheckedCreateWithoutIpoInput[]
    connectOrCreate?: IPOAnalyticsCreateOrConnectWithoutIpoInput | IPOAnalyticsCreateOrConnectWithoutIpoInput[]
    upsert?: IPOAnalyticsUpsertWithWhereUniqueWithoutIpoInput | IPOAnalyticsUpsertWithWhereUniqueWithoutIpoInput[]
    createMany?: IPOAnalyticsCreateManyIpoInputEnvelope
    set?: IPOAnalyticsWhereUniqueInput | IPOAnalyticsWhereUniqueInput[]
    disconnect?: IPOAnalyticsWhereUniqueInput | IPOAnalyticsWhereUniqueInput[]
    delete?: IPOAnalyticsWhereUniqueInput | IPOAnalyticsWhereUniqueInput[]
    connect?: IPOAnalyticsWhereUniqueInput | IPOAnalyticsWhereUniqueInput[]
    update?: IPOAnalyticsUpdateWithWhereUniqueWithoutIpoInput | IPOAnalyticsUpdateWithWhereUniqueWithoutIpoInput[]
    updateMany?: IPOAnalyticsUpdateManyWithWhereWithoutIpoInput | IPOAnalyticsUpdateManyWithWhereWithoutIpoInput[]
    deleteMany?: IPOAnalyticsScalarWhereInput | IPOAnalyticsScalarWhereInput[]
  }

  export type UserWatchlistUpdateManyWithoutIpoNestedInput = {
    create?: XOR<UserWatchlistCreateWithoutIpoInput, UserWatchlistUncheckedCreateWithoutIpoInput> | UserWatchlistCreateWithoutIpoInput[] | UserWatchlistUncheckedCreateWithoutIpoInput[]
    connectOrCreate?: UserWatchlistCreateOrConnectWithoutIpoInput | UserWatchlistCreateOrConnectWithoutIpoInput[]
    upsert?: UserWatchlistUpsertWithWhereUniqueWithoutIpoInput | UserWatchlistUpsertWithWhereUniqueWithoutIpoInput[]
    createMany?: UserWatchlistCreateManyIpoInputEnvelope
    set?: UserWatchlistWhereUniqueInput | UserWatchlistWhereUniqueInput[]
    disconnect?: UserWatchlistWhereUniqueInput | UserWatchlistWhereUniqueInput[]
    delete?: UserWatchlistWhereUniqueInput | UserWatchlistWhereUniqueInput[]
    connect?: UserWatchlistWhereUniqueInput | UserWatchlistWhereUniqueInput[]
    update?: UserWatchlistUpdateWithWhereUniqueWithoutIpoInput | UserWatchlistUpdateWithWhereUniqueWithoutIpoInput[]
    updateMany?: UserWatchlistUpdateManyWithWhereWithoutIpoInput | UserWatchlistUpdateManyWithWhereWithoutIpoInput[]
    deleteMany?: UserWatchlistScalarWhereInput | UserWatchlistScalarWhereInput[]
  }

  export type UserAlertUpdateManyWithoutIpoNestedInput = {
    create?: XOR<UserAlertCreateWithoutIpoInput, UserAlertUncheckedCreateWithoutIpoInput> | UserAlertCreateWithoutIpoInput[] | UserAlertUncheckedCreateWithoutIpoInput[]
    connectOrCreate?: UserAlertCreateOrConnectWithoutIpoInput | UserAlertCreateOrConnectWithoutIpoInput[]
    upsert?: UserAlertUpsertWithWhereUniqueWithoutIpoInput | UserAlertUpsertWithWhereUniqueWithoutIpoInput[]
    createMany?: UserAlertCreateManyIpoInputEnvelope
    set?: UserAlertWhereUniqueInput | UserAlertWhereUniqueInput[]
    disconnect?: UserAlertWhereUniqueInput | UserAlertWhereUniqueInput[]
    delete?: UserAlertWhereUniqueInput | UserAlertWhereUniqueInput[]
    connect?: UserAlertWhereUniqueInput | UserAlertWhereUniqueInput[]
    update?: UserAlertUpdateWithWhereUniqueWithoutIpoInput | UserAlertUpdateWithWhereUniqueWithoutIpoInput[]
    updateMany?: UserAlertUpdateManyWithWhereWithoutIpoInput | UserAlertUpdateManyWithWhereWithoutIpoInput[]
    deleteMany?: UserAlertScalarWhereInput | UserAlertScalarWhereInput[]
  }

  export type GMPUncheckedUpdateManyWithoutIpoNestedInput = {
    create?: XOR<GMPCreateWithoutIpoInput, GMPUncheckedCreateWithoutIpoInput> | GMPCreateWithoutIpoInput[] | GMPUncheckedCreateWithoutIpoInput[]
    connectOrCreate?: GMPCreateOrConnectWithoutIpoInput | GMPCreateOrConnectWithoutIpoInput[]
    upsert?: GMPUpsertWithWhereUniqueWithoutIpoInput | GMPUpsertWithWhereUniqueWithoutIpoInput[]
    createMany?: GMPCreateManyIpoInputEnvelope
    set?: GMPWhereUniqueInput | GMPWhereUniqueInput[]
    disconnect?: GMPWhereUniqueInput | GMPWhereUniqueInput[]
    delete?: GMPWhereUniqueInput | GMPWhereUniqueInput[]
    connect?: GMPWhereUniqueInput | GMPWhereUniqueInput[]
    update?: GMPUpdateWithWhereUniqueWithoutIpoInput | GMPUpdateWithWhereUniqueWithoutIpoInput[]
    updateMany?: GMPUpdateManyWithWhereWithoutIpoInput | GMPUpdateManyWithWhereWithoutIpoInput[]
    deleteMany?: GMPScalarWhereInput | GMPScalarWhereInput[]
  }

  export type SubscriptionDataUncheckedUpdateManyWithoutIpoNestedInput = {
    create?: XOR<SubscriptionDataCreateWithoutIpoInput, SubscriptionDataUncheckedCreateWithoutIpoInput> | SubscriptionDataCreateWithoutIpoInput[] | SubscriptionDataUncheckedCreateWithoutIpoInput[]
    connectOrCreate?: SubscriptionDataCreateOrConnectWithoutIpoInput | SubscriptionDataCreateOrConnectWithoutIpoInput[]
    upsert?: SubscriptionDataUpsertWithWhereUniqueWithoutIpoInput | SubscriptionDataUpsertWithWhereUniqueWithoutIpoInput[]
    createMany?: SubscriptionDataCreateManyIpoInputEnvelope
    set?: SubscriptionDataWhereUniqueInput | SubscriptionDataWhereUniqueInput[]
    disconnect?: SubscriptionDataWhereUniqueInput | SubscriptionDataWhereUniqueInput[]
    delete?: SubscriptionDataWhereUniqueInput | SubscriptionDataWhereUniqueInput[]
    connect?: SubscriptionDataWhereUniqueInput | SubscriptionDataWhereUniqueInput[]
    update?: SubscriptionDataUpdateWithWhereUniqueWithoutIpoInput | SubscriptionDataUpdateWithWhereUniqueWithoutIpoInput[]
    updateMany?: SubscriptionDataUpdateManyWithWhereWithoutIpoInput | SubscriptionDataUpdateManyWithWhereWithoutIpoInput[]
    deleteMany?: SubscriptionDataScalarWhereInput | SubscriptionDataScalarWhereInput[]
  }

  export type AllotmentDataUncheckedUpdateManyWithoutIpoNestedInput = {
    create?: XOR<AllotmentDataCreateWithoutIpoInput, AllotmentDataUncheckedCreateWithoutIpoInput> | AllotmentDataCreateWithoutIpoInput[] | AllotmentDataUncheckedCreateWithoutIpoInput[]
    connectOrCreate?: AllotmentDataCreateOrConnectWithoutIpoInput | AllotmentDataCreateOrConnectWithoutIpoInput[]
    upsert?: AllotmentDataUpsertWithWhereUniqueWithoutIpoInput | AllotmentDataUpsertWithWhereUniqueWithoutIpoInput[]
    createMany?: AllotmentDataCreateManyIpoInputEnvelope
    set?: AllotmentDataWhereUniqueInput | AllotmentDataWhereUniqueInput[]
    disconnect?: AllotmentDataWhereUniqueInput | AllotmentDataWhereUniqueInput[]
    delete?: AllotmentDataWhereUniqueInput | AllotmentDataWhereUniqueInput[]
    connect?: AllotmentDataWhereUniqueInput | AllotmentDataWhereUniqueInput[]
    update?: AllotmentDataUpdateWithWhereUniqueWithoutIpoInput | AllotmentDataUpdateWithWhereUniqueWithoutIpoInput[]
    updateMany?: AllotmentDataUpdateManyWithWhereWithoutIpoInput | AllotmentDataUpdateManyWithWhereWithoutIpoInput[]
    deleteMany?: AllotmentDataScalarWhereInput | AllotmentDataScalarWhereInput[]
  }

  export type IPOAnalyticsUncheckedUpdateManyWithoutIpoNestedInput = {
    create?: XOR<IPOAnalyticsCreateWithoutIpoInput, IPOAnalyticsUncheckedCreateWithoutIpoInput> | IPOAnalyticsCreateWithoutIpoInput[] | IPOAnalyticsUncheckedCreateWithoutIpoInput[]
    connectOrCreate?: IPOAnalyticsCreateOrConnectWithoutIpoInput | IPOAnalyticsCreateOrConnectWithoutIpoInput[]
    upsert?: IPOAnalyticsUpsertWithWhereUniqueWithoutIpoInput | IPOAnalyticsUpsertWithWhereUniqueWithoutIpoInput[]
    createMany?: IPOAnalyticsCreateManyIpoInputEnvelope
    set?: IPOAnalyticsWhereUniqueInput | IPOAnalyticsWhereUniqueInput[]
    disconnect?: IPOAnalyticsWhereUniqueInput | IPOAnalyticsWhereUniqueInput[]
    delete?: IPOAnalyticsWhereUniqueInput | IPOAnalyticsWhereUniqueInput[]
    connect?: IPOAnalyticsWhereUniqueInput | IPOAnalyticsWhereUniqueInput[]
    update?: IPOAnalyticsUpdateWithWhereUniqueWithoutIpoInput | IPOAnalyticsUpdateWithWhereUniqueWithoutIpoInput[]
    updateMany?: IPOAnalyticsUpdateManyWithWhereWithoutIpoInput | IPOAnalyticsUpdateManyWithWhereWithoutIpoInput[]
    deleteMany?: IPOAnalyticsScalarWhereInput | IPOAnalyticsScalarWhereInput[]
  }

  export type UserWatchlistUncheckedUpdateManyWithoutIpoNestedInput = {
    create?: XOR<UserWatchlistCreateWithoutIpoInput, UserWatchlistUncheckedCreateWithoutIpoInput> | UserWatchlistCreateWithoutIpoInput[] | UserWatchlistUncheckedCreateWithoutIpoInput[]
    connectOrCreate?: UserWatchlistCreateOrConnectWithoutIpoInput | UserWatchlistCreateOrConnectWithoutIpoInput[]
    upsert?: UserWatchlistUpsertWithWhereUniqueWithoutIpoInput | UserWatchlistUpsertWithWhereUniqueWithoutIpoInput[]
    createMany?: UserWatchlistCreateManyIpoInputEnvelope
    set?: UserWatchlistWhereUniqueInput | UserWatchlistWhereUniqueInput[]
    disconnect?: UserWatchlistWhereUniqueInput | UserWatchlistWhereUniqueInput[]
    delete?: UserWatchlistWhereUniqueInput | UserWatchlistWhereUniqueInput[]
    connect?: UserWatchlistWhereUniqueInput | UserWatchlistWhereUniqueInput[]
    update?: UserWatchlistUpdateWithWhereUniqueWithoutIpoInput | UserWatchlistUpdateWithWhereUniqueWithoutIpoInput[]
    updateMany?: UserWatchlistUpdateManyWithWhereWithoutIpoInput | UserWatchlistUpdateManyWithWhereWithoutIpoInput[]
    deleteMany?: UserWatchlistScalarWhereInput | UserWatchlistScalarWhereInput[]
  }

  export type UserAlertUncheckedUpdateManyWithoutIpoNestedInput = {
    create?: XOR<UserAlertCreateWithoutIpoInput, UserAlertUncheckedCreateWithoutIpoInput> | UserAlertCreateWithoutIpoInput[] | UserAlertUncheckedCreateWithoutIpoInput[]
    connectOrCreate?: UserAlertCreateOrConnectWithoutIpoInput | UserAlertCreateOrConnectWithoutIpoInput[]
    upsert?: UserAlertUpsertWithWhereUniqueWithoutIpoInput | UserAlertUpsertWithWhereUniqueWithoutIpoInput[]
    createMany?: UserAlertCreateManyIpoInputEnvelope
    set?: UserAlertWhereUniqueInput | UserAlertWhereUniqueInput[]
    disconnect?: UserAlertWhereUniqueInput | UserAlertWhereUniqueInput[]
    delete?: UserAlertWhereUniqueInput | UserAlertWhereUniqueInput[]
    connect?: UserAlertWhereUniqueInput | UserAlertWhereUniqueInput[]
    update?: UserAlertUpdateWithWhereUniqueWithoutIpoInput | UserAlertUpdateWithWhereUniqueWithoutIpoInput[]
    updateMany?: UserAlertUpdateManyWithWhereWithoutIpoInput | UserAlertUpdateManyWithWhereWithoutIpoInput[]
    deleteMany?: UserAlertScalarWhereInput | UserAlertScalarWhereInput[]
  }

  export type IPOCreateNestedOneWithoutGmpDataInput = {
    create?: XOR<IPOCreateWithoutGmpDataInput, IPOUncheckedCreateWithoutGmpDataInput>
    connectOrCreate?: IPOCreateOrConnectWithoutGmpDataInput
    connect?: IPOWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type IPOUpdateOneRequiredWithoutGmpDataNestedInput = {
    create?: XOR<IPOCreateWithoutGmpDataInput, IPOUncheckedCreateWithoutGmpDataInput>
    connectOrCreate?: IPOCreateOrConnectWithoutGmpDataInput
    upsert?: IPOUpsertWithoutGmpDataInput
    connect?: IPOWhereUniqueInput
    update?: XOR<XOR<IPOUpdateToOneWithWhereWithoutGmpDataInput, IPOUpdateWithoutGmpDataInput>, IPOUncheckedUpdateWithoutGmpDataInput>
  }

  export type IPOCreateNestedOneWithoutSubscriptionDataInput = {
    create?: XOR<IPOCreateWithoutSubscriptionDataInput, IPOUncheckedCreateWithoutSubscriptionDataInput>
    connectOrCreate?: IPOCreateOrConnectWithoutSubscriptionDataInput
    connect?: IPOWhereUniqueInput
  }

  export type IPOUpdateOneRequiredWithoutSubscriptionDataNestedInput = {
    create?: XOR<IPOCreateWithoutSubscriptionDataInput, IPOUncheckedCreateWithoutSubscriptionDataInput>
    connectOrCreate?: IPOCreateOrConnectWithoutSubscriptionDataInput
    upsert?: IPOUpsertWithoutSubscriptionDataInput
    connect?: IPOWhereUniqueInput
    update?: XOR<XOR<IPOUpdateToOneWithWhereWithoutSubscriptionDataInput, IPOUpdateWithoutSubscriptionDataInput>, IPOUncheckedUpdateWithoutSubscriptionDataInput>
  }

  export type IPOCreateNestedOneWithoutAllotmentDataInput = {
    create?: XOR<IPOCreateWithoutAllotmentDataInput, IPOUncheckedCreateWithoutAllotmentDataInput>
    connectOrCreate?: IPOCreateOrConnectWithoutAllotmentDataInput
    connect?: IPOWhereUniqueInput
  }

  export type IPOUpdateOneRequiredWithoutAllotmentDataNestedInput = {
    create?: XOR<IPOCreateWithoutAllotmentDataInput, IPOUncheckedCreateWithoutAllotmentDataInput>
    connectOrCreate?: IPOCreateOrConnectWithoutAllotmentDataInput
    upsert?: IPOUpsertWithoutAllotmentDataInput
    connect?: IPOWhereUniqueInput
    update?: XOR<XOR<IPOUpdateToOneWithWhereWithoutAllotmentDataInput, IPOUpdateWithoutAllotmentDataInput>, IPOUncheckedUpdateWithoutAllotmentDataInput>
  }

  export type UserWatchlistCreateNestedManyWithoutUserInput = {
    create?: XOR<UserWatchlistCreateWithoutUserInput, UserWatchlistUncheckedCreateWithoutUserInput> | UserWatchlistCreateWithoutUserInput[] | UserWatchlistUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserWatchlistCreateOrConnectWithoutUserInput | UserWatchlistCreateOrConnectWithoutUserInput[]
    createMany?: UserWatchlistCreateManyUserInputEnvelope
    connect?: UserWatchlistWhereUniqueInput | UserWatchlistWhereUniqueInput[]
  }

  export type UserAlertCreateNestedManyWithoutUserInput = {
    create?: XOR<UserAlertCreateWithoutUserInput, UserAlertUncheckedCreateWithoutUserInput> | UserAlertCreateWithoutUserInput[] | UserAlertUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAlertCreateOrConnectWithoutUserInput | UserAlertCreateOrConnectWithoutUserInput[]
    createMany?: UserAlertCreateManyUserInputEnvelope
    connect?: UserAlertWhereUniqueInput | UserAlertWhereUniqueInput[]
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type UserWatchlistUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserWatchlistCreateWithoutUserInput, UserWatchlistUncheckedCreateWithoutUserInput> | UserWatchlistCreateWithoutUserInput[] | UserWatchlistUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserWatchlistCreateOrConnectWithoutUserInput | UserWatchlistCreateOrConnectWithoutUserInput[]
    createMany?: UserWatchlistCreateManyUserInputEnvelope
    connect?: UserWatchlistWhereUniqueInput | UserWatchlistWhereUniqueInput[]
  }

  export type UserAlertUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserAlertCreateWithoutUserInput, UserAlertUncheckedCreateWithoutUserInput> | UserAlertCreateWithoutUserInput[] | UserAlertUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAlertCreateOrConnectWithoutUserInput | UserAlertCreateOrConnectWithoutUserInput[]
    createMany?: UserAlertCreateManyUserInputEnvelope
    connect?: UserAlertWhereUniqueInput | UserAlertWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type UserWatchlistUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserWatchlistCreateWithoutUserInput, UserWatchlistUncheckedCreateWithoutUserInput> | UserWatchlistCreateWithoutUserInput[] | UserWatchlistUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserWatchlistCreateOrConnectWithoutUserInput | UserWatchlistCreateOrConnectWithoutUserInput[]
    upsert?: UserWatchlistUpsertWithWhereUniqueWithoutUserInput | UserWatchlistUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserWatchlistCreateManyUserInputEnvelope
    set?: UserWatchlistWhereUniqueInput | UserWatchlistWhereUniqueInput[]
    disconnect?: UserWatchlistWhereUniqueInput | UserWatchlistWhereUniqueInput[]
    delete?: UserWatchlistWhereUniqueInput | UserWatchlistWhereUniqueInput[]
    connect?: UserWatchlistWhereUniqueInput | UserWatchlistWhereUniqueInput[]
    update?: UserWatchlistUpdateWithWhereUniqueWithoutUserInput | UserWatchlistUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserWatchlistUpdateManyWithWhereWithoutUserInput | UserWatchlistUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserWatchlistScalarWhereInput | UserWatchlistScalarWhereInput[]
  }

  export type UserAlertUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserAlertCreateWithoutUserInput, UserAlertUncheckedCreateWithoutUserInput> | UserAlertCreateWithoutUserInput[] | UserAlertUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAlertCreateOrConnectWithoutUserInput | UserAlertCreateOrConnectWithoutUserInput[]
    upsert?: UserAlertUpsertWithWhereUniqueWithoutUserInput | UserAlertUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserAlertCreateManyUserInputEnvelope
    set?: UserAlertWhereUniqueInput | UserAlertWhereUniqueInput[]
    disconnect?: UserAlertWhereUniqueInput | UserAlertWhereUniqueInput[]
    delete?: UserAlertWhereUniqueInput | UserAlertWhereUniqueInput[]
    connect?: UserAlertWhereUniqueInput | UserAlertWhereUniqueInput[]
    update?: UserAlertUpdateWithWhereUniqueWithoutUserInput | UserAlertUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserAlertUpdateManyWithWhereWithoutUserInput | UserAlertUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserAlertScalarWhereInput | UserAlertScalarWhereInput[]
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type UserWatchlistUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserWatchlistCreateWithoutUserInput, UserWatchlistUncheckedCreateWithoutUserInput> | UserWatchlistCreateWithoutUserInput[] | UserWatchlistUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserWatchlistCreateOrConnectWithoutUserInput | UserWatchlistCreateOrConnectWithoutUserInput[]
    upsert?: UserWatchlistUpsertWithWhereUniqueWithoutUserInput | UserWatchlistUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserWatchlistCreateManyUserInputEnvelope
    set?: UserWatchlistWhereUniqueInput | UserWatchlistWhereUniqueInput[]
    disconnect?: UserWatchlistWhereUniqueInput | UserWatchlistWhereUniqueInput[]
    delete?: UserWatchlistWhereUniqueInput | UserWatchlistWhereUniqueInput[]
    connect?: UserWatchlistWhereUniqueInput | UserWatchlistWhereUniqueInput[]
    update?: UserWatchlistUpdateWithWhereUniqueWithoutUserInput | UserWatchlistUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserWatchlistUpdateManyWithWhereWithoutUserInput | UserWatchlistUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserWatchlistScalarWhereInput | UserWatchlistScalarWhereInput[]
  }

  export type UserAlertUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserAlertCreateWithoutUserInput, UserAlertUncheckedCreateWithoutUserInput> | UserAlertCreateWithoutUserInput[] | UserAlertUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAlertCreateOrConnectWithoutUserInput | UserAlertCreateOrConnectWithoutUserInput[]
    upsert?: UserAlertUpsertWithWhereUniqueWithoutUserInput | UserAlertUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserAlertCreateManyUserInputEnvelope
    set?: UserAlertWhereUniqueInput | UserAlertWhereUniqueInput[]
    disconnect?: UserAlertWhereUniqueInput | UserAlertWhereUniqueInput[]
    delete?: UserAlertWhereUniqueInput | UserAlertWhereUniqueInput[]
    connect?: UserAlertWhereUniqueInput | UserAlertWhereUniqueInput[]
    update?: UserAlertUpdateWithWhereUniqueWithoutUserInput | UserAlertUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserAlertUpdateManyWithWhereWithoutUserInput | UserAlertUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserAlertScalarWhereInput | UserAlertScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type IPOCreateNestedOneWithoutAnalyticsInput = {
    create?: XOR<IPOCreateWithoutAnalyticsInput, IPOUncheckedCreateWithoutAnalyticsInput>
    connectOrCreate?: IPOCreateOrConnectWithoutAnalyticsInput
    connect?: IPOWhereUniqueInput
  }

  export type IPOUpdateOneRequiredWithoutAnalyticsNestedInput = {
    create?: XOR<IPOCreateWithoutAnalyticsInput, IPOUncheckedCreateWithoutAnalyticsInput>
    connectOrCreate?: IPOCreateOrConnectWithoutAnalyticsInput
    upsert?: IPOUpsertWithoutAnalyticsInput
    connect?: IPOWhereUniqueInput
    update?: XOR<XOR<IPOUpdateToOneWithWhereWithoutAnalyticsInput, IPOUpdateWithoutAnalyticsInput>, IPOUncheckedUpdateWithoutAnalyticsInput>
  }

  export type UserCreateNestedOneWithoutWatchlistsInput = {
    create?: XOR<UserCreateWithoutWatchlistsInput, UserUncheckedCreateWithoutWatchlistsInput>
    connectOrCreate?: UserCreateOrConnectWithoutWatchlistsInput
    connect?: UserWhereUniqueInput
  }

  export type IPOCreateNestedOneWithoutWatchlistsInput = {
    create?: XOR<IPOCreateWithoutWatchlistsInput, IPOUncheckedCreateWithoutWatchlistsInput>
    connectOrCreate?: IPOCreateOrConnectWithoutWatchlistsInput
    connect?: IPOWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutWatchlistsNestedInput = {
    create?: XOR<UserCreateWithoutWatchlistsInput, UserUncheckedCreateWithoutWatchlistsInput>
    connectOrCreate?: UserCreateOrConnectWithoutWatchlistsInput
    upsert?: UserUpsertWithoutWatchlistsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutWatchlistsInput, UserUpdateWithoutWatchlistsInput>, UserUncheckedUpdateWithoutWatchlistsInput>
  }

  export type IPOUpdateOneRequiredWithoutWatchlistsNestedInput = {
    create?: XOR<IPOCreateWithoutWatchlistsInput, IPOUncheckedCreateWithoutWatchlistsInput>
    connectOrCreate?: IPOCreateOrConnectWithoutWatchlistsInput
    upsert?: IPOUpsertWithoutWatchlistsInput
    connect?: IPOWhereUniqueInput
    update?: XOR<XOR<IPOUpdateToOneWithWhereWithoutWatchlistsInput, IPOUpdateWithoutWatchlistsInput>, IPOUncheckedUpdateWithoutWatchlistsInput>
  }

  export type UserCreateNestedOneWithoutAlertsInput = {
    create?: XOR<UserCreateWithoutAlertsInput, UserUncheckedCreateWithoutAlertsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAlertsInput
    connect?: UserWhereUniqueInput
  }

  export type IPOCreateNestedOneWithoutAlertsInput = {
    create?: XOR<IPOCreateWithoutAlertsInput, IPOUncheckedCreateWithoutAlertsInput>
    connectOrCreate?: IPOCreateOrConnectWithoutAlertsInput
    connect?: IPOWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAlertsNestedInput = {
    create?: XOR<UserCreateWithoutAlertsInput, UserUncheckedCreateWithoutAlertsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAlertsInput
    upsert?: UserUpsertWithoutAlertsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAlertsInput, UserUpdateWithoutAlertsInput>, UserUncheckedUpdateWithoutAlertsInput>
  }

  export type IPOUpdateOneWithoutAlertsNestedInput = {
    create?: XOR<IPOCreateWithoutAlertsInput, IPOUncheckedCreateWithoutAlertsInput>
    connectOrCreate?: IPOCreateOrConnectWithoutAlertsInput
    upsert?: IPOUpsertWithoutAlertsInput
    disconnect?: IPOWhereInput | boolean
    delete?: IPOWhereInput | boolean
    connect?: IPOWhereUniqueInput
    update?: XOR<XOR<IPOUpdateToOneWithWhereWithoutAlertsInput, IPOUpdateWithoutAlertsInput>, IPOUncheckedUpdateWithoutAlertsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedBigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedBigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedBigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type GMPCreateWithoutIpoInput = {
    id?: string
    value: number
    percentage: number
    volume?: number | null
    bidPrice?: number | null
    askPrice?: number | null
    timestamp: Date | string
    source: string
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GMPUncheckedCreateWithoutIpoInput = {
    id?: string
    value: number
    percentage: number
    volume?: number | null
    bidPrice?: number | null
    askPrice?: number | null
    timestamp: Date | string
    source: string
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GMPCreateOrConnectWithoutIpoInput = {
    where: GMPWhereUniqueInput
    create: XOR<GMPCreateWithoutIpoInput, GMPUncheckedCreateWithoutIpoInput>
  }

  export type GMPCreateManyIpoInputEnvelope = {
    data: GMPCreateManyIpoInput | GMPCreateManyIpoInput[]
    skipDuplicates?: boolean
  }

  export type SubscriptionDataCreateWithoutIpoInput = {
    id?: string
    category: string
    subCategory?: string | null
    quantity: bigint | number
    bidCount: number
    subscriptionRatio: number
    timestamp: Date | string
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionDataUncheckedCreateWithoutIpoInput = {
    id?: string
    category: string
    subCategory?: string | null
    quantity: bigint | number
    bidCount: number
    subscriptionRatio: number
    timestamp: Date | string
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionDataCreateOrConnectWithoutIpoInput = {
    where: SubscriptionDataWhereUniqueInput
    create: XOR<SubscriptionDataCreateWithoutIpoInput, SubscriptionDataUncheckedCreateWithoutIpoInput>
  }

  export type SubscriptionDataCreateManyIpoInputEnvelope = {
    data: SubscriptionDataCreateManyIpoInput | SubscriptionDataCreateManyIpoInput[]
    skipDuplicates?: boolean
  }

  export type AllotmentDataCreateWithoutIpoInput = {
    id?: string
    pan: string
    applicationNumber?: string | null
    category: string
    appliedQuantity: number
    allottedQuantity?: number
    allottedAmount?: number
    refundAmount?: number
    allotmentStatus: string
    timestamp: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AllotmentDataUncheckedCreateWithoutIpoInput = {
    id?: string
    pan: string
    applicationNumber?: string | null
    category: string
    appliedQuantity: number
    allottedQuantity?: number
    allottedAmount?: number
    refundAmount?: number
    allotmentStatus: string
    timestamp: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AllotmentDataCreateOrConnectWithoutIpoInput = {
    where: AllotmentDataWhereUniqueInput
    create: XOR<AllotmentDataCreateWithoutIpoInput, AllotmentDataUncheckedCreateWithoutIpoInput>
  }

  export type AllotmentDataCreateManyIpoInputEnvelope = {
    data: AllotmentDataCreateManyIpoInput | AllotmentDataCreateManyIpoInput[]
    skipDuplicates?: boolean
  }

  export type IPOAnalyticsCreateWithoutIpoInput = {
    id?: string
    symbol?: string | null
    date: Date | string
    avgGMP?: number | null
    maxGMP?: number | null
    minGMP?: number | null
    gmpVolume?: number | null
    gmpTrend?: string | null
    overallSubscription?: number | null
    retailSubscription?: number | null
    qibSubscription?: number | null
    hniSubscription?: number | null
    marketSentiment?: string | null
    sentimentScore?: number | null
    listingGain?: number | null
    currentReturn?: number | null
    volatilityIndex?: number | null
    totalGMPChanges?: number
    totalSubscriptions?: number
    oversubscribedCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IPOAnalyticsUncheckedCreateWithoutIpoInput = {
    id?: string
    symbol?: string | null
    date: Date | string
    avgGMP?: number | null
    maxGMP?: number | null
    minGMP?: number | null
    gmpVolume?: number | null
    gmpTrend?: string | null
    overallSubscription?: number | null
    retailSubscription?: number | null
    qibSubscription?: number | null
    hniSubscription?: number | null
    marketSentiment?: string | null
    sentimentScore?: number | null
    listingGain?: number | null
    currentReturn?: number | null
    volatilityIndex?: number | null
    totalGMPChanges?: number
    totalSubscriptions?: number
    oversubscribedCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IPOAnalyticsCreateOrConnectWithoutIpoInput = {
    where: IPOAnalyticsWhereUniqueInput
    create: XOR<IPOAnalyticsCreateWithoutIpoInput, IPOAnalyticsUncheckedCreateWithoutIpoInput>
  }

  export type IPOAnalyticsCreateManyIpoInputEnvelope = {
    data: IPOAnalyticsCreateManyIpoInput | IPOAnalyticsCreateManyIpoInput[]
    skipDuplicates?: boolean
  }

  export type UserWatchlistCreateWithoutIpoInput = {
    id?: string
    notes?: string | null
    alertPreferences?: string | null
    addedAt?: Date | string
    user: UserCreateNestedOneWithoutWatchlistsInput
  }

  export type UserWatchlistUncheckedCreateWithoutIpoInput = {
    id?: string
    userId: string
    notes?: string | null
    alertPreferences?: string | null
    addedAt?: Date | string
  }

  export type UserWatchlistCreateOrConnectWithoutIpoInput = {
    where: UserWatchlistWhereUniqueInput
    create: XOR<UserWatchlistCreateWithoutIpoInput, UserWatchlistUncheckedCreateWithoutIpoInput>
  }

  export type UserWatchlistCreateManyIpoInputEnvelope = {
    data: UserWatchlistCreateManyIpoInput | UserWatchlistCreateManyIpoInput[]
    skipDuplicates?: boolean
  }

  export type UserAlertCreateWithoutIpoInput = {
    id?: string
    symbol?: string | null
    alertType: string
    triggerType: string
    triggerValue?: number | null
    triggerCondition?: string | null
    message?: string | null
    isActive?: boolean
    lastTriggered?: Date | string | null
    triggerCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAlertsInput
  }

  export type UserAlertUncheckedCreateWithoutIpoInput = {
    id?: string
    userId: string
    symbol?: string | null
    alertType: string
    triggerType: string
    triggerValue?: number | null
    triggerCondition?: string | null
    message?: string | null
    isActive?: boolean
    lastTriggered?: Date | string | null
    triggerCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserAlertCreateOrConnectWithoutIpoInput = {
    where: UserAlertWhereUniqueInput
    create: XOR<UserAlertCreateWithoutIpoInput, UserAlertUncheckedCreateWithoutIpoInput>
  }

  export type UserAlertCreateManyIpoInputEnvelope = {
    data: UserAlertCreateManyIpoInput | UserAlertCreateManyIpoInput[]
    skipDuplicates?: boolean
  }

  export type GMPUpsertWithWhereUniqueWithoutIpoInput = {
    where: GMPWhereUniqueInput
    update: XOR<GMPUpdateWithoutIpoInput, GMPUncheckedUpdateWithoutIpoInput>
    create: XOR<GMPCreateWithoutIpoInput, GMPUncheckedCreateWithoutIpoInput>
  }

  export type GMPUpdateWithWhereUniqueWithoutIpoInput = {
    where: GMPWhereUniqueInput
    data: XOR<GMPUpdateWithoutIpoInput, GMPUncheckedUpdateWithoutIpoInput>
  }

  export type GMPUpdateManyWithWhereWithoutIpoInput = {
    where: GMPScalarWhereInput
    data: XOR<GMPUpdateManyMutationInput, GMPUncheckedUpdateManyWithoutIpoInput>
  }

  export type GMPScalarWhereInput = {
    AND?: GMPScalarWhereInput | GMPScalarWhereInput[]
    OR?: GMPScalarWhereInput[]
    NOT?: GMPScalarWhereInput | GMPScalarWhereInput[]
    id?: StringFilter<"GMP"> | string
    ipoId?: StringFilter<"GMP"> | string
    value?: FloatFilter<"GMP"> | number
    percentage?: FloatFilter<"GMP"> | number
    volume?: IntNullableFilter<"GMP"> | number | null
    bidPrice?: FloatNullableFilter<"GMP"> | number | null
    askPrice?: FloatNullableFilter<"GMP"> | number | null
    timestamp?: DateTimeFilter<"GMP"> | Date | string
    source?: StringFilter<"GMP"> | string
    metadata?: StringNullableFilter<"GMP"> | string | null
    createdAt?: DateTimeFilter<"GMP"> | Date | string
    updatedAt?: DateTimeFilter<"GMP"> | Date | string
  }

  export type SubscriptionDataUpsertWithWhereUniqueWithoutIpoInput = {
    where: SubscriptionDataWhereUniqueInput
    update: XOR<SubscriptionDataUpdateWithoutIpoInput, SubscriptionDataUncheckedUpdateWithoutIpoInput>
    create: XOR<SubscriptionDataCreateWithoutIpoInput, SubscriptionDataUncheckedCreateWithoutIpoInput>
  }

  export type SubscriptionDataUpdateWithWhereUniqueWithoutIpoInput = {
    where: SubscriptionDataWhereUniqueInput
    data: XOR<SubscriptionDataUpdateWithoutIpoInput, SubscriptionDataUncheckedUpdateWithoutIpoInput>
  }

  export type SubscriptionDataUpdateManyWithWhereWithoutIpoInput = {
    where: SubscriptionDataScalarWhereInput
    data: XOR<SubscriptionDataUpdateManyMutationInput, SubscriptionDataUncheckedUpdateManyWithoutIpoInput>
  }

  export type SubscriptionDataScalarWhereInput = {
    AND?: SubscriptionDataScalarWhereInput | SubscriptionDataScalarWhereInput[]
    OR?: SubscriptionDataScalarWhereInput[]
    NOT?: SubscriptionDataScalarWhereInput | SubscriptionDataScalarWhereInput[]
    id?: StringFilter<"SubscriptionData"> | string
    ipoId?: StringFilter<"SubscriptionData"> | string
    category?: StringFilter<"SubscriptionData"> | string
    subCategory?: StringNullableFilter<"SubscriptionData"> | string | null
    quantity?: BigIntFilter<"SubscriptionData"> | bigint | number
    bidCount?: IntFilter<"SubscriptionData"> | number
    subscriptionRatio?: FloatFilter<"SubscriptionData"> | number
    timestamp?: DateTimeFilter<"SubscriptionData"> | Date | string
    metadata?: StringNullableFilter<"SubscriptionData"> | string | null
    createdAt?: DateTimeFilter<"SubscriptionData"> | Date | string
    updatedAt?: DateTimeFilter<"SubscriptionData"> | Date | string
  }

  export type AllotmentDataUpsertWithWhereUniqueWithoutIpoInput = {
    where: AllotmentDataWhereUniqueInput
    update: XOR<AllotmentDataUpdateWithoutIpoInput, AllotmentDataUncheckedUpdateWithoutIpoInput>
    create: XOR<AllotmentDataCreateWithoutIpoInput, AllotmentDataUncheckedCreateWithoutIpoInput>
  }

  export type AllotmentDataUpdateWithWhereUniqueWithoutIpoInput = {
    where: AllotmentDataWhereUniqueInput
    data: XOR<AllotmentDataUpdateWithoutIpoInput, AllotmentDataUncheckedUpdateWithoutIpoInput>
  }

  export type AllotmentDataUpdateManyWithWhereWithoutIpoInput = {
    where: AllotmentDataScalarWhereInput
    data: XOR<AllotmentDataUpdateManyMutationInput, AllotmentDataUncheckedUpdateManyWithoutIpoInput>
  }

  export type AllotmentDataScalarWhereInput = {
    AND?: AllotmentDataScalarWhereInput | AllotmentDataScalarWhereInput[]
    OR?: AllotmentDataScalarWhereInput[]
    NOT?: AllotmentDataScalarWhereInput | AllotmentDataScalarWhereInput[]
    id?: StringFilter<"AllotmentData"> | string
    ipoId?: StringFilter<"AllotmentData"> | string
    pan?: StringFilter<"AllotmentData"> | string
    applicationNumber?: StringNullableFilter<"AllotmentData"> | string | null
    category?: StringFilter<"AllotmentData"> | string
    appliedQuantity?: IntFilter<"AllotmentData"> | number
    allottedQuantity?: IntFilter<"AllotmentData"> | number
    allottedAmount?: FloatFilter<"AllotmentData"> | number
    refundAmount?: FloatFilter<"AllotmentData"> | number
    allotmentStatus?: StringFilter<"AllotmentData"> | string
    timestamp?: DateTimeFilter<"AllotmentData"> | Date | string
    createdAt?: DateTimeFilter<"AllotmentData"> | Date | string
    updatedAt?: DateTimeFilter<"AllotmentData"> | Date | string
  }

  export type IPOAnalyticsUpsertWithWhereUniqueWithoutIpoInput = {
    where: IPOAnalyticsWhereUniqueInput
    update: XOR<IPOAnalyticsUpdateWithoutIpoInput, IPOAnalyticsUncheckedUpdateWithoutIpoInput>
    create: XOR<IPOAnalyticsCreateWithoutIpoInput, IPOAnalyticsUncheckedCreateWithoutIpoInput>
  }

  export type IPOAnalyticsUpdateWithWhereUniqueWithoutIpoInput = {
    where: IPOAnalyticsWhereUniqueInput
    data: XOR<IPOAnalyticsUpdateWithoutIpoInput, IPOAnalyticsUncheckedUpdateWithoutIpoInput>
  }

  export type IPOAnalyticsUpdateManyWithWhereWithoutIpoInput = {
    where: IPOAnalyticsScalarWhereInput
    data: XOR<IPOAnalyticsUpdateManyMutationInput, IPOAnalyticsUncheckedUpdateManyWithoutIpoInput>
  }

  export type IPOAnalyticsScalarWhereInput = {
    AND?: IPOAnalyticsScalarWhereInput | IPOAnalyticsScalarWhereInput[]
    OR?: IPOAnalyticsScalarWhereInput[]
    NOT?: IPOAnalyticsScalarWhereInput | IPOAnalyticsScalarWhereInput[]
    id?: StringFilter<"IPOAnalytics"> | string
    ipoId?: StringFilter<"IPOAnalytics"> | string
    symbol?: StringNullableFilter<"IPOAnalytics"> | string | null
    date?: DateTimeFilter<"IPOAnalytics"> | Date | string
    avgGMP?: FloatNullableFilter<"IPOAnalytics"> | number | null
    maxGMP?: FloatNullableFilter<"IPOAnalytics"> | number | null
    minGMP?: FloatNullableFilter<"IPOAnalytics"> | number | null
    gmpVolume?: IntNullableFilter<"IPOAnalytics"> | number | null
    gmpTrend?: StringNullableFilter<"IPOAnalytics"> | string | null
    overallSubscription?: FloatNullableFilter<"IPOAnalytics"> | number | null
    retailSubscription?: FloatNullableFilter<"IPOAnalytics"> | number | null
    qibSubscription?: FloatNullableFilter<"IPOAnalytics"> | number | null
    hniSubscription?: FloatNullableFilter<"IPOAnalytics"> | number | null
    marketSentiment?: StringNullableFilter<"IPOAnalytics"> | string | null
    sentimentScore?: FloatNullableFilter<"IPOAnalytics"> | number | null
    listingGain?: FloatNullableFilter<"IPOAnalytics"> | number | null
    currentReturn?: FloatNullableFilter<"IPOAnalytics"> | number | null
    volatilityIndex?: FloatNullableFilter<"IPOAnalytics"> | number | null
    totalGMPChanges?: IntFilter<"IPOAnalytics"> | number
    totalSubscriptions?: IntFilter<"IPOAnalytics"> | number
    oversubscribedCount?: IntFilter<"IPOAnalytics"> | number
    createdAt?: DateTimeFilter<"IPOAnalytics"> | Date | string
    updatedAt?: DateTimeFilter<"IPOAnalytics"> | Date | string
  }

  export type UserWatchlistUpsertWithWhereUniqueWithoutIpoInput = {
    where: UserWatchlistWhereUniqueInput
    update: XOR<UserWatchlistUpdateWithoutIpoInput, UserWatchlistUncheckedUpdateWithoutIpoInput>
    create: XOR<UserWatchlistCreateWithoutIpoInput, UserWatchlistUncheckedCreateWithoutIpoInput>
  }

  export type UserWatchlistUpdateWithWhereUniqueWithoutIpoInput = {
    where: UserWatchlistWhereUniqueInput
    data: XOR<UserWatchlistUpdateWithoutIpoInput, UserWatchlistUncheckedUpdateWithoutIpoInput>
  }

  export type UserWatchlistUpdateManyWithWhereWithoutIpoInput = {
    where: UserWatchlistScalarWhereInput
    data: XOR<UserWatchlistUpdateManyMutationInput, UserWatchlistUncheckedUpdateManyWithoutIpoInput>
  }

  export type UserWatchlistScalarWhereInput = {
    AND?: UserWatchlistScalarWhereInput | UserWatchlistScalarWhereInput[]
    OR?: UserWatchlistScalarWhereInput[]
    NOT?: UserWatchlistScalarWhereInput | UserWatchlistScalarWhereInput[]
    id?: StringFilter<"UserWatchlist"> | string
    userId?: StringFilter<"UserWatchlist"> | string
    ipoId?: StringFilter<"UserWatchlist"> | string
    notes?: StringNullableFilter<"UserWatchlist"> | string | null
    alertPreferences?: StringNullableFilter<"UserWatchlist"> | string | null
    addedAt?: DateTimeFilter<"UserWatchlist"> | Date | string
  }

  export type UserAlertUpsertWithWhereUniqueWithoutIpoInput = {
    where: UserAlertWhereUniqueInput
    update: XOR<UserAlertUpdateWithoutIpoInput, UserAlertUncheckedUpdateWithoutIpoInput>
    create: XOR<UserAlertCreateWithoutIpoInput, UserAlertUncheckedCreateWithoutIpoInput>
  }

  export type UserAlertUpdateWithWhereUniqueWithoutIpoInput = {
    where: UserAlertWhereUniqueInput
    data: XOR<UserAlertUpdateWithoutIpoInput, UserAlertUncheckedUpdateWithoutIpoInput>
  }

  export type UserAlertUpdateManyWithWhereWithoutIpoInput = {
    where: UserAlertScalarWhereInput
    data: XOR<UserAlertUpdateManyMutationInput, UserAlertUncheckedUpdateManyWithoutIpoInput>
  }

  export type UserAlertScalarWhereInput = {
    AND?: UserAlertScalarWhereInput | UserAlertScalarWhereInput[]
    OR?: UserAlertScalarWhereInput[]
    NOT?: UserAlertScalarWhereInput | UserAlertScalarWhereInput[]
    id?: StringFilter<"UserAlert"> | string
    userId?: StringFilter<"UserAlert"> | string
    ipoId?: StringNullableFilter<"UserAlert"> | string | null
    symbol?: StringNullableFilter<"UserAlert"> | string | null
    alertType?: StringFilter<"UserAlert"> | string
    triggerType?: StringFilter<"UserAlert"> | string
    triggerValue?: FloatNullableFilter<"UserAlert"> | number | null
    triggerCondition?: StringNullableFilter<"UserAlert"> | string | null
    message?: StringNullableFilter<"UserAlert"> | string | null
    isActive?: BoolFilter<"UserAlert"> | boolean
    lastTriggered?: DateTimeNullableFilter<"UserAlert"> | Date | string | null
    triggerCount?: IntFilter<"UserAlert"> | number
    createdAt?: DateTimeFilter<"UserAlert"> | Date | string
    updatedAt?: DateTimeFilter<"UserAlert"> | Date | string
  }

  export type IPOCreateWithoutGmpDataInput = {
    id?: string
    symbol: string
    name: string
    companyId?: string | null
    status: string
    sector?: string | null
    industry?: string | null
    minPrice: number
    maxPrice: number
    finalPrice?: number | null
    listingPrice?: number | null
    currentPrice?: number | null
    issueSize: bigint | number
    lotSize: number
    marketLot: number
    openDate: Date | string
    closeDate: Date | string
    listingDate?: Date | string | null
    allotmentDate?: Date | string | null
    refundDate?: Date | string | null
    leadManager?: string | null
    registrar?: string | null
    faceValue?: number | null
    bookValue?: number | null
    marketCap?: bigint | number | null
    peRatio?: number | null
    roe?: number | null
    reservationDetails?: string | null
    aboutCompany?: string | null
    objectives?: string | null
    risks?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    subscriptionData?: SubscriptionDataCreateNestedManyWithoutIpoInput
    allotmentData?: AllotmentDataCreateNestedManyWithoutIpoInput
    analytics?: IPOAnalyticsCreateNestedManyWithoutIpoInput
    watchlists?: UserWatchlistCreateNestedManyWithoutIpoInput
    alerts?: UserAlertCreateNestedManyWithoutIpoInput
  }

  export type IPOUncheckedCreateWithoutGmpDataInput = {
    id?: string
    symbol: string
    name: string
    companyId?: string | null
    status: string
    sector?: string | null
    industry?: string | null
    minPrice: number
    maxPrice: number
    finalPrice?: number | null
    listingPrice?: number | null
    currentPrice?: number | null
    issueSize: bigint | number
    lotSize: number
    marketLot: number
    openDate: Date | string
    closeDate: Date | string
    listingDate?: Date | string | null
    allotmentDate?: Date | string | null
    refundDate?: Date | string | null
    leadManager?: string | null
    registrar?: string | null
    faceValue?: number | null
    bookValue?: number | null
    marketCap?: bigint | number | null
    peRatio?: number | null
    roe?: number | null
    reservationDetails?: string | null
    aboutCompany?: string | null
    objectives?: string | null
    risks?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    subscriptionData?: SubscriptionDataUncheckedCreateNestedManyWithoutIpoInput
    allotmentData?: AllotmentDataUncheckedCreateNestedManyWithoutIpoInput
    analytics?: IPOAnalyticsUncheckedCreateNestedManyWithoutIpoInput
    watchlists?: UserWatchlistUncheckedCreateNestedManyWithoutIpoInput
    alerts?: UserAlertUncheckedCreateNestedManyWithoutIpoInput
  }

  export type IPOCreateOrConnectWithoutGmpDataInput = {
    where: IPOWhereUniqueInput
    create: XOR<IPOCreateWithoutGmpDataInput, IPOUncheckedCreateWithoutGmpDataInput>
  }

  export type IPOUpsertWithoutGmpDataInput = {
    update: XOR<IPOUpdateWithoutGmpDataInput, IPOUncheckedUpdateWithoutGmpDataInput>
    create: XOR<IPOCreateWithoutGmpDataInput, IPOUncheckedCreateWithoutGmpDataInput>
    where?: IPOWhereInput
  }

  export type IPOUpdateToOneWithWhereWithoutGmpDataInput = {
    where?: IPOWhereInput
    data: XOR<IPOUpdateWithoutGmpDataInput, IPOUncheckedUpdateWithoutGmpDataInput>
  }

  export type IPOUpdateWithoutGmpDataInput = {
    id?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    minPrice?: FloatFieldUpdateOperationsInput | number
    maxPrice?: FloatFieldUpdateOperationsInput | number
    finalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    listingPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    currentPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    issueSize?: BigIntFieldUpdateOperationsInput | bigint | number
    lotSize?: IntFieldUpdateOperationsInput | number
    marketLot?: IntFieldUpdateOperationsInput | number
    openDate?: DateTimeFieldUpdateOperationsInput | Date | string
    closeDate?: DateTimeFieldUpdateOperationsInput | Date | string
    listingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    allotmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refundDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    leadManager?: NullableStringFieldUpdateOperationsInput | string | null
    registrar?: NullableStringFieldUpdateOperationsInput | string | null
    faceValue?: NullableFloatFieldUpdateOperationsInput | number | null
    bookValue?: NullableFloatFieldUpdateOperationsInput | number | null
    marketCap?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    peRatio?: NullableFloatFieldUpdateOperationsInput | number | null
    roe?: NullableFloatFieldUpdateOperationsInput | number | null
    reservationDetails?: NullableStringFieldUpdateOperationsInput | string | null
    aboutCompany?: NullableStringFieldUpdateOperationsInput | string | null
    objectives?: NullableStringFieldUpdateOperationsInput | string | null
    risks?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptionData?: SubscriptionDataUpdateManyWithoutIpoNestedInput
    allotmentData?: AllotmentDataUpdateManyWithoutIpoNestedInput
    analytics?: IPOAnalyticsUpdateManyWithoutIpoNestedInput
    watchlists?: UserWatchlistUpdateManyWithoutIpoNestedInput
    alerts?: UserAlertUpdateManyWithoutIpoNestedInput
  }

  export type IPOUncheckedUpdateWithoutGmpDataInput = {
    id?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    minPrice?: FloatFieldUpdateOperationsInput | number
    maxPrice?: FloatFieldUpdateOperationsInput | number
    finalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    listingPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    currentPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    issueSize?: BigIntFieldUpdateOperationsInput | bigint | number
    lotSize?: IntFieldUpdateOperationsInput | number
    marketLot?: IntFieldUpdateOperationsInput | number
    openDate?: DateTimeFieldUpdateOperationsInput | Date | string
    closeDate?: DateTimeFieldUpdateOperationsInput | Date | string
    listingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    allotmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refundDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    leadManager?: NullableStringFieldUpdateOperationsInput | string | null
    registrar?: NullableStringFieldUpdateOperationsInput | string | null
    faceValue?: NullableFloatFieldUpdateOperationsInput | number | null
    bookValue?: NullableFloatFieldUpdateOperationsInput | number | null
    marketCap?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    peRatio?: NullableFloatFieldUpdateOperationsInput | number | null
    roe?: NullableFloatFieldUpdateOperationsInput | number | null
    reservationDetails?: NullableStringFieldUpdateOperationsInput | string | null
    aboutCompany?: NullableStringFieldUpdateOperationsInput | string | null
    objectives?: NullableStringFieldUpdateOperationsInput | string | null
    risks?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptionData?: SubscriptionDataUncheckedUpdateManyWithoutIpoNestedInput
    allotmentData?: AllotmentDataUncheckedUpdateManyWithoutIpoNestedInput
    analytics?: IPOAnalyticsUncheckedUpdateManyWithoutIpoNestedInput
    watchlists?: UserWatchlistUncheckedUpdateManyWithoutIpoNestedInput
    alerts?: UserAlertUncheckedUpdateManyWithoutIpoNestedInput
  }

  export type IPOCreateWithoutSubscriptionDataInput = {
    id?: string
    symbol: string
    name: string
    companyId?: string | null
    status: string
    sector?: string | null
    industry?: string | null
    minPrice: number
    maxPrice: number
    finalPrice?: number | null
    listingPrice?: number | null
    currentPrice?: number | null
    issueSize: bigint | number
    lotSize: number
    marketLot: number
    openDate: Date | string
    closeDate: Date | string
    listingDate?: Date | string | null
    allotmentDate?: Date | string | null
    refundDate?: Date | string | null
    leadManager?: string | null
    registrar?: string | null
    faceValue?: number | null
    bookValue?: number | null
    marketCap?: bigint | number | null
    peRatio?: number | null
    roe?: number | null
    reservationDetails?: string | null
    aboutCompany?: string | null
    objectives?: string | null
    risks?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    gmpData?: GMPCreateNestedManyWithoutIpoInput
    allotmentData?: AllotmentDataCreateNestedManyWithoutIpoInput
    analytics?: IPOAnalyticsCreateNestedManyWithoutIpoInput
    watchlists?: UserWatchlistCreateNestedManyWithoutIpoInput
    alerts?: UserAlertCreateNestedManyWithoutIpoInput
  }

  export type IPOUncheckedCreateWithoutSubscriptionDataInput = {
    id?: string
    symbol: string
    name: string
    companyId?: string | null
    status: string
    sector?: string | null
    industry?: string | null
    minPrice: number
    maxPrice: number
    finalPrice?: number | null
    listingPrice?: number | null
    currentPrice?: number | null
    issueSize: bigint | number
    lotSize: number
    marketLot: number
    openDate: Date | string
    closeDate: Date | string
    listingDate?: Date | string | null
    allotmentDate?: Date | string | null
    refundDate?: Date | string | null
    leadManager?: string | null
    registrar?: string | null
    faceValue?: number | null
    bookValue?: number | null
    marketCap?: bigint | number | null
    peRatio?: number | null
    roe?: number | null
    reservationDetails?: string | null
    aboutCompany?: string | null
    objectives?: string | null
    risks?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    gmpData?: GMPUncheckedCreateNestedManyWithoutIpoInput
    allotmentData?: AllotmentDataUncheckedCreateNestedManyWithoutIpoInput
    analytics?: IPOAnalyticsUncheckedCreateNestedManyWithoutIpoInput
    watchlists?: UserWatchlistUncheckedCreateNestedManyWithoutIpoInput
    alerts?: UserAlertUncheckedCreateNestedManyWithoutIpoInput
  }

  export type IPOCreateOrConnectWithoutSubscriptionDataInput = {
    where: IPOWhereUniqueInput
    create: XOR<IPOCreateWithoutSubscriptionDataInput, IPOUncheckedCreateWithoutSubscriptionDataInput>
  }

  export type IPOUpsertWithoutSubscriptionDataInput = {
    update: XOR<IPOUpdateWithoutSubscriptionDataInput, IPOUncheckedUpdateWithoutSubscriptionDataInput>
    create: XOR<IPOCreateWithoutSubscriptionDataInput, IPOUncheckedCreateWithoutSubscriptionDataInput>
    where?: IPOWhereInput
  }

  export type IPOUpdateToOneWithWhereWithoutSubscriptionDataInput = {
    where?: IPOWhereInput
    data: XOR<IPOUpdateWithoutSubscriptionDataInput, IPOUncheckedUpdateWithoutSubscriptionDataInput>
  }

  export type IPOUpdateWithoutSubscriptionDataInput = {
    id?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    minPrice?: FloatFieldUpdateOperationsInput | number
    maxPrice?: FloatFieldUpdateOperationsInput | number
    finalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    listingPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    currentPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    issueSize?: BigIntFieldUpdateOperationsInput | bigint | number
    lotSize?: IntFieldUpdateOperationsInput | number
    marketLot?: IntFieldUpdateOperationsInput | number
    openDate?: DateTimeFieldUpdateOperationsInput | Date | string
    closeDate?: DateTimeFieldUpdateOperationsInput | Date | string
    listingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    allotmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refundDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    leadManager?: NullableStringFieldUpdateOperationsInput | string | null
    registrar?: NullableStringFieldUpdateOperationsInput | string | null
    faceValue?: NullableFloatFieldUpdateOperationsInput | number | null
    bookValue?: NullableFloatFieldUpdateOperationsInput | number | null
    marketCap?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    peRatio?: NullableFloatFieldUpdateOperationsInput | number | null
    roe?: NullableFloatFieldUpdateOperationsInput | number | null
    reservationDetails?: NullableStringFieldUpdateOperationsInput | string | null
    aboutCompany?: NullableStringFieldUpdateOperationsInput | string | null
    objectives?: NullableStringFieldUpdateOperationsInput | string | null
    risks?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gmpData?: GMPUpdateManyWithoutIpoNestedInput
    allotmentData?: AllotmentDataUpdateManyWithoutIpoNestedInput
    analytics?: IPOAnalyticsUpdateManyWithoutIpoNestedInput
    watchlists?: UserWatchlistUpdateManyWithoutIpoNestedInput
    alerts?: UserAlertUpdateManyWithoutIpoNestedInput
  }

  export type IPOUncheckedUpdateWithoutSubscriptionDataInput = {
    id?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    minPrice?: FloatFieldUpdateOperationsInput | number
    maxPrice?: FloatFieldUpdateOperationsInput | number
    finalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    listingPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    currentPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    issueSize?: BigIntFieldUpdateOperationsInput | bigint | number
    lotSize?: IntFieldUpdateOperationsInput | number
    marketLot?: IntFieldUpdateOperationsInput | number
    openDate?: DateTimeFieldUpdateOperationsInput | Date | string
    closeDate?: DateTimeFieldUpdateOperationsInput | Date | string
    listingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    allotmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refundDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    leadManager?: NullableStringFieldUpdateOperationsInput | string | null
    registrar?: NullableStringFieldUpdateOperationsInput | string | null
    faceValue?: NullableFloatFieldUpdateOperationsInput | number | null
    bookValue?: NullableFloatFieldUpdateOperationsInput | number | null
    marketCap?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    peRatio?: NullableFloatFieldUpdateOperationsInput | number | null
    roe?: NullableFloatFieldUpdateOperationsInput | number | null
    reservationDetails?: NullableStringFieldUpdateOperationsInput | string | null
    aboutCompany?: NullableStringFieldUpdateOperationsInput | string | null
    objectives?: NullableStringFieldUpdateOperationsInput | string | null
    risks?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gmpData?: GMPUncheckedUpdateManyWithoutIpoNestedInput
    allotmentData?: AllotmentDataUncheckedUpdateManyWithoutIpoNestedInput
    analytics?: IPOAnalyticsUncheckedUpdateManyWithoutIpoNestedInput
    watchlists?: UserWatchlistUncheckedUpdateManyWithoutIpoNestedInput
    alerts?: UserAlertUncheckedUpdateManyWithoutIpoNestedInput
  }

  export type IPOCreateWithoutAllotmentDataInput = {
    id?: string
    symbol: string
    name: string
    companyId?: string | null
    status: string
    sector?: string | null
    industry?: string | null
    minPrice: number
    maxPrice: number
    finalPrice?: number | null
    listingPrice?: number | null
    currentPrice?: number | null
    issueSize: bigint | number
    lotSize: number
    marketLot: number
    openDate: Date | string
    closeDate: Date | string
    listingDate?: Date | string | null
    allotmentDate?: Date | string | null
    refundDate?: Date | string | null
    leadManager?: string | null
    registrar?: string | null
    faceValue?: number | null
    bookValue?: number | null
    marketCap?: bigint | number | null
    peRatio?: number | null
    roe?: number | null
    reservationDetails?: string | null
    aboutCompany?: string | null
    objectives?: string | null
    risks?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    gmpData?: GMPCreateNestedManyWithoutIpoInput
    subscriptionData?: SubscriptionDataCreateNestedManyWithoutIpoInput
    analytics?: IPOAnalyticsCreateNestedManyWithoutIpoInput
    watchlists?: UserWatchlistCreateNestedManyWithoutIpoInput
    alerts?: UserAlertCreateNestedManyWithoutIpoInput
  }

  export type IPOUncheckedCreateWithoutAllotmentDataInput = {
    id?: string
    symbol: string
    name: string
    companyId?: string | null
    status: string
    sector?: string | null
    industry?: string | null
    minPrice: number
    maxPrice: number
    finalPrice?: number | null
    listingPrice?: number | null
    currentPrice?: number | null
    issueSize: bigint | number
    lotSize: number
    marketLot: number
    openDate: Date | string
    closeDate: Date | string
    listingDate?: Date | string | null
    allotmentDate?: Date | string | null
    refundDate?: Date | string | null
    leadManager?: string | null
    registrar?: string | null
    faceValue?: number | null
    bookValue?: number | null
    marketCap?: bigint | number | null
    peRatio?: number | null
    roe?: number | null
    reservationDetails?: string | null
    aboutCompany?: string | null
    objectives?: string | null
    risks?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    gmpData?: GMPUncheckedCreateNestedManyWithoutIpoInput
    subscriptionData?: SubscriptionDataUncheckedCreateNestedManyWithoutIpoInput
    analytics?: IPOAnalyticsUncheckedCreateNestedManyWithoutIpoInput
    watchlists?: UserWatchlistUncheckedCreateNestedManyWithoutIpoInput
    alerts?: UserAlertUncheckedCreateNestedManyWithoutIpoInput
  }

  export type IPOCreateOrConnectWithoutAllotmentDataInput = {
    where: IPOWhereUniqueInput
    create: XOR<IPOCreateWithoutAllotmentDataInput, IPOUncheckedCreateWithoutAllotmentDataInput>
  }

  export type IPOUpsertWithoutAllotmentDataInput = {
    update: XOR<IPOUpdateWithoutAllotmentDataInput, IPOUncheckedUpdateWithoutAllotmentDataInput>
    create: XOR<IPOCreateWithoutAllotmentDataInput, IPOUncheckedCreateWithoutAllotmentDataInput>
    where?: IPOWhereInput
  }

  export type IPOUpdateToOneWithWhereWithoutAllotmentDataInput = {
    where?: IPOWhereInput
    data: XOR<IPOUpdateWithoutAllotmentDataInput, IPOUncheckedUpdateWithoutAllotmentDataInput>
  }

  export type IPOUpdateWithoutAllotmentDataInput = {
    id?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    minPrice?: FloatFieldUpdateOperationsInput | number
    maxPrice?: FloatFieldUpdateOperationsInput | number
    finalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    listingPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    currentPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    issueSize?: BigIntFieldUpdateOperationsInput | bigint | number
    lotSize?: IntFieldUpdateOperationsInput | number
    marketLot?: IntFieldUpdateOperationsInput | number
    openDate?: DateTimeFieldUpdateOperationsInput | Date | string
    closeDate?: DateTimeFieldUpdateOperationsInput | Date | string
    listingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    allotmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refundDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    leadManager?: NullableStringFieldUpdateOperationsInput | string | null
    registrar?: NullableStringFieldUpdateOperationsInput | string | null
    faceValue?: NullableFloatFieldUpdateOperationsInput | number | null
    bookValue?: NullableFloatFieldUpdateOperationsInput | number | null
    marketCap?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    peRatio?: NullableFloatFieldUpdateOperationsInput | number | null
    roe?: NullableFloatFieldUpdateOperationsInput | number | null
    reservationDetails?: NullableStringFieldUpdateOperationsInput | string | null
    aboutCompany?: NullableStringFieldUpdateOperationsInput | string | null
    objectives?: NullableStringFieldUpdateOperationsInput | string | null
    risks?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gmpData?: GMPUpdateManyWithoutIpoNestedInput
    subscriptionData?: SubscriptionDataUpdateManyWithoutIpoNestedInput
    analytics?: IPOAnalyticsUpdateManyWithoutIpoNestedInput
    watchlists?: UserWatchlistUpdateManyWithoutIpoNestedInput
    alerts?: UserAlertUpdateManyWithoutIpoNestedInput
  }

  export type IPOUncheckedUpdateWithoutAllotmentDataInput = {
    id?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    minPrice?: FloatFieldUpdateOperationsInput | number
    maxPrice?: FloatFieldUpdateOperationsInput | number
    finalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    listingPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    currentPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    issueSize?: BigIntFieldUpdateOperationsInput | bigint | number
    lotSize?: IntFieldUpdateOperationsInput | number
    marketLot?: IntFieldUpdateOperationsInput | number
    openDate?: DateTimeFieldUpdateOperationsInput | Date | string
    closeDate?: DateTimeFieldUpdateOperationsInput | Date | string
    listingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    allotmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refundDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    leadManager?: NullableStringFieldUpdateOperationsInput | string | null
    registrar?: NullableStringFieldUpdateOperationsInput | string | null
    faceValue?: NullableFloatFieldUpdateOperationsInput | number | null
    bookValue?: NullableFloatFieldUpdateOperationsInput | number | null
    marketCap?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    peRatio?: NullableFloatFieldUpdateOperationsInput | number | null
    roe?: NullableFloatFieldUpdateOperationsInput | number | null
    reservationDetails?: NullableStringFieldUpdateOperationsInput | string | null
    aboutCompany?: NullableStringFieldUpdateOperationsInput | string | null
    objectives?: NullableStringFieldUpdateOperationsInput | string | null
    risks?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gmpData?: GMPUncheckedUpdateManyWithoutIpoNestedInput
    subscriptionData?: SubscriptionDataUncheckedUpdateManyWithoutIpoNestedInput
    analytics?: IPOAnalyticsUncheckedUpdateManyWithoutIpoNestedInput
    watchlists?: UserWatchlistUncheckedUpdateManyWithoutIpoNestedInput
    alerts?: UserAlertUncheckedUpdateManyWithoutIpoNestedInput
  }

  export type UserWatchlistCreateWithoutUserInput = {
    id?: string
    notes?: string | null
    alertPreferences?: string | null
    addedAt?: Date | string
    ipo: IPOCreateNestedOneWithoutWatchlistsInput
  }

  export type UserWatchlistUncheckedCreateWithoutUserInput = {
    id?: string
    ipoId: string
    notes?: string | null
    alertPreferences?: string | null
    addedAt?: Date | string
  }

  export type UserWatchlistCreateOrConnectWithoutUserInput = {
    where: UserWatchlistWhereUniqueInput
    create: XOR<UserWatchlistCreateWithoutUserInput, UserWatchlistUncheckedCreateWithoutUserInput>
  }

  export type UserWatchlistCreateManyUserInputEnvelope = {
    data: UserWatchlistCreateManyUserInput | UserWatchlistCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserAlertCreateWithoutUserInput = {
    id?: string
    symbol?: string | null
    alertType: string
    triggerType: string
    triggerValue?: number | null
    triggerCondition?: string | null
    message?: string | null
    isActive?: boolean
    lastTriggered?: Date | string | null
    triggerCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    ipo?: IPOCreateNestedOneWithoutAlertsInput
  }

  export type UserAlertUncheckedCreateWithoutUserInput = {
    id?: string
    ipoId?: string | null
    symbol?: string | null
    alertType: string
    triggerType: string
    triggerValue?: number | null
    triggerCondition?: string | null
    message?: string | null
    isActive?: boolean
    lastTriggered?: Date | string | null
    triggerCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserAlertCreateOrConnectWithoutUserInput = {
    where: UserAlertWhereUniqueInput
    create: XOR<UserAlertCreateWithoutUserInput, UserAlertUncheckedCreateWithoutUserInput>
  }

  export type UserAlertCreateManyUserInputEnvelope = {
    data: UserAlertCreateManyUserInput | UserAlertCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SessionCreateWithoutUserInput = {
    id?: string
    token: string
    refreshToken: string
    expiresAt: Date | string
    isActive?: boolean
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id?: string
    token: string
    refreshToken: string
    expiresAt: Date | string
    isActive?: boolean
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserWatchlistUpsertWithWhereUniqueWithoutUserInput = {
    where: UserWatchlistWhereUniqueInput
    update: XOR<UserWatchlistUpdateWithoutUserInput, UserWatchlistUncheckedUpdateWithoutUserInput>
    create: XOR<UserWatchlistCreateWithoutUserInput, UserWatchlistUncheckedCreateWithoutUserInput>
  }

  export type UserWatchlistUpdateWithWhereUniqueWithoutUserInput = {
    where: UserWatchlistWhereUniqueInput
    data: XOR<UserWatchlistUpdateWithoutUserInput, UserWatchlistUncheckedUpdateWithoutUserInput>
  }

  export type UserWatchlistUpdateManyWithWhereWithoutUserInput = {
    where: UserWatchlistScalarWhereInput
    data: XOR<UserWatchlistUpdateManyMutationInput, UserWatchlistUncheckedUpdateManyWithoutUserInput>
  }

  export type UserAlertUpsertWithWhereUniqueWithoutUserInput = {
    where: UserAlertWhereUniqueInput
    update: XOR<UserAlertUpdateWithoutUserInput, UserAlertUncheckedUpdateWithoutUserInput>
    create: XOR<UserAlertCreateWithoutUserInput, UserAlertUncheckedCreateWithoutUserInput>
  }

  export type UserAlertUpdateWithWhereUniqueWithoutUserInput = {
    where: UserAlertWhereUniqueInput
    data: XOR<UserAlertUpdateWithoutUserInput, UserAlertUncheckedUpdateWithoutUserInput>
  }

  export type UserAlertUpdateManyWithWhereWithoutUserInput = {
    where: UserAlertScalarWhereInput
    data: XOR<UserAlertUpdateManyMutationInput, UserAlertUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    token?: StringFilter<"Session"> | string
    refreshToken?: StringFilter<"Session"> | string
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    isActive?: BoolFilter<"Session"> | boolean
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
  }

  export type UserCreateWithoutSessionsInput = {
    id?: string
    email: string
    name?: string | null
    phone?: string | null
    pan?: string | null
    role?: string
    isActive?: boolean
    isEmailVerified?: boolean
    kycCompleted?: boolean
    preferences?: string | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    watchlists?: UserWatchlistCreateNestedManyWithoutUserInput
    alerts?: UserAlertCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string
    email: string
    name?: string | null
    phone?: string | null
    pan?: string | null
    role?: string
    isActive?: boolean
    isEmailVerified?: boolean
    kycCompleted?: boolean
    preferences?: string | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    watchlists?: UserWatchlistUncheckedCreateNestedManyWithoutUserInput
    alerts?: UserAlertUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    pan?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    kycCompleted?: BoolFieldUpdateOperationsInput | boolean
    preferences?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    watchlists?: UserWatchlistUpdateManyWithoutUserNestedInput
    alerts?: UserAlertUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    pan?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    kycCompleted?: BoolFieldUpdateOperationsInput | boolean
    preferences?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    watchlists?: UserWatchlistUncheckedUpdateManyWithoutUserNestedInput
    alerts?: UserAlertUncheckedUpdateManyWithoutUserNestedInput
  }

  export type IPOCreateWithoutAnalyticsInput = {
    id?: string
    symbol: string
    name: string
    companyId?: string | null
    status: string
    sector?: string | null
    industry?: string | null
    minPrice: number
    maxPrice: number
    finalPrice?: number | null
    listingPrice?: number | null
    currentPrice?: number | null
    issueSize: bigint | number
    lotSize: number
    marketLot: number
    openDate: Date | string
    closeDate: Date | string
    listingDate?: Date | string | null
    allotmentDate?: Date | string | null
    refundDate?: Date | string | null
    leadManager?: string | null
    registrar?: string | null
    faceValue?: number | null
    bookValue?: number | null
    marketCap?: bigint | number | null
    peRatio?: number | null
    roe?: number | null
    reservationDetails?: string | null
    aboutCompany?: string | null
    objectives?: string | null
    risks?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    gmpData?: GMPCreateNestedManyWithoutIpoInput
    subscriptionData?: SubscriptionDataCreateNestedManyWithoutIpoInput
    allotmentData?: AllotmentDataCreateNestedManyWithoutIpoInput
    watchlists?: UserWatchlistCreateNestedManyWithoutIpoInput
    alerts?: UserAlertCreateNestedManyWithoutIpoInput
  }

  export type IPOUncheckedCreateWithoutAnalyticsInput = {
    id?: string
    symbol: string
    name: string
    companyId?: string | null
    status: string
    sector?: string | null
    industry?: string | null
    minPrice: number
    maxPrice: number
    finalPrice?: number | null
    listingPrice?: number | null
    currentPrice?: number | null
    issueSize: bigint | number
    lotSize: number
    marketLot: number
    openDate: Date | string
    closeDate: Date | string
    listingDate?: Date | string | null
    allotmentDate?: Date | string | null
    refundDate?: Date | string | null
    leadManager?: string | null
    registrar?: string | null
    faceValue?: number | null
    bookValue?: number | null
    marketCap?: bigint | number | null
    peRatio?: number | null
    roe?: number | null
    reservationDetails?: string | null
    aboutCompany?: string | null
    objectives?: string | null
    risks?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    gmpData?: GMPUncheckedCreateNestedManyWithoutIpoInput
    subscriptionData?: SubscriptionDataUncheckedCreateNestedManyWithoutIpoInput
    allotmentData?: AllotmentDataUncheckedCreateNestedManyWithoutIpoInput
    watchlists?: UserWatchlistUncheckedCreateNestedManyWithoutIpoInput
    alerts?: UserAlertUncheckedCreateNestedManyWithoutIpoInput
  }

  export type IPOCreateOrConnectWithoutAnalyticsInput = {
    where: IPOWhereUniqueInput
    create: XOR<IPOCreateWithoutAnalyticsInput, IPOUncheckedCreateWithoutAnalyticsInput>
  }

  export type IPOUpsertWithoutAnalyticsInput = {
    update: XOR<IPOUpdateWithoutAnalyticsInput, IPOUncheckedUpdateWithoutAnalyticsInput>
    create: XOR<IPOCreateWithoutAnalyticsInput, IPOUncheckedCreateWithoutAnalyticsInput>
    where?: IPOWhereInput
  }

  export type IPOUpdateToOneWithWhereWithoutAnalyticsInput = {
    where?: IPOWhereInput
    data: XOR<IPOUpdateWithoutAnalyticsInput, IPOUncheckedUpdateWithoutAnalyticsInput>
  }

  export type IPOUpdateWithoutAnalyticsInput = {
    id?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    minPrice?: FloatFieldUpdateOperationsInput | number
    maxPrice?: FloatFieldUpdateOperationsInput | number
    finalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    listingPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    currentPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    issueSize?: BigIntFieldUpdateOperationsInput | bigint | number
    lotSize?: IntFieldUpdateOperationsInput | number
    marketLot?: IntFieldUpdateOperationsInput | number
    openDate?: DateTimeFieldUpdateOperationsInput | Date | string
    closeDate?: DateTimeFieldUpdateOperationsInput | Date | string
    listingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    allotmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refundDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    leadManager?: NullableStringFieldUpdateOperationsInput | string | null
    registrar?: NullableStringFieldUpdateOperationsInput | string | null
    faceValue?: NullableFloatFieldUpdateOperationsInput | number | null
    bookValue?: NullableFloatFieldUpdateOperationsInput | number | null
    marketCap?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    peRatio?: NullableFloatFieldUpdateOperationsInput | number | null
    roe?: NullableFloatFieldUpdateOperationsInput | number | null
    reservationDetails?: NullableStringFieldUpdateOperationsInput | string | null
    aboutCompany?: NullableStringFieldUpdateOperationsInput | string | null
    objectives?: NullableStringFieldUpdateOperationsInput | string | null
    risks?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gmpData?: GMPUpdateManyWithoutIpoNestedInput
    subscriptionData?: SubscriptionDataUpdateManyWithoutIpoNestedInput
    allotmentData?: AllotmentDataUpdateManyWithoutIpoNestedInput
    watchlists?: UserWatchlistUpdateManyWithoutIpoNestedInput
    alerts?: UserAlertUpdateManyWithoutIpoNestedInput
  }

  export type IPOUncheckedUpdateWithoutAnalyticsInput = {
    id?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    minPrice?: FloatFieldUpdateOperationsInput | number
    maxPrice?: FloatFieldUpdateOperationsInput | number
    finalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    listingPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    currentPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    issueSize?: BigIntFieldUpdateOperationsInput | bigint | number
    lotSize?: IntFieldUpdateOperationsInput | number
    marketLot?: IntFieldUpdateOperationsInput | number
    openDate?: DateTimeFieldUpdateOperationsInput | Date | string
    closeDate?: DateTimeFieldUpdateOperationsInput | Date | string
    listingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    allotmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refundDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    leadManager?: NullableStringFieldUpdateOperationsInput | string | null
    registrar?: NullableStringFieldUpdateOperationsInput | string | null
    faceValue?: NullableFloatFieldUpdateOperationsInput | number | null
    bookValue?: NullableFloatFieldUpdateOperationsInput | number | null
    marketCap?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    peRatio?: NullableFloatFieldUpdateOperationsInput | number | null
    roe?: NullableFloatFieldUpdateOperationsInput | number | null
    reservationDetails?: NullableStringFieldUpdateOperationsInput | string | null
    aboutCompany?: NullableStringFieldUpdateOperationsInput | string | null
    objectives?: NullableStringFieldUpdateOperationsInput | string | null
    risks?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gmpData?: GMPUncheckedUpdateManyWithoutIpoNestedInput
    subscriptionData?: SubscriptionDataUncheckedUpdateManyWithoutIpoNestedInput
    allotmentData?: AllotmentDataUncheckedUpdateManyWithoutIpoNestedInput
    watchlists?: UserWatchlistUncheckedUpdateManyWithoutIpoNestedInput
    alerts?: UserAlertUncheckedUpdateManyWithoutIpoNestedInput
  }

  export type UserCreateWithoutWatchlistsInput = {
    id?: string
    email: string
    name?: string | null
    phone?: string | null
    pan?: string | null
    role?: string
    isActive?: boolean
    isEmailVerified?: boolean
    kycCompleted?: boolean
    preferences?: string | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    alerts?: UserAlertCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutWatchlistsInput = {
    id?: string
    email: string
    name?: string | null
    phone?: string | null
    pan?: string | null
    role?: string
    isActive?: boolean
    isEmailVerified?: boolean
    kycCompleted?: boolean
    preferences?: string | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    alerts?: UserAlertUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutWatchlistsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutWatchlistsInput, UserUncheckedCreateWithoutWatchlistsInput>
  }

  export type IPOCreateWithoutWatchlistsInput = {
    id?: string
    symbol: string
    name: string
    companyId?: string | null
    status: string
    sector?: string | null
    industry?: string | null
    minPrice: number
    maxPrice: number
    finalPrice?: number | null
    listingPrice?: number | null
    currentPrice?: number | null
    issueSize: bigint | number
    lotSize: number
    marketLot: number
    openDate: Date | string
    closeDate: Date | string
    listingDate?: Date | string | null
    allotmentDate?: Date | string | null
    refundDate?: Date | string | null
    leadManager?: string | null
    registrar?: string | null
    faceValue?: number | null
    bookValue?: number | null
    marketCap?: bigint | number | null
    peRatio?: number | null
    roe?: number | null
    reservationDetails?: string | null
    aboutCompany?: string | null
    objectives?: string | null
    risks?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    gmpData?: GMPCreateNestedManyWithoutIpoInput
    subscriptionData?: SubscriptionDataCreateNestedManyWithoutIpoInput
    allotmentData?: AllotmentDataCreateNestedManyWithoutIpoInput
    analytics?: IPOAnalyticsCreateNestedManyWithoutIpoInput
    alerts?: UserAlertCreateNestedManyWithoutIpoInput
  }

  export type IPOUncheckedCreateWithoutWatchlistsInput = {
    id?: string
    symbol: string
    name: string
    companyId?: string | null
    status: string
    sector?: string | null
    industry?: string | null
    minPrice: number
    maxPrice: number
    finalPrice?: number | null
    listingPrice?: number | null
    currentPrice?: number | null
    issueSize: bigint | number
    lotSize: number
    marketLot: number
    openDate: Date | string
    closeDate: Date | string
    listingDate?: Date | string | null
    allotmentDate?: Date | string | null
    refundDate?: Date | string | null
    leadManager?: string | null
    registrar?: string | null
    faceValue?: number | null
    bookValue?: number | null
    marketCap?: bigint | number | null
    peRatio?: number | null
    roe?: number | null
    reservationDetails?: string | null
    aboutCompany?: string | null
    objectives?: string | null
    risks?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    gmpData?: GMPUncheckedCreateNestedManyWithoutIpoInput
    subscriptionData?: SubscriptionDataUncheckedCreateNestedManyWithoutIpoInput
    allotmentData?: AllotmentDataUncheckedCreateNestedManyWithoutIpoInput
    analytics?: IPOAnalyticsUncheckedCreateNestedManyWithoutIpoInput
    alerts?: UserAlertUncheckedCreateNestedManyWithoutIpoInput
  }

  export type IPOCreateOrConnectWithoutWatchlistsInput = {
    where: IPOWhereUniqueInput
    create: XOR<IPOCreateWithoutWatchlistsInput, IPOUncheckedCreateWithoutWatchlistsInput>
  }

  export type UserUpsertWithoutWatchlistsInput = {
    update: XOR<UserUpdateWithoutWatchlistsInput, UserUncheckedUpdateWithoutWatchlistsInput>
    create: XOR<UserCreateWithoutWatchlistsInput, UserUncheckedCreateWithoutWatchlistsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutWatchlistsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutWatchlistsInput, UserUncheckedUpdateWithoutWatchlistsInput>
  }

  export type UserUpdateWithoutWatchlistsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    pan?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    kycCompleted?: BoolFieldUpdateOperationsInput | boolean
    preferences?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    alerts?: UserAlertUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutWatchlistsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    pan?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    kycCompleted?: BoolFieldUpdateOperationsInput | boolean
    preferences?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    alerts?: UserAlertUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type IPOUpsertWithoutWatchlistsInput = {
    update: XOR<IPOUpdateWithoutWatchlistsInput, IPOUncheckedUpdateWithoutWatchlistsInput>
    create: XOR<IPOCreateWithoutWatchlistsInput, IPOUncheckedCreateWithoutWatchlistsInput>
    where?: IPOWhereInput
  }

  export type IPOUpdateToOneWithWhereWithoutWatchlistsInput = {
    where?: IPOWhereInput
    data: XOR<IPOUpdateWithoutWatchlistsInput, IPOUncheckedUpdateWithoutWatchlistsInput>
  }

  export type IPOUpdateWithoutWatchlistsInput = {
    id?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    minPrice?: FloatFieldUpdateOperationsInput | number
    maxPrice?: FloatFieldUpdateOperationsInput | number
    finalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    listingPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    currentPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    issueSize?: BigIntFieldUpdateOperationsInput | bigint | number
    lotSize?: IntFieldUpdateOperationsInput | number
    marketLot?: IntFieldUpdateOperationsInput | number
    openDate?: DateTimeFieldUpdateOperationsInput | Date | string
    closeDate?: DateTimeFieldUpdateOperationsInput | Date | string
    listingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    allotmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refundDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    leadManager?: NullableStringFieldUpdateOperationsInput | string | null
    registrar?: NullableStringFieldUpdateOperationsInput | string | null
    faceValue?: NullableFloatFieldUpdateOperationsInput | number | null
    bookValue?: NullableFloatFieldUpdateOperationsInput | number | null
    marketCap?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    peRatio?: NullableFloatFieldUpdateOperationsInput | number | null
    roe?: NullableFloatFieldUpdateOperationsInput | number | null
    reservationDetails?: NullableStringFieldUpdateOperationsInput | string | null
    aboutCompany?: NullableStringFieldUpdateOperationsInput | string | null
    objectives?: NullableStringFieldUpdateOperationsInput | string | null
    risks?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gmpData?: GMPUpdateManyWithoutIpoNestedInput
    subscriptionData?: SubscriptionDataUpdateManyWithoutIpoNestedInput
    allotmentData?: AllotmentDataUpdateManyWithoutIpoNestedInput
    analytics?: IPOAnalyticsUpdateManyWithoutIpoNestedInput
    alerts?: UserAlertUpdateManyWithoutIpoNestedInput
  }

  export type IPOUncheckedUpdateWithoutWatchlistsInput = {
    id?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    minPrice?: FloatFieldUpdateOperationsInput | number
    maxPrice?: FloatFieldUpdateOperationsInput | number
    finalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    listingPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    currentPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    issueSize?: BigIntFieldUpdateOperationsInput | bigint | number
    lotSize?: IntFieldUpdateOperationsInput | number
    marketLot?: IntFieldUpdateOperationsInput | number
    openDate?: DateTimeFieldUpdateOperationsInput | Date | string
    closeDate?: DateTimeFieldUpdateOperationsInput | Date | string
    listingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    allotmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refundDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    leadManager?: NullableStringFieldUpdateOperationsInput | string | null
    registrar?: NullableStringFieldUpdateOperationsInput | string | null
    faceValue?: NullableFloatFieldUpdateOperationsInput | number | null
    bookValue?: NullableFloatFieldUpdateOperationsInput | number | null
    marketCap?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    peRatio?: NullableFloatFieldUpdateOperationsInput | number | null
    roe?: NullableFloatFieldUpdateOperationsInput | number | null
    reservationDetails?: NullableStringFieldUpdateOperationsInput | string | null
    aboutCompany?: NullableStringFieldUpdateOperationsInput | string | null
    objectives?: NullableStringFieldUpdateOperationsInput | string | null
    risks?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gmpData?: GMPUncheckedUpdateManyWithoutIpoNestedInput
    subscriptionData?: SubscriptionDataUncheckedUpdateManyWithoutIpoNestedInput
    allotmentData?: AllotmentDataUncheckedUpdateManyWithoutIpoNestedInput
    analytics?: IPOAnalyticsUncheckedUpdateManyWithoutIpoNestedInput
    alerts?: UserAlertUncheckedUpdateManyWithoutIpoNestedInput
  }

  export type UserCreateWithoutAlertsInput = {
    id?: string
    email: string
    name?: string | null
    phone?: string | null
    pan?: string | null
    role?: string
    isActive?: boolean
    isEmailVerified?: boolean
    kycCompleted?: boolean
    preferences?: string | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    watchlists?: UserWatchlistCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAlertsInput = {
    id?: string
    email: string
    name?: string | null
    phone?: string | null
    pan?: string | null
    role?: string
    isActive?: boolean
    isEmailVerified?: boolean
    kycCompleted?: boolean
    preferences?: string | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    watchlists?: UserWatchlistUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAlertsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAlertsInput, UserUncheckedCreateWithoutAlertsInput>
  }

  export type IPOCreateWithoutAlertsInput = {
    id?: string
    symbol: string
    name: string
    companyId?: string | null
    status: string
    sector?: string | null
    industry?: string | null
    minPrice: number
    maxPrice: number
    finalPrice?: number | null
    listingPrice?: number | null
    currentPrice?: number | null
    issueSize: bigint | number
    lotSize: number
    marketLot: number
    openDate: Date | string
    closeDate: Date | string
    listingDate?: Date | string | null
    allotmentDate?: Date | string | null
    refundDate?: Date | string | null
    leadManager?: string | null
    registrar?: string | null
    faceValue?: number | null
    bookValue?: number | null
    marketCap?: bigint | number | null
    peRatio?: number | null
    roe?: number | null
    reservationDetails?: string | null
    aboutCompany?: string | null
    objectives?: string | null
    risks?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    gmpData?: GMPCreateNestedManyWithoutIpoInput
    subscriptionData?: SubscriptionDataCreateNestedManyWithoutIpoInput
    allotmentData?: AllotmentDataCreateNestedManyWithoutIpoInput
    analytics?: IPOAnalyticsCreateNestedManyWithoutIpoInput
    watchlists?: UserWatchlistCreateNestedManyWithoutIpoInput
  }

  export type IPOUncheckedCreateWithoutAlertsInput = {
    id?: string
    symbol: string
    name: string
    companyId?: string | null
    status: string
    sector?: string | null
    industry?: string | null
    minPrice: number
    maxPrice: number
    finalPrice?: number | null
    listingPrice?: number | null
    currentPrice?: number | null
    issueSize: bigint | number
    lotSize: number
    marketLot: number
    openDate: Date | string
    closeDate: Date | string
    listingDate?: Date | string | null
    allotmentDate?: Date | string | null
    refundDate?: Date | string | null
    leadManager?: string | null
    registrar?: string | null
    faceValue?: number | null
    bookValue?: number | null
    marketCap?: bigint | number | null
    peRatio?: number | null
    roe?: number | null
    reservationDetails?: string | null
    aboutCompany?: string | null
    objectives?: string | null
    risks?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    gmpData?: GMPUncheckedCreateNestedManyWithoutIpoInput
    subscriptionData?: SubscriptionDataUncheckedCreateNestedManyWithoutIpoInput
    allotmentData?: AllotmentDataUncheckedCreateNestedManyWithoutIpoInput
    analytics?: IPOAnalyticsUncheckedCreateNestedManyWithoutIpoInput
    watchlists?: UserWatchlistUncheckedCreateNestedManyWithoutIpoInput
  }

  export type IPOCreateOrConnectWithoutAlertsInput = {
    where: IPOWhereUniqueInput
    create: XOR<IPOCreateWithoutAlertsInput, IPOUncheckedCreateWithoutAlertsInput>
  }

  export type UserUpsertWithoutAlertsInput = {
    update: XOR<UserUpdateWithoutAlertsInput, UserUncheckedUpdateWithoutAlertsInput>
    create: XOR<UserCreateWithoutAlertsInput, UserUncheckedCreateWithoutAlertsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAlertsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAlertsInput, UserUncheckedUpdateWithoutAlertsInput>
  }

  export type UserUpdateWithoutAlertsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    pan?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    kycCompleted?: BoolFieldUpdateOperationsInput | boolean
    preferences?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    watchlists?: UserWatchlistUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAlertsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    pan?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    kycCompleted?: BoolFieldUpdateOperationsInput | boolean
    preferences?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    watchlists?: UserWatchlistUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type IPOUpsertWithoutAlertsInput = {
    update: XOR<IPOUpdateWithoutAlertsInput, IPOUncheckedUpdateWithoutAlertsInput>
    create: XOR<IPOCreateWithoutAlertsInput, IPOUncheckedCreateWithoutAlertsInput>
    where?: IPOWhereInput
  }

  export type IPOUpdateToOneWithWhereWithoutAlertsInput = {
    where?: IPOWhereInput
    data: XOR<IPOUpdateWithoutAlertsInput, IPOUncheckedUpdateWithoutAlertsInput>
  }

  export type IPOUpdateWithoutAlertsInput = {
    id?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    minPrice?: FloatFieldUpdateOperationsInput | number
    maxPrice?: FloatFieldUpdateOperationsInput | number
    finalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    listingPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    currentPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    issueSize?: BigIntFieldUpdateOperationsInput | bigint | number
    lotSize?: IntFieldUpdateOperationsInput | number
    marketLot?: IntFieldUpdateOperationsInput | number
    openDate?: DateTimeFieldUpdateOperationsInput | Date | string
    closeDate?: DateTimeFieldUpdateOperationsInput | Date | string
    listingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    allotmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refundDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    leadManager?: NullableStringFieldUpdateOperationsInput | string | null
    registrar?: NullableStringFieldUpdateOperationsInput | string | null
    faceValue?: NullableFloatFieldUpdateOperationsInput | number | null
    bookValue?: NullableFloatFieldUpdateOperationsInput | number | null
    marketCap?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    peRatio?: NullableFloatFieldUpdateOperationsInput | number | null
    roe?: NullableFloatFieldUpdateOperationsInput | number | null
    reservationDetails?: NullableStringFieldUpdateOperationsInput | string | null
    aboutCompany?: NullableStringFieldUpdateOperationsInput | string | null
    objectives?: NullableStringFieldUpdateOperationsInput | string | null
    risks?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gmpData?: GMPUpdateManyWithoutIpoNestedInput
    subscriptionData?: SubscriptionDataUpdateManyWithoutIpoNestedInput
    allotmentData?: AllotmentDataUpdateManyWithoutIpoNestedInput
    analytics?: IPOAnalyticsUpdateManyWithoutIpoNestedInput
    watchlists?: UserWatchlistUpdateManyWithoutIpoNestedInput
  }

  export type IPOUncheckedUpdateWithoutAlertsInput = {
    id?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    minPrice?: FloatFieldUpdateOperationsInput | number
    maxPrice?: FloatFieldUpdateOperationsInput | number
    finalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    listingPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    currentPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    issueSize?: BigIntFieldUpdateOperationsInput | bigint | number
    lotSize?: IntFieldUpdateOperationsInput | number
    marketLot?: IntFieldUpdateOperationsInput | number
    openDate?: DateTimeFieldUpdateOperationsInput | Date | string
    closeDate?: DateTimeFieldUpdateOperationsInput | Date | string
    listingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    allotmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refundDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    leadManager?: NullableStringFieldUpdateOperationsInput | string | null
    registrar?: NullableStringFieldUpdateOperationsInput | string | null
    faceValue?: NullableFloatFieldUpdateOperationsInput | number | null
    bookValue?: NullableFloatFieldUpdateOperationsInput | number | null
    marketCap?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    peRatio?: NullableFloatFieldUpdateOperationsInput | number | null
    roe?: NullableFloatFieldUpdateOperationsInput | number | null
    reservationDetails?: NullableStringFieldUpdateOperationsInput | string | null
    aboutCompany?: NullableStringFieldUpdateOperationsInput | string | null
    objectives?: NullableStringFieldUpdateOperationsInput | string | null
    risks?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gmpData?: GMPUncheckedUpdateManyWithoutIpoNestedInput
    subscriptionData?: SubscriptionDataUncheckedUpdateManyWithoutIpoNestedInput
    allotmentData?: AllotmentDataUncheckedUpdateManyWithoutIpoNestedInput
    analytics?: IPOAnalyticsUncheckedUpdateManyWithoutIpoNestedInput
    watchlists?: UserWatchlistUncheckedUpdateManyWithoutIpoNestedInput
  }

  export type GMPCreateManyIpoInput = {
    id?: string
    value: number
    percentage: number
    volume?: number | null
    bidPrice?: number | null
    askPrice?: number | null
    timestamp: Date | string
    source: string
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionDataCreateManyIpoInput = {
    id?: string
    category: string
    subCategory?: string | null
    quantity: bigint | number
    bidCount: number
    subscriptionRatio: number
    timestamp: Date | string
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AllotmentDataCreateManyIpoInput = {
    id?: string
    pan: string
    applicationNumber?: string | null
    category: string
    appliedQuantity: number
    allottedQuantity?: number
    allottedAmount?: number
    refundAmount?: number
    allotmentStatus: string
    timestamp: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IPOAnalyticsCreateManyIpoInput = {
    id?: string
    symbol?: string | null
    date: Date | string
    avgGMP?: number | null
    maxGMP?: number | null
    minGMP?: number | null
    gmpVolume?: number | null
    gmpTrend?: string | null
    overallSubscription?: number | null
    retailSubscription?: number | null
    qibSubscription?: number | null
    hniSubscription?: number | null
    marketSentiment?: string | null
    sentimentScore?: number | null
    listingGain?: number | null
    currentReturn?: number | null
    volatilityIndex?: number | null
    totalGMPChanges?: number
    totalSubscriptions?: number
    oversubscribedCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserWatchlistCreateManyIpoInput = {
    id?: string
    userId: string
    notes?: string | null
    alertPreferences?: string | null
    addedAt?: Date | string
  }

  export type UserAlertCreateManyIpoInput = {
    id?: string
    userId: string
    symbol?: string | null
    alertType: string
    triggerType: string
    triggerValue?: number | null
    triggerCondition?: string | null
    message?: string | null
    isActive?: boolean
    lastTriggered?: Date | string | null
    triggerCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GMPUpdateWithoutIpoInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    percentage?: FloatFieldUpdateOperationsInput | number
    volume?: NullableIntFieldUpdateOperationsInput | number | null
    bidPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    askPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GMPUncheckedUpdateWithoutIpoInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    percentage?: FloatFieldUpdateOperationsInput | number
    volume?: NullableIntFieldUpdateOperationsInput | number | null
    bidPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    askPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GMPUncheckedUpdateManyWithoutIpoInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    percentage?: FloatFieldUpdateOperationsInput | number
    volume?: NullableIntFieldUpdateOperationsInput | number | null
    bidPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    askPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionDataUpdateWithoutIpoInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    subCategory?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: BigIntFieldUpdateOperationsInput | bigint | number
    bidCount?: IntFieldUpdateOperationsInput | number
    subscriptionRatio?: FloatFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionDataUncheckedUpdateWithoutIpoInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    subCategory?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: BigIntFieldUpdateOperationsInput | bigint | number
    bidCount?: IntFieldUpdateOperationsInput | number
    subscriptionRatio?: FloatFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionDataUncheckedUpdateManyWithoutIpoInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    subCategory?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: BigIntFieldUpdateOperationsInput | bigint | number
    bidCount?: IntFieldUpdateOperationsInput | number
    subscriptionRatio?: FloatFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AllotmentDataUpdateWithoutIpoInput = {
    id?: StringFieldUpdateOperationsInput | string
    pan?: StringFieldUpdateOperationsInput | string
    applicationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    appliedQuantity?: IntFieldUpdateOperationsInput | number
    allottedQuantity?: IntFieldUpdateOperationsInput | number
    allottedAmount?: FloatFieldUpdateOperationsInput | number
    refundAmount?: FloatFieldUpdateOperationsInput | number
    allotmentStatus?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AllotmentDataUncheckedUpdateWithoutIpoInput = {
    id?: StringFieldUpdateOperationsInput | string
    pan?: StringFieldUpdateOperationsInput | string
    applicationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    appliedQuantity?: IntFieldUpdateOperationsInput | number
    allottedQuantity?: IntFieldUpdateOperationsInput | number
    allottedAmount?: FloatFieldUpdateOperationsInput | number
    refundAmount?: FloatFieldUpdateOperationsInput | number
    allotmentStatus?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AllotmentDataUncheckedUpdateManyWithoutIpoInput = {
    id?: StringFieldUpdateOperationsInput | string
    pan?: StringFieldUpdateOperationsInput | string
    applicationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    appliedQuantity?: IntFieldUpdateOperationsInput | number
    allottedQuantity?: IntFieldUpdateOperationsInput | number
    allottedAmount?: FloatFieldUpdateOperationsInput | number
    refundAmount?: FloatFieldUpdateOperationsInput | number
    allotmentStatus?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IPOAnalyticsUpdateWithoutIpoInput = {
    id?: StringFieldUpdateOperationsInput | string
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    avgGMP?: NullableFloatFieldUpdateOperationsInput | number | null
    maxGMP?: NullableFloatFieldUpdateOperationsInput | number | null
    minGMP?: NullableFloatFieldUpdateOperationsInput | number | null
    gmpVolume?: NullableIntFieldUpdateOperationsInput | number | null
    gmpTrend?: NullableStringFieldUpdateOperationsInput | string | null
    overallSubscription?: NullableFloatFieldUpdateOperationsInput | number | null
    retailSubscription?: NullableFloatFieldUpdateOperationsInput | number | null
    qibSubscription?: NullableFloatFieldUpdateOperationsInput | number | null
    hniSubscription?: NullableFloatFieldUpdateOperationsInput | number | null
    marketSentiment?: NullableStringFieldUpdateOperationsInput | string | null
    sentimentScore?: NullableFloatFieldUpdateOperationsInput | number | null
    listingGain?: NullableFloatFieldUpdateOperationsInput | number | null
    currentReturn?: NullableFloatFieldUpdateOperationsInput | number | null
    volatilityIndex?: NullableFloatFieldUpdateOperationsInput | number | null
    totalGMPChanges?: IntFieldUpdateOperationsInput | number
    totalSubscriptions?: IntFieldUpdateOperationsInput | number
    oversubscribedCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IPOAnalyticsUncheckedUpdateWithoutIpoInput = {
    id?: StringFieldUpdateOperationsInput | string
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    avgGMP?: NullableFloatFieldUpdateOperationsInput | number | null
    maxGMP?: NullableFloatFieldUpdateOperationsInput | number | null
    minGMP?: NullableFloatFieldUpdateOperationsInput | number | null
    gmpVolume?: NullableIntFieldUpdateOperationsInput | number | null
    gmpTrend?: NullableStringFieldUpdateOperationsInput | string | null
    overallSubscription?: NullableFloatFieldUpdateOperationsInput | number | null
    retailSubscription?: NullableFloatFieldUpdateOperationsInput | number | null
    qibSubscription?: NullableFloatFieldUpdateOperationsInput | number | null
    hniSubscription?: NullableFloatFieldUpdateOperationsInput | number | null
    marketSentiment?: NullableStringFieldUpdateOperationsInput | string | null
    sentimentScore?: NullableFloatFieldUpdateOperationsInput | number | null
    listingGain?: NullableFloatFieldUpdateOperationsInput | number | null
    currentReturn?: NullableFloatFieldUpdateOperationsInput | number | null
    volatilityIndex?: NullableFloatFieldUpdateOperationsInput | number | null
    totalGMPChanges?: IntFieldUpdateOperationsInput | number
    totalSubscriptions?: IntFieldUpdateOperationsInput | number
    oversubscribedCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IPOAnalyticsUncheckedUpdateManyWithoutIpoInput = {
    id?: StringFieldUpdateOperationsInput | string
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    avgGMP?: NullableFloatFieldUpdateOperationsInput | number | null
    maxGMP?: NullableFloatFieldUpdateOperationsInput | number | null
    minGMP?: NullableFloatFieldUpdateOperationsInput | number | null
    gmpVolume?: NullableIntFieldUpdateOperationsInput | number | null
    gmpTrend?: NullableStringFieldUpdateOperationsInput | string | null
    overallSubscription?: NullableFloatFieldUpdateOperationsInput | number | null
    retailSubscription?: NullableFloatFieldUpdateOperationsInput | number | null
    qibSubscription?: NullableFloatFieldUpdateOperationsInput | number | null
    hniSubscription?: NullableFloatFieldUpdateOperationsInput | number | null
    marketSentiment?: NullableStringFieldUpdateOperationsInput | string | null
    sentimentScore?: NullableFloatFieldUpdateOperationsInput | number | null
    listingGain?: NullableFloatFieldUpdateOperationsInput | number | null
    currentReturn?: NullableFloatFieldUpdateOperationsInput | number | null
    volatilityIndex?: NullableFloatFieldUpdateOperationsInput | number | null
    totalGMPChanges?: IntFieldUpdateOperationsInput | number
    totalSubscriptions?: IntFieldUpdateOperationsInput | number
    oversubscribedCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserWatchlistUpdateWithoutIpoInput = {
    id?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    alertPreferences?: NullableStringFieldUpdateOperationsInput | string | null
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutWatchlistsNestedInput
  }

  export type UserWatchlistUncheckedUpdateWithoutIpoInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    alertPreferences?: NullableStringFieldUpdateOperationsInput | string | null
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserWatchlistUncheckedUpdateManyWithoutIpoInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    alertPreferences?: NullableStringFieldUpdateOperationsInput | string | null
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAlertUpdateWithoutIpoInput = {
    id?: StringFieldUpdateOperationsInput | string
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    alertType?: StringFieldUpdateOperationsInput | string
    triggerType?: StringFieldUpdateOperationsInput | string
    triggerValue?: NullableFloatFieldUpdateOperationsInput | number | null
    triggerCondition?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastTriggered?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    triggerCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAlertsNestedInput
  }

  export type UserAlertUncheckedUpdateWithoutIpoInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    alertType?: StringFieldUpdateOperationsInput | string
    triggerType?: StringFieldUpdateOperationsInput | string
    triggerValue?: NullableFloatFieldUpdateOperationsInput | number | null
    triggerCondition?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastTriggered?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    triggerCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAlertUncheckedUpdateManyWithoutIpoInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    alertType?: StringFieldUpdateOperationsInput | string
    triggerType?: StringFieldUpdateOperationsInput | string
    triggerValue?: NullableFloatFieldUpdateOperationsInput | number | null
    triggerCondition?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastTriggered?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    triggerCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserWatchlistCreateManyUserInput = {
    id?: string
    ipoId: string
    notes?: string | null
    alertPreferences?: string | null
    addedAt?: Date | string
  }

  export type UserAlertCreateManyUserInput = {
    id?: string
    ipoId?: string | null
    symbol?: string | null
    alertType: string
    triggerType: string
    triggerValue?: number | null
    triggerCondition?: string | null
    message?: string | null
    isActive?: boolean
    lastTriggered?: Date | string | null
    triggerCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionCreateManyUserInput = {
    id?: string
    token: string
    refreshToken: string
    expiresAt: Date | string
    isActive?: boolean
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserWatchlistUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    alertPreferences?: NullableStringFieldUpdateOperationsInput | string | null
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipo?: IPOUpdateOneRequiredWithoutWatchlistsNestedInput
  }

  export type UserWatchlistUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    ipoId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    alertPreferences?: NullableStringFieldUpdateOperationsInput | string | null
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserWatchlistUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    ipoId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    alertPreferences?: NullableStringFieldUpdateOperationsInput | string | null
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAlertUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    alertType?: StringFieldUpdateOperationsInput | string
    triggerType?: StringFieldUpdateOperationsInput | string
    triggerValue?: NullableFloatFieldUpdateOperationsInput | number | null
    triggerCondition?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastTriggered?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    triggerCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipo?: IPOUpdateOneWithoutAlertsNestedInput
  }

  export type UserAlertUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    ipoId?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    alertType?: StringFieldUpdateOperationsInput | string
    triggerType?: StringFieldUpdateOperationsInput | string
    triggerValue?: NullableFloatFieldUpdateOperationsInput | number | null
    triggerCondition?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastTriggered?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    triggerCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAlertUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    ipoId?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    alertType?: StringFieldUpdateOperationsInput | string
    triggerType?: StringFieldUpdateOperationsInput | string
    triggerValue?: NullableFloatFieldUpdateOperationsInput | number | null
    triggerCondition?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastTriggered?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    triggerCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use IPOCountOutputTypeDefaultArgs instead
     */
    export type IPOCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = IPOCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use IPODefaultArgs instead
     */
    export type IPOArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = IPODefaultArgs<ExtArgs>
    /**
     * @deprecated Use GMPDefaultArgs instead
     */
    export type GMPArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GMPDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SubscriptionDataDefaultArgs instead
     */
    export type SubscriptionDataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SubscriptionDataDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AllotmentDataDefaultArgs instead
     */
    export type AllotmentDataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AllotmentDataDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SessionDefaultArgs instead
     */
    export type SessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SessionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use IPOAnalyticsDefaultArgs instead
     */
    export type IPOAnalyticsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = IPOAnalyticsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserWatchlistDefaultArgs instead
     */
    export type UserWatchlistArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserWatchlistDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserAlertDefaultArgs instead
     */
    export type UserAlertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserAlertDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SystemConfigDefaultArgs instead
     */
    export type SystemConfigArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SystemConfigDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ApiLogDefaultArgs instead
     */
    export type ApiLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ApiLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MarketStatusDefaultArgs instead
     */
    export type MarketStatusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MarketStatusDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CacheEntryDefaultArgs instead
     */
    export type CacheEntryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CacheEntryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SyncLogDefaultArgs instead
     */
    export type SyncLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SyncLogDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}