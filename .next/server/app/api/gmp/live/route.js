/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(() => {
var exports = {};
exports.id = "app/api/gmp/live/route";
exports.ids = ["app/api/gmp/live/route"];
exports.modules = {

/***/ "@prisma/client":
/*!*********************************!*\
  !*** external "@prisma/client" ***!
  \*********************************/
/***/ ((module) => {

"use strict";
module.exports = require("@prisma/client");

/***/ }),

/***/ "next/dist/compiled/next-server/app-page.runtime.dev.js":
/*!*************************************************************************!*\
  !*** external "next/dist/compiled/next-server/app-page.runtime.dev.js" ***!
  \*************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/compiled/next-server/app-page.runtime.dev.js");

/***/ }),

/***/ "next/dist/compiled/next-server/app-route.runtime.dev.js":
/*!**************************************************************************!*\
  !*** external "next/dist/compiled/next-server/app-route.runtime.dev.js" ***!
  \**************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/compiled/next-server/app-route.runtime.dev.js");

/***/ }),

/***/ "buffer":
/*!*************************!*\
  !*** external "buffer" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("buffer");

/***/ }),

/***/ "crypto":
/*!*************************!*\
  !*** external "crypto" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("crypto");

/***/ }),

/***/ "events":
/*!*************************!*\
  !*** external "events" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("events");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/***/ ((module) => {

"use strict";
module.exports = require("fs");

/***/ }),

/***/ "http":
/*!***********************!*\
  !*** external "http" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("http");

/***/ }),

/***/ "https":
/*!************************!*\
  !*** external "https" ***!
  \************************/
/***/ ((module) => {

"use strict";
module.exports = require("https");

/***/ }),

/***/ "net":
/*!**********************!*\
  !*** external "net" ***!
  \**********************/
/***/ ((module) => {

"use strict";
module.exports = require("net");

/***/ }),

/***/ "os":
/*!*********************!*\
  !*** external "os" ***!
  \*********************/
/***/ ((module) => {

"use strict";
module.exports = require("os");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("path");

/***/ }),

/***/ "querystring":
/*!******************************!*\
  !*** external "querystring" ***!
  \******************************/
/***/ ((module) => {

"use strict";
module.exports = require("querystring");

/***/ }),

/***/ "stream":
/*!*************************!*\
  !*** external "stream" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("stream");

/***/ }),

/***/ "timers":
/*!*************************!*\
  !*** external "timers" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("timers");

/***/ }),

/***/ "tls":
/*!**********************!*\
  !*** external "tls" ***!
  \**********************/
/***/ ((module) => {

"use strict";
module.exports = require("tls");

/***/ }),

/***/ "tty":
/*!**********************!*\
  !*** external "tty" ***!
  \**********************/
/***/ ((module) => {

"use strict";
module.exports = require("tty");

/***/ }),

/***/ "url":
/*!**********************!*\
  !*** external "url" ***!
  \**********************/
/***/ ((module) => {

"use strict";
module.exports = require("url");

/***/ }),

/***/ "util":
/*!***********************!*\
  !*** external "util" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("util");

/***/ }),

/***/ "zlib":
/*!***********************!*\
  !*** external "zlib" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("zlib");

/***/ }),

/***/ "node:crypto":
/*!******************************!*\
  !*** external "node:crypto" ***!
  \******************************/
/***/ ((module) => {

"use strict";
module.exports = require("node:crypto");

/***/ }),

/***/ "?c6f9":
/*!****************************!*\
  !*** bufferutil (ignored) ***!
  \****************************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?ae40":
/*!********************************!*\
  !*** utf-8-validate (ignored) ***!
  \********************************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?4410":
/*!****************************!*\
  !*** bufferutil (ignored) ***!
  \****************************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?c757":
/*!********************************!*\
  !*** utf-8-validate (ignored) ***!
  \********************************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fgmp%2Flive%2Froute&page=%2Fapi%2Fgmp%2Flive%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fgmp%2Flive%2Froute.js&appDir=C%3A%5CUsers%5Chp%5COneDrive%5CDesktop%5CIPOs%5Cipo-tracker%5Csrc%5Capp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=C%3A%5CUsers%5Chp%5COneDrive%5CDesktop%5CIPOs%5Cipo-tracker&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D!":
/*!**************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fgmp%2Flive%2Froute&page=%2Fapi%2Fgmp%2Flive%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fgmp%2Flive%2Froute.js&appDir=C%3A%5CUsers%5Chp%5COneDrive%5CDesktop%5CIPOs%5Cipo-tracker%5Csrc%5Capp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=C%3A%5CUsers%5Chp%5COneDrive%5CDesktop%5CIPOs%5Cipo-tracker&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D! ***!
  \**************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   originalPathname: () => (/* binding */ originalPathname),\n/* harmony export */   patchFetch: () => (/* binding */ patchFetch),\n/* harmony export */   requestAsyncStorage: () => (/* binding */ requestAsyncStorage),\n/* harmony export */   routeModule: () => (/* binding */ routeModule),\n/* harmony export */   serverHooks: () => (/* binding */ serverHooks),\n/* harmony export */   staticGenerationAsyncStorage: () => (/* binding */ staticGenerationAsyncStorage)\n/* harmony export */ });\n/* harmony import */ var next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/dist/server/future/route-modules/app-route/module.compiled */ \"(rsc)/./node_modules/next/dist/server/future/route-modules/app-route/module.compiled.js\");\n/* harmony import */ var next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/dist/server/future/route-kind */ \"(rsc)/./node_modules/next/dist/server/future/route-kind.js\");\n/* harmony import */ var next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/dist/server/lib/patch-fetch */ \"(rsc)/./node_modules/next/dist/server/lib/patch-fetch.js\");\n/* harmony import */ var next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var C_Users_hp_OneDrive_Desktop_IPOs_ipo_tracker_src_app_api_gmp_live_route_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./src/app/api/gmp/live/route.js */ \"(rsc)/./src/app/api/gmp/live/route.js\");\n\n\n\n\n// We inject the nextConfigOutput here so that we can use them in the route\n// module.\nconst nextConfigOutput = \"\"\nconst routeModule = new next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__.AppRouteRouteModule({\n    definition: {\n        kind: next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__.RouteKind.APP_ROUTE,\n        page: \"/api/gmp/live/route\",\n        pathname: \"/api/gmp/live\",\n        filename: \"route\",\n        bundlePath: \"app/api/gmp/live/route\"\n    },\n    resolvedPagePath: \"C:\\\\Users\\\\hp\\\\OneDrive\\\\Desktop\\\\IPOs\\\\ipo-tracker\\\\src\\\\app\\\\api\\\\gmp\\\\live\\\\route.js\",\n    nextConfigOutput,\n    userland: C_Users_hp_OneDrive_Desktop_IPOs_ipo_tracker_src_app_api_gmp_live_route_js__WEBPACK_IMPORTED_MODULE_3__\n});\n// Pull out the exports that we need to expose from the module. This should\n// be eliminated when we've moved the other routes to the new format. These\n// are used to hook into the route.\nconst { requestAsyncStorage, staticGenerationAsyncStorage, serverHooks } = routeModule;\nconst originalPathname = \"/api/gmp/live/route\";\nfunction patchFetch() {\n    return (0,next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__.patchFetch)({\n        serverHooks,\n        staticGenerationAsyncStorage\n    });\n}\n\n\n//# sourceMappingURL=app-route.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LWFwcC1sb2FkZXIuanM/bmFtZT1hcHAlMkZhcGklMkZnbXAlMkZsaXZlJTJGcm91dGUmcGFnZT0lMkZhcGklMkZnbXAlMkZsaXZlJTJGcm91dGUmYXBwUGF0aHM9JnBhZ2VQYXRoPXByaXZhdGUtbmV4dC1hcHAtZGlyJTJGYXBpJTJGZ21wJTJGbGl2ZSUyRnJvdXRlLmpzJmFwcERpcj1DJTNBJTVDVXNlcnMlNUNocCU1Q09uZURyaXZlJTVDRGVza3RvcCU1Q0lQT3MlNUNpcG8tdHJhY2tlciU1Q3NyYyU1Q2FwcCZwYWdlRXh0ZW5zaW9ucz10c3gmcGFnZUV4dGVuc2lvbnM9dHMmcGFnZUV4dGVuc2lvbnM9anN4JnBhZ2VFeHRlbnNpb25zPWpzJnJvb3REaXI9QyUzQSU1Q1VzZXJzJTVDaHAlNUNPbmVEcml2ZSU1Q0Rlc2t0b3AlNUNJUE9zJTVDaXBvLXRyYWNrZXImaXNEZXY9dHJ1ZSZ0c2NvbmZpZ1BhdGg9dHNjb25maWcuanNvbiZiYXNlUGF0aD0mYXNzZXRQcmVmaXg9Jm5leHRDb25maWdPdXRwdXQ9JnByZWZlcnJlZFJlZ2lvbj0mbWlkZGxld2FyZUNvbmZpZz1lMzAlM0QhIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFzRztBQUN2QztBQUNjO0FBQ3VDO0FBQ3BIO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnSEFBbUI7QUFDM0M7QUFDQSxjQUFjLHlFQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxZQUFZO0FBQ1osQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLFFBQVEsaUVBQWlFO0FBQ3pFO0FBQ0E7QUFDQSxXQUFXLDRFQUFXO0FBQ3RCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDdUg7O0FBRXZIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaXBvLXRyYWNrZXIvP2VhMWMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQXBwUm91dGVSb3V0ZU1vZHVsZSB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL2Z1dHVyZS9yb3V0ZS1tb2R1bGVzL2FwcC1yb3V0ZS9tb2R1bGUuY29tcGlsZWRcIjtcbmltcG9ydCB7IFJvdXRlS2luZCB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL2Z1dHVyZS9yb3V0ZS1raW5kXCI7XG5pbXBvcnQgeyBwYXRjaEZldGNoIGFzIF9wYXRjaEZldGNoIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvbGliL3BhdGNoLWZldGNoXCI7XG5pbXBvcnQgKiBhcyB1c2VybGFuZCBmcm9tIFwiQzpcXFxcVXNlcnNcXFxcaHBcXFxcT25lRHJpdmVcXFxcRGVza3RvcFxcXFxJUE9zXFxcXGlwby10cmFja2VyXFxcXHNyY1xcXFxhcHBcXFxcYXBpXFxcXGdtcFxcXFxsaXZlXFxcXHJvdXRlLmpzXCI7XG4vLyBXZSBpbmplY3QgdGhlIG5leHRDb25maWdPdXRwdXQgaGVyZSBzbyB0aGF0IHdlIGNhbiB1c2UgdGhlbSBpbiB0aGUgcm91dGVcbi8vIG1vZHVsZS5cbmNvbnN0IG5leHRDb25maWdPdXRwdXQgPSBcIlwiXG5jb25zdCByb3V0ZU1vZHVsZSA9IG5ldyBBcHBSb3V0ZVJvdXRlTW9kdWxlKHtcbiAgICBkZWZpbml0aW9uOiB7XG4gICAgICAgIGtpbmQ6IFJvdXRlS2luZC5BUFBfUk9VVEUsXG4gICAgICAgIHBhZ2U6IFwiL2FwaS9nbXAvbGl2ZS9yb3V0ZVwiLFxuICAgICAgICBwYXRobmFtZTogXCIvYXBpL2dtcC9saXZlXCIsXG4gICAgICAgIGZpbGVuYW1lOiBcInJvdXRlXCIsXG4gICAgICAgIGJ1bmRsZVBhdGg6IFwiYXBwL2FwaS9nbXAvbGl2ZS9yb3V0ZVwiXG4gICAgfSxcbiAgICByZXNvbHZlZFBhZ2VQYXRoOiBcIkM6XFxcXFVzZXJzXFxcXGhwXFxcXE9uZURyaXZlXFxcXERlc2t0b3BcXFxcSVBPc1xcXFxpcG8tdHJhY2tlclxcXFxzcmNcXFxcYXBwXFxcXGFwaVxcXFxnbXBcXFxcbGl2ZVxcXFxyb3V0ZS5qc1wiLFxuICAgIG5leHRDb25maWdPdXRwdXQsXG4gICAgdXNlcmxhbmRcbn0pO1xuLy8gUHVsbCBvdXQgdGhlIGV4cG9ydHMgdGhhdCB3ZSBuZWVkIHRvIGV4cG9zZSBmcm9tIHRoZSBtb2R1bGUuIFRoaXMgc2hvdWxkXG4vLyBiZSBlbGltaW5hdGVkIHdoZW4gd2UndmUgbW92ZWQgdGhlIG90aGVyIHJvdXRlcyB0byB0aGUgbmV3IGZvcm1hdC4gVGhlc2Vcbi8vIGFyZSB1c2VkIHRvIGhvb2sgaW50byB0aGUgcm91dGUuXG5jb25zdCB7IHJlcXVlc3RBc3luY1N0b3JhZ2UsIHN0YXRpY0dlbmVyYXRpb25Bc3luY1N0b3JhZ2UsIHNlcnZlckhvb2tzIH0gPSByb3V0ZU1vZHVsZTtcbmNvbnN0IG9yaWdpbmFsUGF0aG5hbWUgPSBcIi9hcGkvZ21wL2xpdmUvcm91dGVcIjtcbmZ1bmN0aW9uIHBhdGNoRmV0Y2goKSB7XG4gICAgcmV0dXJuIF9wYXRjaEZldGNoKHtcbiAgICAgICAgc2VydmVySG9va3MsXG4gICAgICAgIHN0YXRpY0dlbmVyYXRpb25Bc3luY1N0b3JhZ2VcbiAgICB9KTtcbn1cbmV4cG9ydCB7IHJvdXRlTW9kdWxlLCByZXF1ZXN0QXN5bmNTdG9yYWdlLCBzdGF0aWNHZW5lcmF0aW9uQXN5bmNTdG9yYWdlLCBzZXJ2ZXJIb29rcywgb3JpZ2luYWxQYXRobmFtZSwgcGF0Y2hGZXRjaCwgIH07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFwcC1yb3V0ZS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fgmp%2Flive%2Froute&page=%2Fapi%2Fgmp%2Flive%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fgmp%2Flive%2Froute.js&appDir=C%3A%5CUsers%5Chp%5COneDrive%5CDesktop%5CIPOs%5Cipo-tracker%5Csrc%5Capp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=C%3A%5CUsers%5Chp%5COneDrive%5CDesktop%5CIPOs%5Cipo-tracker&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D!\n");

/***/ }),

/***/ "(rsc)/./src/app/api/gmp/live/route.js":
/*!***************************************!*\
  !*** ./src/app/api/gmp/live/route.js ***!
  \***************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GET: () => (/* binding */ GET),\n/* harmony export */   POST: () => (/* binding */ POST)\n/* harmony export */ });\n/* harmony import */ var next_server__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/server */ \"(rsc)/./node_modules/next/dist/api/server.js\");\n/* harmony import */ var _lib_db__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../lib/db */ \"(rsc)/./src/lib/db.js\");\n/* harmony import */ var _lib_cache__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../lib/cache */ \"(rsc)/./src/lib/cache.js\");\n/* harmony import */ var _lib_websocket__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../../lib/websocket */ \"(rsc)/./src/lib/websocket.js\");\n// Live GMP API Routes\n// GET /api/gmp/live - Real-time GMP data with WebSocket integration\n\n\n\n\n// GET /api/gmp/live?symbols=SYM1,SYM2&ipoIds=id1,id2\nasync function GET(request) {\n    try {\n        const { searchParams } = new URL(request.url);\n        const symbolsParam = searchParams.get(\"symbols\");\n        const ipoIdsParam = searchParams.get(\"ipoIds\");\n        const includeHistory = searchParams.get(\"includeHistory\") === \"true\";\n        const historyDays = Math.min(parseInt(searchParams.get(\"historyDays\")) || 7, 30);\n        if (!symbolsParam && !ipoIdsParam) {\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                error: \"Either symbols or ipoIds parameter is required\"\n            }, {\n                status: 400\n            });\n        }\n        let whereClause = {};\n        if (symbolsParam) {\n            const symbols = symbolsParam.split(\",\").map((s)=>s.trim().toUpperCase());\n            whereClause = {\n                symbol: {\n                    in: symbols\n                },\n                isActive: true\n            };\n        } else if (ipoIdsParam) {\n            const ipoIds = ipoIdsParam.split(\",\").map((id)=>id.trim());\n            whereClause = {\n                id: {\n                    in: ipoIds\n                },\n                isActive: true\n            };\n        }\n        // Fetch IPOs with latest GMP data\n        const ipos = await _lib_db__WEBPACK_IMPORTED_MODULE_1__.prisma.iPO.findMany({\n            where: whereClause,\n            select: {\n                id: true,\n                symbol: true,\n                name: true,\n                status: true,\n                minPrice: true,\n                maxPrice: true,\n                openDate: true,\n                closeDate: true,\n                gmp: {\n                    orderBy: {\n                        timestamp: \"desc\"\n                    },\n                    take: includeHistory ? historyDays * 24 : 1,\n                    select: {\n                        id: true,\n                        value: true,\n                        percentage: true,\n                        source: true,\n                        volume: true,\n                        timestamp: true\n                    }\n                }\n            }\n        });\n        if (ipos.length === 0) {\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                gmpData: [],\n                message: \"No IPOs found\",\n                timestamp: new Date().toISOString()\n            });\n        }\n        // Enhance with live cache data and calculations\n        const enhancedData = await Promise.all(ipos.map(async (ipo)=>{\n            // Get cached live GMP if available\n            const liveGMP = await _lib_cache__WEBPACK_IMPORTED_MODULE_2__.cache.getCachedLiveGMP(ipo.id);\n            const latestGMP = ipo.gmp[0] || null;\n            // Use live data if fresher than database data\n            const currentGMP = liveGMP && liveGMP.timestamp > (latestGMP?.timestamp || 0) ? liveGMP : latestGMP;\n            // Calculate GMP statistics if history is requested\n            let gmpStats = null;\n            if (includeHistory && ipo.gmp.length > 1) {\n                const values = ipo.gmp.map((g)=>Number(g.value));\n                const percentages = ipo.gmp.map((g)=>Number(g.percentage));\n                gmpStats = {\n                    count: values.length,\n                    average: values.reduce((a, b)=>a + b, 0) / values.length,\n                    max: Math.max(...values),\n                    min: Math.min(...values),\n                    latest: values[0],\n                    change24h: values.length > 1 ? values[0] - values[values.length - 1] : 0,\n                    volatility: calculateVolatility(values),\n                    trend: calculateTrend(values),\n                    averagePercentage: percentages.reduce((a, b)=>a + b, 0) / percentages.length\n                };\n            }\n            // Calculate potential returns\n            const potentialReturns = calculatePotentialReturns(ipo, currentGMP);\n            return {\n                ipoId: ipo.id,\n                symbol: ipo.symbol,\n                name: ipo.name,\n                status: ipo.status,\n                priceRange: {\n                    min: ipo.minPrice ? Number(ipo.minPrice) : null,\n                    max: ipo.maxPrice ? Number(ipo.maxPrice) : null\n                },\n                dates: {\n                    open: ipo.openDate,\n                    close: ipo.closeDate\n                },\n                currentGMP: currentGMP ? {\n                    value: Number(currentGMP.value),\n                    percentage: Number(currentGMP.percentage),\n                    source: currentGMP.source || \"market\",\n                    volume: currentGMP.volume || null,\n                    timestamp: currentGMP.timestamp,\n                    isLive: !!liveGMP\n                } : null,\n                gmpHistory: includeHistory ? ipo.gmp.map((gmp)=>({\n                        value: Number(gmp.value),\n                        percentage: Number(gmp.percentage),\n                        source: gmp.source,\n                        volume: gmp.volume,\n                        timestamp: gmp.timestamp\n                    })) : null,\n                statistics: gmpStats,\n                potentialReturns,\n                lastUpdated: currentGMP?.timestamp || new Date().toISOString()\n            };\n        }));\n        const response = {\n            gmpData: enhancedData,\n            metadata: {\n                totalIPOs: enhancedData.length,\n                liveDataCount: enhancedData.filter((d)=>d.currentGMP?.isLive).length,\n                includeHistory,\n                historyDays: includeHistory ? historyDays : 0\n            },\n            timestamp: new Date().toISOString()\n        };\n        // Cache the response briefly for performance\n        const cacheKey = `live_gmp_${symbolsParam || ipoIdsParam}_${includeHistory}_${historyDays}`;\n        await _lib_cache__WEBPACK_IMPORTED_MODULE_2__.cache.set(cacheKey, response, 30); // 30 seconds cache\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json(response);\n    } catch (error) {\n        console.error(\"Failed to fetch live GMP data:\", error);\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n            error: \"Failed to fetch live GMP data\",\n            message: error.message,\n            timestamp: new Date().toISOString()\n        }, {\n            status: 500\n        });\n    }\n}\n// POST /api/gmp/live - Update GMP data (for authorized sources)\nasync function POST(request) {\n    try {\n        const body = await request.json();\n        const { updates } = body;\n        if (!Array.isArray(updates)) {\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                error: \"Updates must be an array\"\n            }, {\n                status: 400\n            });\n        }\n        const results = [];\n        const validUpdates = [];\n        // Validate and process updates\n        for (const update of updates){\n            try {\n                const { ipoId, symbol, value, percentage, source, volume } = update;\n                if (!ipoId && !symbol) {\n                    results.push({\n                        status: \"error\",\n                        error: \"Either ipoId or symbol is required\",\n                        data: update\n                    });\n                    continue;\n                }\n                if (typeof value !== \"number\") {\n                    results.push({\n                        status: \"error\",\n                        error: \"Value must be a number\",\n                        data: update\n                    });\n                    continue;\n                }\n                // Find IPO\n                let ipo;\n                if (ipoId) {\n                    ipo = await _lib_db__WEBPACK_IMPORTED_MODULE_1__.prisma.iPO.findUnique({\n                        where: {\n                            id: ipoId\n                        }\n                    });\n                } else {\n                    ipo = await _lib_db__WEBPACK_IMPORTED_MODULE_1__.prisma.iPO.findUnique({\n                        where: {\n                            symbol: symbol.toUpperCase()\n                        }\n                    });\n                }\n                if (!ipo) {\n                    results.push({\n                        status: \"error\",\n                        error: \"IPO not found\",\n                        data: update\n                    });\n                    continue;\n                }\n                // Calculate percentage if not provided\n                const calculatedPercentage = percentage || (ipo.minPrice ? value / Number(ipo.minPrice) * 100 - 100 : 0);\n                const gmpData = {\n                    ipoId: ipo.id,\n                    value: value,\n                    percentage: calculatedPercentage,\n                    source: source || \"api\",\n                    volume: volume || null,\n                    timestamp: new Date(),\n                    date: new Date()\n                };\n                validUpdates.push(gmpData);\n                results.push({\n                    ipoId: ipo.id,\n                    symbol: ipo.symbol,\n                    status: \"queued\",\n                    data: gmpData\n                });\n            } catch (error) {\n                results.push({\n                    status: \"error\",\n                    error: error.message,\n                    data: update\n                });\n            }\n        }\n        // Batch insert valid updates\n        if (validUpdates.length > 0) {\n            try {\n                await _lib_db__WEBPACK_IMPORTED_MODULE_1__.prisma.gMP.createMany({\n                    data: validUpdates\n                });\n                // Update cache and broadcast real-time updates\n                for (const gmpData of validUpdates){\n                    // Cache live GMP data\n                    await _lib_cache__WEBPACK_IMPORTED_MODULE_2__.cache.cacheLiveGMP(gmpData.ipoId, gmpData.value);\n                    // Find IPO symbol for WebSocket broadcast\n                    const ipo = await _lib_db__WEBPACK_IMPORTED_MODULE_1__.prisma.iPO.findUnique({\n                        where: {\n                            id: gmpData.ipoId\n                        },\n                        select: {\n                            symbol: true\n                        }\n                    });\n                    if (ipo && _lib_websocket__WEBPACK_IMPORTED_MODULE_3__.webSocketService.io) {\n                        // Broadcast to WebSocket subscribers\n                        _lib_websocket__WEBPACK_IMPORTED_MODULE_3__.webSocketService.broadcastGMPUpdate(gmpData.ipoId, {\n                            value: gmpData.value,\n                            percentage: gmpData.percentage,\n                            source: gmpData.source,\n                            volume: gmpData.volume,\n                            timestamp: gmpData.timestamp\n                        });\n                    }\n                }\n                console.log(`âœ… Processed ${validUpdates.length} GMP updates`);\n            } catch (dbError) {\n                console.error(\"Database insert failed:\", dbError);\n                return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                    error: \"Failed to save GMP updates\",\n                    message: dbError.message\n                }, {\n                    status: 500\n                });\n            }\n        }\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n            message: `Processed ${results.length} updates`,\n            successful: validUpdates.length,\n            failed: results.length - validUpdates.length,\n            results,\n            timestamp: new Date().toISOString()\n        });\n    } catch (error) {\n        console.error(\"Failed to update GMP data:\", error);\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n            error: \"Failed to update GMP data\",\n            message: error.message\n        }, {\n            status: 500\n        });\n    }\n}\n// Utility functions\nfunction calculateVolatility(values) {\n    if (values.length < 2) return 0;\n    const mean = values.reduce((a, b)=>a + b, 0) / values.length;\n    const variance = values.reduce((acc, val)=>acc + Math.pow(val - mean, 2), 0) / values.length;\n    return Math.sqrt(variance);\n}\nfunction calculateTrend(values) {\n    if (values.length < 2) return \"neutral\";\n    const recent = values.slice(0, Math.min(5, values.length));\n    const older = values.slice(Math.min(5, values.length));\n    if (older.length === 0) return \"neutral\";\n    const recentAvg = recent.reduce((a, b)=>a + b, 0) / recent.length;\n    const olderAvg = older.reduce((a, b)=>a + b, 0) / older.length;\n    const diff = recentAvg - olderAvg;\n    const threshold = olderAvg * 0.05; // 5% threshold\n    if (diff > threshold) return \"bullish\";\n    if (diff < -threshold) return \"bearish\";\n    return \"neutral\";\n}\nfunction calculatePotentialReturns(ipo, gmp) {\n    if (!gmp || !ipo.minPrice || !ipo.maxPrice) return null;\n    const minPrice = Number(ipo.minPrice);\n    const maxPrice = Number(ipo.maxPrice);\n    const gmpValue = Number(gmp.value);\n    const expectedListingPrice = minPrice + gmpValue;\n    return {\n        atMinPrice: {\n            investment: minPrice,\n            expectedReturn: gmpValue,\n            returnPercentage: gmpValue / minPrice * 100\n        },\n        atMaxPrice: {\n            investment: maxPrice,\n            expectedReturn: expectedListingPrice - maxPrice,\n            returnPercentage: (expectedListingPrice - maxPrice) / maxPrice * 100\n        },\n        expectedListingPrice,\n        breakeven: {\n            minGMP: -minPrice,\n            maxGMP: -maxPrice\n        }\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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bGl2ZS9yb3V0ZS5qcz9jZTRiIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIExpdmUgR01QIEFQSSBSb3V0ZXNcclxuLy8gR0VUIC9hcGkvZ21wL2xpdmUgLSBSZWFsLXRpbWUgR01QIGRhdGEgd2l0aCBXZWJTb2NrZXQgaW50ZWdyYXRpb25cclxuXHJcbmltcG9ydCB7IE5leHRSZXNwb25zZSB9IGZyb20gJ25leHQvc2VydmVyJztcclxuaW1wb3J0IHsgcHJpc21hIH0gZnJvbSAnLi4vLi4vLi4vLi4vbGliL2RiJztcclxuaW1wb3J0IHsgY2FjaGUgfSBmcm9tICcuLi8uLi8uLi8uLi9saWIvY2FjaGUnO1xyXG5pbXBvcnQgeyB3ZWJTb2NrZXRTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vLi4vLi4vbGliL3dlYnNvY2tldCc7XHJcblxyXG4vLyBHRVQgL2FwaS9nbXAvbGl2ZT9zeW1ib2xzPVNZTTEsU1lNMiZpcG9JZHM9aWQxLGlkMlxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gR0VUKHJlcXVlc3QpIHtcclxuICB0cnkge1xyXG4gICAgY29uc3QgeyBzZWFyY2hQYXJhbXMgfSA9IG5ldyBVUkwocmVxdWVzdC51cmwpO1xyXG4gICAgY29uc3Qgc3ltYm9sc1BhcmFtID0gc2VhcmNoUGFyYW1zLmdldCgnc3ltYm9scycpO1xyXG4gICAgY29uc3QgaXBvSWRzUGFyYW0gPSBzZWFyY2hQYXJhbXMuZ2V0KCdpcG9JZHMnKTtcclxuICAgIGNvbnN0IGluY2x1ZGVIaXN0b3J5ID0gc2VhcmNoUGFyYW1zLmdldCgnaW5jbHVkZUhpc3RvcnknKSA9PT0gJ3RydWUnO1xyXG4gICAgY29uc3QgaGlzdG9yeURheXMgPSBNYXRoLm1pbihwYXJzZUludChzZWFyY2hQYXJhbXMuZ2V0KCdoaXN0b3J5RGF5cycpKSB8fCA3LCAzMCk7XHJcblxyXG4gICAgaWYgKCFzeW1ib2xzUGFyYW0gJiYgIWlwb0lkc1BhcmFtKSB7XHJcbiAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbihcclxuICAgICAgICB7IGVycm9yOiAnRWl0aGVyIHN5bWJvbHMgb3IgaXBvSWRzIHBhcmFtZXRlciBpcyByZXF1aXJlZCcgfSxcclxuICAgICAgICB7IHN0YXR1czogNDAwIH1cclxuICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICBsZXQgd2hlcmVDbGF1c2UgPSB7fTtcclxuXHJcbiAgICBpZiAoc3ltYm9sc1BhcmFtKSB7XHJcbiAgICAgIGNvbnN0IHN5bWJvbHMgPSBzeW1ib2xzUGFyYW0uc3BsaXQoJywnKS5tYXAoKHMpID0+IHMudHJpbSgpLnRvVXBwZXJDYXNlKCkpO1xyXG4gICAgICB3aGVyZUNsYXVzZSA9IHtcclxuICAgICAgICBzeW1ib2w6IHsgaW46IHN5bWJvbHMgfSxcclxuICAgICAgICBpc0FjdGl2ZTogdHJ1ZSxcclxuICAgICAgfTtcclxuICAgIH0gZWxzZSBpZiAoaXBvSWRzUGFyYW0pIHtcclxuICAgICAgY29uc3QgaXBvSWRzID0gaXBvSWRzUGFyYW0uc3BsaXQoJywnKS5tYXAoKGlkKSA9PiBpZC50cmltKCkpO1xyXG4gICAgICB3aGVyZUNsYXVzZSA9IHtcclxuICAgICAgICBpZDogeyBpbjogaXBvSWRzIH0sXHJcbiAgICAgICAgaXNBY3RpdmU6IHRydWUsXHJcbiAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRmV0Y2ggSVBPcyB3aXRoIGxhdGVzdCBHTVAgZGF0YVxyXG4gICAgY29uc3QgaXBvcyA9IGF3YWl0IHByaXNtYS5pUE8uZmluZE1hbnkoe1xyXG4gICAgICB3aGVyZTogd2hlcmVDbGF1c2UsXHJcbiAgICAgIHNlbGVjdDoge1xyXG4gICAgICAgIGlkOiB0cnVlLFxyXG4gICAgICAgIHN5bWJvbDogdHJ1ZSxcclxuICAgICAgICBuYW1lOiB0cnVlLFxyXG4gICAgICAgIHN0YXR1czogdHJ1ZSxcclxuICAgICAgICBtaW5QcmljZTogdHJ1ZSxcclxuICAgICAgICBtYXhQcmljZTogdHJ1ZSxcclxuICAgICAgICBvcGVuRGF0ZTogdHJ1ZSxcclxuICAgICAgICBjbG9zZURhdGU6IHRydWUsXHJcbiAgICAgICAgZ21wOiB7XHJcbiAgICAgICAgICBvcmRlckJ5OiB7IHRpbWVzdGFtcDogJ2Rlc2MnIH0sXHJcbiAgICAgICAgICB0YWtlOiBpbmNsdWRlSGlzdG9yeSA/IGhpc3RvcnlEYXlzICogMjQgOiAxLCAvLyBBc3N1bWUgaG91cmx5IGRhdGFcclxuICAgICAgICAgIHNlbGVjdDoge1xyXG4gICAgICAgICAgICBpZDogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IHRydWUsXHJcbiAgICAgICAgICAgIHBlcmNlbnRhZ2U6IHRydWUsXHJcbiAgICAgICAgICAgIHNvdXJjZTogdHJ1ZSxcclxuICAgICAgICAgICAgdm9sdW1lOiB0cnVlLFxyXG4gICAgICAgICAgICB0aW1lc3RhbXA6IHRydWUsXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgIH0sXHJcbiAgICAgIH0sXHJcbiAgICB9KTtcclxuXHJcbiAgICBpZiAoaXBvcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKHtcclxuICAgICAgICBnbXBEYXRhOiBbXSxcclxuICAgICAgICBtZXNzYWdlOiAnTm8gSVBPcyBmb3VuZCcsXHJcbiAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEVuaGFuY2Ugd2l0aCBsaXZlIGNhY2hlIGRhdGEgYW5kIGNhbGN1bGF0aW9uc1xyXG4gICAgY29uc3QgZW5oYW5jZWREYXRhID0gYXdhaXQgUHJvbWlzZS5hbGwoXHJcbiAgICAgIGlwb3MubWFwKGFzeW5jIChpcG8pID0+IHtcclxuICAgICAgICAvLyBHZXQgY2FjaGVkIGxpdmUgR01QIGlmIGF2YWlsYWJsZVxyXG4gICAgICAgIGNvbnN0IGxpdmVHTVAgPSBhd2FpdCBjYWNoZS5nZXRDYWNoZWRMaXZlR01QKGlwby5pZCk7XHJcbiAgICAgICAgY29uc3QgbGF0ZXN0R01QID0gaXBvLmdtcFswXSB8fCBudWxsO1xyXG5cclxuICAgICAgICAvLyBVc2UgbGl2ZSBkYXRhIGlmIGZyZXNoZXIgdGhhbiBkYXRhYmFzZSBkYXRhXHJcbiAgICAgICAgY29uc3QgY3VycmVudEdNUCA9XHJcbiAgICAgICAgICBsaXZlR01QICYmIGxpdmVHTVAudGltZXN0YW1wID4gKGxhdGVzdEdNUD8udGltZXN0YW1wIHx8IDApID8gbGl2ZUdNUCA6IGxhdGVzdEdNUDtcclxuXHJcbiAgICAgICAgLy8gQ2FsY3VsYXRlIEdNUCBzdGF0aXN0aWNzIGlmIGhpc3RvcnkgaXMgcmVxdWVzdGVkXHJcbiAgICAgICAgbGV0IGdtcFN0YXRzID0gbnVsbDtcclxuICAgICAgICBpZiAoaW5jbHVkZUhpc3RvcnkgJiYgaXBvLmdtcC5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICBjb25zdCB2YWx1ZXMgPSBpcG8uZ21wLm1hcCgoZykgPT4gTnVtYmVyKGcudmFsdWUpKTtcclxuICAgICAgICAgIGNvbnN0IHBlcmNlbnRhZ2VzID0gaXBvLmdtcC5tYXAoKGcpID0+IE51bWJlcihnLnBlcmNlbnRhZ2UpKTtcclxuXHJcbiAgICAgICAgICBnbXBTdGF0cyA9IHtcclxuICAgICAgICAgICAgY291bnQ6IHZhbHVlcy5sZW5ndGgsXHJcbiAgICAgICAgICAgIGF2ZXJhZ2U6IHZhbHVlcy5yZWR1Y2UoKGEsIGIpID0+IGEgKyBiLCAwKSAvIHZhbHVlcy5sZW5ndGgsXHJcbiAgICAgICAgICAgIG1heDogTWF0aC5tYXgoLi4udmFsdWVzKSxcclxuICAgICAgICAgICAgbWluOiBNYXRoLm1pbiguLi52YWx1ZXMpLFxyXG4gICAgICAgICAgICBsYXRlc3Q6IHZhbHVlc1swXSxcclxuICAgICAgICAgICAgY2hhbmdlMjRoOiB2YWx1ZXMubGVuZ3RoID4gMSA/IHZhbHVlc1swXSAtIHZhbHVlc1t2YWx1ZXMubGVuZ3RoIC0gMV0gOiAwLFxyXG4gICAgICAgICAgICB2b2xhdGlsaXR5OiBjYWxjdWxhdGVWb2xhdGlsaXR5KHZhbHVlcyksXHJcbiAgICAgICAgICAgIHRyZW5kOiBjYWxjdWxhdGVUcmVuZCh2YWx1ZXMpLFxyXG4gICAgICAgICAgICBhdmVyYWdlUGVyY2VudGFnZTogcGVyY2VudGFnZXMucmVkdWNlKChhLCBiKSA9PiBhICsgYiwgMCkgLyBwZXJjZW50YWdlcy5sZW5ndGgsXHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQ2FsY3VsYXRlIHBvdGVudGlhbCByZXR1cm5zXHJcbiAgICAgICAgY29uc3QgcG90ZW50aWFsUmV0dXJucyA9IGNhbGN1bGF0ZVBvdGVudGlhbFJldHVybnMoaXBvLCBjdXJyZW50R01QKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgIGlwb0lkOiBpcG8uaWQsXHJcbiAgICAgICAgICBzeW1ib2w6IGlwby5zeW1ib2wsXHJcbiAgICAgICAgICBuYW1lOiBpcG8ubmFtZSxcclxuICAgICAgICAgIHN0YXR1czogaXBvLnN0YXR1cyxcclxuICAgICAgICAgIHByaWNlUmFuZ2U6IHtcclxuICAgICAgICAgICAgbWluOiBpcG8ubWluUHJpY2UgPyBOdW1iZXIoaXBvLm1pblByaWNlKSA6IG51bGwsXHJcbiAgICAgICAgICAgIG1heDogaXBvLm1heFByaWNlID8gTnVtYmVyKGlwby5tYXhQcmljZSkgOiBudWxsLFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIGRhdGVzOiB7XHJcbiAgICAgICAgICAgIG9wZW46IGlwby5vcGVuRGF0ZSxcclxuICAgICAgICAgICAgY2xvc2U6IGlwby5jbG9zZURhdGUsXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgY3VycmVudEdNUDogY3VycmVudEdNUFxyXG4gICAgICAgICAgICA/IHtcclxuICAgICAgICAgICAgICAgIHZhbHVlOiBOdW1iZXIoY3VycmVudEdNUC52YWx1ZSksXHJcbiAgICAgICAgICAgICAgICBwZXJjZW50YWdlOiBOdW1iZXIoY3VycmVudEdNUC5wZXJjZW50YWdlKSxcclxuICAgICAgICAgICAgICAgIHNvdXJjZTogY3VycmVudEdNUC5zb3VyY2UgfHwgJ21hcmtldCcsXHJcbiAgICAgICAgICAgICAgICB2b2x1bWU6IGN1cnJlbnRHTVAudm9sdW1lIHx8IG51bGwsXHJcbiAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IGN1cnJlbnRHTVAudGltZXN0YW1wLFxyXG4gICAgICAgICAgICAgICAgaXNMaXZlOiAhIWxpdmVHTVAsXHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICA6IG51bGwsXHJcbiAgICAgICAgICBnbXBIaXN0b3J5OiBpbmNsdWRlSGlzdG9yeVxyXG4gICAgICAgICAgICA/IGlwby5nbXAubWFwKChnbXApID0+ICh7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogTnVtYmVyKGdtcC52YWx1ZSksXHJcbiAgICAgICAgICAgICAgICBwZXJjZW50YWdlOiBOdW1iZXIoZ21wLnBlcmNlbnRhZ2UpLFxyXG4gICAgICAgICAgICAgICAgc291cmNlOiBnbXAuc291cmNlLFxyXG4gICAgICAgICAgICAgICAgdm9sdW1lOiBnbXAudm9sdW1lLFxyXG4gICAgICAgICAgICAgICAgdGltZXN0YW1wOiBnbXAudGltZXN0YW1wLFxyXG4gICAgICAgICAgICAgIH0pKVxyXG4gICAgICAgICAgICA6IG51bGwsXHJcbiAgICAgICAgICBzdGF0aXN0aWNzOiBnbXBTdGF0cyxcclxuICAgICAgICAgIHBvdGVudGlhbFJldHVybnMsXHJcbiAgICAgICAgICBsYXN0VXBkYXRlZDogY3VycmVudEdNUD8udGltZXN0YW1wIHx8IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcclxuICAgICAgICB9O1xyXG4gICAgICB9KVxyXG4gICAgKTtcclxuXHJcbiAgICBjb25zdCByZXNwb25zZSA9IHtcclxuICAgICAgZ21wRGF0YTogZW5oYW5jZWREYXRhLFxyXG4gICAgICBtZXRhZGF0YToge1xyXG4gICAgICAgIHRvdGFsSVBPczogZW5oYW5jZWREYXRhLmxlbmd0aCxcclxuICAgICAgICBsaXZlRGF0YUNvdW50OiBlbmhhbmNlZERhdGEuZmlsdGVyKChkKSA9PiBkLmN1cnJlbnRHTVA/LmlzTGl2ZSkubGVuZ3RoLFxyXG4gICAgICAgIGluY2x1ZGVIaXN0b3J5LFxyXG4gICAgICAgIGhpc3RvcnlEYXlzOiBpbmNsdWRlSGlzdG9yeSA/IGhpc3RvcnlEYXlzIDogMCxcclxuICAgICAgfSxcclxuICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXHJcbiAgICB9O1xyXG5cclxuICAgIC8vIENhY2hlIHRoZSByZXNwb25zZSBicmllZmx5IGZvciBwZXJmb3JtYW5jZVxyXG4gICAgY29uc3QgY2FjaGVLZXkgPSBgbGl2ZV9nbXBfJHtzeW1ib2xzUGFyYW0gfHwgaXBvSWRzUGFyYW19XyR7aW5jbHVkZUhpc3Rvcnl9XyR7aGlzdG9yeURheXN9YDtcclxuICAgIGF3YWl0IGNhY2hlLnNldChjYWNoZUtleSwgcmVzcG9uc2UsIDMwKTsgLy8gMzAgc2Vjb25kcyBjYWNoZVxyXG5cclxuICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbihyZXNwb25zZSk7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBmZXRjaCBsaXZlIEdNUCBkYXRhOicsIGVycm9yKTtcclxuICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbihcclxuICAgICAge1xyXG4gICAgICAgIGVycm9yOiAnRmFpbGVkIHRvIGZldGNoIGxpdmUgR01QIGRhdGEnLFxyXG4gICAgICAgIG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2UsXHJcbiAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXHJcbiAgICAgIH0sXHJcbiAgICAgIHsgc3RhdHVzOiA1MDAgfVxyXG4gICAgKTtcclxuICB9XHJcbn1cclxuXHJcbi8vIFBPU1QgL2FwaS9nbXAvbGl2ZSAtIFVwZGF0ZSBHTVAgZGF0YSAoZm9yIGF1dGhvcml6ZWQgc291cmNlcylcclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIFBPU1QocmVxdWVzdCkge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCBib2R5ID0gYXdhaXQgcmVxdWVzdC5qc29uKCk7XHJcbiAgICBjb25zdCB7IHVwZGF0ZXMgfSA9IGJvZHk7XHJcblxyXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHVwZGF0ZXMpKSB7XHJcbiAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbih7IGVycm9yOiAnVXBkYXRlcyBtdXN0IGJlIGFuIGFycmF5JyB9LCB7IHN0YXR1czogNDAwIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcclxuICAgIGNvbnN0IHZhbGlkVXBkYXRlcyA9IFtdO1xyXG5cclxuICAgIC8vIFZhbGlkYXRlIGFuZCBwcm9jZXNzIHVwZGF0ZXNcclxuICAgIGZvciAoY29uc3QgdXBkYXRlIG9mIHVwZGF0ZXMpIHtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBjb25zdCB7IGlwb0lkLCBzeW1ib2wsIHZhbHVlLCBwZXJjZW50YWdlLCBzb3VyY2UsIHZvbHVtZSB9ID0gdXBkYXRlO1xyXG5cclxuICAgICAgICBpZiAoIWlwb0lkICYmICFzeW1ib2wpIHtcclxuICAgICAgICAgIHJlc3VsdHMucHVzaCh7XHJcbiAgICAgICAgICAgIHN0YXR1czogJ2Vycm9yJyxcclxuICAgICAgICAgICAgZXJyb3I6ICdFaXRoZXIgaXBvSWQgb3Igc3ltYm9sIGlzIHJlcXVpcmVkJyxcclxuICAgICAgICAgICAgZGF0YTogdXBkYXRlLFxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICByZXN1bHRzLnB1c2goe1xyXG4gICAgICAgICAgICBzdGF0dXM6ICdlcnJvcicsXHJcbiAgICAgICAgICAgIGVycm9yOiAnVmFsdWUgbXVzdCBiZSBhIG51bWJlcicsXHJcbiAgICAgICAgICAgIGRhdGE6IHVwZGF0ZSxcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBGaW5kIElQT1xyXG4gICAgICAgIGxldCBpcG87XHJcbiAgICAgICAgaWYgKGlwb0lkKSB7XHJcbiAgICAgICAgICBpcG8gPSBhd2FpdCBwcmlzbWEuaVBPLmZpbmRVbmlxdWUoeyB3aGVyZTogeyBpZDogaXBvSWQgfSB9KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgaXBvID0gYXdhaXQgcHJpc21hLmlQTy5maW5kVW5pcXVlKHtcclxuICAgICAgICAgICAgd2hlcmU6IHsgc3ltYm9sOiBzeW1ib2wudG9VcHBlckNhc2UoKSB9LFxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIWlwbykge1xyXG4gICAgICAgICAgcmVzdWx0cy5wdXNoKHtcclxuICAgICAgICAgICAgc3RhdHVzOiAnZXJyb3InLFxyXG4gICAgICAgICAgICBlcnJvcjogJ0lQTyBub3QgZm91bmQnLFxyXG4gICAgICAgICAgICBkYXRhOiB1cGRhdGUsXHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQ2FsY3VsYXRlIHBlcmNlbnRhZ2UgaWYgbm90IHByb3ZpZGVkXHJcbiAgICAgICAgY29uc3QgY2FsY3VsYXRlZFBlcmNlbnRhZ2UgPVxyXG4gICAgICAgICAgcGVyY2VudGFnZSB8fCAoaXBvLm1pblByaWNlID8gKHZhbHVlIC8gTnVtYmVyKGlwby5taW5QcmljZSkpICogMTAwIC0gMTAwIDogMCk7XHJcblxyXG4gICAgICAgIGNvbnN0IGdtcERhdGEgPSB7XHJcbiAgICAgICAgICBpcG9JZDogaXBvLmlkLFxyXG4gICAgICAgICAgdmFsdWU6IHZhbHVlLFxyXG4gICAgICAgICAgcGVyY2VudGFnZTogY2FsY3VsYXRlZFBlcmNlbnRhZ2UsXHJcbiAgICAgICAgICBzb3VyY2U6IHNvdXJjZSB8fCAnYXBpJyxcclxuICAgICAgICAgIHZvbHVtZTogdm9sdW1lIHx8IG51bGwsXHJcbiAgICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCksXHJcbiAgICAgICAgICBkYXRlOiBuZXcgRGF0ZSgpLFxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHZhbGlkVXBkYXRlcy5wdXNoKGdtcERhdGEpO1xyXG4gICAgICAgIHJlc3VsdHMucHVzaCh7XHJcbiAgICAgICAgICBpcG9JZDogaXBvLmlkLFxyXG4gICAgICAgICAgc3ltYm9sOiBpcG8uc3ltYm9sLFxyXG4gICAgICAgICAgc3RhdHVzOiAncXVldWVkJyxcclxuICAgICAgICAgIGRhdGE6IGdtcERhdGEsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgcmVzdWx0cy5wdXNoKHtcclxuICAgICAgICAgIHN0YXR1czogJ2Vycm9yJyxcclxuICAgICAgICAgIGVycm9yOiBlcnJvci5tZXNzYWdlLFxyXG4gICAgICAgICAgZGF0YTogdXBkYXRlLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQmF0Y2ggaW5zZXJ0IHZhbGlkIHVwZGF0ZXNcclxuICAgIGlmICh2YWxpZFVwZGF0ZXMubGVuZ3RoID4gMCkge1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGF3YWl0IHByaXNtYS5nTVAuY3JlYXRlTWFueSh7XHJcbiAgICAgICAgICBkYXRhOiB2YWxpZFVwZGF0ZXMsXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIC8vIFVwZGF0ZSBjYWNoZSBhbmQgYnJvYWRjYXN0IHJlYWwtdGltZSB1cGRhdGVzXHJcbiAgICAgICAgZm9yIChjb25zdCBnbXBEYXRhIG9mIHZhbGlkVXBkYXRlcykge1xyXG4gICAgICAgICAgLy8gQ2FjaGUgbGl2ZSBHTVAgZGF0YVxyXG4gICAgICAgICAgYXdhaXQgY2FjaGUuY2FjaGVMaXZlR01QKGdtcERhdGEuaXBvSWQsIGdtcERhdGEudmFsdWUpO1xyXG5cclxuICAgICAgICAgIC8vIEZpbmQgSVBPIHN5bWJvbCBmb3IgV2ViU29ja2V0IGJyb2FkY2FzdFxyXG4gICAgICAgICAgY29uc3QgaXBvID0gYXdhaXQgcHJpc21hLmlQTy5maW5kVW5pcXVlKHtcclxuICAgICAgICAgICAgd2hlcmU6IHsgaWQ6IGdtcERhdGEuaXBvSWQgfSxcclxuICAgICAgICAgICAgc2VsZWN0OiB7IHN5bWJvbDogdHJ1ZSB9LFxyXG4gICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgaWYgKGlwbyAmJiB3ZWJTb2NrZXRTZXJ2aWNlLmlvKSB7XHJcbiAgICAgICAgICAgIC8vIEJyb2FkY2FzdCB0byBXZWJTb2NrZXQgc3Vic2NyaWJlcnNcclxuICAgICAgICAgICAgd2ViU29ja2V0U2VydmljZS5icm9hZGNhc3RHTVBVcGRhdGUoZ21wRGF0YS5pcG9JZCwge1xyXG4gICAgICAgICAgICAgIHZhbHVlOiBnbXBEYXRhLnZhbHVlLFxyXG4gICAgICAgICAgICAgIHBlcmNlbnRhZ2U6IGdtcERhdGEucGVyY2VudGFnZSxcclxuICAgICAgICAgICAgICBzb3VyY2U6IGdtcERhdGEuc291cmNlLFxyXG4gICAgICAgICAgICAgIHZvbHVtZTogZ21wRGF0YS52b2x1bWUsXHJcbiAgICAgICAgICAgICAgdGltZXN0YW1wOiBnbXBEYXRhLnRpbWVzdGFtcCxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zb2xlLmxvZyhg4pyFIFByb2Nlc3NlZCAke3ZhbGlkVXBkYXRlcy5sZW5ndGh9IEdNUCB1cGRhdGVzYCk7XHJcbiAgICAgIH0gY2F0Y2ggKGRiRXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdEYXRhYmFzZSBpbnNlcnQgZmFpbGVkOicsIGRiRXJyb3IpO1xyXG4gICAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbihcclxuICAgICAgICAgIHsgZXJyb3I6ICdGYWlsZWQgdG8gc2F2ZSBHTVAgdXBkYXRlcycsIG1lc3NhZ2U6IGRiRXJyb3IubWVzc2FnZSB9LFxyXG4gICAgICAgICAgeyBzdGF0dXM6IDUwMCB9XHJcbiAgICAgICAgKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbih7XHJcbiAgICAgIG1lc3NhZ2U6IGBQcm9jZXNzZWQgJHtyZXN1bHRzLmxlbmd0aH0gdXBkYXRlc2AsXHJcbiAgICAgIHN1Y2Nlc3NmdWw6IHZhbGlkVXBkYXRlcy5sZW5ndGgsXHJcbiAgICAgIGZhaWxlZDogcmVzdWx0cy5sZW5ndGggLSB2YWxpZFVwZGF0ZXMubGVuZ3RoLFxyXG4gICAgICByZXN1bHRzLFxyXG4gICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcclxuICAgIH0pO1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gdXBkYXRlIEdNUCBkYXRhOicsIGVycm9yKTtcclxuICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbihcclxuICAgICAgeyBlcnJvcjogJ0ZhaWxlZCB0byB1cGRhdGUgR01QIGRhdGEnLCBtZXNzYWdlOiBlcnJvci5tZXNzYWdlIH0sXHJcbiAgICAgIHsgc3RhdHVzOiA1MDAgfVxyXG4gICAgKTtcclxuICB9XHJcbn1cclxuXHJcbi8vIFV0aWxpdHkgZnVuY3Rpb25zXHJcbmZ1bmN0aW9uIGNhbGN1bGF0ZVZvbGF0aWxpdHkodmFsdWVzKSB7XHJcbiAgaWYgKHZhbHVlcy5sZW5ndGggPCAyKSByZXR1cm4gMDtcclxuXHJcbiAgY29uc3QgbWVhbiA9IHZhbHVlcy5yZWR1Y2UoKGEsIGIpID0+IGEgKyBiLCAwKSAvIHZhbHVlcy5sZW5ndGg7XHJcbiAgY29uc3QgdmFyaWFuY2UgPSB2YWx1ZXMucmVkdWNlKChhY2MsIHZhbCkgPT4gYWNjICsgTWF0aC5wb3codmFsIC0gbWVhbiwgMiksIDApIC8gdmFsdWVzLmxlbmd0aDtcclxuICByZXR1cm4gTWF0aC5zcXJ0KHZhcmlhbmNlKTtcclxufVxyXG5cclxuZnVuY3Rpb24gY2FsY3VsYXRlVHJlbmQodmFsdWVzKSB7XHJcbiAgaWYgKHZhbHVlcy5sZW5ndGggPCAyKSByZXR1cm4gJ25ldXRyYWwnO1xyXG5cclxuICBjb25zdCByZWNlbnQgPSB2YWx1ZXMuc2xpY2UoMCwgTWF0aC5taW4oNSwgdmFsdWVzLmxlbmd0aCkpO1xyXG4gIGNvbnN0IG9sZGVyID0gdmFsdWVzLnNsaWNlKE1hdGgubWluKDUsIHZhbHVlcy5sZW5ndGgpKTtcclxuXHJcbiAgaWYgKG9sZGVyLmxlbmd0aCA9PT0gMCkgcmV0dXJuICduZXV0cmFsJztcclxuXHJcbiAgY29uc3QgcmVjZW50QXZnID0gcmVjZW50LnJlZHVjZSgoYSwgYikgPT4gYSArIGIsIDApIC8gcmVjZW50Lmxlbmd0aDtcclxuICBjb25zdCBvbGRlckF2ZyA9IG9sZGVyLnJlZHVjZSgoYSwgYikgPT4gYSArIGIsIDApIC8gb2xkZXIubGVuZ3RoO1xyXG5cclxuICBjb25zdCBkaWZmID0gcmVjZW50QXZnIC0gb2xkZXJBdmc7XHJcbiAgY29uc3QgdGhyZXNob2xkID0gb2xkZXJBdmcgKiAwLjA1OyAvLyA1JSB0aHJlc2hvbGRcclxuXHJcbiAgaWYgKGRpZmYgPiB0aHJlc2hvbGQpIHJldHVybiAnYnVsbGlzaCc7XHJcbiAgaWYgKGRpZmYgPCAtdGhyZXNob2xkKSByZXR1cm4gJ2JlYXJpc2gnO1xyXG4gIHJldHVybiAnbmV1dHJhbCc7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNhbGN1bGF0ZVBvdGVudGlhbFJldHVybnMoaXBvLCBnbXApIHtcclxuICBpZiAoIWdtcCB8fCAhaXBvLm1pblByaWNlIHx8ICFpcG8ubWF4UHJpY2UpIHJldHVybiBudWxsO1xyXG5cclxuICBjb25zdCBtaW5QcmljZSA9IE51bWJlcihpcG8ubWluUHJpY2UpO1xyXG4gIGNvbnN0IG1heFByaWNlID0gTnVtYmVyKGlwby5tYXhQcmljZSk7XHJcbiAgY29uc3QgZ21wVmFsdWUgPSBOdW1iZXIoZ21wLnZhbHVlKTtcclxuXHJcbiAgY29uc3QgZXhwZWN0ZWRMaXN0aW5nUHJpY2UgPSBtaW5QcmljZSArIGdtcFZhbHVlO1xyXG5cclxuICByZXR1cm4ge1xyXG4gICAgYXRNaW5QcmljZToge1xyXG4gICAgICBpbnZlc3RtZW50OiBtaW5QcmljZSxcclxuICAgICAgZXhwZWN0ZWRSZXR1cm46IGdtcFZhbHVlLFxyXG4gICAgICByZXR1cm5QZXJjZW50YWdlOiAoZ21wVmFsdWUgLyBtaW5QcmljZSkgKiAxMDAsXHJcbiAgICB9LFxyXG4gICAgYXRNYXhQcmljZToge1xyXG4gICAgICBpbnZlc3RtZW50OiBtYXhQcmljZSxcclxuICAgICAgZXhwZWN0ZWRSZXR1cm46IGV4cGVjdGVkTGlzdGluZ1ByaWNlIC0gbWF4UHJpY2UsXHJcbiAgICAgIHJldHVyblBlcmNlbnRhZ2U6ICgoZXhwZWN0ZWRMaXN0aW5nUHJpY2UgLSBtYXhQcmljZSkgLyBtYXhQcmljZSkgKiAxMDAsXHJcbiAgICB9LFxyXG4gICAgZXhwZWN0ZWRMaXN0aW5nUHJpY2UsXHJcbiAgICBicmVha2V2ZW46IHtcclxuICAgICAgbWluR01QOiAtbWluUHJpY2UsXHJcbiAgICAgIG1heEdNUDogLW1heFByaWNlLFxyXG4gICAgfSxcclxuICB9O1xyXG59XHJcbiJdLCJuYW1lcyI6WyJOZXh0UmVzcG9uc2UiLCJwcmlzbWEiLCJjYWNoZSIsIndlYlNvY2tldFNlcnZpY2UiLCJHRVQiLCJyZXF1ZXN0Iiwic2VhcmNoUGFyYW1zIiwiVVJMIiwidXJsIiwic3ltYm9sc1BhcmFtIiwiZ2V0IiwiaXBvSWRzUGFyYW0iLCJpbmNsdWRlSGlzdG9yeSIsImhpc3RvcnlEYXlzIiwiTWF0aCIsIm1pbiIsInBhcnNlSW50IiwianNvbiIsImVycm9yIiwic3RhdHVzIiwid2hlcmVDbGF1c2UiLCJzeW1ib2xzIiwic3BsaXQiLCJtYXAiLCJzIiwidHJpbSIsInRvVXBwZXJDYXNlIiwic3ltYm9sIiwiaW4iLCJpc0FjdGl2ZSIsImlwb0lkcyIsImlkIiwiaXBvcyIsImlQTyIsImZpbmRNYW55Iiwid2hlcmUiLCJzZWxlY3QiLCJuYW1lIiwibWluUHJpY2UiLCJtYXhQcmljZSIsIm9wZW5EYXRlIiwiY2xvc2VEYXRlIiwiZ21wIiwib3JkZXJCeSIsInRpbWVzdGFtcCIsInRha2UiLCJ2YWx1ZSIsInBlcmNlbnRhZ2UiLCJzb3VyY2UiLCJ2b2x1bWUiLCJsZW5ndGgiLCJnbXBEYXRhIiwibWVzc2FnZSIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsImVuaGFuY2VkRGF0YSIsIlByb21pc2UiLCJhbGwiLCJpcG8iLCJsaXZlR01QIiwiZ2V0Q2FjaGVkTGl2ZUdNUCIsImxhdGVzdEdNUCIsImN1cnJlbnRHTVAiLCJnbXBTdGF0cyIsInZhbHVlcyIsImciLCJOdW1iZXIiLCJwZXJjZW50YWdlcyIsImNvdW50IiwiYXZlcmFnZSIsInJlZHVjZSIsImEiLCJiIiwibWF4IiwibGF0ZXN0IiwiY2hhbmdlMjRoIiwidm9sYXRpbGl0eSIsImNhbGN1bGF0ZVZvbGF0aWxpdHkiLCJ0cmVuZCIsImNhbGN1bGF0ZVRyZW5kIiwiYXZlcmFnZVBlcmNlbnRhZ2UiLCJwb3RlbnRpYWxSZXR1cm5zIiwiY2FsY3VsYXRlUG90ZW50aWFsUmV0dXJucyIsImlwb0lkIiwicHJpY2VSYW5nZSIsImRhdGVzIiwib3BlbiIsImNsb3NlIiwiaXNMaXZlIiwiZ21wSGlzdG9yeSIsInN0YXRpc3RpY3MiLCJsYXN0VXBkYXRlZCIsInJlc3BvbnNlIiwibWV0YWRhdGEiLCJ0b3RhbElQT3MiLCJsaXZlRGF0YUNvdW50IiwiZmlsdGVyIiwiZCIsImNhY2hlS2V5Iiwic2V0IiwiY29uc29sZSIsIlBPU1QiLCJib2R5IiwidXBkYXRlcyIsIkFycmF5IiwiaXNBcnJheSIsInJlc3VsdHMiLCJ2YWxpZFVwZGF0ZXMiLCJ1cGRhdGUiLCJwdXNoIiwiZGF0YSIsImZpbmRVbmlxdWUiLCJjYWxjdWxhdGVkUGVyY2VudGFnZSIsImRhdGUiLCJnTVAiLCJjcmVhdGVNYW55IiwiY2FjaGVMaXZlR01QIiwiaW8iLCJicm9hZGNhc3RHTVBVcGRhdGUiLCJsb2ciLCJkYkVycm9yIiwic3VjY2Vzc2Z1bCIsImZhaWxlZCIsIm1lYW4iLCJ2YXJpYW5jZSIsImFjYyIsInZhbCIsInBvdyIsInNxcnQiLCJyZWNlbnQiLCJzbGljZSIsIm9sZGVyIiwicmVjZW50QXZnIiwib2xkZXJBdmciLCJkaWZmIiwidGhyZXNob2xkIiwiZ21wVmFsdWUiLCJleHBlY3RlZExpc3RpbmdQcmljZSIsImF0TWluUHJpY2UiLCJpbnZlc3RtZW50IiwiZXhwZWN0ZWRSZXR1cm4iLCJyZXR1cm5QZXJjZW50YWdlIiwiYXRNYXhQcmljZSIsImJyZWFrZXZlbiIsIm1pbkdNUCIsIm1heEdNUCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./src/app/api/gmp/live/route.js\n");

/***/ }),

/***/ "(rsc)/./src/lib/cache.js":
/*!**************************!*\
  !*** ./src/lib/cache.js ***!
  \**************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   cache: () => (/* binding */ cache),\n/* harmony export */   cacheMiddleware: () => (/* binding */ cacheMiddleware),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   invalidateCacheOnUpdate: () => (/* binding */ invalidateCacheOnUpdate)\n/* harmony export */ });\n/* harmony import */ var _upstash_redis__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @upstash/redis */ \"(rsc)/./node_modules/@upstash/redis/nodejs.mjs\");\n/* harmony import */ var _db_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./db.js */ \"(rsc)/./src/lib/db.js\");\n\n\nclass CacheService {\n    constructor(){\n        this.redis = new _upstash_redis__WEBPACK_IMPORTED_MODULE_0__.Redis({\n            url: process.env.UPSTASH_REDIS_REST_URL,\n            token: process.env.UPSTASH_REDIS_REST_TOKEN\n        });\n        // Memory cache fallback for when Redis is unavailable\n        this.memoryCache = new Map();\n        this.memoryCacheSize = 0;\n        this.maxMemoryCache = 1000; // Maximum items in memory cache\n        // Cache key prefixes for organization\n        this.prefixes = {\n            IPO: \"ipo:\",\n            GMP: \"gmp:\",\n            SUBSCRIPTION: \"sub:\",\n            DEMAND: \"demand:\",\n            ALLOTMENT: \"allot:\",\n            USER: \"user:\",\n            SESSION: \"session:\",\n            API: \"api:\",\n            ANALYTICS: \"analytics:\",\n            REALTIME: \"rt:\",\n            SEARCH: \"search:\",\n            SYSTEM: \"sys:\"\n        };\n        // Default TTL values (in seconds)\n        this.defaultTTL = {\n            IPO_LIST: 300,\n            IPO_DETAIL: 180,\n            GMP_DATA: 60,\n            SUBSCRIPTION: 30,\n            DEMAND: 30,\n            ALLOTMENT: 3600,\n            USER_SESSION: 3600,\n            API_RESPONSE: 60,\n            ANALYTICS: 1800,\n            SEARCH: 600,\n            REALTIME: 15,\n            SYSTEM: 300\n        };\n        // Performance metrics\n        this.metrics = {\n            hits: 0,\n            misses: 0,\n            errors: 0,\n            operations: 0\n        };\n    }\n    // Generate cache key with prefix\n    key(prefix, identifier) {\n        return `${this.prefixes[prefix] || \"\"}${identifier}`;\n    }\n    // Enhanced get with fallback to memory cache\n    async get(key) {\n        this.metrics.operations++;\n        try {\n            // Try Redis first\n            const data = await this.redis.get(key);\n            if (data !== null) {\n                this.metrics.hits++;\n                return typeof data === \"string\" ? JSON.parse(data) : data;\n            }\n            // Fallback to memory cache\n            const memoryData = this.memoryCache.get(key);\n            if (memoryData && memoryData.expiresAt > Date.now()) {\n                this.metrics.hits++;\n                return memoryData.value;\n            }\n            this.metrics.misses++;\n            return null;\n        } catch (error) {\n            this.metrics.errors++;\n            console.error(\"Cache get error:\", error);\n            // Try memory cache as fallback\n            const memoryData = this.memoryCache.get(key);\n            if (memoryData && memoryData.expiresAt > Date.now()) {\n                return memoryData.value;\n            }\n            return null;\n        }\n    }\n    // Enhanced set with memory cache backup\n    async set(key, value, ttl = null) {\n        this.metrics.operations++;\n        try {\n            const serialized = typeof value === \"string\" ? value : JSON.stringify(value);\n            let result;\n            if (ttl) {\n                result = await this.redis.setex(key, ttl, serialized);\n            } else {\n                result = await this.redis.set(key, serialized);\n            }\n            // Also store in memory cache as backup\n            this.setMemoryCache(key, value, ttl);\n            return result;\n        } catch (error) {\n            this.metrics.errors++;\n            console.error(\"Cache set error:\", error);\n            // Fallback to memory cache only\n            this.setMemoryCache(key, value, ttl);\n            return false;\n        }\n    }\n    // Memory cache management\n    setMemoryCache(key, value, ttl = null) {\n        const expiresAt = ttl ? Date.now() + ttl * 1000 : Date.now() + 5 * 60 * 1000; // Default 5 min\n        // Remove old entry if exists\n        if (this.memoryCache.has(key)) {\n            this.memoryCacheSize--;\n        }\n        // Check if we need to evict items\n        if (this.memoryCacheSize >= this.maxMemoryCache) {\n            this.evictOldestMemoryCache();\n        }\n        this.memoryCache.set(key, {\n            value,\n            expiresAt\n        });\n        this.memoryCacheSize++;\n    }\n    // Evict oldest items from memory cache\n    evictOldestMemoryCache() {\n        const entries = Array.from(this.memoryCache.entries());\n        entries.sort((a, b)=>a[1].expiresAt - b[1].expiresAt);\n        // Remove oldest 10% of items\n        const toRemove = Math.max(1, Math.floor(entries.length * 0.1));\n        for(let i = 0; i < toRemove; i++){\n            this.memoryCache.delete(entries[i][0]);\n            this.memoryCacheSize--;\n        }\n    }\n    // Enhanced delete with memory cache cleanup\n    async del(key) {\n        this.metrics.operations++;\n        try {\n            const result = await this.redis.del(key);\n            // Also remove from memory cache\n            if (this.memoryCache.has(key)) {\n                this.memoryCache.delete(key);\n                this.memoryCacheSize--;\n            }\n            return result;\n        } catch (error) {\n            this.metrics.errors++;\n            console.error(\"Cache delete error:\", error);\n            // Still try to remove from memory cache\n            if (this.memoryCache.has(key)) {\n                this.memoryCache.delete(key);\n                this.memoryCacheSize--;\n            }\n            return false;\n        }\n    }\n    // Check if key exists\n    async exists(key) {\n        try {\n            const redisExists = await this.redis.exists(key);\n            if (redisExists) return true;\n            // Check memory cache\n            const memoryData = this.memoryCache.get(key);\n            return memoryData && memoryData.expiresAt > Date.now();\n        } catch (error) {\n            console.error(\"Cache exists error:\", error);\n            // Check memory cache only\n            const memoryData = this.memoryCache.get(key);\n            return memoryData && memoryData.expiresAt > Date.now();\n        }\n    }\n    // IPO-specific cache operations\n    async cacheIPOList(ipos, filters = {}) {\n        const filterKey = Object.keys(filters).sort().map((k)=>`${k}:${filters[k]}`).join(\"|\");\n        const cacheKey = this.key(\"IPO\", `list:${filterKey || \"all\"}`);\n        return this.set(cacheKey, ipos, this.defaultTTL.IPO_LIST);\n    }\n    async getCachedIPOList(filters = {}) {\n        const filterKey = Object.keys(filters).sort().map((k)=>`${k}:${filters[k]}`).join(\"|\");\n        const cacheKey = this.key(\"IPO\", `list:${filterKey || \"all\"}`);\n        return this.get(cacheKey);\n    }\n    async cacheIPODetail(ipoId, data) {\n        const cacheKey = this.key(\"IPO\", `detail:${ipoId}`);\n        return this.set(cacheKey, data, this.defaultTTL.IPO_DETAIL);\n    }\n    async getCachedIPODetail(ipoId) {\n        const cacheKey = this.key(\"IPO\", `detail:${ipoId}`);\n        return this.get(cacheKey);\n    }\n    // Real-time data cache with pub/sub support\n    async cacheRealTimeData(type, identifier, data) {\n        const cacheKey = this.key(\"REALTIME\", `${type}:${identifier}`);\n        const enrichedData = {\n            ...data,\n            timestamp: Date.now(),\n            cached_at: new Date().toISOString()\n        };\n        // Cache with short TTL for real-time data\n        await this.set(cacheKey, enrichedData, this.defaultTTL.REALTIME);\n        // Also publish to Redis pub/sub for WebSocket distribution (if available)\n        try {\n            await this.redis.publish(`realtime:${type}:${identifier}`, JSON.stringify(enrichedData));\n        } catch (error) {\n            console.warn(\"Redis publish failed, continuing without pub/sub:\", error.message);\n        }\n        return enrichedData;\n    }\n    async getRealTimeData(type, identifier) {\n        const cacheKey = this.key(\"REALTIME\", `${type}:${identifier}`);\n        const data = await this.get(cacheKey);\n        // Check if data is fresh (less than TTL)\n        if (data && Date.now() - data.timestamp < this.defaultTTL.REALTIME * 1000) {\n            return data;\n        }\n        return null;\n    }\n    // GMP cache operations\n    async cacheGMPData(ipoId, gmpData) {\n        const cacheKey = this.key(\"GMP\", `data:${ipoId}`);\n        return this.set(cacheKey, gmpData, this.defaultTTL.GMP_DATA);\n    }\n    async getCachedGMPData(ipoId) {\n        const cacheKey = this.key(\"GMP\", `data:${ipoId}`);\n        return this.get(cacheKey);\n    }\n    async cacheLiveGMP(ipoId, gmpValue) {\n        const cacheKey = this.key(\"GMP\", `live:${ipoId}`);\n        const gmpData = {\n            value: gmpValue,\n            timestamp: Date.now(),\n            cached_at: new Date().toISOString()\n        };\n        // Store with short TTL for real-time updates\n        return this.set(cacheKey, gmpData, 30);\n    }\n    async getCachedLiveGMP(ipoId) {\n        const cacheKey = this.key(\"GMP\", `live:${ipoId}`);\n        return this.get(cacheKey);\n    }\n    // Subscription data cache\n    async cacheSubscriptionData(symbol, data) {\n        const cacheKey = this.key(\"SUBSCRIPTION\", `data:${symbol}`);\n        return this.set(cacheKey, data, this.defaultTTL.SUBSCRIPTION);\n    }\n    async getCachedSubscriptionData(symbol) {\n        const cacheKey = this.key(\"SUBSCRIPTION\", `data:${symbol}`);\n        return this.get(cacheKey);\n    }\n    // Market demand cache\n    async cacheDemandData(symbol, data) {\n        const cacheKey = this.key(\"DEMAND\", `data:${symbol}`);\n        return this.set(cacheKey, data, this.defaultTTL.DEMAND);\n    }\n    async getCachedDemandData(symbol) {\n        const cacheKey = this.key(\"DEMAND\", `data:${symbol}`);\n        return this.get(cacheKey);\n    }\n    // Allotment cache\n    async cacheAllotmentStatus(panNumber, applicationNumber, data) {\n        const cacheKey = this.key(\"ALLOTMENT\", `status:${panNumber}:${applicationNumber}`);\n        return this.set(cacheKey, data, this.defaultTTL.ALLOTMENT);\n    }\n    async getCachedAllotmentStatus(panNumber, applicationNumber) {\n        const cacheKey = this.key(\"ALLOTMENT\", `status:${panNumber}:${applicationNumber}`);\n        return this.get(cacheKey);\n    }\n    // User session cache\n    async cacheUserSession(userId, sessionData) {\n        const cacheKey = this.key(\"USER\", `session:${userId}`);\n        return this.set(cacheKey, sessionData, this.defaultTTL.USER_SESSION);\n    }\n    async getCachedUserSession(userId) {\n        const cacheKey = this.key(\"USER\", `session:${userId}`);\n        return this.get(cacheKey);\n    }\n    // API response cache\n    async cacheAPIResponse(endpoint, params, data) {\n        const paramKey = Object.keys(params).sort().map((k)=>`${k}:${params[k]}`).join(\"|\");\n        const cacheKey = this.key(\"API\", `${endpoint}:${paramKey}`);\n        return this.set(cacheKey, data, this.defaultTTL.API_RESPONSE);\n    }\n    async getCachedAPIResponse(endpoint, params) {\n        const paramKey = Object.keys(params).sort().map((k)=>`${k}:${params[k]}`).join(\"|\");\n        const cacheKey = this.key(\"API\", `${endpoint}:${paramKey}`);\n        return this.get(cacheKey);\n    }\n    // Search results cache\n    async cacheSearchResults(query, results) {\n        const cacheKey = this.key(\"SEARCH\", `query:${query.toLowerCase()}`);\n        return this.set(cacheKey, results, this.defaultTTL.SEARCH);\n    }\n    async getCachedSearchResults(query) {\n        const cacheKey = this.key(\"SEARCH\", `query:${query.toLowerCase()}`);\n        return this.get(cacheKey);\n    }\n    // Analytics cache\n    async cacheAnalytics(type, identifier, data) {\n        const cacheKey = this.key(\"ANALYTICS\", `${type}:${identifier}`);\n        return this.set(cacheKey, data, this.defaultTTL.ANALYTICS);\n    }\n    async getCachedAnalytics(type, identifier) {\n        const cacheKey = this.key(\"ANALYTICS\", `${type}:${identifier}`);\n        return this.get(cacheKey);\n    }\n    // Batch operations\n    async mget(keys) {\n        try {\n            return await this.redis.mget(...keys);\n        } catch (error) {\n            console.error(\"Cache mget error:\", error);\n            // Fallback to individual gets from memory cache\n            const results = [];\n            for (const key of keys){\n                const memoryData = this.memoryCache.get(key);\n                if (memoryData && memoryData.expiresAt > Date.now()) {\n                    results.push(memoryData.value);\n                } else {\n                    results.push(null);\n                }\n            }\n            return results;\n        }\n    }\n    async mset(keyValuePairs) {\n        try {\n            const pairs = [];\n            for (const [key, value] of keyValuePairs){\n                pairs.push(key, typeof value === \"string\" ? value : JSON.stringify(value));\n                // Also set in memory cache\n                this.setMemoryCache(key, value);\n            }\n            return await this.redis.mset(...pairs);\n        } catch (error) {\n            console.error(\"Cache mset error:\", error);\n            // Fallback to memory cache only\n            for (const [key, value] of keyValuePairs){\n                this.setMemoryCache(key, value);\n            }\n            return false;\n        }\n    }\n    // Cache invalidation\n    async invalidatePattern(pattern) {\n        try {\n            const keys = await this.redis.keys(pattern);\n            if (keys.length > 0) {\n                // Delete from Redis\n                const redisResult = await this.redis.del(...keys);\n                // Delete from memory cache\n                for (const key of keys){\n                    if (this.memoryCache.has(key)) {\n                        this.memoryCache.delete(key);\n                        this.memoryCacheSize--;\n                    }\n                }\n                return redisResult;\n            }\n            return 0;\n        } catch (error) {\n            console.error(\"Cache invalidation error:\", error);\n            // Try to clear memory cache patterns (simple string matching)\n            let cleared = 0;\n            for (const [key] of this.memoryCache){\n                if (key.includes(pattern.replace(\"*\", \"\"))) {\n                    this.memoryCache.delete(key);\n                    this.memoryCacheSize--;\n                    cleared++;\n                }\n            }\n            return cleared;\n        }\n    }\n    async invalidateIPOCache(ipoId) {\n        const patterns = [\n            this.key(\"IPO\", `detail:${ipoId}`),\n            this.key(\"IPO\", \"list:*\"),\n            this.key(\"GMP\", `*:${ipoId}`),\n            this.key(\"SUBSCRIPTION\", `*:${ipoId}`),\n            this.key(\"DEMAND\", `*:${ipoId}`),\n            this.key(\"REALTIME\", `*:${ipoId}`)\n        ];\n        const results = await Promise.allSettled(patterns.map((pattern)=>this.invalidatePattern(pattern)));\n        return results.every((result)=>result.status === \"fulfilled\");\n    }\n    // Performance monitoring\n    async getCacheStats() {\n        try {\n            const redisInfo = await this.redis.info();\n            const hitRate = this.metrics.operations > 0 ? (this.metrics.hits / this.metrics.operations * 100).toFixed(2) : \"0.00\";\n            return {\n                connected: true,\n                redis: {\n                    memory: redisInfo.match(/used_memory_human:(.+)/)?.[1]?.trim(),\n                    keys: redisInfo.match(/db0:keys=(\\d+)/)?.[1],\n                    hits: redisInfo.match(/keyspace_hits:(\\d+)/)?.[1],\n                    misses: redisInfo.match(/keyspace_misses:(\\d+)/)?.[1]\n                },\n                local: {\n                    hitRate: `${hitRate}%`,\n                    totalOperations: this.metrics.operations,\n                    hits: this.metrics.hits,\n                    misses: this.metrics.misses,\n                    errors: this.metrics.errors,\n                    memoryCacheSize: this.memoryCacheSize,\n                    memoryCacheLimit: this.maxMemoryCache\n                },\n                timestamp: new Date().toISOString()\n            };\n        } catch (error) {\n            const hitRate = this.metrics.operations > 0 ? (this.metrics.hits / this.metrics.operations * 100).toFixed(2) : \"0.00\";\n            return {\n                connected: false,\n                error: error.message,\n                local: {\n                    hitRate: `${hitRate}%`,\n                    totalOperations: this.metrics.operations,\n                    hits: this.metrics.hits,\n                    misses: this.metrics.misses,\n                    errors: this.metrics.errors,\n                    memoryCacheSize: this.memoryCacheSize,\n                    memoryCacheLimit: this.maxMemoryCache\n                },\n                timestamp: new Date().toISOString()\n            };\n        }\n    }\n    // Cache warming for frequently accessed data\n    async warmCache() {\n        try {\n            console.log(\"\\uD83D\\uDD25 Starting cache warm-up...\");\n            // Cache active IPOs\n            const activeIPOs = await _db_js__WEBPACK_IMPORTED_MODULE_1__.prisma.iPO.findMany({\n                where: {\n                    status: {\n                        in: [\n                            \"open\",\n                            \"upcoming\"\n                        ]\n                    },\n                    isActive: true\n                },\n                include: {\n                    gmp: {\n                        take: 10,\n                        orderBy: {\n                            timestamp: \"desc\"\n                        }\n                    },\n                    subscription: {\n                        take: 5,\n                        orderBy: {\n                            timestamp: \"desc\"\n                        }\n                    },\n                    analytics: true\n                }\n            });\n            const cachePromises = activeIPOs.map((ipo)=>this.cacheIPODetail(ipo.id, ipo));\n            await Promise.all(cachePromises);\n            // Cache IPO list with common filters\n            await this.cacheIPOList(activeIPOs.filter((ipo)=>ipo.status === \"open\"), {\n                status: \"open\"\n            });\n            await this.cacheIPOList(activeIPOs.filter((ipo)=>ipo.status === \"upcoming\"), {\n                status: \"upcoming\"\n            });\n            console.log(`ðŸ”¥ Cache warmed with ${activeIPOs.length} active IPOs`);\n            return true;\n        } catch (error) {\n            console.error(\"Cache warm-up failed:\", error);\n            return false;\n        }\n    }\n    // Health check\n    async healthCheck() {\n        try {\n            const testKey = \"health_check\";\n            const testValue = Date.now().toString();\n            await this.set(testKey, testValue, 10);\n            const retrieved = await this.get(testKey);\n            await this.del(testKey);\n            const isHealthy = retrieved === testValue;\n            return {\n                status: isHealthy ? \"healthy\" : \"degraded\",\n                redis: isHealthy,\n                memoryCache: this.memoryCacheSize < this.maxMemoryCache,\n                metrics: this.metrics,\n                timestamp: new Date().toISOString()\n            };\n        } catch (error) {\n            console.error(\"Cache health check failed:\", error);\n            return {\n                status: \"unhealthy\",\n                redis: false,\n                memoryCache: this.memoryCacheSize < this.maxMemoryCache,\n                error: error.message,\n                metrics: this.metrics,\n                timestamp: new Date().toISOString()\n            };\n        }\n    }\n    // Clean expired entries from memory cache\n    cleanExpiredMemoryCache() {\n        const now = Date.now();\n        const toDelete = [];\n        for (const [key, data] of this.memoryCache){\n            if (data.expiresAt <= now) {\n                toDelete.push(key);\n            }\n        }\n        for (const key of toDelete){\n            this.memoryCache.delete(key);\n            this.memoryCacheSize--;\n        }\n        return toDelete.length;\n    }\n    // Reset metrics\n    resetMetrics() {\n        this.metrics = {\n            hits: 0,\n            misses: 0,\n            errors: 0,\n            operations: 0\n        };\n    }\n    // Get cache size info\n    getCacheSize() {\n        return {\n            memoryCache: this.memoryCacheSize,\n            maxMemoryCache: this.maxMemoryCache,\n            utilizationPercent: (this.memoryCacheSize / this.maxMemoryCache * 100).toFixed(2)\n        };\n    }\n}\n// Export singleton instance\nconst cache = new CacheService();\n// Utility middleware for cache management\nconst cacheMiddleware = (ttl = 300)=>{\n    return async (req, res, next)=>{\n        const cacheKey = cache.key(\"API\", `${req.path}:${JSON.stringify(req.query)}`);\n        try {\n            const cached = await cache.get(cacheKey);\n            if (cached) {\n                return res.json({\n                    ...cached,\n                    cached: true,\n                    cacheTimestamp: new Date().toISOString()\n                });\n            }\n            // Store original res.json\n            const originalJson = res.json;\n            // Override res.json to cache the response\n            res.json = function(data) {\n                cache.set(cacheKey, data, ttl);\n                return originalJson.call(this, data);\n            };\n            next();\n        } catch (error) {\n            console.error(\"Cache middleware error:\", error);\n            next();\n        }\n    };\n};\n// Middleware to invalidate cache on updates\nconst invalidateCacheOnUpdate = (patterns)=>{\n    return async (req, res, next)=>{\n        // Store original response methods\n        const originalJson = res.json;\n        const originalSend = res.send;\n        const cleanup = async (data)=>{\n            if (res.statusCode >= 200 && res.statusCode < 300) {\n                // Success response, invalidate cache\n                await Promise.all(patterns.map((pattern)=>cache.invalidatePattern(pattern)));\n            }\n            return data;\n        };\n        res.json = function(data) {\n            cleanup(data);\n            return originalJson.call(this, data);\n        };\n        res.send = function(data) {\n            cleanup(data);\n            return originalSend.call(this, data);\n        };\n        next();\n    };\n};\n// Auto-cleanup expired memory cache entries every 5 minutes\nsetInterval(()=>{\n    const cleaned = cache.cleanExpiredMemoryCache();\n    if (cleaned > 0) {\n        console.log(`ðŸ§¹ Cleaned up ${cleaned} expired memory cache entries`);\n    }\n}, 5 * 60 * 1000);\n// Periodic cache warming (every hour)\nsetInterval(async ()=>{\n    try {\n        await cache.warmCache();\n    } catch (error) {\n        console.error(\"Scheduled cache warming failed:\", error);\n    }\n}, 60 * 60 * 1000);\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (cache);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q2pELHFDQUFxQztnQkFDckMsTUFBTTdELFFBQVFpQyxHQUFHLENBQ2ZsQyxTQUFTN0QsR0FBRyxDQUFDLENBQUN1RCxVQUFZcUQsTUFBTXRELGlCQUFpQixDQUFDQztZQUV0RDtZQUNBLE9BQU9oRztRQUNUO1FBRUF3SixJQUFJSSxJQUFJLEdBQUcsU0FBVTVKLElBQUk7WUFDdkJtSyxRQUFRbks7WUFDUixPQUFPOEosYUFBYUMsSUFBSSxDQUFDLElBQUksRUFBRS9KO1FBQ2pDO1FBRUF3SixJQUFJVSxJQUFJLEdBQUcsU0FBVWxLLElBQUk7WUFDdkJtSyxRQUFRbks7WUFDUixPQUFPaUssYUFBYUYsSUFBSSxDQUFDLElBQUksRUFBRS9KO1FBQ2pDO1FBRUF5SjtJQUNGO0FBQ0YsRUFBRTtBQUVGLDREQUE0RDtBQUM1RFksWUFDRTtJQUNFLE1BQU1DLFVBQVVqQixNQUFNTCx1QkFBdUI7SUFDN0MsSUFBSXNCLFVBQVUsR0FBRztRQUNmN0osUUFBUStHLEdBQUcsQ0FBQyxDQUFDLGNBQWMsRUFBRThDLFFBQVEsNkJBQTZCLENBQUM7SUFDckU7QUFDRixHQUNBLElBQUksS0FBSztBQUdYLHNDQUFzQztBQUN0Q0QsWUFDRTtJQUNFLElBQUk7UUFDRixNQUFNaEIsTUFBTTlCLFNBQVM7SUFDdkIsRUFBRSxPQUFPL0csT0FBTztRQUNkQyxRQUFRRCxLQUFLLENBQUMsbUNBQW1DQTtJQUNuRDtBQUNGLEdBQ0EsS0FBSyxLQUFLO0FBR1osaUVBQWU2SSxLQUFLQSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaXBvLXRyYWNrZXIvLi9zcmMvbGliL2NhY2hlLmpzP2JlNTYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUmVkaXMgfSBmcm9tIFwiQHVwc3Rhc2gvcmVkaXNcIjtcclxuaW1wb3J0IHsgcHJpc21hIH0gZnJvbSBcIi4vZGIuanNcIjtcclxuXHJcbmNsYXNzIENhY2hlU2VydmljZSB7XHJcbiAgY29uc3RydWN0b3IoKSB7XHJcbiAgICB0aGlzLnJlZGlzID0gbmV3IFJlZGlzKHtcclxuICAgICAgdXJsOiBwcm9jZXNzLmVudi5VUFNUQVNIX1JFRElTX1JFU1RfVVJMLFxyXG4gICAgICB0b2tlbjogcHJvY2Vzcy5lbnYuVVBTVEFTSF9SRURJU19SRVNUX1RPS0VOLFxyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gTWVtb3J5IGNhY2hlIGZhbGxiYWNrIGZvciB3aGVuIFJlZGlzIGlzIHVuYXZhaWxhYmxlXHJcbiAgICB0aGlzLm1lbW9yeUNhY2hlID0gbmV3IE1hcCgpO1xyXG4gICAgdGhpcy5tZW1vcnlDYWNoZVNpemUgPSAwO1xyXG4gICAgdGhpcy5tYXhNZW1vcnlDYWNoZSA9IDEwMDA7IC8vIE1heGltdW0gaXRlbXMgaW4gbWVtb3J5IGNhY2hlXHJcblxyXG4gICAgLy8gQ2FjaGUga2V5IHByZWZpeGVzIGZvciBvcmdhbml6YXRpb25cclxuICAgIHRoaXMucHJlZml4ZXMgPSB7XHJcbiAgICAgIElQTzogXCJpcG86XCIsXHJcbiAgICAgIEdNUDogXCJnbXA6XCIsXHJcbiAgICAgIFNVQlNDUklQVElPTjogXCJzdWI6XCIsXHJcbiAgICAgIERFTUFORDogXCJkZW1hbmQ6XCIsXHJcbiAgICAgIEFMTE9UTUVOVDogXCJhbGxvdDpcIixcclxuICAgICAgVVNFUjogXCJ1c2VyOlwiLFxyXG4gICAgICBTRVNTSU9OOiBcInNlc3Npb246XCIsXHJcbiAgICAgIEFQSTogXCJhcGk6XCIsXHJcbiAgICAgIEFOQUxZVElDUzogXCJhbmFseXRpY3M6XCIsXHJcbiAgICAgIFJFQUxUSU1FOiBcInJ0OlwiLFxyXG4gICAgICBTRUFSQ0g6IFwic2VhcmNoOlwiLFxyXG4gICAgICBTWVNURU06IFwic3lzOlwiLFxyXG4gICAgfTtcclxuXHJcbiAgICAvLyBEZWZhdWx0IFRUTCB2YWx1ZXMgKGluIHNlY29uZHMpXHJcbiAgICB0aGlzLmRlZmF1bHRUVEwgPSB7XHJcbiAgICAgIElQT19MSVNUOiAzMDAsIC8vIDUgbWludXRlc1xyXG4gICAgICBJUE9fREVUQUlMOiAxODAsIC8vIDMgbWludXRlc1xyXG4gICAgICBHTVBfREFUQTogNjAsIC8vIDEgbWludXRlXHJcbiAgICAgIFNVQlNDUklQVElPTjogMzAsIC8vIDMwIHNlY29uZHNcclxuICAgICAgREVNQU5EOiAzMCwgLy8gMzAgc2Vjb25kc1xyXG4gICAgICBBTExPVE1FTlQ6IDM2MDAsIC8vIDEgaG91clxyXG4gICAgICBVU0VSX1NFU1NJT046IDM2MDAsIC8vIDEgaG91clxyXG4gICAgICBBUElfUkVTUE9OU0U6IDYwLCAvLyAxIG1pbnV0ZVxyXG4gICAgICBBTkFMWVRJQ1M6IDE4MDAsIC8vIDMwIG1pbnV0ZXNcclxuICAgICAgU0VBUkNIOiA2MDAsIC8vIDEwIG1pbnV0ZXNcclxuICAgICAgUkVBTFRJTUU6IDE1LCAvLyAxNSBzZWNvbmRzXHJcbiAgICAgIFNZU1RFTTogMzAwLCAvLyA1IG1pbnV0ZXNcclxuICAgIH07XHJcblxyXG4gICAgLy8gUGVyZm9ybWFuY2UgbWV0cmljc1xyXG4gICAgdGhpcy5tZXRyaWNzID0ge1xyXG4gICAgICBoaXRzOiAwLFxyXG4gICAgICBtaXNzZXM6IDAsXHJcbiAgICAgIGVycm9yczogMCxcclxuICAgICAgb3BlcmF0aW9uczogMCxcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICAvLyBHZW5lcmF0ZSBjYWNoZSBrZXkgd2l0aCBwcmVmaXhcclxuICBrZXkocHJlZml4LCBpZGVudGlmaWVyKSB7XHJcbiAgICByZXR1cm4gYCR7dGhpcy5wcmVmaXhlc1twcmVmaXhdIHx8IFwiXCJ9JHtpZGVudGlmaWVyfWA7XHJcbiAgfVxyXG5cclxuICAvLyBFbmhhbmNlZCBnZXQgd2l0aCBmYWxsYmFjayB0byBtZW1vcnkgY2FjaGVcclxuICBhc3luYyBnZXQoa2V5KSB7XHJcbiAgICB0aGlzLm1ldHJpY3Mub3BlcmF0aW9ucysrO1xyXG5cclxuICAgIHRyeSB7XHJcbiAgICAgIC8vIFRyeSBSZWRpcyBmaXJzdFxyXG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy5yZWRpcy5nZXQoa2V5KTtcclxuICAgICAgaWYgKGRhdGEgIT09IG51bGwpIHtcclxuICAgICAgICB0aGlzLm1ldHJpY3MuaGl0cysrO1xyXG4gICAgICAgIHJldHVybiB0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIiA/IEpTT04ucGFyc2UoZGF0YSkgOiBkYXRhO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBGYWxsYmFjayB0byBtZW1vcnkgY2FjaGVcclxuICAgICAgY29uc3QgbWVtb3J5RGF0YSA9IHRoaXMubWVtb3J5Q2FjaGUuZ2V0KGtleSk7XHJcbiAgICAgIGlmIChtZW1vcnlEYXRhICYmIG1lbW9yeURhdGEuZXhwaXJlc0F0ID4gRGF0ZS5ub3coKSkge1xyXG4gICAgICAgIHRoaXMubWV0cmljcy5oaXRzKys7XHJcbiAgICAgICAgcmV0dXJuIG1lbW9yeURhdGEudmFsdWU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMubWV0cmljcy5taXNzZXMrKztcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICB0aGlzLm1ldHJpY3MuZXJyb3JzKys7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJDYWNoZSBnZXQgZXJyb3I6XCIsIGVycm9yKTtcclxuXHJcbiAgICAgIC8vIFRyeSBtZW1vcnkgY2FjaGUgYXMgZmFsbGJhY2tcclxuICAgICAgY29uc3QgbWVtb3J5RGF0YSA9IHRoaXMubWVtb3J5Q2FjaGUuZ2V0KGtleSk7XHJcbiAgICAgIGlmIChtZW1vcnlEYXRhICYmIG1lbW9yeURhdGEuZXhwaXJlc0F0ID4gRGF0ZS5ub3coKSkge1xyXG4gICAgICAgIHJldHVybiBtZW1vcnlEYXRhLnZhbHVlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIEVuaGFuY2VkIHNldCB3aXRoIG1lbW9yeSBjYWNoZSBiYWNrdXBcclxuICBhc3luYyBzZXQoa2V5LCB2YWx1ZSwgdHRsID0gbnVsbCkge1xyXG4gICAgdGhpcy5tZXRyaWNzLm9wZXJhdGlvbnMrKztcclxuXHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBzZXJpYWxpemVkID1cclxuICAgICAgICB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgPyB2YWx1ZSA6IEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcclxuXHJcbiAgICAgIGxldCByZXN1bHQ7XHJcbiAgICAgIGlmICh0dGwpIHtcclxuICAgICAgICByZXN1bHQgPSBhd2FpdCB0aGlzLnJlZGlzLnNldGV4KGtleSwgdHRsLCBzZXJpYWxpemVkKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICByZXN1bHQgPSBhd2FpdCB0aGlzLnJlZGlzLnNldChrZXksIHNlcmlhbGl6ZWQpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBBbHNvIHN0b3JlIGluIG1lbW9yeSBjYWNoZSBhcyBiYWNrdXBcclxuICAgICAgdGhpcy5zZXRNZW1vcnlDYWNoZShrZXksIHZhbHVlLCB0dGwpO1xyXG5cclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIHRoaXMubWV0cmljcy5lcnJvcnMrKztcclxuICAgICAgY29uc29sZS5lcnJvcihcIkNhY2hlIHNldCBlcnJvcjpcIiwgZXJyb3IpO1xyXG5cclxuICAgICAgLy8gRmFsbGJhY2sgdG8gbWVtb3J5IGNhY2hlIG9ubHlcclxuICAgICAgdGhpcy5zZXRNZW1vcnlDYWNoZShrZXksIHZhbHVlLCB0dGwpO1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBNZW1vcnkgY2FjaGUgbWFuYWdlbWVudFxyXG4gIHNldE1lbW9yeUNhY2hlKGtleSwgdmFsdWUsIHR0bCA9IG51bGwpIHtcclxuICAgIGNvbnN0IGV4cGlyZXNBdCA9IHR0bFxyXG4gICAgICA/IERhdGUubm93KCkgKyB0dGwgKiAxMDAwXHJcbiAgICAgIDogRGF0ZS5ub3coKSArIDUgKiA2MCAqIDEwMDA7IC8vIERlZmF1bHQgNSBtaW5cclxuXHJcbiAgICAvLyBSZW1vdmUgb2xkIGVudHJ5IGlmIGV4aXN0c1xyXG4gICAgaWYgKHRoaXMubWVtb3J5Q2FjaGUuaGFzKGtleSkpIHtcclxuICAgICAgdGhpcy5tZW1vcnlDYWNoZVNpemUtLTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBDaGVjayBpZiB3ZSBuZWVkIHRvIGV2aWN0IGl0ZW1zXHJcbiAgICBpZiAodGhpcy5tZW1vcnlDYWNoZVNpemUgPj0gdGhpcy5tYXhNZW1vcnlDYWNoZSkge1xyXG4gICAgICB0aGlzLmV2aWN0T2xkZXN0TWVtb3J5Q2FjaGUoKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLm1lbW9yeUNhY2hlLnNldChrZXksIHsgdmFsdWUsIGV4cGlyZXNBdCB9KTtcclxuICAgIHRoaXMubWVtb3J5Q2FjaGVTaXplKys7XHJcbiAgfVxyXG5cclxuICAvLyBFdmljdCBvbGRlc3QgaXRlbXMgZnJvbSBtZW1vcnkgY2FjaGVcclxuICBldmljdE9sZGVzdE1lbW9yeUNhY2hlKCkge1xyXG4gICAgY29uc3QgZW50cmllcyA9IEFycmF5LmZyb20odGhpcy5tZW1vcnlDYWNoZS5lbnRyaWVzKCkpO1xyXG4gICAgZW50cmllcy5zb3J0KChhLCBiKSA9PiBhWzFdLmV4cGlyZXNBdCAtIGJbMV0uZXhwaXJlc0F0KTtcclxuXHJcbiAgICAvLyBSZW1vdmUgb2xkZXN0IDEwJSBvZiBpdGVtc1xyXG4gICAgY29uc3QgdG9SZW1vdmUgPSBNYXRoLm1heCgxLCBNYXRoLmZsb29yKGVudHJpZXMubGVuZ3RoICogMC4xKSk7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRvUmVtb3ZlOyBpKyspIHtcclxuICAgICAgdGhpcy5tZW1vcnlDYWNoZS5kZWxldGUoZW50cmllc1tpXVswXSk7XHJcbiAgICAgIHRoaXMubWVtb3J5Q2FjaGVTaXplLS07XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBFbmhhbmNlZCBkZWxldGUgd2l0aCBtZW1vcnkgY2FjaGUgY2xlYW51cFxyXG4gIGFzeW5jIGRlbChrZXkpIHtcclxuICAgIHRoaXMubWV0cmljcy5vcGVyYXRpb25zKys7XHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5yZWRpcy5kZWwoa2V5KTtcclxuXHJcbiAgICAgIC8vIEFsc28gcmVtb3ZlIGZyb20gbWVtb3J5IGNhY2hlXHJcbiAgICAgIGlmICh0aGlzLm1lbW9yeUNhY2hlLmhhcyhrZXkpKSB7XHJcbiAgICAgICAgdGhpcy5tZW1vcnlDYWNoZS5kZWxldGUoa2V5KTtcclxuICAgICAgICB0aGlzLm1lbW9yeUNhY2hlU2l6ZS0tO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgdGhpcy5tZXRyaWNzLmVycm9ycysrO1xyXG4gICAgICBjb25zb2xlLmVycm9yKFwiQ2FjaGUgZGVsZXRlIGVycm9yOlwiLCBlcnJvcik7XHJcblxyXG4gICAgICAvLyBTdGlsbCB0cnkgdG8gcmVtb3ZlIGZyb20gbWVtb3J5IGNhY2hlXHJcbiAgICAgIGlmICh0aGlzLm1lbW9yeUNhY2hlLmhhcyhrZXkpKSB7XHJcbiAgICAgICAgdGhpcy5tZW1vcnlDYWNoZS5kZWxldGUoa2V5KTtcclxuICAgICAgICB0aGlzLm1lbW9yeUNhY2hlU2l6ZS0tO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBDaGVjayBpZiBrZXkgZXhpc3RzXHJcbiAgYXN5bmMgZXhpc3RzKGtleSkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgcmVkaXNFeGlzdHMgPSBhd2FpdCB0aGlzLnJlZGlzLmV4aXN0cyhrZXkpO1xyXG4gICAgICBpZiAocmVkaXNFeGlzdHMpIHJldHVybiB0cnVlO1xyXG5cclxuICAgICAgLy8gQ2hlY2sgbWVtb3J5IGNhY2hlXHJcbiAgICAgIGNvbnN0IG1lbW9yeURhdGEgPSB0aGlzLm1lbW9yeUNhY2hlLmdldChrZXkpO1xyXG4gICAgICByZXR1cm4gbWVtb3J5RGF0YSAmJiBtZW1vcnlEYXRhLmV4cGlyZXNBdCA+IERhdGUubm93KCk7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKFwiQ2FjaGUgZXhpc3RzIGVycm9yOlwiLCBlcnJvcik7XHJcblxyXG4gICAgICAvLyBDaGVjayBtZW1vcnkgY2FjaGUgb25seVxyXG4gICAgICBjb25zdCBtZW1vcnlEYXRhID0gdGhpcy5tZW1vcnlDYWNoZS5nZXQoa2V5KTtcclxuICAgICAgcmV0dXJuIG1lbW9yeURhdGEgJiYgbWVtb3J5RGF0YS5leHBpcmVzQXQgPiBEYXRlLm5vdygpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gSVBPLXNwZWNpZmljIGNhY2hlIG9wZXJhdGlvbnNcclxuICBhc3luYyBjYWNoZUlQT0xpc3QoaXBvcywgZmlsdGVycyA9IHt9KSB7XHJcbiAgICBjb25zdCBmaWx0ZXJLZXkgPSBPYmplY3Qua2V5cyhmaWx0ZXJzKVxyXG4gICAgICAuc29ydCgpXHJcbiAgICAgIC5tYXAoKGspID0+IGAke2t9OiR7ZmlsdGVyc1trXX1gKVxyXG4gICAgICAuam9pbihcInxcIik7XHJcbiAgICBjb25zdCBjYWNoZUtleSA9IHRoaXMua2V5KFwiSVBPXCIsIGBsaXN0OiR7ZmlsdGVyS2V5IHx8IFwiYWxsXCJ9YCk7XHJcbiAgICByZXR1cm4gdGhpcy5zZXQoY2FjaGVLZXksIGlwb3MsIHRoaXMuZGVmYXVsdFRUTC5JUE9fTElTVCk7XHJcbiAgfVxyXG5cclxuICBhc3luYyBnZXRDYWNoZWRJUE9MaXN0KGZpbHRlcnMgPSB7fSkge1xyXG4gICAgY29uc3QgZmlsdGVyS2V5ID0gT2JqZWN0LmtleXMoZmlsdGVycylcclxuICAgICAgLnNvcnQoKVxyXG4gICAgICAubWFwKChrKSA9PiBgJHtrfToke2ZpbHRlcnNba119YClcclxuICAgICAgLmpvaW4oXCJ8XCIpO1xyXG4gICAgY29uc3QgY2FjaGVLZXkgPSB0aGlzLmtleShcIklQT1wiLCBgbGlzdDoke2ZpbHRlcktleSB8fCBcImFsbFwifWApO1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0KGNhY2hlS2V5KTtcclxuICB9XHJcblxyXG4gIGFzeW5jIGNhY2hlSVBPRGV0YWlsKGlwb0lkLCBkYXRhKSB7XHJcbiAgICBjb25zdCBjYWNoZUtleSA9IHRoaXMua2V5KFwiSVBPXCIsIGBkZXRhaWw6JHtpcG9JZH1gKTtcclxuICAgIHJldHVybiB0aGlzLnNldChjYWNoZUtleSwgZGF0YSwgdGhpcy5kZWZhdWx0VFRMLklQT19ERVRBSUwpO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgZ2V0Q2FjaGVkSVBPRGV0YWlsKGlwb0lkKSB7XHJcbiAgICBjb25zdCBjYWNoZUtleSA9IHRoaXMua2V5KFwiSVBPXCIsIGBkZXRhaWw6JHtpcG9JZH1gKTtcclxuICAgIHJldHVybiB0aGlzLmdldChjYWNoZUtleSk7XHJcbiAgfVxyXG5cclxuICAvLyBSZWFsLXRpbWUgZGF0YSBjYWNoZSB3aXRoIHB1Yi9zdWIgc3VwcG9ydFxyXG4gIGFzeW5jIGNhY2hlUmVhbFRpbWVEYXRhKHR5cGUsIGlkZW50aWZpZXIsIGRhdGEpIHtcclxuICAgIGNvbnN0IGNhY2hlS2V5ID0gdGhpcy5rZXkoXCJSRUFMVElNRVwiLCBgJHt0eXBlfToke2lkZW50aWZpZXJ9YCk7XHJcbiAgICBjb25zdCBlbnJpY2hlZERhdGEgPSB7XHJcbiAgICAgIC4uLmRhdGEsXHJcbiAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcclxuICAgICAgY2FjaGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXHJcbiAgICB9O1xyXG5cclxuICAgIC8vIENhY2hlIHdpdGggc2hvcnQgVFRMIGZvciByZWFsLXRpbWUgZGF0YVxyXG4gICAgYXdhaXQgdGhpcy5zZXQoY2FjaGVLZXksIGVucmljaGVkRGF0YSwgdGhpcy5kZWZhdWx0VFRMLlJFQUxUSU1FKTtcclxuXHJcbiAgICAvLyBBbHNvIHB1Ymxpc2ggdG8gUmVkaXMgcHViL3N1YiBmb3IgV2ViU29ja2V0IGRpc3RyaWJ1dGlvbiAoaWYgYXZhaWxhYmxlKVxyXG4gICAgdHJ5IHtcclxuICAgICAgYXdhaXQgdGhpcy5yZWRpcy5wdWJsaXNoKFxyXG4gICAgICAgIGByZWFsdGltZToke3R5cGV9OiR7aWRlbnRpZmllcn1gLFxyXG4gICAgICAgIEpTT04uc3RyaW5naWZ5KGVucmljaGVkRGF0YSlcclxuICAgICAgKTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUud2FybihcclxuICAgICAgICBcIlJlZGlzIHB1Ymxpc2ggZmFpbGVkLCBjb250aW51aW5nIHdpdGhvdXQgcHViL3N1YjpcIixcclxuICAgICAgICBlcnJvci5tZXNzYWdlXHJcbiAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGVucmljaGVkRGF0YTtcclxuICB9XHJcblxyXG4gIGFzeW5jIGdldFJlYWxUaW1lRGF0YSh0eXBlLCBpZGVudGlmaWVyKSB7XHJcbiAgICBjb25zdCBjYWNoZUtleSA9IHRoaXMua2V5KFwiUkVBTFRJTUVcIiwgYCR7dHlwZX06JHtpZGVudGlmaWVyfWApO1xyXG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IHRoaXMuZ2V0KGNhY2hlS2V5KTtcclxuXHJcbiAgICAvLyBDaGVjayBpZiBkYXRhIGlzIGZyZXNoIChsZXNzIHRoYW4gVFRMKVxyXG4gICAgaWYgKGRhdGEgJiYgRGF0ZS5ub3coKSAtIGRhdGEudGltZXN0YW1wIDwgdGhpcy5kZWZhdWx0VFRMLlJFQUxUSU1FICogMTAwMCkge1xyXG4gICAgICByZXR1cm4gZGF0YTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcblxyXG4gIC8vIEdNUCBjYWNoZSBvcGVyYXRpb25zXHJcbiAgYXN5bmMgY2FjaGVHTVBEYXRhKGlwb0lkLCBnbXBEYXRhKSB7XHJcbiAgICBjb25zdCBjYWNoZUtleSA9IHRoaXMua2V5KFwiR01QXCIsIGBkYXRhOiR7aXBvSWR9YCk7XHJcbiAgICByZXR1cm4gdGhpcy5zZXQoY2FjaGVLZXksIGdtcERhdGEsIHRoaXMuZGVmYXVsdFRUTC5HTVBfREFUQSk7XHJcbiAgfVxyXG5cclxuICBhc3luYyBnZXRDYWNoZWRHTVBEYXRhKGlwb0lkKSB7XHJcbiAgICBjb25zdCBjYWNoZUtleSA9IHRoaXMua2V5KFwiR01QXCIsIGBkYXRhOiR7aXBvSWR9YCk7XHJcbiAgICByZXR1cm4gdGhpcy5nZXQoY2FjaGVLZXkpO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgY2FjaGVMaXZlR01QKGlwb0lkLCBnbXBWYWx1ZSkge1xyXG4gICAgY29uc3QgY2FjaGVLZXkgPSB0aGlzLmtleShcIkdNUFwiLCBgbGl2ZToke2lwb0lkfWApO1xyXG4gICAgY29uc3QgZ21wRGF0YSA9IHtcclxuICAgICAgdmFsdWU6IGdtcFZhbHVlLFxyXG4gICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXHJcbiAgICAgIGNhY2hlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxyXG4gICAgfTtcclxuXHJcbiAgICAvLyBTdG9yZSB3aXRoIHNob3J0IFRUTCBmb3IgcmVhbC10aW1lIHVwZGF0ZXNcclxuICAgIHJldHVybiB0aGlzLnNldChjYWNoZUtleSwgZ21wRGF0YSwgMzApO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgZ2V0Q2FjaGVkTGl2ZUdNUChpcG9JZCkge1xyXG4gICAgY29uc3QgY2FjaGVLZXkgPSB0aGlzLmtleShcIkdNUFwiLCBgbGl2ZToke2lwb0lkfWApO1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0KGNhY2hlS2V5KTtcclxuICB9XHJcblxyXG4gIC8vIFN1YnNjcmlwdGlvbiBkYXRhIGNhY2hlXHJcbiAgYXN5bmMgY2FjaGVTdWJzY3JpcHRpb25EYXRhKHN5bWJvbCwgZGF0YSkge1xyXG4gICAgY29uc3QgY2FjaGVLZXkgPSB0aGlzLmtleShcIlNVQlNDUklQVElPTlwiLCBgZGF0YToke3N5bWJvbH1gKTtcclxuICAgIHJldHVybiB0aGlzLnNldChjYWNoZUtleSwgZGF0YSwgdGhpcy5kZWZhdWx0VFRMLlNVQlNDUklQVElPTik7XHJcbiAgfVxyXG5cclxuICBhc3luYyBnZXRDYWNoZWRTdWJzY3JpcHRpb25EYXRhKHN5bWJvbCkge1xyXG4gICAgY29uc3QgY2FjaGVLZXkgPSB0aGlzLmtleShcIlNVQlNDUklQVElPTlwiLCBgZGF0YToke3N5bWJvbH1gKTtcclxuICAgIHJldHVybiB0aGlzLmdldChjYWNoZUtleSk7XHJcbiAgfVxyXG5cclxuICAvLyBNYXJrZXQgZGVtYW5kIGNhY2hlXHJcbiAgYXN5bmMgY2FjaGVEZW1hbmREYXRhKHN5bWJvbCwgZGF0YSkge1xyXG4gICAgY29uc3QgY2FjaGVLZXkgPSB0aGlzLmtleShcIkRFTUFORFwiLCBgZGF0YToke3N5bWJvbH1gKTtcclxuICAgIHJldHVybiB0aGlzLnNldChjYWNoZUtleSwgZGF0YSwgdGhpcy5kZWZhdWx0VFRMLkRFTUFORCk7XHJcbiAgfVxyXG5cclxuICBhc3luYyBnZXRDYWNoZWREZW1hbmREYXRhKHN5bWJvbCkge1xyXG4gICAgY29uc3QgY2FjaGVLZXkgPSB0aGlzLmtleShcIkRFTUFORFwiLCBgZGF0YToke3N5bWJvbH1gKTtcclxuICAgIHJldHVybiB0aGlzLmdldChjYWNoZUtleSk7XHJcbiAgfVxyXG5cclxuICAvLyBBbGxvdG1lbnQgY2FjaGVcclxuICBhc3luYyBjYWNoZUFsbG90bWVudFN0YXR1cyhwYW5OdW1iZXIsIGFwcGxpY2F0aW9uTnVtYmVyLCBkYXRhKSB7XHJcbiAgICBjb25zdCBjYWNoZUtleSA9IHRoaXMua2V5KFxyXG4gICAgICBcIkFMTE9UTUVOVFwiLFxyXG4gICAgICBgc3RhdHVzOiR7cGFuTnVtYmVyfToke2FwcGxpY2F0aW9uTnVtYmVyfWBcclxuICAgICk7XHJcbiAgICByZXR1cm4gdGhpcy5zZXQoY2FjaGVLZXksIGRhdGEsIHRoaXMuZGVmYXVsdFRUTC5BTExPVE1FTlQpO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgZ2V0Q2FjaGVkQWxsb3RtZW50U3RhdHVzKHBhbk51bWJlciwgYXBwbGljYXRpb25OdW1iZXIpIHtcclxuICAgIGNvbnN0IGNhY2hlS2V5ID0gdGhpcy5rZXkoXHJcbiAgICAgIFwiQUxMT1RNRU5UXCIsXHJcbiAgICAgIGBzdGF0dXM6JHtwYW5OdW1iZXJ9OiR7YXBwbGljYXRpb25OdW1iZXJ9YFxyXG4gICAgKTtcclxuICAgIHJldHVybiB0aGlzLmdldChjYWNoZUtleSk7XHJcbiAgfVxyXG5cclxuICAvLyBVc2VyIHNlc3Npb24gY2FjaGVcclxuICBhc3luYyBjYWNoZVVzZXJTZXNzaW9uKHVzZXJJZCwgc2Vzc2lvbkRhdGEpIHtcclxuICAgIGNvbnN0IGNhY2hlS2V5ID0gdGhpcy5rZXkoXCJVU0VSXCIsIGBzZXNzaW9uOiR7dXNlcklkfWApO1xyXG4gICAgcmV0dXJuIHRoaXMuc2V0KGNhY2hlS2V5LCBzZXNzaW9uRGF0YSwgdGhpcy5kZWZhdWx0VFRMLlVTRVJfU0VTU0lPTik7XHJcbiAgfVxyXG5cclxuICBhc3luYyBnZXRDYWNoZWRVc2VyU2Vzc2lvbih1c2VySWQpIHtcclxuICAgIGNvbnN0IGNhY2hlS2V5ID0gdGhpcy5rZXkoXCJVU0VSXCIsIGBzZXNzaW9uOiR7dXNlcklkfWApO1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0KGNhY2hlS2V5KTtcclxuICB9XHJcblxyXG4gIC8vIEFQSSByZXNwb25zZSBjYWNoZVxyXG4gIGFzeW5jIGNhY2hlQVBJUmVzcG9uc2UoZW5kcG9pbnQsIHBhcmFtcywgZGF0YSkge1xyXG4gICAgY29uc3QgcGFyYW1LZXkgPSBPYmplY3Qua2V5cyhwYXJhbXMpXHJcbiAgICAgIC5zb3J0KClcclxuICAgICAgLm1hcCgoaykgPT4gYCR7a306JHtwYXJhbXNba119YClcclxuICAgICAgLmpvaW4oXCJ8XCIpO1xyXG4gICAgY29uc3QgY2FjaGVLZXkgPSB0aGlzLmtleShcIkFQSVwiLCBgJHtlbmRwb2ludH06JHtwYXJhbUtleX1gKTtcclxuICAgIHJldHVybiB0aGlzLnNldChjYWNoZUtleSwgZGF0YSwgdGhpcy5kZWZhdWx0VFRMLkFQSV9SRVNQT05TRSk7XHJcbiAgfVxyXG5cclxuICBhc3luYyBnZXRDYWNoZWRBUElSZXNwb25zZShlbmRwb2ludCwgcGFyYW1zKSB7XHJcbiAgICBjb25zdCBwYXJhbUtleSA9IE9iamVjdC5rZXlzKHBhcmFtcylcclxuICAgICAgLnNvcnQoKVxyXG4gICAgICAubWFwKChrKSA9PiBgJHtrfToke3BhcmFtc1trXX1gKVxyXG4gICAgICAuam9pbihcInxcIik7XHJcbiAgICBjb25zdCBjYWNoZUtleSA9IHRoaXMua2V5KFwiQVBJXCIsIGAke2VuZHBvaW50fToke3BhcmFtS2V5fWApO1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0KGNhY2hlS2V5KTtcclxuICB9XHJcblxyXG4gIC8vIFNlYXJjaCByZXN1bHRzIGNhY2hlXHJcbiAgYXN5bmMgY2FjaGVTZWFyY2hSZXN1bHRzKHF1ZXJ5LCByZXN1bHRzKSB7XHJcbiAgICBjb25zdCBjYWNoZUtleSA9IHRoaXMua2V5KFwiU0VBUkNIXCIsIGBxdWVyeToke3F1ZXJ5LnRvTG93ZXJDYXNlKCl9YCk7XHJcbiAgICByZXR1cm4gdGhpcy5zZXQoY2FjaGVLZXksIHJlc3VsdHMsIHRoaXMuZGVmYXVsdFRUTC5TRUFSQ0gpO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgZ2V0Q2FjaGVkU2VhcmNoUmVzdWx0cyhxdWVyeSkge1xyXG4gICAgY29uc3QgY2FjaGVLZXkgPSB0aGlzLmtleShcIlNFQVJDSFwiLCBgcXVlcnk6JHtxdWVyeS50b0xvd2VyQ2FzZSgpfWApO1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0KGNhY2hlS2V5KTtcclxuICB9XHJcblxyXG4gIC8vIEFuYWx5dGljcyBjYWNoZVxyXG4gIGFzeW5jIGNhY2hlQW5hbHl0aWNzKHR5cGUsIGlkZW50aWZpZXIsIGRhdGEpIHtcclxuICAgIGNvbnN0IGNhY2hlS2V5ID0gdGhpcy5rZXkoXCJBTkFMWVRJQ1NcIiwgYCR7dHlwZX06JHtpZGVudGlmaWVyfWApO1xyXG4gICAgcmV0dXJuIHRoaXMuc2V0KGNhY2hlS2V5LCBkYXRhLCB0aGlzLmRlZmF1bHRUVEwuQU5BTFlUSUNTKTtcclxuICB9XHJcblxyXG4gIGFzeW5jIGdldENhY2hlZEFuYWx5dGljcyh0eXBlLCBpZGVudGlmaWVyKSB7XHJcbiAgICBjb25zdCBjYWNoZUtleSA9IHRoaXMua2V5KFwiQU5BTFlUSUNTXCIsIGAke3R5cGV9OiR7aWRlbnRpZmllcn1gKTtcclxuICAgIHJldHVybiB0aGlzLmdldChjYWNoZUtleSk7XHJcbiAgfVxyXG5cclxuICAvLyBCYXRjaCBvcGVyYXRpb25zXHJcbiAgYXN5bmMgbWdldChrZXlzKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5yZWRpcy5tZ2V0KC4uLmtleXMpO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcihcIkNhY2hlIG1nZXQgZXJyb3I6XCIsIGVycm9yKTtcclxuXHJcbiAgICAgIC8vIEZhbGxiYWNrIHRvIGluZGl2aWR1YWwgZ2V0cyBmcm9tIG1lbW9yeSBjYWNoZVxyXG4gICAgICBjb25zdCByZXN1bHRzID0gW107XHJcbiAgICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcclxuICAgICAgICBjb25zdCBtZW1vcnlEYXRhID0gdGhpcy5tZW1vcnlDYWNoZS5nZXQoa2V5KTtcclxuICAgICAgICBpZiAobWVtb3J5RGF0YSAmJiBtZW1vcnlEYXRhLmV4cGlyZXNBdCA+IERhdGUubm93KCkpIHtcclxuICAgICAgICAgIHJlc3VsdHMucHVzaChtZW1vcnlEYXRhLnZhbHVlKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgcmVzdWx0cy5wdXNoKG51bGwpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gcmVzdWx0cztcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGFzeW5jIG1zZXQoa2V5VmFsdWVQYWlycykge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgcGFpcnMgPSBbXTtcclxuICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2Yga2V5VmFsdWVQYWlycykge1xyXG4gICAgICAgIHBhaXJzLnB1c2goXHJcbiAgICAgICAgICBrZXksXHJcbiAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgPyB2YWx1ZSA6IEpTT04uc3RyaW5naWZ5KHZhbHVlKVxyXG4gICAgICAgICk7XHJcbiAgICAgICAgLy8gQWxzbyBzZXQgaW4gbWVtb3J5IGNhY2hlXHJcbiAgICAgICAgdGhpcy5zZXRNZW1vcnlDYWNoZShrZXksIHZhbHVlKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5yZWRpcy5tc2V0KC4uLnBhaXJzKTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJDYWNoZSBtc2V0IGVycm9yOlwiLCBlcnJvcik7XHJcblxyXG4gICAgICAvLyBGYWxsYmFjayB0byBtZW1vcnkgY2FjaGUgb25seVxyXG4gICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBrZXlWYWx1ZVBhaXJzKSB7XHJcbiAgICAgICAgdGhpcy5zZXRNZW1vcnlDYWNoZShrZXksIHZhbHVlKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBDYWNoZSBpbnZhbGlkYXRpb25cclxuICBhc3luYyBpbnZhbGlkYXRlUGF0dGVybihwYXR0ZXJuKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBrZXlzID0gYXdhaXQgdGhpcy5yZWRpcy5rZXlzKHBhdHRlcm4pO1xyXG4gICAgICBpZiAoa2V5cy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgLy8gRGVsZXRlIGZyb20gUmVkaXNcclxuICAgICAgICBjb25zdCByZWRpc1Jlc3VsdCA9IGF3YWl0IHRoaXMucmVkaXMuZGVsKC4uLmtleXMpO1xyXG5cclxuICAgICAgICAvLyBEZWxldGUgZnJvbSBtZW1vcnkgY2FjaGVcclxuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XHJcbiAgICAgICAgICBpZiAodGhpcy5tZW1vcnlDYWNoZS5oYXMoa2V5KSkge1xyXG4gICAgICAgICAgICB0aGlzLm1lbW9yeUNhY2hlLmRlbGV0ZShrZXkpO1xyXG4gICAgICAgICAgICB0aGlzLm1lbW9yeUNhY2hlU2l6ZS0tO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHJlZGlzUmVzdWx0O1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiAwO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcihcIkNhY2hlIGludmFsaWRhdGlvbiBlcnJvcjpcIiwgZXJyb3IpO1xyXG5cclxuICAgICAgLy8gVHJ5IHRvIGNsZWFyIG1lbW9yeSBjYWNoZSBwYXR0ZXJucyAoc2ltcGxlIHN0cmluZyBtYXRjaGluZylcclxuICAgICAgbGV0IGNsZWFyZWQgPSAwO1xyXG4gICAgICBmb3IgKGNvbnN0IFtrZXldIG9mIHRoaXMubWVtb3J5Q2FjaGUpIHtcclxuICAgICAgICBpZiAoa2V5LmluY2x1ZGVzKHBhdHRlcm4ucmVwbGFjZShcIipcIiwgXCJcIikpKSB7XHJcbiAgICAgICAgICB0aGlzLm1lbW9yeUNhY2hlLmRlbGV0ZShrZXkpO1xyXG4gICAgICAgICAgdGhpcy5tZW1vcnlDYWNoZVNpemUtLTtcclxuICAgICAgICAgIGNsZWFyZWQrKztcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGNsZWFyZWQ7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBhc3luYyBpbnZhbGlkYXRlSVBPQ2FjaGUoaXBvSWQpIHtcclxuICAgIGNvbnN0IHBhdHRlcm5zID0gW1xyXG4gICAgICB0aGlzLmtleShcIklQT1wiLCBgZGV0YWlsOiR7aXBvSWR9YCksXHJcbiAgICAgIHRoaXMua2V5KFwiSVBPXCIsIFwibGlzdDoqXCIpLFxyXG4gICAgICB0aGlzLmtleShcIkdNUFwiLCBgKjoke2lwb0lkfWApLFxyXG4gICAgICB0aGlzLmtleShcIlNVQlNDUklQVElPTlwiLCBgKjoke2lwb0lkfWApLFxyXG4gICAgICB0aGlzLmtleShcIkRFTUFORFwiLCBgKjoke2lwb0lkfWApLFxyXG4gICAgICB0aGlzLmtleShcIlJFQUxUSU1FXCIsIGAqOiR7aXBvSWR9YCksXHJcbiAgICBdO1xyXG5cclxuICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBQcm9taXNlLmFsbFNldHRsZWQoXHJcbiAgICAgIHBhdHRlcm5zLm1hcCgocGF0dGVybikgPT4gdGhpcy5pbnZhbGlkYXRlUGF0dGVybihwYXR0ZXJuKSlcclxuICAgICk7XHJcbiAgICByZXR1cm4gcmVzdWx0cy5ldmVyeSgocmVzdWx0KSA9PiByZXN1bHQuc3RhdHVzID09PSBcImZ1bGZpbGxlZFwiKTtcclxuICB9XHJcblxyXG4gIC8vIFBlcmZvcm1hbmNlIG1vbml0b3JpbmdcclxuICBhc3luYyBnZXRDYWNoZVN0YXRzKCkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgcmVkaXNJbmZvID0gYXdhaXQgdGhpcy5yZWRpcy5pbmZvKCk7XHJcbiAgICAgIGNvbnN0IGhpdFJhdGUgPVxyXG4gICAgICAgIHRoaXMubWV0cmljcy5vcGVyYXRpb25zID4gMFxyXG4gICAgICAgICAgPyAoKHRoaXMubWV0cmljcy5oaXRzIC8gdGhpcy5tZXRyaWNzLm9wZXJhdGlvbnMpICogMTAwKS50b0ZpeGVkKDIpXHJcbiAgICAgICAgICA6IFwiMC4wMFwiO1xyXG5cclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBjb25uZWN0ZWQ6IHRydWUsXHJcbiAgICAgICAgcmVkaXM6IHtcclxuICAgICAgICAgIG1lbW9yeTogcmVkaXNJbmZvLm1hdGNoKC91c2VkX21lbW9yeV9odW1hbjooLispLyk/LlsxXT8udHJpbSgpLFxyXG4gICAgICAgICAga2V5czogcmVkaXNJbmZvLm1hdGNoKC9kYjA6a2V5cz0oXFxkKykvKT8uWzFdLFxyXG4gICAgICAgICAgaGl0czogcmVkaXNJbmZvLm1hdGNoKC9rZXlzcGFjZV9oaXRzOihcXGQrKS8pPy5bMV0sXHJcbiAgICAgICAgICBtaXNzZXM6IHJlZGlzSW5mby5tYXRjaCgva2V5c3BhY2VfbWlzc2VzOihcXGQrKS8pPy5bMV0sXHJcbiAgICAgICAgfSxcclxuICAgICAgICBsb2NhbDoge1xyXG4gICAgICAgICAgaGl0UmF0ZTogYCR7aGl0UmF0ZX0lYCxcclxuICAgICAgICAgIHRvdGFsT3BlcmF0aW9uczogdGhpcy5tZXRyaWNzLm9wZXJhdGlvbnMsXHJcbiAgICAgICAgICBoaXRzOiB0aGlzLm1ldHJpY3MuaGl0cyxcclxuICAgICAgICAgIG1pc3NlczogdGhpcy5tZXRyaWNzLm1pc3NlcyxcclxuICAgICAgICAgIGVycm9yczogdGhpcy5tZXRyaWNzLmVycm9ycyxcclxuICAgICAgICAgIG1lbW9yeUNhY2hlU2l6ZTogdGhpcy5tZW1vcnlDYWNoZVNpemUsXHJcbiAgICAgICAgICBtZW1vcnlDYWNoZUxpbWl0OiB0aGlzLm1heE1lbW9yeUNhY2hlLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXHJcbiAgICAgIH07XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zdCBoaXRSYXRlID1cclxuICAgICAgICB0aGlzLm1ldHJpY3Mub3BlcmF0aW9ucyA+IDBcclxuICAgICAgICAgID8gKCh0aGlzLm1ldHJpY3MuaGl0cyAvIHRoaXMubWV0cmljcy5vcGVyYXRpb25zKSAqIDEwMCkudG9GaXhlZCgyKVxyXG4gICAgICAgICAgOiBcIjAuMDBcIjtcclxuXHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgY29ubmVjdGVkOiBmYWxzZSxcclxuICAgICAgICBlcnJvcjogZXJyb3IubWVzc2FnZSxcclxuICAgICAgICBsb2NhbDoge1xyXG4gICAgICAgICAgaGl0UmF0ZTogYCR7aGl0UmF0ZX0lYCxcclxuICAgICAgICAgIHRvdGFsT3BlcmF0aW9uczogdGhpcy5tZXRyaWNzLm9wZXJhdGlvbnMsXHJcbiAgICAgICAgICBoaXRzOiB0aGlzLm1ldHJpY3MuaGl0cyxcclxuICAgICAgICAgIG1pc3NlczogdGhpcy5tZXRyaWNzLm1pc3NlcyxcclxuICAgICAgICAgIGVycm9yczogdGhpcy5tZXRyaWNzLmVycm9ycyxcclxuICAgICAgICAgIG1lbW9yeUNhY2hlU2l6ZTogdGhpcy5tZW1vcnlDYWNoZVNpemUsXHJcbiAgICAgICAgICBtZW1vcnlDYWNoZUxpbWl0OiB0aGlzLm1heE1lbW9yeUNhY2hlLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXHJcbiAgICAgIH07XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBDYWNoZSB3YXJtaW5nIGZvciBmcmVxdWVudGx5IGFjY2Vzc2VkIGRhdGFcclxuICBhc3luYyB3YXJtQ2FjaGUoKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zb2xlLmxvZyhcIvCflKUgU3RhcnRpbmcgY2FjaGUgd2FybS11cC4uLlwiKTtcclxuXHJcbiAgICAgIC8vIENhY2hlIGFjdGl2ZSBJUE9zXHJcbiAgICAgIGNvbnN0IGFjdGl2ZUlQT3MgPSBhd2FpdCBwcmlzbWEuaVBPLmZpbmRNYW55KHtcclxuICAgICAgICB3aGVyZToge1xyXG4gICAgICAgICAgc3RhdHVzOiB7IGluOiBbXCJvcGVuXCIsIFwidXBjb21pbmdcIl0gfSxcclxuICAgICAgICAgIGlzQWN0aXZlOiB0cnVlLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaW5jbHVkZToge1xyXG4gICAgICAgICAgZ21wOiB7IHRha2U6IDEwLCBvcmRlckJ5OiB7IHRpbWVzdGFtcDogXCJkZXNjXCIgfSB9LFxyXG4gICAgICAgICAgc3Vic2NyaXB0aW9uOiB7IHRha2U6IDUsIG9yZGVyQnk6IHsgdGltZXN0YW1wOiBcImRlc2NcIiB9IH0sXHJcbiAgICAgICAgICBhbmFseXRpY3M6IHRydWUsXHJcbiAgICAgICAgfSxcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBjb25zdCBjYWNoZVByb21pc2VzID0gYWN0aXZlSVBPcy5tYXAoKGlwbykgPT5cclxuICAgICAgICB0aGlzLmNhY2hlSVBPRGV0YWlsKGlwby5pZCwgaXBvKVxyXG4gICAgICApO1xyXG5cclxuICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoY2FjaGVQcm9taXNlcyk7XHJcblxyXG4gICAgICAvLyBDYWNoZSBJUE8gbGlzdCB3aXRoIGNvbW1vbiBmaWx0ZXJzXHJcbiAgICAgIGF3YWl0IHRoaXMuY2FjaGVJUE9MaXN0KFxyXG4gICAgICAgIGFjdGl2ZUlQT3MuZmlsdGVyKChpcG8pID0+IGlwby5zdGF0dXMgPT09IFwib3BlblwiKSxcclxuICAgICAgICB7IHN0YXR1czogXCJvcGVuXCIgfVxyXG4gICAgICApO1xyXG4gICAgICBhd2FpdCB0aGlzLmNhY2hlSVBPTGlzdChcclxuICAgICAgICBhY3RpdmVJUE9zLmZpbHRlcigoaXBvKSA9PiBpcG8uc3RhdHVzID09PSBcInVwY29taW5nXCIpLFxyXG4gICAgICAgIHsgc3RhdHVzOiBcInVwY29taW5nXCIgfVxyXG4gICAgICApO1xyXG5cclxuICAgICAgY29uc29sZS5sb2coYPCflKUgQ2FjaGUgd2FybWVkIHdpdGggJHthY3RpdmVJUE9zLmxlbmd0aH0gYWN0aXZlIElQT3NgKTtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKFwiQ2FjaGUgd2FybS11cCBmYWlsZWQ6XCIsIGVycm9yKTtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gSGVhbHRoIGNoZWNrXHJcbiAgYXN5bmMgaGVhbHRoQ2hlY2soKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCB0ZXN0S2V5ID0gXCJoZWFsdGhfY2hlY2tcIjtcclxuICAgICAgY29uc3QgdGVzdFZhbHVlID0gRGF0ZS5ub3coKS50b1N0cmluZygpO1xyXG4gICAgICBhd2FpdCB0aGlzLnNldCh0ZXN0S2V5LCB0ZXN0VmFsdWUsIDEwKTtcclxuICAgICAgY29uc3QgcmV0cmlldmVkID0gYXdhaXQgdGhpcy5nZXQodGVzdEtleSk7XHJcbiAgICAgIGF3YWl0IHRoaXMuZGVsKHRlc3RLZXkpO1xyXG5cclxuICAgICAgY29uc3QgaXNIZWFsdGh5ID0gcmV0cmlldmVkID09PSB0ZXN0VmFsdWU7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgc3RhdHVzOiBpc0hlYWx0aHkgPyBcImhlYWx0aHlcIiA6IFwiZGVncmFkZWRcIixcclxuICAgICAgICByZWRpczogaXNIZWFsdGh5LFxyXG4gICAgICAgIG1lbW9yeUNhY2hlOiB0aGlzLm1lbW9yeUNhY2hlU2l6ZSA8IHRoaXMubWF4TWVtb3J5Q2FjaGUsXHJcbiAgICAgICAgbWV0cmljczogdGhpcy5tZXRyaWNzLFxyXG4gICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxyXG4gICAgICB9O1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcihcIkNhY2hlIGhlYWx0aCBjaGVjayBmYWlsZWQ6XCIsIGVycm9yKTtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBzdGF0dXM6IFwidW5oZWFsdGh5XCIsXHJcbiAgICAgICAgcmVkaXM6IGZhbHNlLFxyXG4gICAgICAgIG1lbW9yeUNhY2hlOiB0aGlzLm1lbW9yeUNhY2hlU2l6ZSA8IHRoaXMubWF4TWVtb3J5Q2FjaGUsXHJcbiAgICAgICAgZXJyb3I6IGVycm9yLm1lc3NhZ2UsXHJcbiAgICAgICAgbWV0cmljczogdGhpcy5tZXRyaWNzLFxyXG4gICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gQ2xlYW4gZXhwaXJlZCBlbnRyaWVzIGZyb20gbWVtb3J5IGNhY2hlXHJcbiAgY2xlYW5FeHBpcmVkTWVtb3J5Q2FjaGUoKSB7XHJcbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xyXG4gICAgY29uc3QgdG9EZWxldGUgPSBbXTtcclxuXHJcbiAgICBmb3IgKGNvbnN0IFtrZXksIGRhdGFdIG9mIHRoaXMubWVtb3J5Q2FjaGUpIHtcclxuICAgICAgaWYgKGRhdGEuZXhwaXJlc0F0IDw9IG5vdykge1xyXG4gICAgICAgIHRvRGVsZXRlLnB1c2goa2V5KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZvciAoY29uc3Qga2V5IG9mIHRvRGVsZXRlKSB7XHJcbiAgICAgIHRoaXMubWVtb3J5Q2FjaGUuZGVsZXRlKGtleSk7XHJcbiAgICAgIHRoaXMubWVtb3J5Q2FjaGVTaXplLS07XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRvRGVsZXRlLmxlbmd0aDtcclxuICB9XHJcblxyXG4gIC8vIFJlc2V0IG1ldHJpY3NcclxuICByZXNldE1ldHJpY3MoKSB7XHJcbiAgICB0aGlzLm1ldHJpY3MgPSB7XHJcbiAgICAgIGhpdHM6IDAsXHJcbiAgICAgIG1pc3NlczogMCxcclxuICAgICAgZXJyb3JzOiAwLFxyXG4gICAgICBvcGVyYXRpb25zOiAwLFxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIC8vIEdldCBjYWNoZSBzaXplIGluZm9cclxuICBnZXRDYWNoZVNpemUoKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBtZW1vcnlDYWNoZTogdGhpcy5tZW1vcnlDYWNoZVNpemUsXHJcbiAgICAgIG1heE1lbW9yeUNhY2hlOiB0aGlzLm1heE1lbW9yeUNhY2hlLFxyXG4gICAgICB1dGlsaXphdGlvblBlcmNlbnQ6IChcclxuICAgICAgICAodGhpcy5tZW1vcnlDYWNoZVNpemUgLyB0aGlzLm1heE1lbW9yeUNhY2hlKSAqXHJcbiAgICAgICAgMTAwXHJcbiAgICAgICkudG9GaXhlZCgyKSxcclxuICAgIH07XHJcbiAgfVxyXG59XHJcblxyXG4vLyBFeHBvcnQgc2luZ2xldG9uIGluc3RhbmNlXHJcbmV4cG9ydCBjb25zdCBjYWNoZSA9IG5ldyBDYWNoZVNlcnZpY2UoKTtcclxuXHJcbi8vIFV0aWxpdHkgbWlkZGxld2FyZSBmb3IgY2FjaGUgbWFuYWdlbWVudFxyXG5leHBvcnQgY29uc3QgY2FjaGVNaWRkbGV3YXJlID0gKHR0bCA9IDMwMCkgPT4ge1xyXG4gIHJldHVybiBhc3luYyAocmVxLCByZXMsIG5leHQpID0+IHtcclxuICAgIGNvbnN0IGNhY2hlS2V5ID0gY2FjaGUua2V5KFxyXG4gICAgICBcIkFQSVwiLFxyXG4gICAgICBgJHtyZXEucGF0aH06JHtKU09OLnN0cmluZ2lmeShyZXEucXVlcnkpfWBcclxuICAgICk7XHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgY2FjaGVkID0gYXdhaXQgY2FjaGUuZ2V0KGNhY2hlS2V5KTtcclxuICAgICAgaWYgKGNhY2hlZCkge1xyXG4gICAgICAgIHJldHVybiByZXMuanNvbih7XHJcbiAgICAgICAgICAuLi5jYWNoZWQsXHJcbiAgICAgICAgICBjYWNoZWQ6IHRydWUsXHJcbiAgICAgICAgICBjYWNoZVRpbWVzdGFtcDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBTdG9yZSBvcmlnaW5hbCByZXMuanNvblxyXG4gICAgICBjb25zdCBvcmlnaW5hbEpzb24gPSByZXMuanNvbjtcclxuICAgICAgLy8gT3ZlcnJpZGUgcmVzLmpzb24gdG8gY2FjaGUgdGhlIHJlc3BvbnNlXHJcbiAgICAgIHJlcy5qc29uID0gZnVuY3Rpb24gKGRhdGEpIHtcclxuICAgICAgICBjYWNoZS5zZXQoY2FjaGVLZXksIGRhdGEsIHR0bCk7XHJcbiAgICAgICAgcmV0dXJuIG9yaWdpbmFsSnNvbi5jYWxsKHRoaXMsIGRhdGEpO1xyXG4gICAgICB9O1xyXG4gICAgICBuZXh0KCk7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKFwiQ2FjaGUgbWlkZGxld2FyZSBlcnJvcjpcIiwgZXJyb3IpO1xyXG4gICAgICBuZXh0KCk7XHJcbiAgICB9XHJcbiAgfTtcclxufTtcclxuXHJcbi8vIE1pZGRsZXdhcmUgdG8gaW52YWxpZGF0ZSBjYWNoZSBvbiB1cGRhdGVzXHJcbmV4cG9ydCBjb25zdCBpbnZhbGlkYXRlQ2FjaGVPblVwZGF0ZSA9IChwYXR0ZXJucykgPT4ge1xyXG4gIHJldHVybiBhc3luYyAocmVxLCByZXMsIG5leHQpID0+IHtcclxuICAgIC8vIFN0b3JlIG9yaWdpbmFsIHJlc3BvbnNlIG1ldGhvZHNcclxuICAgIGNvbnN0IG9yaWdpbmFsSnNvbiA9IHJlcy5qc29uO1xyXG4gICAgY29uc3Qgb3JpZ2luYWxTZW5kID0gcmVzLnNlbmQ7XHJcblxyXG4gICAgY29uc3QgY2xlYW51cCA9IGFzeW5jIChkYXRhKSA9PiB7XHJcbiAgICAgIGlmIChyZXMuc3RhdHVzQ29kZSA+PSAyMDAgJiYgcmVzLnN0YXR1c0NvZGUgPCAzMDApIHtcclxuICAgICAgICAvLyBTdWNjZXNzIHJlc3BvbnNlLCBpbnZhbGlkYXRlIGNhY2hlXHJcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoXHJcbiAgICAgICAgICBwYXR0ZXJucy5tYXAoKHBhdHRlcm4pID0+IGNhY2hlLmludmFsaWRhdGVQYXR0ZXJuKHBhdHRlcm4pKVxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGRhdGE7XHJcbiAgICB9O1xyXG5cclxuICAgIHJlcy5qc29uID0gZnVuY3Rpb24gKGRhdGEpIHtcclxuICAgICAgY2xlYW51cChkYXRhKTtcclxuICAgICAgcmV0dXJuIG9yaWdpbmFsSnNvbi5jYWxsKHRoaXMsIGRhdGEpO1xyXG4gICAgfTtcclxuXHJcbiAgICByZXMuc2VuZCA9IGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICAgIGNsZWFudXAoZGF0YSk7XHJcbiAgICAgIHJldHVybiBvcmlnaW5hbFNlbmQuY2FsbCh0aGlzLCBkYXRhKTtcclxuICAgIH07XHJcblxyXG4gICAgbmV4dCgpO1xyXG4gIH07XHJcbn07XHJcblxyXG4vLyBBdXRvLWNsZWFudXAgZXhwaXJlZCBtZW1vcnkgY2FjaGUgZW50cmllcyBldmVyeSA1IG1pbnV0ZXNcclxuc2V0SW50ZXJ2YWwoXHJcbiAgKCkgPT4ge1xyXG4gICAgY29uc3QgY2xlYW5lZCA9IGNhY2hlLmNsZWFuRXhwaXJlZE1lbW9yeUNhY2hlKCk7XHJcbiAgICBpZiAoY2xlYW5lZCA+IDApIHtcclxuICAgICAgY29uc29sZS5sb2coYPCfp7kgQ2xlYW5lZCB1cCAke2NsZWFuZWR9IGV4cGlyZWQgbWVtb3J5IGNhY2hlIGVudHJpZXNgKTtcclxuICAgIH1cclxuICB9LFxyXG4gIDUgKiA2MCAqIDEwMDBcclxuKTtcclxuXHJcbi8vIFBlcmlvZGljIGNhY2hlIHdhcm1pbmcgKGV2ZXJ5IGhvdXIpXHJcbnNldEludGVydmFsKFxyXG4gIGFzeW5jICgpID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGF3YWl0IGNhY2hlLndhcm1DYWNoZSgpO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcihcIlNjaGVkdWxlZCBjYWNoZSB3YXJtaW5nIGZhaWxlZDpcIiwgZXJyb3IpO1xyXG4gICAgfVxyXG4gIH0sXHJcbiAgNjAgKiA2MCAqIDEwMDBcclxuKTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNhY2hlO1xyXG4iXSwibmFtZXMiOlsiUmVkaXMiLCJwcmlzbWEiLCJDYWNoZVNlcnZpY2UiLCJjb25zdHJ1Y3RvciIsInJlZGlzIiwidXJsIiwicHJvY2VzcyIsImVudiIsIlVQU1RBU0hfUkVESVNfUkVTVF9VUkwiLCJ0b2tlbiIsIlVQU1RBU0hfUkVESVNfUkVTVF9UT0tFTiIsIm1lbW9yeUNhY2hlIiwiTWFwIiwibWVtb3J5Q2FjaGVTaXplIiwibWF4TWVtb3J5Q2FjaGUiLCJwcmVmaXhlcyIsIklQTyIsIkdNUCIsIlNVQlNDUklQVElPTiIsIkRFTUFORCIsIkFMTE9UTUVOVCIsIlVTRVIiLCJTRVNTSU9OIiwiQVBJIiwiQU5BTFlUSUNTIiwiUkVBTFRJTUUiLCJTRUFSQ0giLCJTWVNURU0iLCJkZWZhdWx0VFRMIiwiSVBPX0xJU1QiLCJJUE9fREVUQUlMIiwiR01QX0RBVEEiLCJVU0VSX1NFU1NJT04iLCJBUElfUkVTUE9OU0UiLCJtZXRyaWNzIiwiaGl0cyIsIm1pc3NlcyIsImVycm9ycyIsIm9wZXJhdGlvbnMiLCJrZXkiLCJwcmVmaXgiLCJpZGVudGlmaWVyIiwiZ2V0IiwiZGF0YSIsIkpTT04iLCJwYXJzZSIsIm1lbW9yeURhdGEiLCJleHBpcmVzQXQiLCJEYXRlIiwibm93IiwidmFsdWUiLCJlcnJvciIsImNvbnNvbGUiLCJzZXQiLCJ0dGwiLCJzZXJpYWxpemVkIiwic3RyaW5naWZ5IiwicmVzdWx0Iiwic2V0ZXgiLCJzZXRNZW1vcnlDYWNoZSIsImhhcyIsImV2aWN0T2xkZXN0TWVtb3J5Q2FjaGUiLCJlbnRyaWVzIiwiQXJyYXkiLCJmcm9tIiwic29ydCIsImEiLCJiIiwidG9SZW1vdmUiLCJNYXRoIiwibWF4IiwiZmxvb3IiLCJsZW5ndGgiLCJpIiwiZGVsZXRlIiwiZGVsIiwiZXhpc3RzIiwicmVkaXNFeGlzdHMiLCJjYWNoZUlQT0xpc3QiLCJpcG9zIiwiZmlsdGVycyIsImZpbHRlcktleSIsIk9iamVjdCIsImtleXMiLCJtYXAiLCJrIiwiam9pbiIsImNhY2hlS2V5IiwiZ2V0Q2FjaGVkSVBPTGlzdCIsImNhY2hlSVBPRGV0YWlsIiwiaXBvSWQiLCJnZXRDYWNoZWRJUE9EZXRhaWwiLCJjYWNoZVJlYWxUaW1lRGF0YSIsInR5cGUiLCJlbnJpY2hlZERhdGEiLCJ0aW1lc3RhbXAiLCJjYWNoZWRfYXQiLCJ0b0lTT1N0cmluZyIsInB1Ymxpc2giLCJ3YXJuIiwibWVzc2FnZSIsImdldFJlYWxUaW1lRGF0YSIsImNhY2hlR01QRGF0YSIsImdtcERhdGEiLCJnZXRDYWNoZWRHTVBEYXRhIiwiY2FjaGVMaXZlR01QIiwiZ21wVmFsdWUiLCJnZXRDYWNoZWRMaXZlR01QIiwiY2FjaGVTdWJzY3JpcHRpb25EYXRhIiwic3ltYm9sIiwiZ2V0Q2FjaGVkU3Vic2NyaXB0aW9uRGF0YSIsImNhY2hlRGVtYW5kRGF0YSIsImdldENhY2hlZERlbWFuZERhdGEiLCJjYWNoZUFsbG90bWVudFN0YXR1cyIsInBhbk51bWJlciIsImFwcGxpY2F0aW9uTnVtYmVyIiwiZ2V0Q2FjaGVkQWxsb3RtZW50U3RhdHVzIiwiY2FjaGVVc2VyU2Vzc2lvbiIsInVzZXJJZCIsInNlc3Npb25EYXRhIiwiZ2V0Q2FjaGVkVXNlclNlc3Npb24iLCJjYWNoZUFQSVJlc3BvbnNlIiwiZW5kcG9pbnQiLCJwYXJhbXMiLCJwYXJhbUtleSIsImdldENhY2hlZEFQSVJlc3BvbnNlIiwiY2FjaGVTZWFyY2hSZXN1bHRzIiwicXVlcnkiLCJyZXN1bHRzIiwidG9Mb3dlckNhc2UiLCJnZXRDYWNoZWRTZWFyY2hSZXN1bHRzIiwiY2FjaGVBbmFseXRpY3MiLCJnZXRDYWNoZWRBbmFseXRpY3MiLCJtZ2V0IiwicHVzaCIsIm1zZXQiLCJrZXlWYWx1ZVBhaXJzIiwicGFpcnMiLCJpbnZhbGlkYXRlUGF0dGVybiIsInBhdHRlcm4iLCJyZWRpc1Jlc3VsdCIsImNsZWFyZWQiLCJpbmNsdWRlcyIsInJlcGxhY2UiLCJpbnZhbGlkYXRlSVBPQ2FjaGUiLCJwYXR0ZXJucyIsIlByb21pc2UiLCJhbGxTZXR0bGVkIiwiZXZlcnkiLCJzdGF0dXMiLCJnZXRDYWNoZVN0YXRzIiwicmVkaXNJbmZvIiwiaW5mbyIsImhpdFJhdGUiLCJ0b0ZpeGVkIiwiY29ubmVjdGVkIiwibWVtb3J5IiwibWF0Y2giLCJ0cmltIiwibG9jYWwiLCJ0b3RhbE9wZXJhdGlvbnMiLCJtZW1vcnlDYWNoZUxpbWl0Iiwid2FybUNhY2hlIiwibG9nIiwiYWN0aXZlSVBPcyIsImlQTyIsImZpbmRNYW55Iiwid2hlcmUiLCJpbiIsImlzQWN0aXZlIiwiaW5jbHVkZSIsImdtcCIsInRha2UiLCJvcmRlckJ5Iiwic3Vic2NyaXB0aW9uIiwiYW5hbHl0aWNzIiwiY2FjaGVQcm9taXNlcyIsImlwbyIsImlkIiwiYWxsIiwiZmlsdGVyIiwiaGVhbHRoQ2hlY2siLCJ0ZXN0S2V5IiwidGVzdFZhbHVlIiwidG9TdHJpbmciLCJyZXRyaWV2ZWQiLCJpc0hlYWx0aHkiLCJjbGVhbkV4cGlyZWRNZW1vcnlDYWNoZSIsInRvRGVsZXRlIiwicmVzZXRNZXRyaWNzIiwiZ2V0Q2FjaGVTaXplIiwidXRpbGl6YXRpb25QZXJjZW50IiwiY2FjaGUiLCJjYWNoZU1pZGRsZXdhcmUiLCJyZXEiLCJyZXMiLCJuZXh0IiwicGF0aCIsImNhY2hlZCIsImpzb24iLCJjYWNoZVRpbWVzdGFtcCIsIm9yaWdpbmFsSnNvbiIsImNhbGwiLCJpbnZhbGlkYXRlQ2FjaGVPblVwZGF0ZSIsIm9yaWdpbmFsU2VuZCIsInNlbmQiLCJjbGVhbnVwIiwic3RhdHVzQ29kZSIsInNldEludGVydmFsIiwiY2xlYW5lZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./src/lib/cache.js\n");

/***/ }),

/***/ "(rsc)/./src/lib/db.js":
/*!***********************!*\
  !*** ./src/lib/db.js ***!
  \***********************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   batchOperation: () => (/* binding */ batchOperation),\n/* harmony export */   checkDBHealth: () => (/* binding */ checkDBHealth),\n/* harmony export */   checkDatabaseSeeded: () => (/* binding */ checkDatabaseSeeded),\n/* harmony export */   cleanupExpiredCache: () => (/* binding */ cleanupExpiredCache),\n/* harmony export */   cleanupOldSyncLogs: () => (/* binding */ cleanupOldSyncLogs),\n/* harmony export */   createBackupSnapshot: () => (/* binding */ createBackupSnapshot),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   getConnectionInfo: () => (/* binding */ getConnectionInfo),\n/* harmony export */   getDatabaseMetrics: () => (/* binding */ getDatabaseMetrics),\n/* harmony export */   getDatabaseSize: () => (/* binding */ getDatabaseSize),\n/* harmony export */   getSlowQueries: () => (/* binding */ getSlowQueries),\n/* harmony export */   optimizeDatabase: () => (/* binding */ optimizeDatabase),\n/* harmony export */   performMaintenance: () => (/* binding */ performMaintenance),\n/* harmony export */   prisma: () => (/* binding */ prisma),\n/* harmony export */   resetTables: () => (/* binding */ resetTables),\n/* harmony export */   withTransaction: () => (/* binding */ withTransaction)\n/* harmony export */ });\n/* harmony import */ var _prisma_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @prisma/client */ \"@prisma/client\");\n\nconst globalForPrisma = globalThis;\nconst prisma = globalForPrisma.prisma || new _prisma_client__WEBPACK_IMPORTED_MODULE_0__.PrismaClient({\n    log: [\n        \"query\",\n        \"error\",\n        \"warn\"\n    ],\n    datasources: {\n        db: {\n            url: process.env.DATABASE_URL\n        }\n    },\n    // Connection pool configuration for better performance\n    __internal: {\n        engine: {\n            connectTimeout: 60000,\n            queryTimeout: 60000\n        }\n    }\n});\nif (true) {\n    globalForPrisma.prisma = prisma;\n}\n// Database health check\nasync function checkDBHealth() {\n    try {\n        await prisma.$queryRaw`SELECT 1 as health`;\n        return {\n            status: \"healthy\",\n            timestamp: new Date().toISOString(),\n            connection: \"active\",\n            version: await getDatabaseVersion()\n        };\n    } catch (error) {\n        return {\n            status: \"unhealthy\",\n            error: error.message,\n            timestamp: new Date().toISOString(),\n            connection: \"failed\"\n        };\n    }\n}\n// Get database version\nasync function getDatabaseVersion() {\n    try {\n        const result = await prisma.$queryRaw`SELECT VERSION() as version`;\n        return result[0]?.version || \"unknown\";\n    } catch (error) {\n        return \"unknown\";\n    }\n}\n// Database cleanup utility for expired cache entries\nasync function cleanupExpiredCache() {\n    try {\n        const result = await prisma.cacheEntry.deleteMany({\n            where: {\n                expiresAt: {\n                    lt: new Date()\n                }\n            }\n        });\n        console.log(`ðŸ§¹ Cleaned up ${result.count} expired cache entries`);\n        return result.count;\n    } catch (error) {\n        console.error(\"Cache cleanup failed:\", error);\n        return 0;\n    }\n}\n// Cleanup old sync logs (keep only last 30 days)\nasync function cleanupOldSyncLogs() {\n    try {\n        const thirtyDaysAgo = new Date();\n        thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);\n        const result = await prisma.syncLog.deleteMany({\n            where: {\n                createdAt: {\n                    lt: thirtyDaysAgo\n                }\n            }\n        });\n        console.log(`ðŸ§¹ Cleaned up ${result.count} old sync logs`);\n        return result.count;\n    } catch (error) {\n        console.error(\"Sync logs cleanup failed:\", error);\n        return 0;\n    }\n}\n// Transaction helper for complex operations\nasync function withTransaction(callback) {\n    return await prisma.$transaction(callback, {\n        maxWait: 5000,\n        timeout: 10000,\n        isolationLevel: \"ReadCommitted\"\n    });\n}\n// Batch operations helper\nasync function batchOperation(operation, data, batchSize = 100) {\n    const results = [];\n    const errors = [];\n    for(let i = 0; i < data.length; i += batchSize){\n        const batch = data.slice(i, i + batchSize);\n        try {\n            const batchResult = await operation(batch);\n            results.push(batchResult);\n        } catch (error) {\n            errors.push({\n                batchIndex: Math.floor(i / batchSize),\n                error: error.message,\n                data: batch\n            });\n        }\n    }\n    return {\n        results,\n        errors\n    };\n}\n// Connection pool management\nasync function getConnectionInfo() {\n    try {\n        const result = await prisma.$queryRaw`\r\n      SELECT \r\n        count(*) as total_connections,\r\n        count(*) FILTER (WHERE state = 'active') as active_connections,\r\n        count(*) FILTER (WHERE state = 'idle') as idle_connections\r\n      FROM pg_stat_activity \r\n      WHERE datname = current_database()\r\n    `;\n        return result[0];\n    } catch (error) {\n        console.error(\"Failed to get connection info:\", error);\n        return null;\n    }\n}\n// Database performance metrics\nasync function getDatabaseMetrics() {\n    try {\n        const [connectionInfo, tableStats, indexStats] = await Promise.all([\n            getConnectionInfo(),\n            getTableStats(),\n            getIndexStats()\n        ]);\n        return {\n            connections: connectionInfo,\n            tables: tableStats,\n            indexes: indexStats,\n            timestamp: new Date().toISOString()\n        };\n    } catch (error) {\n        console.error(\"Failed to get database metrics:\", error);\n        return {\n            error: error.message\n        };\n    }\n}\n// Get table statistics\nasync function getTableStats() {\n    try {\n        const result = await prisma.$queryRaw`\r\n      SELECT \r\n        schemaname,\r\n        tablename,\r\n        n_tup_ins as inserts,\r\n        n_tup_upd as updates,\r\n        n_tup_del as deletes,\r\n        n_live_tup as live_tuples,\r\n        n_dead_tup as dead_tuples\r\n      FROM pg_stat_user_tables\r\n      ORDER BY n_live_tup DESC\r\n      LIMIT 10\r\n    `;\n        return result;\n    } catch (error) {\n        return [];\n    }\n}\n// Get index statistics\nasync function getIndexStats() {\n    try {\n        const result = await prisma.$queryRaw`\r\n      SELECT \r\n        schemaname,\r\n        tablename,\r\n        indexname,\r\n        idx_tup_read as tuples_read,\r\n        idx_tup_fetch as tuples_fetched\r\n      FROM pg_stat_user_indexes\r\n      WHERE idx_tup_read > 0\r\n      ORDER BY idx_tup_read DESC\r\n      LIMIT 10\r\n    `;\n        return result;\n    } catch (error) {\n        return [];\n    }\n}\n// Backup and maintenance functions\nasync function createBackupSnapshot() {\n    try {\n        const timestamp = new Date().toISOString().replace(/[:.]/g, \"-\");\n        console.log(`ðŸ“¦ Creating backup snapshot at ${timestamp}`);\n        // This would integrate with your backup solution\n        // For now, we'll just log the operation\n        console.log(\"âœ… Backup snapshot created successfully\");\n        return {\n            success: true,\n            timestamp,\n            message: \"Backup snapshot created\"\n        };\n    } catch (error) {\n        console.error(\"Backup snapshot failed:\", error);\n        return {\n            success: false,\n            error: error.message\n        };\n    }\n}\n// Database optimization\nasync function optimizeDatabase() {\n    try {\n        console.log(\"\\uD83D\\uDD27 Starting database optimization...\");\n        // Analyze tables for better query planning\n        await prisma.$executeRaw`ANALYZE`;\n        // Vacuum to reclaim space (for PostgreSQL)\n        await prisma.$executeRaw`VACUUM (ANALYZE, VERBOSE)`;\n        console.log(\"âœ… Database optimization completed\");\n        return {\n            success: true,\n            message: \"Database optimization completed\",\n            timestamp: new Date().toISOString()\n        };\n    } catch (error) {\n        console.error(\"Database optimization failed:\", error);\n        return {\n            success: false,\n            error: error.message\n        };\n    }\n}\n// Seed check - verify if database has initial data\nasync function checkDatabaseSeeded() {\n    try {\n        const ipoCount = await prisma.iPO.count();\n        const userCount = await prisma.user.count();\n        return {\n            isSeeded: ipoCount > 0 && userCount > 0,\n            counts: {\n                ipos: ipoCount,\n                users: userCount\n            }\n        };\n    } catch (error) {\n        return {\n            isSeeded: false,\n            error: error.message\n        };\n    }\n}\n// Utility function to reset specific tables (for development)\nasync function resetTables(tableNames = []) {\n    if (false) {}\n    try {\n        console.log(`ðŸ—‘ï¸  Resetting tables: ${tableNames.join(\", \")}`);\n        for (const tableName of tableNames){\n            switch(tableName.toLowerCase()){\n                case \"gmp\":\n                    await prisma.gMP.deleteMany();\n                    break;\n                case \"subscription\":\n                    await prisma.subscriptionData.deleteMany();\n                    break;\n                case \"demand\":\n                    await prisma.marketDemand.deleteMany();\n                    break;\n                case \"allotments\":\n                    await prisma.allotment.deleteMany();\n                    break;\n                case \"analytics\":\n                    await prisma.iPOAnalytics.deleteMany();\n                    break;\n                case \"synclogs\":\n                    await prisma.syncLog.deleteMany();\n                    break;\n                case \"cache\":\n                    await prisma.cacheEntry.deleteMany();\n                    break;\n                default:\n                    console.warn(`Unknown table: ${tableName}`);\n            }\n        }\n        console.log(\"âœ… Tables reset successfully\");\n        return {\n            success: true\n        };\n    } catch (error) {\n        console.error(\"Table reset failed:\", error);\n        return {\n            success: false,\n            error: error.message\n        };\n    }\n}\n// Get database size and usage information\nasync function getDatabaseSize() {\n    try {\n        const result = await prisma.$queryRaw`\r\n      SELECT \r\n        pg_size_pretty(pg_database_size(current_database())) as database_size,\r\n        pg_size_pretty(pg_total_relation_size('ipos')) as ipos_table_size,\r\n        pg_size_pretty(pg_total_relation_size('gmp')) as gmp_table_size,\r\n        pg_size_pretty(pg_total_relation_size('subscription_data')) as subscription_table_size\r\n    `;\n        return result[0];\n    } catch (error) {\n        console.error(\"Failed to get database size:\", error);\n        return null;\n    }\n}\n// Monitor slow queries (if available)\nasync function getSlowQueries(limit = 10) {\n    try {\n        // This requires pg_stat_statements extension\n        const result = await prisma.$queryRaw`\r\n      SELECT \r\n        query,\r\n        calls,\r\n        total_time,\r\n        mean_time,\r\n        rows\r\n      FROM pg_stat_statements\r\n      ORDER BY mean_time DESC\r\n      LIMIT ${limit}\r\n    `;\n        return result;\n    } catch (error) {\n        // Extension might not be available\n        return [];\n    }\n}\n// Periodic maintenance function\nasync function performMaintenance() {\n    try {\n        console.log(\"\\uD83D\\uDD27 Starting periodic maintenance...\");\n        const results = await Promise.allSettled([\n            cleanupExpiredCache(),\n            cleanupOldSyncLogs(),\n            optimizeDatabase()\n        ]);\n        const summary = {\n            timestamp: new Date().toISOString(),\n            operations: [\n                {\n                    name: \"cleanupExpiredCache\",\n                    status: results[0].status,\n                    result: results[0].value || results[0].reason\n                },\n                {\n                    name: \"cleanupOldSyncLogs\",\n                    status: results[1].status,\n                    result: results[1].value || results[1].reason\n                },\n                {\n                    name: \"optimizeDatabase\",\n                    status: results[2].status,\n                    result: results[2].value || results[2].reason\n                }\n            ]\n        };\n        console.log(\"âœ… Periodic maintenance completed:\", summary);\n        return summary;\n    } catch (error) {\n        console.error(\"Periodic maintenance failed:\", error);\n        return {\n            error: error.message,\n            timestamp: new Date().toISOString()\n        };\n    }\n}\n// Schedule periodic maintenance (runs every 6 hours)\nif ( true && process.env.ENABLE_MAINTENANCE !== \"false\") {\n    setInterval(async ()=>{\n        try {\n            await performMaintenance();\n        } catch (error) {\n            console.error(\"Scheduled maintenance failed:\", error);\n        }\n    }, 6 * 60 * 60 * 1000); // 6 hours\n}\n// Graceful shutdown handler\nasync function gracefulShutdown() {\n    console.log(\"\\uD83D\\uDD0C Closing database connections...\");\n    try {\n        await prisma.$disconnect();\n        console.log(\"âœ… Database connections closed successfully\");\n    } catch (error) {\n        console.error(\"âŒ Error closing database connections:\", error);\n    }\n}\n// Handle process shutdown\nprocess.on(\"SIGINT\", gracefulShutdown);\nprocess.on(\"SIGTERM\", gracefulShutdown);\nprocess.on(\"SIGQUIT\", gracefulShutdown);\n// Handle uncaught exceptions\nprocess.on(\"uncaughtException\", async (error)=>{\n    console.error(\"Uncaught Exception:\", error);\n    await gracefulShutdown();\n    process.exit(1);\n});\nprocess.on(\"unhandledRejection\", async (reason, promise)=>{\n    console.error(\"Unhandled Rejection at:\", promise, \"reason:\", reason);\n    await gracefulShutdown();\n    process.exit(1);\n});\n// Default export\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (prisma);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUF5Q0E7SUFDekQ7QUFDRjtBQUVBLDBCQUEwQjtBQUMxQmhCLFFBQVEwRyxFQUFFLENBQUMsVUFBVUY7QUFDckJ4RyxRQUFRMEcsRUFBRSxDQUFDLFdBQVdGO0FBQ3RCeEcsUUFBUTBHLEVBQUUsQ0FBQyxXQUFXRjtBQUV0Qiw2QkFBNkI7QUFDN0J4RyxRQUFRMEcsRUFBRSxDQUFDLHFCQUFxQixPQUFPMUY7SUFDckNTLFFBQVFULEtBQUssQ0FBQyx1QkFBdUJBO0lBQ3JDLE1BQU13RjtJQUNOeEcsUUFBUTJHLElBQUksQ0FBQztBQUNmO0FBRUEzRyxRQUFRMEcsRUFBRSxDQUFDLHNCQUFzQixPQUFPTCxRQUFRTztJQUM5Q25GLFFBQVFULEtBQUssQ0FBQywyQkFBMkI0RixTQUFTLFdBQVdQO0lBQzdELE1BQU1HO0lBQ054RyxRQUFRMkcsSUFBSSxDQUFDO0FBQ2Y7QUFFQSxpQkFBaUI7QUFDakIsaUVBQWVoSCxNQUFNQSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaXBvLXRyYWNrZXIvLi9zcmMvbGliL2RiLmpzPzdmOWEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUHJpc21hQ2xpZW50IH0gZnJvbSAnQHByaXNtYS9jbGllbnQnO1xyXG5cclxuY29uc3QgZ2xvYmFsRm9yUHJpc21hID0gZ2xvYmFsVGhpcztcclxuXHJcbmV4cG9ydCBjb25zdCBwcmlzbWEgPVxyXG4gIGdsb2JhbEZvclByaXNtYS5wcmlzbWEgfHxcclxuICBuZXcgUHJpc21hQ2xpZW50KHtcclxuICAgIGxvZzogWydxdWVyeScsICdlcnJvcicsICd3YXJuJ10sXHJcbiAgICBkYXRhc291cmNlczoge1xyXG4gICAgICBkYjoge1xyXG4gICAgICAgIHVybDogcHJvY2Vzcy5lbnYuREFUQUJBU0VfVVJMLFxyXG4gICAgICB9LFxyXG4gICAgfSxcclxuICAgIC8vIENvbm5lY3Rpb24gcG9vbCBjb25maWd1cmF0aW9uIGZvciBiZXR0ZXIgcGVyZm9ybWFuY2VcclxuICAgIF9faW50ZXJuYWw6IHtcclxuICAgICAgZW5naW5lOiB7XHJcbiAgICAgICAgY29ubmVjdFRpbWVvdXQ6IDYwMDAwLFxyXG4gICAgICAgIHF1ZXJ5VGltZW91dDogNjAwMDAsXHJcbiAgICAgIH0sXHJcbiAgICB9LFxyXG4gIH0pO1xyXG5cclxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcclxuICBnbG9iYWxGb3JQcmlzbWEucHJpc21hID0gcHJpc21hO1xyXG59XHJcblxyXG4vLyBEYXRhYmFzZSBoZWFsdGggY2hlY2tcclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNoZWNrREJIZWFsdGgoKSB7XHJcbiAgdHJ5IHtcclxuICAgIGF3YWl0IHByaXNtYS4kcXVlcnlSYXdgU0VMRUNUIDEgYXMgaGVhbHRoYDtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHN0YXR1czogJ2hlYWx0aHknLFxyXG4gICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcclxuICAgICAgY29ubmVjdGlvbjogJ2FjdGl2ZScsXHJcbiAgICAgIHZlcnNpb246IGF3YWl0IGdldERhdGFiYXNlVmVyc2lvbigpLFxyXG4gICAgfTtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgc3RhdHVzOiAndW5oZWFsdGh5JyxcclxuICAgICAgZXJyb3I6IGVycm9yLm1lc3NhZ2UsXHJcbiAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxyXG4gICAgICBjb25uZWN0aW9uOiAnZmFpbGVkJyxcclxuICAgIH07XHJcbiAgfVxyXG59XHJcblxyXG4vLyBHZXQgZGF0YWJhc2UgdmVyc2lvblxyXG5hc3luYyBmdW5jdGlvbiBnZXREYXRhYmFzZVZlcnNpb24oKSB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHByaXNtYS4kcXVlcnlSYXdgU0VMRUNUIFZFUlNJT04oKSBhcyB2ZXJzaW9uYDtcclxuICAgIHJldHVybiByZXN1bHRbMF0/LnZlcnNpb24gfHwgJ3Vua25vd24nO1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICByZXR1cm4gJ3Vua25vd24nO1xyXG4gIH1cclxufVxyXG5cclxuLy8gRGF0YWJhc2UgY2xlYW51cCB1dGlsaXR5IGZvciBleHBpcmVkIGNhY2hlIGVudHJpZXNcclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNsZWFudXBFeHBpcmVkQ2FjaGUoKSB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHByaXNtYS5jYWNoZUVudHJ5LmRlbGV0ZU1hbnkoe1xyXG4gICAgICB3aGVyZToge1xyXG4gICAgICAgIGV4cGlyZXNBdDoge1xyXG4gICAgICAgICAgbHQ6IG5ldyBEYXRlKCksXHJcbiAgICAgICAgfSxcclxuICAgICAgfSxcclxuICAgIH0pO1xyXG4gICAgY29uc29sZS5sb2coYPCfp7kgQ2xlYW5lZCB1cCAke3Jlc3VsdC5jb3VudH0gZXhwaXJlZCBjYWNoZSBlbnRyaWVzYCk7XHJcbiAgICByZXR1cm4gcmVzdWx0LmNvdW50O1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdDYWNoZSBjbGVhbnVwIGZhaWxlZDonLCBlcnJvcik7XHJcbiAgICByZXR1cm4gMDtcclxuICB9XHJcbn1cclxuXHJcbi8vIENsZWFudXAgb2xkIHN5bmMgbG9ncyAoa2VlcCBvbmx5IGxhc3QgMzAgZGF5cylcclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNsZWFudXBPbGRTeW5jTG9ncygpIHtcclxuICB0cnkge1xyXG4gICAgY29uc3QgdGhpcnR5RGF5c0FnbyA9IG5ldyBEYXRlKCk7XHJcbiAgICB0aGlydHlEYXlzQWdvLnNldERhdGUodGhpcnR5RGF5c0Fnby5nZXREYXRlKCkgLSAzMCk7XHJcblxyXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcHJpc21hLnN5bmNMb2cuZGVsZXRlTWFueSh7XHJcbiAgICAgIHdoZXJlOiB7XHJcbiAgICAgICAgY3JlYXRlZEF0OiB7XHJcbiAgICAgICAgICBsdDogdGhpcnR5RGF5c0FnbyxcclxuICAgICAgICB9LFxyXG4gICAgICB9LFxyXG4gICAgfSk7XHJcbiAgICBjb25zb2xlLmxvZyhg8J+nuSBDbGVhbmVkIHVwICR7cmVzdWx0LmNvdW50fSBvbGQgc3luYyBsb2dzYCk7XHJcbiAgICByZXR1cm4gcmVzdWx0LmNvdW50O1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdTeW5jIGxvZ3MgY2xlYW51cCBmYWlsZWQ6JywgZXJyb3IpO1xyXG4gICAgcmV0dXJuIDA7XHJcbiAgfVxyXG59XHJcblxyXG4vLyBUcmFuc2FjdGlvbiBoZWxwZXIgZm9yIGNvbXBsZXggb3BlcmF0aW9uc1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gd2l0aFRyYW5zYWN0aW9uKGNhbGxiYWNrKSB7XHJcbiAgcmV0dXJuIGF3YWl0IHByaXNtYS4kdHJhbnNhY3Rpb24oY2FsbGJhY2ssIHtcclxuICAgIG1heFdhaXQ6IDUwMDAsIC8vIDUgc2Vjb25kc1xyXG4gICAgdGltZW91dDogMTAwMDAsIC8vIDEwIHNlY29uZHNcclxuICAgIGlzb2xhdGlvbkxldmVsOiAnUmVhZENvbW1pdHRlZCcsXHJcbiAgfSk7XHJcbn1cclxuXHJcbi8vIEJhdGNoIG9wZXJhdGlvbnMgaGVscGVyXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBiYXRjaE9wZXJhdGlvbihvcGVyYXRpb24sIGRhdGEsIGJhdGNoU2l6ZSA9IDEwMCkge1xyXG4gIGNvbnN0IHJlc3VsdHMgPSBbXTtcclxuICBjb25zdCBlcnJvcnMgPSBbXTtcclxuXHJcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSArPSBiYXRjaFNpemUpIHtcclxuICAgIGNvbnN0IGJhdGNoID0gZGF0YS5zbGljZShpLCBpICsgYmF0Y2hTaXplKTtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IGJhdGNoUmVzdWx0ID0gYXdhaXQgb3BlcmF0aW9uKGJhdGNoKTtcclxuICAgICAgcmVzdWx0cy5wdXNoKGJhdGNoUmVzdWx0KTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGVycm9ycy5wdXNoKHtcclxuICAgICAgICBiYXRjaEluZGV4OiBNYXRoLmZsb29yKGkgLyBiYXRjaFNpemUpLFxyXG4gICAgICAgIGVycm9yOiBlcnJvci5tZXNzYWdlLFxyXG4gICAgICAgIGRhdGE6IGJhdGNoLFxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiB7IHJlc3VsdHMsIGVycm9ycyB9O1xyXG59XHJcblxyXG4vLyBDb25uZWN0aW9uIHBvb2wgbWFuYWdlbWVudFxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0Q29ubmVjdGlvbkluZm8oKSB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHByaXNtYS4kcXVlcnlSYXdgXHJcbiAgICAgIFNFTEVDVCBcclxuICAgICAgICBjb3VudCgqKSBhcyB0b3RhbF9jb25uZWN0aW9ucyxcclxuICAgICAgICBjb3VudCgqKSBGSUxURVIgKFdIRVJFIHN0YXRlID0gJ2FjdGl2ZScpIGFzIGFjdGl2ZV9jb25uZWN0aW9ucyxcclxuICAgICAgICBjb3VudCgqKSBGSUxURVIgKFdIRVJFIHN0YXRlID0gJ2lkbGUnKSBhcyBpZGxlX2Nvbm5lY3Rpb25zXHJcbiAgICAgIEZST00gcGdfc3RhdF9hY3Rpdml0eSBcclxuICAgICAgV0hFUkUgZGF0bmFtZSA9IGN1cnJlbnRfZGF0YWJhc2UoKVxyXG4gICAgYDtcclxuICAgIHJldHVybiByZXN1bHRbMF07XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBnZXQgY29ubmVjdGlvbiBpbmZvOicsIGVycm9yKTtcclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxufVxyXG5cclxuLy8gRGF0YWJhc2UgcGVyZm9ybWFuY2UgbWV0cmljc1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0RGF0YWJhc2VNZXRyaWNzKCkge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCBbY29ubmVjdGlvbkluZm8sIHRhYmxlU3RhdHMsIGluZGV4U3RhdHNdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xyXG4gICAgICBnZXRDb25uZWN0aW9uSW5mbygpLFxyXG4gICAgICBnZXRUYWJsZVN0YXRzKCksXHJcbiAgICAgIGdldEluZGV4U3RhdHMoKSxcclxuICAgIF0pO1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgIGNvbm5lY3Rpb25zOiBjb25uZWN0aW9uSW5mbyxcclxuICAgICAgdGFibGVzOiB0YWJsZVN0YXRzLFxyXG4gICAgICBpbmRleGVzOiBpbmRleFN0YXRzLFxyXG4gICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcclxuICAgIH07XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBnZXQgZGF0YWJhc2UgbWV0cmljczonLCBlcnJvcik7XHJcbiAgICByZXR1cm4geyBlcnJvcjogZXJyb3IubWVzc2FnZSB9O1xyXG4gIH1cclxufVxyXG5cclxuLy8gR2V0IHRhYmxlIHN0YXRpc3RpY3NcclxuYXN5bmMgZnVuY3Rpb24gZ2V0VGFibGVTdGF0cygpIHtcclxuICB0cnkge1xyXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcHJpc21hLiRxdWVyeVJhd2BcclxuICAgICAgU0VMRUNUIFxyXG4gICAgICAgIHNjaGVtYW5hbWUsXHJcbiAgICAgICAgdGFibGVuYW1lLFxyXG4gICAgICAgIG5fdHVwX2lucyBhcyBpbnNlcnRzLFxyXG4gICAgICAgIG5fdHVwX3VwZCBhcyB1cGRhdGVzLFxyXG4gICAgICAgIG5fdHVwX2RlbCBhcyBkZWxldGVzLFxyXG4gICAgICAgIG5fbGl2ZV90dXAgYXMgbGl2ZV90dXBsZXMsXHJcbiAgICAgICAgbl9kZWFkX3R1cCBhcyBkZWFkX3R1cGxlc1xyXG4gICAgICBGUk9NIHBnX3N0YXRfdXNlcl90YWJsZXNcclxuICAgICAgT1JERVIgQlkgbl9saXZlX3R1cCBERVNDXHJcbiAgICAgIExJTUlUIDEwXHJcbiAgICBgO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgcmV0dXJuIFtdO1xyXG4gIH1cclxufVxyXG5cclxuLy8gR2V0IGluZGV4IHN0YXRpc3RpY3NcclxuYXN5bmMgZnVuY3Rpb24gZ2V0SW5kZXhTdGF0cygpIHtcclxuICB0cnkge1xyXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcHJpc21hLiRxdWVyeVJhd2BcclxuICAgICAgU0VMRUNUIFxyXG4gICAgICAgIHNjaGVtYW5hbWUsXHJcbiAgICAgICAgdGFibGVuYW1lLFxyXG4gICAgICAgIGluZGV4bmFtZSxcclxuICAgICAgICBpZHhfdHVwX3JlYWQgYXMgdHVwbGVzX3JlYWQsXHJcbiAgICAgICAgaWR4X3R1cF9mZXRjaCBhcyB0dXBsZXNfZmV0Y2hlZFxyXG4gICAgICBGUk9NIHBnX3N0YXRfdXNlcl9pbmRleGVzXHJcbiAgICAgIFdIRVJFIGlkeF90dXBfcmVhZCA+IDBcclxuICAgICAgT1JERVIgQlkgaWR4X3R1cF9yZWFkIERFU0NcclxuICAgICAgTElNSVQgMTBcclxuICAgIGA7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICByZXR1cm4gW107XHJcbiAgfVxyXG59XHJcblxyXG4vLyBCYWNrdXAgYW5kIG1haW50ZW5hbmNlIGZ1bmN0aW9uc1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY3JlYXRlQmFja3VwU25hcHNob3QoKSB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IHRpbWVzdGFtcCA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKS5yZXBsYWNlKC9bOi5dL2csICctJyk7XHJcbiAgICBjb25zb2xlLmxvZyhg8J+TpiBDcmVhdGluZyBiYWNrdXAgc25hcHNob3QgYXQgJHt0aW1lc3RhbXB9YCk7XHJcblxyXG4gICAgLy8gVGhpcyB3b3VsZCBpbnRlZ3JhdGUgd2l0aCB5b3VyIGJhY2t1cCBzb2x1dGlvblxyXG4gICAgLy8gRm9yIG5vdywgd2UnbGwganVzdCBsb2cgdGhlIG9wZXJhdGlvblxyXG4gICAgY29uc29sZS5sb2coJ+KchSBCYWNrdXAgc25hcHNob3QgY3JlYXRlZCBzdWNjZXNzZnVsbHknKTtcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBzdWNjZXNzOiB0cnVlLFxyXG4gICAgICB0aW1lc3RhbXAsXHJcbiAgICAgIG1lc3NhZ2U6ICdCYWNrdXAgc25hcHNob3QgY3JlYXRlZCcsXHJcbiAgICB9O1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdCYWNrdXAgc25hcHNob3QgZmFpbGVkOicsIGVycm9yKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxyXG4gICAgICBlcnJvcjogZXJyb3IubWVzc2FnZSxcclxuICAgIH07XHJcbiAgfVxyXG59XHJcblxyXG4vLyBEYXRhYmFzZSBvcHRpbWl6YXRpb25cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIG9wdGltaXplRGF0YWJhc2UoKSB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnNvbGUubG9nKCfwn5SnIFN0YXJ0aW5nIGRhdGFiYXNlIG9wdGltaXphdGlvbi4uLicpO1xyXG5cclxuICAgIC8vIEFuYWx5emUgdGFibGVzIGZvciBiZXR0ZXIgcXVlcnkgcGxhbm5pbmdcclxuICAgIGF3YWl0IHByaXNtYS4kZXhlY3V0ZVJhd2BBTkFMWVpFYDtcclxuXHJcbiAgICAvLyBWYWN1dW0gdG8gcmVjbGFpbSBzcGFjZSAoZm9yIFBvc3RncmVTUUwpXHJcbiAgICBhd2FpdCBwcmlzbWEuJGV4ZWN1dGVSYXdgVkFDVVVNIChBTkFMWVpFLCBWRVJCT1NFKWA7XHJcblxyXG4gICAgY29uc29sZS5sb2coJ+KchSBEYXRhYmFzZSBvcHRpbWl6YXRpb24gY29tcGxldGVkJyk7XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgc3VjY2VzczogdHJ1ZSxcclxuICAgICAgbWVzc2FnZTogJ0RhdGFiYXNlIG9wdGltaXphdGlvbiBjb21wbGV0ZWQnLFxyXG4gICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcclxuICAgIH07XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0RhdGFiYXNlIG9wdGltaXphdGlvbiBmYWlsZWQ6JywgZXJyb3IpO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgc3VjY2VzczogZmFsc2UsXHJcbiAgICAgIGVycm9yOiBlcnJvci5tZXNzYWdlLFxyXG4gICAgfTtcclxuICB9XHJcbn1cclxuXHJcbi8vIFNlZWQgY2hlY2sgLSB2ZXJpZnkgaWYgZGF0YWJhc2UgaGFzIGluaXRpYWwgZGF0YVxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY2hlY2tEYXRhYmFzZVNlZWRlZCgpIHtcclxuICB0cnkge1xyXG4gICAgY29uc3QgaXBvQ291bnQgPSBhd2FpdCBwcmlzbWEuaVBPLmNvdW50KCk7XHJcbiAgICBjb25zdCB1c2VyQ291bnQgPSBhd2FpdCBwcmlzbWEudXNlci5jb3VudCgpO1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgIGlzU2VlZGVkOiBpcG9Db3VudCA+IDAgJiYgdXNlckNvdW50ID4gMCxcclxuICAgICAgY291bnRzOiB7XHJcbiAgICAgICAgaXBvczogaXBvQ291bnQsXHJcbiAgICAgICAgdXNlcnM6IHVzZXJDb3VudCxcclxuICAgICAgfSxcclxuICAgIH07XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGlzU2VlZGVkOiBmYWxzZSxcclxuICAgICAgZXJyb3I6IGVycm9yLm1lc3NhZ2UsXHJcbiAgICB9O1xyXG4gIH1cclxufVxyXG5cclxuLy8gVXRpbGl0eSBmdW5jdGlvbiB0byByZXNldCBzcGVjaWZpYyB0YWJsZXMgKGZvciBkZXZlbG9wbWVudClcclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJlc2V0VGFibGVzKHRhYmxlTmFtZXMgPSBbXSkge1xyXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCByZXNldCB0YWJsZXMgaW4gcHJvZHVjdGlvbiBlbnZpcm9ubWVudCcpO1xyXG4gIH1cclxuXHJcbiAgdHJ5IHtcclxuICAgIGNvbnNvbGUubG9nKGDwn5eR77iPICBSZXNldHRpbmcgdGFibGVzOiAke3RhYmxlTmFtZXMuam9pbignLCAnKX1gKTtcclxuXHJcbiAgICBmb3IgKGNvbnN0IHRhYmxlTmFtZSBvZiB0YWJsZU5hbWVzKSB7XHJcbiAgICAgIHN3aXRjaCAodGFibGVOYW1lLnRvTG93ZXJDYXNlKCkpIHtcclxuICAgICAgICBjYXNlICdnbXAnOlxyXG4gICAgICAgICAgYXdhaXQgcHJpc21hLmdNUC5kZWxldGVNYW55KCk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlICdzdWJzY3JpcHRpb24nOlxyXG4gICAgICAgICAgYXdhaXQgcHJpc21hLnN1YnNjcmlwdGlvbkRhdGEuZGVsZXRlTWFueSgpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAnZGVtYW5kJzpcclxuICAgICAgICAgIGF3YWl0IHByaXNtYS5tYXJrZXREZW1hbmQuZGVsZXRlTWFueSgpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAnYWxsb3RtZW50cyc6XHJcbiAgICAgICAgICBhd2FpdCBwcmlzbWEuYWxsb3RtZW50LmRlbGV0ZU1hbnkoKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgJ2FuYWx5dGljcyc6XHJcbiAgICAgICAgICBhd2FpdCBwcmlzbWEuaVBPQW5hbHl0aWNzLmRlbGV0ZU1hbnkoKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgJ3N5bmNsb2dzJzpcclxuICAgICAgICAgIGF3YWl0IHByaXNtYS5zeW5jTG9nLmRlbGV0ZU1hbnkoKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgJ2NhY2hlJzpcclxuICAgICAgICAgIGF3YWl0IHByaXNtYS5jYWNoZUVudHJ5LmRlbGV0ZU1hbnkoKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICBjb25zb2xlLndhcm4oYFVua25vd24gdGFibGU6ICR7dGFibGVOYW1lfWApO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgY29uc29sZS5sb2coJ+KchSBUYWJsZXMgcmVzZXQgc3VjY2Vzc2Z1bGx5Jyk7XHJcbiAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlIH07XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ1RhYmxlIHJlc2V0IGZhaWxlZDonLCBlcnJvcik7XHJcbiAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IGVycm9yLm1lc3NhZ2UgfTtcclxuICB9XHJcbn1cclxuXHJcbi8vIEdldCBkYXRhYmFzZSBzaXplIGFuZCB1c2FnZSBpbmZvcm1hdGlvblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0RGF0YWJhc2VTaXplKCkge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBwcmlzbWEuJHF1ZXJ5UmF3YFxyXG4gICAgICBTRUxFQ1QgXHJcbiAgICAgICAgcGdfc2l6ZV9wcmV0dHkocGdfZGF0YWJhc2Vfc2l6ZShjdXJyZW50X2RhdGFiYXNlKCkpKSBhcyBkYXRhYmFzZV9zaXplLFxyXG4gICAgICAgIHBnX3NpemVfcHJldHR5KHBnX3RvdGFsX3JlbGF0aW9uX3NpemUoJ2lwb3MnKSkgYXMgaXBvc190YWJsZV9zaXplLFxyXG4gICAgICAgIHBnX3NpemVfcHJldHR5KHBnX3RvdGFsX3JlbGF0aW9uX3NpemUoJ2dtcCcpKSBhcyBnbXBfdGFibGVfc2l6ZSxcclxuICAgICAgICBwZ19zaXplX3ByZXR0eShwZ190b3RhbF9yZWxhdGlvbl9zaXplKCdzdWJzY3JpcHRpb25fZGF0YScpKSBhcyBzdWJzY3JpcHRpb25fdGFibGVfc2l6ZVxyXG4gICAgYDtcclxuXHJcbiAgICByZXR1cm4gcmVzdWx0WzBdO1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gZ2V0IGRhdGFiYXNlIHNpemU6JywgZXJyb3IpO1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG59XHJcblxyXG4vLyBNb25pdG9yIHNsb3cgcXVlcmllcyAoaWYgYXZhaWxhYmxlKVxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0U2xvd1F1ZXJpZXMobGltaXQgPSAxMCkge1xyXG4gIHRyeSB7XHJcbiAgICAvLyBUaGlzIHJlcXVpcmVzIHBnX3N0YXRfc3RhdGVtZW50cyBleHRlbnNpb25cclxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHByaXNtYS4kcXVlcnlSYXdgXHJcbiAgICAgIFNFTEVDVCBcclxuICAgICAgICBxdWVyeSxcclxuICAgICAgICBjYWxscyxcclxuICAgICAgICB0b3RhbF90aW1lLFxyXG4gICAgICAgIG1lYW5fdGltZSxcclxuICAgICAgICByb3dzXHJcbiAgICAgIEZST00gcGdfc3RhdF9zdGF0ZW1lbnRzXHJcbiAgICAgIE9SREVSIEJZIG1lYW5fdGltZSBERVNDXHJcbiAgICAgIExJTUlUICR7bGltaXR9XHJcbiAgICBgO1xyXG5cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIC8vIEV4dGVuc2lvbiBtaWdodCBub3QgYmUgYXZhaWxhYmxlXHJcbiAgICByZXR1cm4gW107XHJcbiAgfVxyXG59XHJcblxyXG4vLyBQZXJpb2RpYyBtYWludGVuYW5jZSBmdW5jdGlvblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcGVyZm9ybU1haW50ZW5hbmNlKCkge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zb2xlLmxvZygn8J+UpyBTdGFydGluZyBwZXJpb2RpYyBtYWludGVuYW5jZS4uLicpO1xyXG5cclxuICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBQcm9taXNlLmFsbFNldHRsZWQoW1xyXG4gICAgICBjbGVhbnVwRXhwaXJlZENhY2hlKCksXHJcbiAgICAgIGNsZWFudXBPbGRTeW5jTG9ncygpLFxyXG4gICAgICBvcHRpbWl6ZURhdGFiYXNlKCksXHJcbiAgICBdKTtcclxuXHJcbiAgICBjb25zdCBzdW1tYXJ5ID0ge1xyXG4gICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcclxuICAgICAgb3BlcmF0aW9uczogW1xyXG4gICAgICAgIHtcclxuICAgICAgICAgIG5hbWU6ICdjbGVhbnVwRXhwaXJlZENhY2hlJyxcclxuICAgICAgICAgIHN0YXR1czogcmVzdWx0c1swXS5zdGF0dXMsXHJcbiAgICAgICAgICByZXN1bHQ6IHJlc3VsdHNbMF0udmFsdWUgfHwgcmVzdWx0c1swXS5yZWFzb24sXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBuYW1lOiAnY2xlYW51cE9sZFN5bmNMb2dzJyxcclxuICAgICAgICAgIHN0YXR1czogcmVzdWx0c1sxXS5zdGF0dXMsXHJcbiAgICAgICAgICByZXN1bHQ6IHJlc3VsdHNbMV0udmFsdWUgfHwgcmVzdWx0c1sxXS5yZWFzb24sXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBuYW1lOiAnb3B0aW1pemVEYXRhYmFzZScsXHJcbiAgICAgICAgICBzdGF0dXM6IHJlc3VsdHNbMl0uc3RhdHVzLFxyXG4gICAgICAgICAgcmVzdWx0OiByZXN1bHRzWzJdLnZhbHVlIHx8IHJlc3VsdHNbMl0ucmVhc29uLFxyXG4gICAgICAgIH0sXHJcbiAgICAgIF0sXHJcbiAgICB9O1xyXG5cclxuICAgIGNvbnNvbGUubG9nKCfinIUgUGVyaW9kaWMgbWFpbnRlbmFuY2UgY29tcGxldGVkOicsIHN1bW1hcnkpO1xyXG4gICAgcmV0dXJuIHN1bW1hcnk7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ1BlcmlvZGljIG1haW50ZW5hbmNlIGZhaWxlZDonLCBlcnJvcik7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBlcnJvcjogZXJyb3IubWVzc2FnZSxcclxuICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXHJcbiAgICB9O1xyXG4gIH1cclxufVxyXG5cclxuLy8gU2NoZWR1bGUgcGVyaW9kaWMgbWFpbnRlbmFuY2UgKHJ1bnMgZXZlcnkgNiBob3VycylcclxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAndGVzdCcgJiYgcHJvY2Vzcy5lbnYuRU5BQkxFX01BSU5URU5BTkNFICE9PSAnZmFsc2UnKSB7XHJcbiAgc2V0SW50ZXJ2YWwoXHJcbiAgICBhc3luYyAoKSA9PiB7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgYXdhaXQgcGVyZm9ybU1haW50ZW5hbmNlKCk7XHJcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcignU2NoZWR1bGVkIG1haW50ZW5hbmNlIGZhaWxlZDonLCBlcnJvcik7XHJcbiAgICAgIH1cclxuICAgIH0sXHJcbiAgICA2ICogNjAgKiA2MCAqIDEwMDBcclxuICApOyAvLyA2IGhvdXJzXHJcbn1cclxuXHJcbi8vIEdyYWNlZnVsIHNodXRkb3duIGhhbmRsZXJcclxuYXN5bmMgZnVuY3Rpb24gZ3JhY2VmdWxTaHV0ZG93bigpIHtcclxuICBjb25zb2xlLmxvZygn8J+UjCBDbG9zaW5nIGRhdGFiYXNlIGNvbm5lY3Rpb25zLi4uJyk7XHJcbiAgdHJ5IHtcclxuICAgIGF3YWl0IHByaXNtYS4kZGlzY29ubmVjdCgpO1xyXG4gICAgY29uc29sZS5sb2coJ+KchSBEYXRhYmFzZSBjb25uZWN0aW9ucyBjbG9zZWQgc3VjY2Vzc2Z1bGx5Jyk7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBFcnJvciBjbG9zaW5nIGRhdGFiYXNlIGNvbm5lY3Rpb25zOicsIGVycm9yKTtcclxuICB9XHJcbn1cclxuXHJcbi8vIEhhbmRsZSBwcm9jZXNzIHNodXRkb3duXHJcbnByb2Nlc3Mub24oJ1NJR0lOVCcsIGdyYWNlZnVsU2h1dGRvd24pO1xyXG5wcm9jZXNzLm9uKCdTSUdURVJNJywgZ3JhY2VmdWxTaHV0ZG93bik7XHJcbnByb2Nlc3Mub24oJ1NJR1FVSVQnLCBncmFjZWZ1bFNodXRkb3duKTtcclxuXHJcbi8vIEhhbmRsZSB1bmNhdWdodCBleGNlcHRpb25zXHJcbnByb2Nlc3Mub24oJ3VuY2F1Z2h0RXhjZXB0aW9uJywgYXN5bmMgKGVycm9yKSA9PiB7XHJcbiAgY29uc29sZS5lcnJvcignVW5jYXVnaHQgRXhjZXB0aW9uOicsIGVycm9yKTtcclxuICBhd2FpdCBncmFjZWZ1bFNodXRkb3duKCk7XHJcbiAgcHJvY2Vzcy5leGl0KDEpO1xyXG59KTtcclxuXHJcbnByb2Nlc3Mub24oJ3VuaGFuZGxlZFJlamVjdGlvbicsIGFzeW5jIChyZWFzb24sIHByb21pc2UpID0+IHtcclxuICBjb25zb2xlLmVycm9yKCdVbmhhbmRsZWQgUmVqZWN0aW9uIGF0OicsIHByb21pc2UsICdyZWFzb246JywgcmVhc29uKTtcclxuICBhd2FpdCBncmFjZWZ1bFNodXRkb3duKCk7XHJcbiAgcHJvY2Vzcy5leGl0KDEpO1xyXG59KTtcclxuXHJcbi8vIERlZmF1bHQgZXhwb3J0XHJcbmV4cG9ydCBkZWZhdWx0IHByaXNtYTtcclxuIl0sIm5hbWVzIjpbIlByaXNtYUNsaWVudCIsImdsb2JhbEZvclByaXNtYSIsImdsb2JhbFRoaXMiLCJwcmlzbWEiLCJsb2ciLCJkYXRhc291cmNlcyIsImRiIiwidXJsIiwicHJvY2VzcyIsImVudiIsIkRBVEFCQVNFX1VSTCIsIl9faW50ZXJuYWwiLCJlbmdpbmUiLCJjb25uZWN0VGltZW91dCIsInF1ZXJ5VGltZW91dCIsImNoZWNrREJIZWFsdGgiLCIkcXVlcnlSYXciLCJzdGF0dXMiLCJ0aW1lc3RhbXAiLCJEYXRlIiwidG9JU09TdHJpbmciLCJjb25uZWN0aW9uIiwidmVyc2lvbiIsImdldERhdGFiYXNlVmVyc2lvbiIsImVycm9yIiwibWVzc2FnZSIsInJlc3VsdCIsImNsZWFudXBFeHBpcmVkQ2FjaGUiLCJjYWNoZUVudHJ5IiwiZGVsZXRlTWFueSIsIndoZXJlIiwiZXhwaXJlc0F0IiwibHQiLCJjb25zb2xlIiwiY291bnQiLCJjbGVhbnVwT2xkU3luY0xvZ3MiLCJ0aGlydHlEYXlzQWdvIiwic2V0RGF0ZSIsImdldERhdGUiLCJzeW5jTG9nIiwiY3JlYXRlZEF0Iiwid2l0aFRyYW5zYWN0aW9uIiwiY2FsbGJhY2siLCIkdHJhbnNhY3Rpb24iLCJtYXhXYWl0IiwidGltZW91dCIsImlzb2xhdGlvbkxldmVsIiwiYmF0Y2hPcGVyYXRpb24iLCJvcGVyYXRpb24iLCJkYXRhIiwiYmF0Y2hTaXplIiwicmVzdWx0cyIsImVycm9ycyIsImkiLCJsZW5ndGgiLCJiYXRjaCIsInNsaWNlIiwiYmF0Y2hSZXN1bHQiLCJwdXNoIiwiYmF0Y2hJbmRleCIsIk1hdGgiLCJmbG9vciIsImdldENvbm5lY3Rpb25JbmZvIiwiZ2V0RGF0YWJhc2VNZXRyaWNzIiwiY29ubmVjdGlvbkluZm8iLCJ0YWJsZVN0YXRzIiwiaW5kZXhTdGF0cyIsIlByb21pc2UiLCJhbGwiLCJnZXRUYWJsZVN0YXRzIiwiZ2V0SW5kZXhTdGF0cyIsImNvbm5lY3Rpb25zIiwidGFibGVzIiwiaW5kZXhlcyIsImNyZWF0ZUJhY2t1cFNuYXBzaG90IiwicmVwbGFjZSIsInN1Y2Nlc3MiLCJvcHRpbWl6ZURhdGFiYXNlIiwiJGV4ZWN1dGVSYXciLCJjaGVja0RhdGFiYXNlU2VlZGVkIiwiaXBvQ291bnQiLCJpUE8iLCJ1c2VyQ291bnQiLCJ1c2VyIiwiaXNTZWVkZWQiLCJjb3VudHMiLCJpcG9zIiwidXNlcnMiLCJyZXNldFRhYmxlcyIsInRhYmxlTmFtZXMiLCJFcnJvciIsImpvaW4iLCJ0YWJsZU5hbWUiLCJ0b0xvd2VyQ2FzZSIsImdNUCIsInN1YnNjcmlwdGlvbkRhdGEiLCJtYXJrZXREZW1hbmQiLCJhbGxvdG1lbnQiLCJpUE9BbmFseXRpY3MiLCJ3YXJuIiwiZ2V0RGF0YWJhc2VTaXplIiwiZ2V0U2xvd1F1ZXJpZXMiLCJsaW1pdCIsInBlcmZvcm1NYWludGVuYW5jZSIsImFsbFNldHRsZWQiLCJzdW1tYXJ5Iiwib3BlcmF0aW9ucyIsIm5hbWUiLCJ2YWx1ZSIsInJlYXNvbiIsIkVOQUJMRV9NQUlOVEVOQU5DRSIsInNldEludGVydmFsIiwiZ3JhY2VmdWxTaHV0ZG93biIsIiRkaXNjb25uZWN0Iiwib24iLCJleGl0IiwicHJvbWlzZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./src/lib/db.js\n");

/***/ }),

/***/ "(rsc)/./src/lib/websocket.js":
/*!******************************!*\
  !*** ./src/lib/websocket.js ***!
  \******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   io: () => (/* binding */ io),\n/* harmony export */   webSocketService: () => (/* binding */ webSocketService)\n/* harmony export */ });\n/* harmony import */ var socket_io__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! socket.io */ \"(rsc)/./node_modules/socket.io/wrapper.mjs\");\n/* harmony import */ var http__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! http */ \"http\");\n/* harmony import */ var _cache_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./cache.js */ \"(rsc)/./src/lib/cache.js\");\n/* harmony import */ var _db_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./db.js */ \"(rsc)/./src/lib/db.js\");\n\n\n\n\nclass WebSocketService {\n    constructor(){\n        this.io = null;\n        this.server = null;\n        this.connectedClients = new Map();\n        this.roomSubscriptions = new Map();\n        this.port = process.env.WEBSOCKET_PORT || 3001;\n        // Event types for real-time updates\n        this.events = {\n            IPO_UPDATE: \"ipo:update\",\n            GMP_UPDATE: \"gmp:update\",\n            SUBSCRIPTION_UPDATE: \"subscription:update\",\n            DEMAND_UPDATE: \"demand:update\",\n            ALLOTMENT_UPDATE: \"allotment:update\",\n            SYSTEM_STATUS: \"system:status\",\n            ANALYTICS_UPDATE: \"analytics:update\",\n            NEWS_UPDATE: \"news:update\",\n            ALERT_TRIGGERED: \"alert:triggered\"\n        };\n        // Rate limiting configuration\n        this.rateLimits = new Map();\n        this.maxEventsPerSecond = 20;\n        this.maxSubscriptionsPerClient = 100;\n        // Performance monitoring\n        this.metrics = {\n            totalConnections: 0,\n            currentConnections: 0,\n            totalMessages: 0,\n            totalSubscriptions: 0,\n            errors: 0,\n            startTime: Date.now(),\n            averageResponseTime: 0,\n            peakConnections: 0\n        };\n        // Connection health tracking\n        this.connectionHealth = new Map();\n        // Message queue for offline clients\n        this.messageQueue = new Map();\n        this.maxQueueSize = 50;\n    }\n    // Initialize WebSocket server with enhanced configuration\n    initialize() {\n        try {\n            this.server = (0,http__WEBPACK_IMPORTED_MODULE_1__.createServer)();\n            this.io = new socket_io__WEBPACK_IMPORTED_MODULE_0__.Server(this.server, {\n                cors: {\n                    origin: process.env.FRONTEND_URL || \"http://localhost:3000\",\n                    methods: [\n                        \"GET\",\n                        \"POST\"\n                    ],\n                    credentials: true\n                },\n                pingTimeout: 60000,\n                pingInterval: 25000,\n                maxHttpBufferSize: 2e6,\n                transports: [\n                    \"websocket\",\n                    \"polling\"\n                ],\n                allowEIO3: true,\n                // Connection rate limiting\n                connectTimeout: 45000,\n                upgradeTimeout: 10000\n            });\n            this.setupEventHandlers();\n            this.startHeartbeat();\n            this.startMetricsCollection();\n            this.startHealthMonitoring();\n            console.log(\"\\uD83D\\uDD0C WebSocket service initialized successfully\");\n            return this;\n        } catch (error) {\n            console.error(\"âŒ Failed to initialize WebSocket service:\", error);\n            throw error;\n        }\n    }\n    // Start the WebSocket server\n    async start() {\n        try {\n            await new Promise((resolve, reject)=>{\n                this.server.listen(this.port, (err)=>{\n                    if (err) {\n                        reject(err);\n                    } else {\n                        console.log(`ðŸš€ WebSocket server running on port ${this.port}`);\n                        console.log(`ðŸŒ Accepting connections from: ${process.env.FRONTEND_URL || \"http://localhost:3000\"}`);\n                        resolve();\n                    }\n                });\n            });\n            // Start periodic cleanup\n            this.startPeriodicCleanup();\n        } catch (error) {\n            console.error(\"âŒ Failed to start WebSocket server:\", error);\n            throw error;\n        }\n    }\n    // Enhanced event handlers\n    setupEventHandlers() {\n        this.io.on(\"connection\", (socket)=>{\n            this.handleClientConnection(socket);\n            this.setupClientEventListeners(socket);\n            // Track metrics\n            this.metrics.totalConnections++;\n            this.metrics.currentConnections++;\n            this.metrics.peakConnections = Math.max(this.metrics.peakConnections, this.metrics.currentConnections);\n        });\n        // Handle server errors\n        this.io.on(\"error\", (error)=>{\n            console.error(\"\\uD83D\\uDD0C WebSocket server error:\", error);\n            this.metrics.errors++;\n        });\n    }\n    handleClientConnection(socket) {\n        const clientIP = socket.handshake.address;\n        const userAgent = socket.handshake.headers[\"user-agent\"] || \"Unknown\";\n        console.log(`ðŸ”Œ Client connected: ${socket.id} from ${clientIP}`);\n        const clientInfo = {\n            socket,\n            connectedAt: new Date(),\n            subscriptions: new Set(),\n            lastActivity: new Date(),\n            subscriptionCount: 0,\n            messageCount: 0,\n            userAgent,\n            ipAddress: clientIP,\n            isHealthy: true,\n            lastPing: Date.now(),\n            reconnectCount: 0\n        };\n        this.connectedClients.set(socket.id, clientInfo);\n        this.connectionHealth.set(socket.id, {\n            status: \"connected\",\n            latency: 0,\n            lastSeen: Date.now()\n        });\n        // Send connection confirmation with server info\n        socket.emit(\"connected\", {\n            socketId: socket.id,\n            timestamp: Date.now(),\n            serverVersion: \"1.0.0\",\n            availableEvents: Object.values(this.events),\n            maxSubscriptions: this.maxSubscriptionsPerClient,\n            rateLimits: {\n                maxEventsPerSecond: this.maxEventsPerSecond\n            },\n            features: {\n                realTimeUpdates: true,\n                batchSubscriptions: true,\n                messageQueue: true,\n                analytics: true\n            }\n        });\n        // Send queued messages if any\n        this.sendQueuedMessages(socket.id);\n    }\n    setupClientEventListeners(socket) {\n        // IPO subscription with enhanced features\n        socket.on(\"subscribe:ipo\", async (data)=>{\n            await this.handleSubscription(socket, \"ipo\", data, async ()=>{\n                const { ipoId, symbol, includeAnalytics = false } = data;\n                if (ipoId) {\n                    socket.join(`ipo:${ipoId}`);\n                    this.addSubscription(socket.id, \"ipo\", ipoId);\n                    // Send current data immediately\n                    const ipoData = await this.getCurrentIPOData(ipoId);\n                    if (ipoData) {\n                        socket.emit(this.events.IPO_UPDATE, {\n                            ipoId,\n                            data: ipoData,\n                            type: \"initial_data\",\n                            timestamp: Date.now()\n                        });\n                        // Send analytics if requested\n                        if (includeAnalytics && ipoData.analytics) {\n                            socket.emit(this.events.ANALYTICS_UPDATE, {\n                                ipoId,\n                                data: ipoData.analytics,\n                                type: \"initial_analytics\",\n                                timestamp: Date.now()\n                            });\n                        }\n                    }\n                }\n            });\n        });\n        // Enhanced GMP subscription\n        socket.on(\"subscribe:gmp\", async (data)=>{\n            await this.handleSubscription(socket, \"gmp\", data, async ()=>{\n                const { ipoId, symbol, historical = false, alertThreshold = null } = data;\n                if (ipoId) {\n                    socket.join(`gmp:${ipoId}`);\n                    this.addSubscription(socket.id, \"gmp\", ipoId);\n                    // Send current GMP data\n                    const gmpData = await _cache_js__WEBPACK_IMPORTED_MODULE_2__.cache.getRealTimeData(\"GMP\", ipoId);\n                    if (gmpData) {\n                        socket.emit(this.events.GMP_UPDATE, {\n                            ipoId,\n                            data: gmpData,\n                            type: \"current\",\n                            timestamp: Date.now()\n                        });\n                    }\n                    // Send historical data if requested\n                    if (historical) {\n                        const historicalGMP = await this.getHistoricalGMPData(ipoId, 30);\n                        socket.emit(\"gmp:historical\", {\n                            ipoId,\n                            data: historicalGMP,\n                            type: \"historical\",\n                            days: 30\n                        });\n                    }\n                    // Set up alert threshold if provided\n                    if (alertThreshold !== null) {\n                        this.setupGMPAlert(socket.id, ipoId, alertThreshold);\n                    }\n                }\n            });\n        });\n        // Real-time subscription data updates\n        socket.on(\"subscribe:subscription\", async (data)=>{\n            await this.handleSubscription(socket, \"subscription\", data, async ()=>{\n                const { symbol, categories = [], realTime = true } = data;\n                socket.join(`subscription:${symbol}`);\n                this.addSubscription(socket.id, \"subscription\", symbol);\n                // Send current subscription data\n                const subData = await _cache_js__WEBPACK_IMPORTED_MODULE_2__.cache.getRealTimeData(\"SUBSCRIPTION\", symbol);\n                if (subData) {\n                    const filteredData = categories.length > 0 ? subData.data?.filter((item)=>categories.includes(item.category)) : subData;\n                    socket.emit(this.events.SUBSCRIPTION_UPDATE, {\n                        symbol,\n                        data: filteredData,\n                        categories: categories.length > 0 ? categories : \"all\",\n                        timestamp: Date.now()\n                    });\n                }\n            });\n        });\n        // Market demand updates with price filtering\n        socket.on(\"subscribe:demand\", async (data)=>{\n            await this.handleSubscription(socket, \"demand\", data, async ()=>{\n                const { symbol, priceRange = null, cutOffOnly = false } = data;\n                socket.join(`demand:${symbol}`);\n                this.addSubscription(socket.id, \"demand\", symbol);\n                // Send current demand data\n                const demandData = await _cache_js__WEBPACK_IMPORTED_MODULE_2__.cache.getRealTimeData(\"DEMAND\", symbol);\n                if (demandData) {\n                    let filteredData = demandData.data || [];\n                    // Apply filters\n                    if (cutOffOnly) {\n                        filteredData = filteredData.filter((item)=>item.cutOffIndicator);\n                    }\n                    if (priceRange && priceRange.min !== undefined && priceRange.max !== undefined) {\n                        filteredData = filteredData.filter((item)=>item.price >= priceRange.min && item.price <= priceRange.max);\n                    }\n                    socket.emit(this.events.DEMAND_UPDATE, {\n                        symbol,\n                        data: filteredData,\n                        filters: {\n                            priceRange,\n                            cutOffOnly\n                        },\n                        timestamp: Date.now()\n                    });\n                }\n            });\n        });\n        // Analytics subscription with customizable metrics\n        socket.on(\"subscribe:analytics\", async (data)=>{\n            await this.handleSubscription(socket, \"analytics\", data, async ()=>{\n                const { ipoId, type = \"all\", metrics = [], updateInterval = 30000 } = data;\n                socket.join(`analytics:${ipoId}`);\n                this.addSubscription(socket.id, \"analytics\", ipoId);\n                // Send current analytics\n                const analytics = await this.getCurrentAnalytics(ipoId, type);\n                if (analytics) {\n                    const filteredAnalytics = metrics.length > 0 ? this.filterAnalyticsByMetrics(analytics, metrics) : analytics;\n                    socket.emit(this.events.ANALYTICS_UPDATE, {\n                        ipoId,\n                        type,\n                        data: filteredAnalytics,\n                        metrics: metrics.length > 0 ? metrics : \"all\",\n                        timestamp: Date.now()\n                    });\n                }\n            });\n        });\n        // System status subscription\n        socket.on(\"subscribe:system\", async ()=>{\n            socket.join(\"system:status\");\n            this.addSubscription(socket.id, \"system\", \"status\");\n            // Send current system status\n            const systemStatus = await this.getSystemStatus();\n            socket.emit(this.events.SYSTEM_STATUS, {\n                ...systemStatus,\n                type: \"current_status\",\n                timestamp: Date.now()\n            });\n        });\n        // Batch subscription for multiple IPOs with advanced options\n        socket.on(\"subscribe:batch\", async (data)=>{\n            const { subscriptions = [], options = {} } = data;\n            const { maxSubscriptions = 20, skipErrors = true } = options;\n            const results = [];\n            // Limit batch size\n            const limitedSubscriptions = subscriptions.slice(0, maxSubscriptions);\n            for (const sub of limitedSubscriptions){\n                try {\n                    await this.handleSingleSubscription(socket, sub);\n                    results.push({\n                        ...sub,\n                        status: \"success\"\n                    });\n                } catch (error) {\n                    results.push({\n                        ...sub,\n                        status: \"error\",\n                        error: error.message\n                    });\n                    if (!skipErrors) {\n                        break;\n                    }\n                }\n            }\n            socket.emit(\"subscribe:batch:result\", {\n                results,\n                processed: results.length,\n                successful: results.filter((r)=>r.status === \"success\").length,\n                errors: results.filter((r)=>r.status === \"error\").length,\n                timestamp: Date.now()\n            });\n        });\n        // Enhanced unsubscribe with patterns\n        socket.on(\"unsubscribe\", (data)=>{\n            const { type, identifier, pattern } = data;\n            if (pattern === \"all\") {\n                this.unsubscribeAll(socket.id);\n                socket.emit(\"unsubscribe:result\", {\n                    pattern: \"all\",\n                    status: \"success\",\n                    message: \"Unsubscribed from all events\"\n                });\n            } else if (type && identifier) {\n                const roomKey = `${type}:${identifier}`;\n                socket.leave(roomKey);\n                this.removeSubscription(socket.id, type, identifier);\n                socket.emit(\"unsubscribe:result\", {\n                    type,\n                    identifier,\n                    status: \"success\"\n                });\n            } else if (type) {\n                // Unsubscribe from all subscriptions of a specific type\n                this.unsubscribeByType(socket.id, type);\n                socket.emit(\"unsubscribe:result\", {\n                    type,\n                    status: \"success\",\n                    message: `Unsubscribed from all ${type} events`\n                });\n            }\n        });\n        // Enhanced heartbeat with performance metrics\n        socket.on(\"ping\", (data)=>{\n            const client = this.connectedClients.get(socket.id);\n            const now = Date.now();\n            if (client) {\n                client.lastActivity = new Date();\n                client.messageCount++;\n                client.lastPing = now;\n            }\n            // Calculate latency\n            const latency = data?.timestamp ? now - data.timestamp : 0;\n            this.connectionHealth.set(socket.id, {\n                status: \"healthy\",\n                latency,\n                lastSeen: now\n            });\n            socket.emit(\"pong\", {\n                timestamp: now,\n                serverUptime: now - this.metrics.startTime,\n                latency,\n                clientInfo: client ? {\n                    subscriptions: client.subscriptionCount,\n                    messages: client.messageCount,\n                    connectedFor: now - client.connectedAt.getTime()\n                } : null\n            });\n        });\n        // Client info and statistics request\n        socket.on(\"client:info\", ()=>{\n            const client = this.connectedClients.get(socket.id);\n            const health = this.connectionHealth.get(socket.id);\n            if (client) {\n                socket.emit(\"client:info\", {\n                    socketId: socket.id,\n                    connectedAt: client.connectedAt,\n                    subscriptions: Array.from(client.subscriptions),\n                    subscriptionCount: client.subscriptionCount,\n                    messageCount: client.messageCount,\n                    userAgent: client.userAgent,\n                    ipAddress: client.ipAddress,\n                    health: health || {\n                        status: \"unknown\"\n                    },\n                    serverMetrics: {\n                        totalConnections: this.metrics.currentConnections,\n                        serverUptime: Date.now() - this.metrics.startTime\n                    }\n                });\n            }\n        });\n        // Request server statistics\n        socket.on(\"server:stats\", ()=>{\n            if (this.isAuthorized(socket)) {\n                // Only for authorized clients\n                const stats = this.getDetailedStats();\n                socket.emit(\"server:stats\", stats);\n            } else {\n                socket.emit(\"error\", {\n                    type: \"unauthorized\",\n                    message: \"Not authorized to view server statistics\"\n                });\n            }\n        });\n        // Error handling\n        socket.on(\"error\", (error)=>{\n            console.error(`ðŸ”Œ Socket error for ${socket.id}:`, error);\n            this.metrics.errors++;\n            const client = this.connectedClients.get(socket.id);\n            if (client) {\n                client.isHealthy = false;\n            }\n            this.connectionHealth.set(socket.id, {\n                status: \"error\",\n                error: error.message,\n                lastSeen: Date.now()\n            });\n        });\n        // Disconnect handling with cleanup\n        socket.on(\"disconnect\", (reason)=>{\n            console.log(`ðŸ”Œ Client disconnected: ${socket.id}, reason: ${reason}`);\n            const client = this.connectedClients.get(socket.id);\n            if (client) {\n                // Store disconnection info for potential reconnection\n                this.handleClientDisconnection(socket.id, reason);\n            }\n            this.cleanupClient(socket.id);\n            this.metrics.currentConnections--;\n        });\n        // Reconnection handling\n        socket.on(\"reconnect\", (data)=>{\n            console.log(`ðŸ”„ Client reconnected: ${socket.id}`);\n            const client = this.connectedClients.get(socket.id);\n            if (client) {\n                client.reconnectCount++;\n                client.lastActivity = new Date();\n                // Send queued messages\n                this.sendQueuedMessages(socket.id);\n            }\n        });\n    }\n    // Enhanced subscription handling with validation\n    async handleSubscription(socket, type, data, subscriptionLogic) {\n        try {\n            const client = this.connectedClients.get(socket.id);\n            if (!client) {\n                throw new Error(\"Client not found\");\n            }\n            // Check subscription limits\n            if (client.subscriptionCount >= this.maxSubscriptionsPerClient) {\n                throw new Error(`Maximum subscriptions limit reached (${this.maxSubscriptionsPerClient})`);\n            }\n            // Check rate limits\n            if (!this.checkRateLimit(socket.id, type)) {\n                throw new Error(\"Rate limit exceeded. Please slow down.\");\n            }\n            // Validate subscription data\n            this.validateSubscriptionData(type, data);\n            // Execute subscription logic\n            await subscriptionLogic();\n            // Update client info\n            client.lastActivity = new Date();\n            client.messageCount++;\n            // Send success confirmation\n            socket.emit(\"subscribe:success\", {\n                type,\n                data,\n                timestamp: Date.now(),\n                subscriptionCount: client.subscriptionCount\n            });\n        } catch (error) {\n            console.error(`Subscription failed for ${socket.id}:`, error.message);\n            socket.emit(\"subscribe:error\", {\n                type: \"subscription_failed\",\n                message: error.message,\n                subscriptionType: type,\n                data,\n                timestamp: Date.now()\n            });\n        }\n    }\n    // Validate subscription data\n    validateSubscriptionData(type, data) {\n        switch(type){\n            case \"ipo\":\n                if (!data.ipoId && !data.symbol) {\n                    throw new Error(\"Either ipoId or symbol is required for IPO subscription\");\n                }\n                break;\n            case \"gmp\":\n                if (!data.ipoId && !data.symbol) {\n                    throw new Error(\"Either ipoId or symbol is required for GMP subscription\");\n                }\n                break;\n            case \"subscription\":\n            case \"demand\":\n                if (!data.symbol) {\n                    throw new Error(\"Symbol is required for subscription/demand data\");\n                }\n                break;\n            case \"analytics\":\n                if (!data.ipoId) {\n                    throw new Error(\"IPO ID is required for analytics subscription\");\n                }\n                break;\n        }\n    }\n    // Handle single subscription (for batch operations)\n    async handleSingleSubscription(socket, { type, ipoId, symbol, options = {} }) {\n        switch(type){\n            case \"ipo\":\n                if (ipoId) {\n                    socket.join(`ipo:${ipoId}`);\n                    this.addSubscription(socket.id, \"ipo\", ipoId);\n                }\n                break;\n            case \"gmp\":\n                if (ipoId) {\n                    socket.join(`gmp:${ipoId}`);\n                    this.addSubscription(socket.id, \"gmp\", ipoId);\n                }\n                break;\n            case \"subscription\":\n                if (symbol) {\n                    socket.join(`subscription:${symbol}`);\n                    this.addSubscription(socket.id, \"subscription\", symbol);\n                }\n                break;\n            case \"demand\":\n                if (symbol) {\n                    socket.join(`demand:${symbol}`);\n                    this.addSubscription(socket.id, \"demand\", symbol);\n                }\n                break;\n            case \"analytics\":\n                if (ipoId) {\n                    socket.join(`analytics:${ipoId}`);\n                    this.addSubscription(socket.id, \"analytics\", ipoId);\n                }\n                break;\n            default:\n                throw new Error(`Unknown subscription type: ${type}`);\n        }\n    }\n    // Enhanced rate limiting\n    checkRateLimit(socketId, eventType) {\n        const key = `${socketId}:${eventType}`;\n        const now = Date.now();\n        const windowStart = Math.floor(now / 1000) * 1000;\n        if (!this.rateLimits.has(key)) {\n            this.rateLimits.set(key, {\n                count: 0,\n                windowStart\n            });\n        }\n        const limit = this.rateLimits.get(key);\n        if (limit.windowStart !== windowStart) {\n            limit.count = 0;\n            limit.windowStart = windowStart;\n        }\n        if (limit.count >= this.maxEventsPerSecond) {\n            return false;\n        }\n        limit.count++;\n        return true;\n    }\n    // Subscription management\n    addSubscription(socketId, type, identifier) {\n        const client = this.connectedClients.get(socketId);\n        if (client) {\n            const subscriptionKey = `${type}:${identifier}`;\n            client.subscriptions.add(subscriptionKey);\n            client.subscriptionCount = client.subscriptions.size;\n            // Track room subscriptions\n            if (!this.roomSubscriptions.has(subscriptionKey)) {\n                this.roomSubscriptions.set(subscriptionKey, new Set());\n            }\n            this.roomSubscriptions.get(subscriptionKey).add(socketId);\n            this.metrics.totalSubscriptions++;\n        }\n    }\n    removeSubscription(socketId, type, identifier) {\n        const client = this.connectedClients.get(socketId);\n        if (client) {\n            const subscriptionKey = `${type}:${identifier}`;\n            client.subscriptions.delete(subscriptionKey);\n            client.subscriptionCount = client.subscriptions.size;\n            // Remove from room subscriptions\n            const roomSubs = this.roomSubscriptions.get(subscriptionKey);\n            if (roomSubs) {\n                roomSubs.delete(socketId);\n                if (roomSubs.size === 0) {\n                    this.roomSubscriptions.delete(subscriptionKey);\n                }\n            }\n        }\n    }\n    unsubscribeAll(socketId) {\n        const client = this.connectedClients.get(socketId);\n        if (client) {\n            for (const subscription of client.subscriptions){\n                const [type, identifier] = subscription.split(\":\");\n                client.socket.leave(subscription);\n                this.removeSubscription(socketId, type, identifier);\n            }\n        }\n    }\n    unsubscribeByType(socketId, type) {\n        const client = this.connectedClients.get(socketId);\n        if (client) {\n            const subscriptionsToRemove = Array.from(client.subscriptions).filter((sub)=>sub.startsWith(`${type}:`));\n            for (const subscription of subscriptionsToRemove){\n                const [, identifier] = subscription.split(\":\");\n                client.socket.leave(subscription);\n                this.removeSubscription(socketId, type, identifier);\n            }\n        }\n    }\n    // Enhanced broadcasting methods\n    async broadcastIPOUpdate(ipoId, updateData, options = {}) {\n        try {\n            const { priority = \"normal\", excludeSocket = null, includeAnalytics = false } = options;\n            if (!this.checkBroadcastRateLimit(\"ipo\", ipoId)) {\n                return;\n            }\n            const room = `ipo:${ipoId}`;\n            const subscriberCount = this.roomSubscriptions.get(room)?.size || 0;\n            if (subscriberCount > 0) {\n                const enrichedData = {\n                    ipoId,\n                    data: updateData,\n                    timestamp: Date.now(),\n                    priority,\n                    server: process.env.SERVER_ID || \"ws-1\",\n                    type: \"update\"\n                };\n                if (includeAnalytics && updateData.analytics) {\n                    enrichedData.analytics = updateData.analytics;\n                }\n                if (excludeSocket) {\n                    this.io.to(room).except(excludeSocket).emit(this.events.IPO_UPDATE, enrichedData);\n                } else {\n                    this.io.to(room).emit(this.events.IPO_UPDATE, enrichedData);\n                }\n                console.log(`ðŸ“¡ IPO update broadcast to ${subscriberCount} clients for IPO ${ipoId}`);\n                this.metrics.totalMessages++;\n                // Queue message for offline clients if critical\n                if (priority === \"high\") {\n                    this.queueMessageForOfflineClients(room, enrichedData);\n                }\n            }\n        } catch (error) {\n            console.error(\"Error broadcasting IPO update:\", error);\n            this.metrics.errors++;\n        }\n    }\n    async broadcastGMPUpdate(ipoId, gmpData, options = {}) {\n        try {\n            const { historical = false, alertCheck = true } = options;\n            if (!this.checkBroadcastRateLimit(\"gmp\", ipoId)) {\n                return;\n            }\n            const room = `gmp:${ipoId}`;\n            const subscriberCount = this.roomSubscriptions.get(room)?.size || 0;\n            if (subscriberCount > 0) {\n                const change = await this.calculateGMPChange(ipoId, gmpData.value);\n                const enrichedData = {\n                    ipoId,\n                    data: gmpData,\n                    timestamp: Date.now(),\n                    historical,\n                    change,\n                    trend: this.calculateGMPTrend(change),\n                    volatility: await this.calculateGMPVolatility(ipoId)\n                };\n                this.io.to(room).emit(this.events.GMP_UPDATE, enrichedData);\n                console.log(`ðŸ’° GMP update broadcast to ${subscriberCount} clients for IPO ${ipoId} (Value: ${gmpData.value})`);\n                this.metrics.totalMessages++;\n                // Check for GMP alerts\n                if (alertCheck) {\n                    this.checkGMPAlerts(ipoId, gmpData.value);\n                }\n            }\n        } catch (error) {\n            console.error(\"Error broadcasting GMP update:\", error);\n            this.metrics.errors++;\n        }\n    }\n    async broadcastSubscriptionUpdate(symbol, subscriptionData, options = {}) {\n        try {\n            const { category = null, alertOnOversubscription = true } = options;\n            if (!this.checkBroadcastRateLimit(\"subscription\", symbol)) {\n                return;\n            }\n            const room = `subscription:${symbol}`;\n            const subscriberCount = this.roomSubscriptions.get(room)?.size || 0;\n            if (subscriberCount > 0) {\n                const enrichedData = {\n                    symbol,\n                    data: subscriptionData,\n                    timestamp: Date.now(),\n                    category,\n                    overallSubscription: this.calculateOverallSubscription(subscriptionData),\n                    isOversubscribed: this.isOversubscribed(subscriptionData)\n                };\n                this.io.to(room).emit(this.events.SUBSCRIPTION_UPDATE, enrichedData);\n                console.log(`ðŸ“Š Subscription update broadcast to ${subscriberCount} clients for ${symbol}`);\n                this.metrics.totalMessages++;\n                // Alert on oversubscription\n                if (alertOnOversubscription && enrichedData.isOversubscribed) {\n                    this.broadcastAlert(\"oversubscription\", {\n                        symbol,\n                        subscription: enrichedData.overallSubscription,\n                        timestamp: Date.now()\n                    });\n                }\n            }\n        } catch (error) {\n            console.error(\"Error broadcasting subscription update:\", error);\n            this.metrics.errors++;\n        }\n    }\n    async broadcastDemandUpdate(symbol, demandData, options = {}) {\n        try {\n            const { priceLevel = null } = options;\n            if (!this.checkBroadcastRateLimit(\"demand\", symbol)) {\n                return;\n            }\n            const room = `demand:${symbol}`;\n            const subscriberCount = this.roomSubscriptions.get(room)?.size || 0;\n            if (subscriberCount > 0) {\n                const enrichedData = {\n                    symbol,\n                    data: demandData,\n                    timestamp: Date.now(),\n                    priceLevel,\n                    totalDemand: this.calculateTotalDemand(demandData),\n                    cutOffDemand: this.calculateCutOffDemand(demandData)\n                };\n                this.io.to(room).emit(this.events.DEMAND_UPDATE, enrichedData);\n                console.log(`ðŸ“ˆ Demand update broadcast to ${subscriberCount} clients for ${symbol}`);\n                this.metrics.totalMessages++;\n            }\n        } catch (error) {\n            console.error(\"Error broadcasting demand update:\", error);\n            this.metrics.errors++;\n        }\n    }\n    async broadcastAnalyticsUpdate(ipoId, analyticsData, options = {}) {\n        try {\n            const { type = \"general\", metrics = null } = options;\n            if (!this.checkBroadcastRateLimit(\"analytics\", ipoId)) {\n                return;\n            }\n            const room = `analytics:${ipoId}`;\n            const subscriberCount = this.roomSubscriptions.get(room)?.size || 0;\n            if (subscriberCount > 0) {\n                const enrichedData = {\n                    ipoId,\n                    type,\n                    data: analyticsData,\n                    metrics,\n                    timestamp: Date.now(),\n                    insights: await this.generateAnalyticsInsights(analyticsData)\n                };\n                this.io.to(room).emit(this.events.ANALYTICS_UPDATE, enrichedData);\n                console.log(`ðŸ“Š Analytics update broadcast to ${subscriberCount} clients for IPO ${ipoId}`);\n                this.metrics.totalMessages++;\n            }\n        } catch (error) {\n            console.error(\"Error broadcasting analytics update:\", error);\n            this.metrics.errors++;\n        }\n    }\n    // Broadcast system status\n    async broadcastSystemStatus(status, options = {}) {\n        try {\n            const { priority = \"normal\", room = \"system:status\" } = options;\n            const subscriberCount = this.roomSubscriptions.get(room)?.size || 0;\n            if (subscriberCount > 0) {\n                const enrichedStatus = {\n                    ...status,\n                    timestamp: Date.now(),\n                    server: process.env.SERVER_ID || \"ws-1\",\n                    priority,\n                    connections: this.metrics.currentConnections\n                };\n                this.io.to(room).emit(this.events.SYSTEM_STATUS, enrichedStatus);\n                console.log(`ðŸ”” System status broadcast to ${subscriberCount} clients`);\n                this.metrics.totalMessages++;\n            }\n        } catch (error) {\n            console.error(\"Error broadcasting system status:\", error);\n            this.metrics.errors++;\n        }\n    }\n    // Broadcast alerts\n    async broadcastAlert(alertType, alertData) {\n        try {\n            const enrichedAlert = {\n                type: alertType,\n                data: alertData,\n                timestamp: Date.now(),\n                server: process.env.SERVER_ID || \"ws-1\",\n                severity: this.getAlertSeverity(alertType)\n            };\n            // Broadcast to all connected clients\n            this.io.emit(this.events.ALERT_TRIGGERED, enrichedAlert);\n            console.log(`ðŸš¨ Alert broadcast: ${alertType}`);\n            this.metrics.totalMessages++;\n            // Store alert for queuing\n            this.queueMessageForOfflineClients(\"global\", enrichedAlert);\n        } catch (error) {\n            console.error(\"Error broadcasting alert:\", error);\n            this.metrics.errors++;\n        }\n    }\n    // Broadcast rate limiting\n    checkBroadcastRateLimit(eventType, identifier) {\n        const key = `broadcast:${eventType}:${identifier}`;\n        const now = Date.now();\n        const windowStart = Math.floor(now / 5000) * 5000; // 5-second window\n        if (!this.rateLimits.has(key)) {\n            this.rateLimits.set(key, {\n                count: 0,\n                windowStart\n            });\n        }\n        const limit = this.rateLimits.get(key);\n        if (limit.windowStart !== windowStart) {\n            limit.count = 0;\n            limit.windowStart = windowStart;\n        }\n        // Max 10 broadcasts per 5 seconds per event type\n        if (limit.count >= 10) {\n            return false;\n        }\n        limit.count++;\n        return true;\n    }\n    // Calculate GMP change and trend\n    async calculateGMPChange(ipoId, currentValue) {\n        try {\n            if (!this.previousGMPValues) {\n                this.previousGMPValues = new Map();\n            }\n            const previousValue = this.previousGMPValues.get(ipoId) || currentValue;\n            this.previousGMPValues.set(ipoId, currentValue);\n            return {\n                absolute: currentValue - previousValue,\n                percentage: previousValue > 0 ? parseFloat(((currentValue - previousValue) / previousValue * 100).toFixed(2)) : 0,\n                direction: currentValue > previousValue ? \"up\" : currentValue < previousValue ? \"down\" : \"stable\"\n            };\n        } catch (error) {\n            return {\n                absolute: 0,\n                percentage: 0,\n                direction: \"stable\"\n            };\n        }\n    }\n    calculateGMPTrend(change) {\n        if (Math.abs(change.percentage) < 1) return \"stable\";\n        if (change.percentage > 5) return \"bullish\";\n        if (change.percentage < -5) return \"bearish\";\n        return change.direction;\n    }\n    async calculateGMPVolatility(ipoId) {\n        try {\n            const recentGMP = await _db_js__WEBPACK_IMPORTED_MODULE_3__.prisma.gMP.findMany({\n                where: {\n                    ipoId\n                },\n                orderBy: {\n                    timestamp: \"desc\"\n                },\n                take: 10\n            });\n            if (recentGMP.length < 2) return 0;\n            const values = recentGMP.map((g)=>g.value);\n            const mean = values.reduce((a, b)=>a + b) / values.length;\n            const variance = values.reduce((acc, val)=>acc + Math.pow(val - mean, 2), 0) / values.length;\n            return Math.round(Math.sqrt(variance) * 100) / 100;\n        } catch (error) {\n            return 0;\n        }\n    }\n    // Subscription calculation utilities\n    calculateOverallSubscription(subscriptionData) {\n        if (!Array.isArray(subscriptionData)) return 0;\n        const ratios = subscriptionData.map((item)=>parseFloat(item.subscriptionRatio || 0));\n        return ratios.length > 0 ? Math.max(...ratios) : 0;\n    }\n    isOversubscribed(subscriptionData) {\n        return this.calculateOverallSubscription(subscriptionData) > 1;\n    }\n    calculateTotalDemand(demandData) {\n        if (!Array.isArray(demandData)) return 0;\n        return demandData.reduce((total, item)=>total + parseInt(item.absoluteQuantity || 0), 0);\n    }\n    calculateCutOffDemand(demandData) {\n        if (!Array.isArray(demandData)) return 0;\n        return demandData.filter((item)=>item.cutOffIndicator).reduce((total, item)=>total + parseInt(item.absoluteQuantity || 0), 0);\n    }\n    // Generate analytics insights\n    async generateAnalyticsInsights(analyticsData) {\n        const insights = [];\n        try {\n            if (analyticsData.gmpVolatility > 20) {\n                insights.push({\n                    type: \"warning\",\n                    message: \"High GMP volatility detected\",\n                    value: analyticsData.gmpVolatility\n                });\n            }\n            if (analyticsData.finalSubscription > 5) {\n                insights.push({\n                    type: \"positive\",\n                    message: \"Strong subscription demand\",\n                    value: analyticsData.finalSubscription\n                });\n            }\n            if (analyticsData.riskScore > 70) {\n                insights.push({\n                    type: \"caution\",\n                    message: \"High risk score\",\n                    value: analyticsData.riskScore\n                });\n            }\n        } catch (error) {\n            console.error(\"Error generating insights:\", error);\n        }\n        return insights;\n    }\n    // Data fetching methods\n    async getCurrentIPOData(ipoId) {\n        try {\n            const ipo = await _db_js__WEBPACK_IMPORTED_MODULE_3__.prisma.iPO.findUnique({\n                where: {\n                    id: ipoId\n                },\n                include: {\n                    gmp: {\n                        take: 5,\n                        orderBy: {\n                            timestamp: \"desc\"\n                        }\n                    },\n                    subscription: {\n                        orderBy: {\n                            timestamp: \"desc\"\n                        },\n                        take: 10\n                    },\n                    analytics: true,\n                    categories: true\n                }\n            });\n            return ipo;\n        } catch (error) {\n            console.error(\"Error fetching current IPO data:\", error);\n            return null;\n        }\n    }\n    async getHistoricalGMPData(ipoId, days = 30) {\n        try {\n            const startDate = new Date();\n            startDate.setDate(startDate.getDate() - days);\n            const gmpData = await _db_js__WEBPACK_IMPORTED_MODULE_3__.prisma.gMP.findMany({\n                where: {\n                    ipoId,\n                    timestamp: {\n                        gte: startDate\n                    }\n                },\n                orderBy: {\n                    timestamp: \"asc\"\n                },\n                take: 1000\n            });\n            return gmpData;\n        } catch (error) {\n            console.error(\"Error fetching historical GMP data:\", error);\n            return [];\n        }\n    }\n    async getCurrentAnalytics(ipoId, type = \"all\") {\n        try {\n            const analytics = await _db_js__WEBPACK_IMPORTED_MODULE_3__.prisma.iPOAnalytics.findUnique({\n                where: {\n                    ipoId\n                }\n            });\n            if (type === \"all\") {\n                return analytics;\n            }\n            // Return specific analytics based on type\n            const typeMapping = {\n                gmp: [\n                    \"avgGMP\",\n                    \"maxGMP\",\n                    \"minGMP\",\n                    \"gmpVolatility\"\n                ],\n                subscription: [\n                    \"finalSubscription\",\n                    \"retailSubscription\",\n                    \"qibSubscription\"\n                ],\n                prediction: [\n                    \"predictedListingGain\",\n                    \"allotmentProbability\",\n                    \"riskScore\"\n                ]\n            };\n            if (typeMapping[type] && analytics) {\n                const filteredAnalytics = {};\n                typeMapping[type].forEach((key)=>{\n                    if (analytics[key] !== undefined) {\n                        filteredAnalytics[key] = analytics[key];\n                    }\n                });\n                return filteredAnalytics;\n            }\n            return analytics;\n        } catch (error) {\n            console.error(\"Error fetching analytics:\", error);\n            return null;\n        }\n    }\n    // System status\n    async getSystemStatus() {\n        try {\n            const [dbHealth, cacheHealth] = await Promise.allSettled([\n                _db_js__WEBPACK_IMPORTED_MODULE_3__.prisma.$queryRaw`SELECT 1`,\n                _cache_js__WEBPACK_IMPORTED_MODULE_2__.cache.healthCheck()\n            ]);\n            return {\n                status: \"operational\",\n                connections: this.metrics.currentConnections,\n                uptime: Date.now() - this.metrics.startTime,\n                database: dbHealth.status === \"fulfilled\" ? \"healthy\" : \"degraded\",\n                cache: cacheHealth.status === \"fulfilled\" && cacheHealth.value.status === \"healthy\" ? \"healthy\" : \"degraded\",\n                websocket: \"healthy\",\n                version: \"1.0.0\"\n            };\n        } catch (error) {\n            return {\n                status: \"degraded\",\n                error: error.message,\n                uptime: Date.now() - this.metrics.startTime\n            };\n        }\n    }\n    // Filter analytics by specific metrics\n    filterAnalyticsByMetrics(analytics, metrics) {\n        if (!analytics || !Array.isArray(metrics)) return analytics;\n        const filtered = {};\n        metrics.forEach((metric)=>{\n            if (analytics[metric] !== undefined) {\n                filtered[metric] = analytics[metric];\n            }\n        });\n        return filtered;\n    }\n    // GMP Alert management\n    setupGMPAlert(socketId, ipoId, threshold) {\n        if (!this.gmpAlerts) {\n            this.gmpAlerts = new Map();\n        }\n        const alertKey = `${socketId}:${ipoId}`;\n        this.gmpAlerts.set(alertKey, {\n            threshold,\n            triggered: false,\n            createdAt: Date.now()\n        });\n    }\n    checkGMPAlerts(ipoId, currentGMP) {\n        if (!this.gmpAlerts) return;\n        for (const [alertKey, alert] of this.gmpAlerts){\n            const [socketId, alertIpoId] = alertKey.split(\":\");\n            if (alertIpoId === ipoId && !alert.triggered) {\n                if (currentGMP >= alert.threshold) {\n                    const client = this.connectedClients.get(socketId);\n                    if (client) {\n                        client.socket.emit(this.events.ALERT_TRIGGERED, {\n                            type: \"gmp_threshold\",\n                            ipoId,\n                            threshold: alert.threshold,\n                            currentValue: currentGMP,\n                            timestamp: Date.now()\n                        });\n                        alert.triggered = true;\n                        console.log(`ðŸš¨ GMP alert triggered for ${socketId}: ${ipoId} reached ${currentGMP}`);\n                    }\n                }\n            }\n        }\n    }\n    // Get alert severity\n    getAlertSeverity(alertType) {\n        const severityMap = {\n            gmp_threshold: \"medium\",\n            oversubscription: \"high\",\n            system_error: \"critical\",\n            connection_issue: \"low\",\n            rate_limit: \"medium\"\n        };\n        return severityMap[alertType] || \"low\";\n    }\n    // Message queuing for offline clients\n    queueMessageForOfflineClients(room, message) {\n        if (!this.messageQueue.has(room)) {\n            this.messageQueue.set(room, []);\n        }\n        const queue = this.messageQueue.get(room);\n        queue.push({\n            message,\n            timestamp: Date.now()\n        });\n        // Keep only the latest messages\n        if (queue.length > this.maxQueueSize) {\n            queue.splice(0, queue.length - this.maxQueueSize);\n        }\n    }\n    sendQueuedMessages(socketId) {\n        const client = this.connectedClients.get(socketId);\n        if (!client) return;\n        // Send queued messages for subscribed rooms\n        for (const subscription of client.subscriptions){\n            const queuedMessages = this.messageQueue.get(subscription);\n            if (queuedMessages && queuedMessages.length > 0) {\n                client.socket.emit(\"queued:messages\", {\n                    room: subscription,\n                    messages: queuedMessages,\n                    count: queuedMessages.length\n                });\n                // Clear the queue after sending\n                this.messageQueue.delete(subscription);\n            }\n        }\n    }\n    // Client disconnection handling\n    handleClientDisconnection(socketId, reason) {\n        const client = this.connectedClients.get(socketId);\n        if (client) {\n            // Store disconnection info\n            this.disconnectionLog = this.disconnectionLog || new Map();\n            this.disconnectionLog.set(socketId, {\n                reason,\n                disconnectedAt: Date.now(),\n                subscriptions: Array.from(client.subscriptions),\n                reconnectCount: client.reconnectCount\n            });\n            // Keep only recent disconnections\n            if (this.disconnectionLog.size > 1000) {\n                const entries = Array.from(this.disconnectionLog.entries());\n                entries.sort((a, b)=>b[1].disconnectedAt - a[1].disconnectedAt);\n                this.disconnectionLog = new Map(entries.slice(0, 500));\n            }\n        }\n    }\n    // Authorization check (implement based on your auth system)\n    isAuthorized(socket) {\n        // Implement your authorization logic here\n        // For now, return true for basic functionality\n        return true;\n    }\n    // Enhanced heartbeat with health monitoring\n    startHeartbeat() {\n        setInterval(()=>{\n            const now = Date.now();\n            const staleThreshold = 5 * 60 * 1000; // 5 minutes\n            const staleClients = [];\n            for (const [socketId, client] of this.connectedClients){\n                const timeSinceLastActivity = now - client.lastActivity.getTime();\n                if (timeSinceLastActivity > staleThreshold) {\n                    console.log(`ðŸ§¹ Disconnecting stale client: ${socketId} (inactive for ${Math.round(timeSinceLastActivity / 1000)}s)`);\n                    client.socket.disconnect(true);\n                    staleClients.push(socketId);\n                }\n            }\n            if (staleClients.length > 0) {\n                console.log(`ðŸ§¹ Cleaned up ${staleClients.length} stale connections`);\n            }\n            // Broadcast system heartbeat every 5 minutes\n            if (now % (5 * 60 * 1000) < 60000) {\n                // Within 1 minute of 5-minute mark\n                this.broadcastSystemStatus({\n                    type: \"heartbeat\",\n                    status: \"healthy\",\n                    uptime: now - this.metrics.startTime,\n                    connections: this.metrics.currentConnections,\n                    message: \"System running normally\"\n                });\n            }\n        }, 60000); // Check every minute\n    }\n    // Health monitoring\n    startHealthMonitoring() {\n        setInterval(()=>{\n            const now = Date.now();\n            // Monitor connection health\n            for (const [socketId, health] of this.connectionHealth){\n                if (now - health.lastSeen > 2 * 60 * 1000) {\n                    // 2 minutes\n                    health.status = \"stale\";\n                }\n                if (health.latency > 1000) {\n                    // High latency\n                    health.status = \"degraded\";\n                }\n            }\n            // Clean up old health records\n            const healthEntries = Array.from(this.connectionHealth.entries());\n            const activeClients = new Set(this.connectedClients.keys());\n            for (const [socketId] of healthEntries){\n                if (!activeClients.has(socketId)) {\n                    this.connectionHealth.delete(socketId);\n                }\n            }\n        }, 30000); // Every 30 seconds\n    }\n    // Metrics collection\n    startMetricsCollection() {\n        setInterval(()=>{\n            const stats = this.getDetailedStats();\n            console.log(`ðŸ“Š WebSocket Metrics: Connections: ${stats.connections}, Messages: ${stats.totalMessages}, Uptime: ${Math.round(stats.uptime / 1000)}s`);\n            // Store metrics in cache for monitoring dashboards\n            _cache_js__WEBPACK_IMPORTED_MODULE_2__.cache.set(\"websocket_metrics\", stats, 300); // 5 minutes\n            // Reset hourly counters\n            const now = Date.now();\n            if (now - this.metrics.startTime > 60 * 60 * 1000) {\n                // Every hour\n                this.resetHourlyMetrics();\n            }\n        }, 30000); // Every 30 seconds\n    }\n    // Periodic cleanup\n    startPeriodicCleanup() {\n        setInterval(()=>{\n            // Clean up rate limits\n            const now = Date.now();\n            for (const [key, limit] of this.rateLimits){\n                if (now - limit.windowStart > 60000) {\n                    // 1 minute old\n                    this.rateLimits.delete(key);\n                }\n            }\n            // Clean up old GMP alerts\n            if (this.gmpAlerts) {\n                for (const [key, alert] of this.gmpAlerts){\n                    if (now - alert.createdAt > 24 * 60 * 60 * 1000) {\n                        // 24 hours old\n                        this.gmpAlerts.delete(key);\n                    }\n                }\n            }\n            // Clean up message queues\n            for (const [room, messages] of this.messageQueue){\n                const validMessages = messages.filter((msg)=>now - msg.timestamp < 60 * 60 * 1000 // Keep messages for 1 hour\n                );\n                if (validMessages.length === 0) {\n                    this.messageQueue.delete(room);\n                } else {\n                    this.messageQueue.set(room, validMessages);\n                }\n            }\n        }, 5 * 60 * 1000); // Every 5 minutes\n    }\n    // Reset hourly metrics\n    resetHourlyMetrics() {\n        this.metrics.totalMessages = 0;\n        this.metrics.errors = 0;\n        console.log(\"\\uD83D\\uDCCA Hourly metrics reset\");\n    }\n    // Enhanced statistics\n    getDetailedStats() {\n        const connections = this.connectedClients.size;\n        const rooms = Array.from(this.roomSubscriptions.keys());\n        const totalSubscriptions = Array.from(this.roomSubscriptions.values()).reduce((sum, subs)=>sum + subs.size, 0);\n        // Calculate averages\n        const avgSubscriptionsPerClient = connections > 0 ? parseFloat((totalSubscriptions / connections).toFixed(2)) : 0;\n        // Get memory usage\n        const memoryUsage = process.memoryUsage();\n        // Calculate health stats\n        const healthyConnections = Array.from(this.connectionHealth.values()).filter((h)=>h.status === \"healthy\").length;\n        return {\n            connections,\n            rooms: rooms.length,\n            subscriptions: totalSubscriptions,\n            avgSubscriptionsPerClient,\n            totalMessages: this.metrics.totalMessages,\n            totalConnections: this.metrics.totalConnections,\n            peakConnections: this.metrics.peakConnections,\n            errors: this.metrics.errors,\n            uptime: Date.now() - this.metrics.startTime,\n            rateLimitEntries: this.rateLimits.size,\n            queuedMessages: Array.from(this.messageQueue.values()).reduce((sum, msgs)=>sum + msgs.length, 0),\n            health: {\n                healthy: healthyConnections,\n                degraded: this.connectionHealth.size - healthyConnections,\n                healthRate: this.connectionHealth.size > 0 ? parseFloat((healthyConnections / this.connectionHealth.size * 100).toFixed(2)) : 100\n            },\n            memory: {\n                rss: Math.round(memoryUsage.rss / 1024 / 1024) + \"MB\",\n                heapUsed: Math.round(memoryUsage.heapUsed / 1024 / 1024) + \"MB\",\n                heapTotal: Math.round(memoryUsage.heapTotal / 1024 / 1024) + \"MB\",\n                external: Math.round(memoryUsage.external / 1024 / 1024) + \"MB\"\n            },\n            roomDetails: Object.fromEntries(Array.from(this.roomSubscriptions.entries()).map(([room, subs])=>[\n                    room,\n                    subs.size\n                ])),\n            timestamp: Date.now()\n        };\n    }\n    // Health check\n    getHealthCheck() {\n        const stats = this.getDetailedStats();\n        const isHealthy = this.io && stats.connections >= 0 && !this.isOverloaded();\n        return {\n            status: isHealthy ? \"healthy\" : \"unhealthy\",\n            uptime: stats.uptime,\n            connections: stats.connections,\n            rooms: stats.rooms,\n            subscriptions: stats.subscriptions,\n            averageLoad: this.calculateAverageLoad(),\n            memoryUsage: stats.memory,\n            health: stats.health,\n            errors: stats.errors,\n            lastErrors: this.getRecentErrors(),\n            timestamp: Date.now()\n        };\n    }\n    isOverloaded() {\n        const stats = this.getDetailedStats();\n        const memoryUsage = process.memoryUsage();\n        // Define overload thresholds\n        const maxConnections = parseInt(process.env.WS_MAX_CONNECTIONS) || 10000;\n        const maxMemoryMB = parseInt(process.env.WS_MAX_MEMORY_MB) || 1024;\n        const maxSubscriptions = parseInt(process.env.WS_MAX_SUBSCRIPTIONS) || 50000;\n        return stats.connections > maxConnections || memoryUsage.heapUsed / 1024 / 1024 > maxMemoryMB || stats.subscriptions > maxSubscriptions || stats.errors > 100 // High error rate\n        ;\n    }\n    calculateAverageLoad() {\n        const timeDiff = (Date.now() - this.metrics.startTime) / 1000;\n        const messagesPerSecond = timeDiff > 0 ? this.metrics.totalMessages / timeDiff : 0;\n        const connectionsRatio = this.connectedClients.size / 1000; // Normalize to 1000 connections\n        return parseFloat((messagesPerSecond * connectionsRatio).toFixed(2));\n    }\n    getRecentErrors() {\n        // In a production environment, you'd implement proper error logging\n        return {\n            count: this.metrics.errors,\n            lastErrorTime: this.lastErrorTime || null\n        };\n    }\n    // Client cleanup\n    cleanupClient(socketId) {\n        const client = this.connectedClients.get(socketId);\n        if (client) {\n            // Remove from all room subscriptions\n            for (const subscription of client.subscriptions){\n                const roomSubs = this.roomSubscriptions.get(subscription);\n                if (roomSubs) {\n                    roomSubs.delete(socketId);\n                    if (roomSubs.size === 0) {\n                        this.roomSubscriptions.delete(subscription);\n                    }\n                }\n            }\n            this.connectedClients.delete(socketId);\n        }\n        // Clean up connection health\n        this.connectionHealth.delete(socketId);\n        // Clean up rate limits for this client\n        const keysToDelete = [];\n        for (const [key] of this.rateLimits){\n            if (key.startsWith(socketId)) {\n                keysToDelete.push(key);\n            }\n        }\n        keysToDelete.forEach((key)=>this.rateLimits.delete(key));\n        // Clean up GMP alerts\n        if (this.gmpAlerts) {\n            const alertKeysToDelete = [];\n            for (const [key] of this.gmpAlerts){\n                if (key.startsWith(socketId)) {\n                    alertKeysToDelete.push(key);\n                }\n            }\n            alertKeysToDelete.forEach((key)=>this.gmpAlerts.delete(key));\n        }\n    }\n    // Graceful shutdown\n    async shutdown() {\n        console.log(\"\\uD83D\\uDD0C Shutting down WebSocket service...\");\n        if (this.io) {\n            // Notify all clients about shutdown\n            await this.broadcastSystemStatus({\n                type: \"shutdown\",\n                message: \"Server is shutting down for maintenance\",\n                estimatedDowntime: \"5 minutes\"\n            }, {\n                priority: \"high\"\n            });\n            // Give clients time to receive the message\n            await new Promise((resolve)=>setTimeout(resolve, 3000));\n            // Gracefully disconnect all clients\n            for (const [socketId, client] of this.connectedClients){\n                try {\n                    client.socket.emit(\"server:shutdown\", {\n                        message: \"Server shutting down\",\n                        reconnectIn: 10000\n                    });\n                    client.socket.disconnect(true);\n                } catch (error) {\n                    console.warn(`Error disconnecting client ${socketId}:`, error.message);\n                }\n            }\n            // Close the server\n            this.io.close();\n        }\n        if (this.server) {\n            this.server.close();\n        }\n        // Clear all data structures\n        this.connectedClients.clear();\n        this.roomSubscriptions.clear();\n        this.rateLimits.clear();\n        this.connectionHealth.clear();\n        this.messageQueue.clear();\n        if (this.gmpAlerts) {\n            this.gmpAlerts.clear();\n        }\n        console.log(\"âœ… WebSocket service shutdown complete\");\n    }\n}\n// Export singleton instance\nconst webSocketService = new WebSocketService();\n// Initialize and start if not in test environment\nif (true) {\n    webSocketService.initialize();\n    if (process.env.AUTO_START_WEBSOCKET !== \"false\") {\n        webSocketService.start().catch((error)=>{\n            console.error(\"Failed to start WebSocket service:\", error);\n            process.exit(1);\n        });\n    }\n}\n// Graceful shutdown handlers\nprocess.on(\"SIGTERM\", async ()=>{\n    console.log(\"Received SIGTERM, shutting down WebSocket service gracefully...\");\n    await webSocketService.shutdown();\n    process.exit(0);\n});\nprocess.on(\"SIGINT\", async ()=>{\n    console.log(\"Received SIGINT, shutting down WebSocket service gracefully...\");\n    await webSocketService.shutdown();\n    process.exit(0);\n});\n// Unhandled error handling\nprocess.on(\"uncaughtException\", async (error)=>{\n    console.error(\"Uncaught Exception in WebSocket service:\", error);\n    webSocketService.lastErrorTime = Date.now();\n    webSocketService.metrics.errors++;\n    // Attempt graceful shutdown\n    try {\n        await webSocketService.shutdown();\n    } catch (shutdownError) {\n        console.error(\"Error during emergency shutdown:\", shutdownError);\n    }\n    process.exit(1);\n});\n// Export the io instance for use in other modules\nconst io = webSocketService.io;\n// Export default\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (webSocketService);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9zcmMvbGliL3dlYnNvY2tldC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQW1DO0FBQ0M7QUFDRDtBQUNGO0FBRWpDLE1BQU1JO0lBQ0pDLGFBQWM7UUFDWixJQUFJLENBQUNDLEVBQUUsR0FBRztRQUNWLElBQUksQ0FBQ0MsTUFBTSxHQUFHO1FBQ2QsSUFBSSxDQUFDQyxnQkFBZ0IsR0FBRyxJQUFJQztRQUM1QixJQUFJLENBQUNDLGlCQUFpQixHQUFHLElBQUlEO1FBQzdCLElBQUksQ0FBQ0UsSUFBSSxHQUFHQyxRQUFRQyxHQUFHLENBQUNDLGNBQWMsSUFBSTtRQUUxQyxvQ0FBb0M7UUFDcEMsSUFBSSxDQUFDQyxNQUFNLEdBQUc7WUFDWkMsWUFBWTtZQUNaQyxZQUFZO1lBQ1pDLHFCQUFxQjtZQUNyQkMsZUFBZTtZQUNmQyxrQkFBa0I7WUFDbEJDLGVBQWU7WUFDZkMsa0JBQWtCO1lBQ2xCQyxhQUFhO1lBQ2JDLGlCQUFpQjtRQUNuQjtRQUVBLDhCQUE4QjtRQUM5QixJQUFJLENBQUNDLFVBQVUsR0FBRyxJQUFJaEI7UUFDdEIsSUFBSSxDQUFDaUIsa0JBQWtCLEdBQUc7UUFDMUIsSUFBSSxDQUFDQyx5QkFBeUIsR0FBRztRQUVqQyx5QkFBeUI7UUFDekIsSUFBSSxDQUFDQyxPQUFPLEdBQUc7WUFDYkMsa0JBQWtCO1lBQ2xCQyxvQkFBb0I7WUFDcEJDLGVBQWU7WUFDZkMsb0JBQW9CO1lBQ3BCQyxRQUFRO1lBQ1JDLFdBQVdDLEtBQUtDLEdBQUc7WUFDbkJDLHFCQUFxQjtZQUNyQkMsaUJBQWlCO1FBQ25CO1FBRUEsNkJBQTZCO1FBQzdCLElBQUksQ0FBQ0MsZ0JBQWdCLEdBQUcsSUFBSTlCO1FBRTVCLG9DQUFvQztRQUNwQyxJQUFJLENBQUMrQixZQUFZLEdBQUcsSUFBSS9CO1FBQ3hCLElBQUksQ0FBQ2dDLFlBQVksR0FBRztJQUN0QjtJQUVBLDBEQUEwRDtJQUMxREMsYUFBYTtRQUNYLElBQUk7WUFDRixJQUFJLENBQUNuQyxNQUFNLEdBQUdOLGtEQUFZQTtZQUMxQixJQUFJLENBQUNLLEVBQUUsR0FBRyxJQUFJTiw2Q0FBTUEsQ0FBQyxJQUFJLENBQUNPLE1BQU0sRUFBRTtnQkFDaENvQyxNQUFNO29CQUNKQyxRQUFRaEMsUUFBUUMsR0FBRyxDQUFDZ0MsWUFBWSxJQUFJO29CQUNwQ0MsU0FBUzt3QkFBQzt3QkFBTztxQkFBTztvQkFDeEJDLGFBQWE7Z0JBQ2Y7Z0JBQ0FDLGFBQWE7Z0JBQ2JDLGNBQWM7Z0JBQ2RDLG1CQUFtQjtnQkFDbkJDLFlBQVk7b0JBQUM7b0JBQWE7aUJBQVU7Z0JBQ3BDQyxXQUFXO2dCQUNYLDJCQUEyQjtnQkFDM0JDLGdCQUFnQjtnQkFDaEJDLGdCQUFnQjtZQUNsQjtZQUVBLElBQUksQ0FBQ0Msa0JBQWtCO1lBQ3ZCLElBQUksQ0FBQ0MsY0FBYztZQUNuQixJQUFJLENBQUNDLHNCQUFzQjtZQUMzQixJQUFJLENBQUNDLHFCQUFxQjtZQUUxQkMsUUFBUUMsR0FBRyxDQUFDO1lBQ1osT0FBTyxJQUFJO1FBQ2IsRUFBRSxPQUFPQyxPQUFPO1lBQ2RGLFFBQVFFLEtBQUssQ0FBQyw2Q0FBNkNBO1lBQzNELE1BQU1BO1FBQ1I7SUFDRjtJQUVBLDZCQUE2QjtJQUM3QixNQUFNQyxRQUFRO1FBQ1osSUFBSTtZQUNGLE1BQU0sSUFBSUMsUUFBUSxDQUFDQyxTQUFTQztnQkFDMUIsSUFBSSxDQUFDMUQsTUFBTSxDQUFDMkQsTUFBTSxDQUFDLElBQUksQ0FBQ3ZELElBQUksRUFBRSxDQUFDd0Q7b0JBQzdCLElBQUlBLEtBQUs7d0JBQ1BGLE9BQU9FO29CQUNULE9BQU87d0JBQ0xSLFFBQVFDLEdBQUcsQ0FBQyxDQUFDLG9DQUFvQyxFQUFFLElBQUksQ0FBQ2pELElBQUksQ0FBQyxDQUFDO3dCQUM5RGdELFFBQVFDLEdBQUcsQ0FDVCxDQUFDLCtCQUErQixFQUFFaEQsUUFBUUMsR0FBRyxDQUFDZ0MsWUFBWSxJQUFJLHdCQUF3QixDQUFDO3dCQUV6Rm1CO29CQUNGO2dCQUNGO1lBQ0Y7WUFFQSx5QkFBeUI7WUFDekIsSUFBSSxDQUFDSSxvQkFBb0I7UUFDM0IsRUFBRSxPQUFPUCxPQUFPO1lBQ2RGLFFBQVFFLEtBQUssQ0FBQyx1Q0FBdUNBO1lBQ3JELE1BQU1BO1FBQ1I7SUFDRjtJQUVBLDBCQUEwQjtJQUMxQk4scUJBQXFCO1FBQ25CLElBQUksQ0FBQ2pELEVBQUUsQ0FBQytELEVBQUUsQ0FBQyxjQUFjLENBQUNDO1lBQ3hCLElBQUksQ0FBQ0Msc0JBQXNCLENBQUNEO1lBQzVCLElBQUksQ0FBQ0UseUJBQXlCLENBQUNGO1lBRS9CLGdCQUFnQjtZQUNoQixJQUFJLENBQUMxQyxPQUFPLENBQUNDLGdCQUFnQjtZQUM3QixJQUFJLENBQUNELE9BQU8sQ0FBQ0Usa0JBQWtCO1lBQy9CLElBQUksQ0FBQ0YsT0FBTyxDQUFDVSxlQUFlLEdBQUdtQyxLQUFLQyxHQUFHLENBQ3JDLElBQUksQ0FBQzlDLE9BQU8sQ0FBQ1UsZUFBZSxFQUM1QixJQUFJLENBQUNWLE9BQU8sQ0FBQ0Usa0JBQWtCO1FBRW5DO1FBRUEsdUJBQXVCO1FBQ3ZCLElBQUksQ0FBQ3hCLEVBQUUsQ0FBQytELEVBQUUsQ0FBQyxTQUFTLENBQUNSO1lBQ25CRixRQUFRRSxLQUFLLENBQUMsd0NBQThCQTtZQUM1QyxJQUFJLENBQUNqQyxPQUFPLENBQUNLLE1BQU07UUFDckI7SUFDRjtJQUVBc0MsdUJBQXVCRCxNQUFNLEVBQUU7UUFDN0IsTUFBTUssV0FBV0wsT0FBT00sU0FBUyxDQUFDQyxPQUFPO1FBQ3pDLE1BQU1DLFlBQVlSLE9BQU9NLFNBQVMsQ0FBQ0csT0FBTyxDQUFDLGFBQWEsSUFBSTtRQUU1RHBCLFFBQVFDLEdBQUcsQ0FBQyxDQUFDLHFCQUFxQixFQUFFVSxPQUFPVSxFQUFFLENBQUMsTUFBTSxFQUFFTCxTQUFTLENBQUM7UUFFaEUsTUFBTU0sYUFBYTtZQUNqQlg7WUFDQVksYUFBYSxJQUFJL0M7WUFDakJnRCxlQUFlLElBQUlDO1lBQ25CQyxjQUFjLElBQUlsRDtZQUNsQm1ELG1CQUFtQjtZQUNuQkMsY0FBYztZQUNkVDtZQUNBVSxXQUFXYjtZQUNYYyxXQUFXO1lBQ1hDLFVBQVV2RCxLQUFLQyxHQUFHO1lBQ2xCdUQsZ0JBQWdCO1FBQ2xCO1FBRUEsSUFBSSxDQUFDbkYsZ0JBQWdCLENBQUNvRixHQUFHLENBQUN0QixPQUFPVSxFQUFFLEVBQUVDO1FBQ3JDLElBQUksQ0FBQzFDLGdCQUFnQixDQUFDcUQsR0FBRyxDQUFDdEIsT0FBT1UsRUFBRSxFQUFFO1lBQ25DYSxRQUFRO1lBQ1JDLFNBQVM7WUFDVEMsVUFBVTVELEtBQUtDLEdBQUc7UUFDcEI7UUFFQSxnREFBZ0Q7UUFDaERrQyxPQUFPMEIsSUFBSSxDQUFDLGFBQWE7WUFDdkJDLFVBQVUzQixPQUFPVSxFQUFFO1lBQ25Ca0IsV0FBVy9ELEtBQUtDLEdBQUc7WUFDbkIrRCxlQUFlO1lBQ2ZDLGlCQUFpQkMsT0FBT0MsTUFBTSxDQUFDLElBQUksQ0FBQ3ZGLE1BQU07WUFDMUN3RixrQkFBa0IsSUFBSSxDQUFDNUUseUJBQXlCO1lBQ2hERixZQUFZO2dCQUNWQyxvQkFBb0IsSUFBSSxDQUFDQSxrQkFBa0I7WUFDN0M7WUFDQThFLFVBQVU7Z0JBQ1JDLGlCQUFpQjtnQkFDakJDLG9CQUFvQjtnQkFDcEJsRSxjQUFjO2dCQUNkbUUsV0FBVztZQUNiO1FBQ0Y7UUFFQSw4QkFBOEI7UUFDOUIsSUFBSSxDQUFDQyxrQkFBa0IsQ0FBQ3RDLE9BQU9VLEVBQUU7SUFDbkM7SUFFQVIsMEJBQTBCRixNQUFNLEVBQUU7UUFDaEMsMENBQTBDO1FBQzFDQSxPQUFPRCxFQUFFLENBQUMsaUJBQWlCLE9BQU93QztZQUNoQyxNQUFNLElBQUksQ0FBQ0Msa0JBQWtCLENBQUN4QyxRQUFRLE9BQU91QyxNQUFNO2dCQUNqRCxNQUFNLEVBQUVFLEtBQUssRUFBRUMsTUFBTSxFQUFFQyxtQkFBbUIsS0FBSyxFQUFFLEdBQUdKO2dCQUVwRCxJQUFJRSxPQUFPO29CQUNUekMsT0FBTzRDLElBQUksQ0FBQyxDQUFDLElBQUksRUFBRUgsTUFBTSxDQUFDO29CQUMxQixJQUFJLENBQUNJLGVBQWUsQ0FBQzdDLE9BQU9VLEVBQUUsRUFBRSxPQUFPK0I7b0JBRXZDLGdDQUFnQztvQkFDaEMsTUFBTUssVUFBVSxNQUFNLElBQUksQ0FBQ0MsaUJBQWlCLENBQUNOO29CQUM3QyxJQUFJSyxTQUFTO3dCQUNYOUMsT0FBTzBCLElBQUksQ0FBQyxJQUFJLENBQUNqRixNQUFNLENBQUNDLFVBQVUsRUFBRTs0QkFDbEMrRjs0QkFDQUYsTUFBTU87NEJBQ05FLE1BQU07NEJBQ05wQixXQUFXL0QsS0FBS0MsR0FBRzt3QkFDckI7d0JBRUEsOEJBQThCO3dCQUM5QixJQUFJNkUsb0JBQW9CRyxRQUFRVCxTQUFTLEVBQUU7NEJBQ3pDckMsT0FBTzBCLElBQUksQ0FBQyxJQUFJLENBQUNqRixNQUFNLENBQUNPLGdCQUFnQixFQUFFO2dDQUN4Q3lGO2dDQUNBRixNQUFNTyxRQUFRVCxTQUFTO2dDQUN2QlcsTUFBTTtnQ0FDTnBCLFdBQVcvRCxLQUFLQyxHQUFHOzRCQUNyQjt3QkFDRjtvQkFDRjtnQkFDRjtZQUNGO1FBQ0Y7UUFFQSw0QkFBNEI7UUFDNUJrQyxPQUFPRCxFQUFFLENBQUMsaUJBQWlCLE9BQU93QztZQUNoQyxNQUFNLElBQUksQ0FBQ0Msa0JBQWtCLENBQUN4QyxRQUFRLE9BQU91QyxNQUFNO2dCQUNqRCxNQUFNLEVBQ0pFLEtBQUssRUFDTEMsTUFBTSxFQUNOTyxhQUFhLEtBQUssRUFDbEJDLGlCQUFpQixJQUFJLEVBQ3RCLEdBQUdYO2dCQUVKLElBQUlFLE9BQU87b0JBQ1R6QyxPQUFPNEMsSUFBSSxDQUFDLENBQUMsSUFBSSxFQUFFSCxNQUFNLENBQUM7b0JBQzFCLElBQUksQ0FBQ0ksZUFBZSxDQUFDN0MsT0FBT1UsRUFBRSxFQUFFLE9BQU8rQjtvQkFFdkMsd0JBQXdCO29CQUN4QixNQUFNVSxVQUFVLE1BQU12SCw0Q0FBS0EsQ0FBQ3dILGVBQWUsQ0FBQyxPQUFPWDtvQkFDbkQsSUFBSVUsU0FBUzt3QkFDWG5ELE9BQU8wQixJQUFJLENBQUMsSUFBSSxDQUFDakYsTUFBTSxDQUFDRSxVQUFVLEVBQUU7NEJBQ2xDOEY7NEJBQ0FGLE1BQU1ZOzRCQUNOSCxNQUFNOzRCQUNOcEIsV0FBVy9ELEtBQUtDLEdBQUc7d0JBQ3JCO29CQUNGO29CQUVBLG9DQUFvQztvQkFDcEMsSUFBSW1GLFlBQVk7d0JBQ2QsTUFBTUksZ0JBQWdCLE1BQU0sSUFBSSxDQUFDQyxvQkFBb0IsQ0FBQ2IsT0FBTzt3QkFDN0R6QyxPQUFPMEIsSUFBSSxDQUFDLGtCQUFrQjs0QkFDNUJlOzRCQUNBRixNQUFNYzs0QkFDTkwsTUFBTTs0QkFDTk8sTUFBTTt3QkFDUjtvQkFDRjtvQkFFQSxxQ0FBcUM7b0JBQ3JDLElBQUlMLG1CQUFtQixNQUFNO3dCQUMzQixJQUFJLENBQUNNLGFBQWEsQ0FBQ3hELE9BQU9VLEVBQUUsRUFBRStCLE9BQU9TO29CQUN2QztnQkFDRjtZQUNGO1FBQ0Y7UUFFQSxzQ0FBc0M7UUFDdENsRCxPQUFPRCxFQUFFLENBQUMsMEJBQTBCLE9BQU93QztZQUN6QyxNQUFNLElBQUksQ0FBQ0Msa0JBQWtCLENBQUN4QyxRQUFRLGdCQUFnQnVDLE1BQU07Z0JBQzFELE1BQU0sRUFBRUcsTUFBTSxFQUFFZSxhQUFhLEVBQUUsRUFBRUMsV0FBVyxJQUFJLEVBQUUsR0FBR25CO2dCQUVyRHZDLE9BQU80QyxJQUFJLENBQUMsQ0FBQyxhQUFhLEVBQUVGLE9BQU8sQ0FBQztnQkFDcEMsSUFBSSxDQUFDRyxlQUFlLENBQUM3QyxPQUFPVSxFQUFFLEVBQUUsZ0JBQWdCZ0M7Z0JBRWhELGlDQUFpQztnQkFDakMsTUFBTWlCLFVBQVUsTUFBTS9ILDRDQUFLQSxDQUFDd0gsZUFBZSxDQUFDLGdCQUFnQlY7Z0JBQzVELElBQUlpQixTQUFTO29CQUNYLE1BQU1DLGVBQ0pILFdBQVdJLE1BQU0sR0FBRyxJQUNoQkYsUUFBUXBCLElBQUksRUFBRXVCLE9BQU8sQ0FBQ0MsT0FDcEJOLFdBQVdPLFFBQVEsQ0FBQ0QsS0FBS0UsUUFBUSxLQUVuQ047b0JBRU4zRCxPQUFPMEIsSUFBSSxDQUFDLElBQUksQ0FBQ2pGLE1BQU0sQ0FBQ0csbUJBQW1CLEVBQUU7d0JBQzNDOEY7d0JBQ0FILE1BQU1xQjt3QkFDTkgsWUFBWUEsV0FBV0ksTUFBTSxHQUFHLElBQUlKLGFBQWE7d0JBQ2pEN0IsV0FBVy9ELEtBQUtDLEdBQUc7b0JBQ3JCO2dCQUNGO1lBQ0Y7UUFDRjtRQUVBLDZDQUE2QztRQUM3Q2tDLE9BQU9ELEVBQUUsQ0FBQyxvQkFBb0IsT0FBT3dDO1lBQ25DLE1BQU0sSUFBSSxDQUFDQyxrQkFBa0IsQ0FBQ3hDLFFBQVEsVUFBVXVDLE1BQU07Z0JBQ3BELE1BQU0sRUFBRUcsTUFBTSxFQUFFd0IsYUFBYSxJQUFJLEVBQUVDLGFBQWEsS0FBSyxFQUFFLEdBQUc1QjtnQkFFMUR2QyxPQUFPNEMsSUFBSSxDQUFDLENBQUMsT0FBTyxFQUFFRixPQUFPLENBQUM7Z0JBQzlCLElBQUksQ0FBQ0csZUFBZSxDQUFDN0MsT0FBT1UsRUFBRSxFQUFFLFVBQVVnQztnQkFFMUMsMkJBQTJCO2dCQUMzQixNQUFNMEIsYUFBYSxNQUFNeEksNENBQUtBLENBQUN3SCxlQUFlLENBQUMsVUFBVVY7Z0JBQ3pELElBQUkwQixZQUFZO29CQUNkLElBQUlSLGVBQWVRLFdBQVc3QixJQUFJLElBQUksRUFBRTtvQkFFeEMsZ0JBQWdCO29CQUNoQixJQUFJNEIsWUFBWTt3QkFDZFAsZUFBZUEsYUFBYUUsTUFBTSxDQUFDLENBQUNDLE9BQVNBLEtBQUtNLGVBQWU7b0JBQ25FO29CQUVBLElBQ0VILGNBQ0FBLFdBQVdJLEdBQUcsS0FBS0MsYUFDbkJMLFdBQVc5RCxHQUFHLEtBQUttRSxXQUNuQjt3QkFDQVgsZUFBZUEsYUFBYUUsTUFBTSxDQUNoQyxDQUFDQyxPQUNDQSxLQUFLUyxLQUFLLElBQUlOLFdBQVdJLEdBQUcsSUFBSVAsS0FBS1MsS0FBSyxJQUFJTixXQUFXOUQsR0FBRztvQkFFbEU7b0JBRUFKLE9BQU8wQixJQUFJLENBQUMsSUFBSSxDQUFDakYsTUFBTSxDQUFDSSxhQUFhLEVBQUU7d0JBQ3JDNkY7d0JBQ0FILE1BQU1xQjt3QkFDTmEsU0FBUzs0QkFBRVA7NEJBQVlDO3dCQUFXO3dCQUNsQ3ZDLFdBQVcvRCxLQUFLQyxHQUFHO29CQUNyQjtnQkFDRjtZQUNGO1FBQ0Y7UUFFQSxtREFBbUQ7UUFDbkRrQyxPQUFPRCxFQUFFLENBQUMsdUJBQXVCLE9BQU93QztZQUN0QyxNQUFNLElBQUksQ0FBQ0Msa0JBQWtCLENBQUN4QyxRQUFRLGFBQWF1QyxNQUFNO2dCQUN2RCxNQUFNLEVBQ0pFLEtBQUssRUFDTE8sT0FBTyxLQUFLLEVBQ1oxRixVQUFVLEVBQUUsRUFDWm9ILGlCQUFpQixLQUFLLEVBQ3ZCLEdBQUduQztnQkFFSnZDLE9BQU80QyxJQUFJLENBQUMsQ0FBQyxVQUFVLEVBQUVILE1BQU0sQ0FBQztnQkFDaEMsSUFBSSxDQUFDSSxlQUFlLENBQUM3QyxPQUFPVSxFQUFFLEVBQUUsYUFBYStCO2dCQUU3Qyx5QkFBeUI7Z0JBQ3pCLE1BQU1KLFlBQVksTUFBTSxJQUFJLENBQUNzQyxtQkFBbUIsQ0FBQ2xDLE9BQU9PO2dCQUN4RCxJQUFJWCxXQUFXO29CQUNiLE1BQU11QyxvQkFDSnRILFFBQVF1RyxNQUFNLEdBQUcsSUFDYixJQUFJLENBQUNnQix3QkFBd0IsQ0FBQ3hDLFdBQVcvRSxXQUN6QytFO29CQUVOckMsT0FBTzBCLElBQUksQ0FBQyxJQUFJLENBQUNqRixNQUFNLENBQUNPLGdCQUFnQixFQUFFO3dCQUN4Q3lGO3dCQUNBTzt3QkFDQVQsTUFBTXFDO3dCQUNOdEgsU0FBU0EsUUFBUXVHLE1BQU0sR0FBRyxJQUFJdkcsVUFBVTt3QkFDeENzRSxXQUFXL0QsS0FBS0MsR0FBRztvQkFDckI7Z0JBQ0Y7WUFDRjtRQUNGO1FBRUEsNkJBQTZCO1FBQzdCa0MsT0FBT0QsRUFBRSxDQUFDLG9CQUFvQjtZQUM1QkMsT0FBTzRDLElBQUksQ0FBQztZQUNaLElBQUksQ0FBQ0MsZUFBZSxDQUFDN0MsT0FBT1UsRUFBRSxFQUFFLFVBQVU7WUFFMUMsNkJBQTZCO1lBQzdCLE1BQU1vRSxlQUFlLE1BQU0sSUFBSSxDQUFDQyxlQUFlO1lBQy9DL0UsT0FBTzBCLElBQUksQ0FBQyxJQUFJLENBQUNqRixNQUFNLENBQUNNLGFBQWEsRUFBRTtnQkFDckMsR0FBRytILFlBQVk7Z0JBQ2Y5QixNQUFNO2dCQUNOcEIsV0FBVy9ELEtBQUtDLEdBQUc7WUFDckI7UUFDRjtRQUVBLDZEQUE2RDtRQUM3RGtDLE9BQU9ELEVBQUUsQ0FBQyxtQkFBbUIsT0FBT3dDO1lBQ2xDLE1BQU0sRUFBRTFCLGdCQUFnQixFQUFFLEVBQUVtRSxVQUFVLENBQUMsQ0FBQyxFQUFFLEdBQUd6QztZQUM3QyxNQUFNLEVBQUVOLG1CQUFtQixFQUFFLEVBQUVnRCxhQUFhLElBQUksRUFBRSxHQUFHRDtZQUNyRCxNQUFNRSxVQUFVLEVBQUU7WUFFbEIsbUJBQW1CO1lBQ25CLE1BQU1DLHVCQUF1QnRFLGNBQWN1RSxLQUFLLENBQUMsR0FBR25EO1lBRXBELEtBQUssTUFBTW9ELE9BQU9GLHFCQUFzQjtnQkFDdEMsSUFBSTtvQkFDRixNQUFNLElBQUksQ0FBQ0csd0JBQXdCLENBQUN0RixRQUFRcUY7b0JBQzVDSCxRQUFRSyxJQUFJLENBQUM7d0JBQUUsR0FBR0YsR0FBRzt3QkFBRTlELFFBQVE7b0JBQVU7Z0JBQzNDLEVBQUUsT0FBT2hDLE9BQU87b0JBQ2QyRixRQUFRSyxJQUFJLENBQUM7d0JBQUUsR0FBR0YsR0FBRzt3QkFBRTlELFFBQVE7d0JBQVNoQyxPQUFPQSxNQUFNaUcsT0FBTztvQkFBQztvQkFDN0QsSUFBSSxDQUFDUCxZQUFZO3dCQUNmO29CQUNGO2dCQUNGO1lBQ0Y7WUFFQWpGLE9BQU8wQixJQUFJLENBQUMsMEJBQTBCO2dCQUNwQ3dEO2dCQUNBTyxXQUFXUCxRQUFRckIsTUFBTTtnQkFDekI2QixZQUFZUixRQUFRcEIsTUFBTSxDQUFDLENBQUM2QixJQUFNQSxFQUFFcEUsTUFBTSxLQUFLLFdBQVdzQyxNQUFNO2dCQUNoRWxHLFFBQVF1SCxRQUFRcEIsTUFBTSxDQUFDLENBQUM2QixJQUFNQSxFQUFFcEUsTUFBTSxLQUFLLFNBQVNzQyxNQUFNO2dCQUMxRGpDLFdBQVcvRCxLQUFLQyxHQUFHO1lBQ3JCO1FBQ0Y7UUFFQSxxQ0FBcUM7UUFDckNrQyxPQUFPRCxFQUFFLENBQUMsZUFBZSxDQUFDd0M7WUFDeEIsTUFBTSxFQUFFUyxJQUFJLEVBQUU0QyxVQUFVLEVBQUVDLE9BQU8sRUFBRSxHQUFHdEQ7WUFFdEMsSUFBSXNELFlBQVksT0FBTztnQkFDckIsSUFBSSxDQUFDQyxjQUFjLENBQUM5RixPQUFPVSxFQUFFO2dCQUM3QlYsT0FBTzBCLElBQUksQ0FBQyxzQkFBc0I7b0JBQ2hDbUUsU0FBUztvQkFDVHRFLFFBQVE7b0JBQ1JpRSxTQUFTO2dCQUNYO1lBQ0YsT0FBTyxJQUFJeEMsUUFBUTRDLFlBQVk7Z0JBQzdCLE1BQU1HLFVBQVUsQ0FBQyxFQUFFL0MsS0FBSyxDQUFDLEVBQUU0QyxXQUFXLENBQUM7Z0JBQ3ZDNUYsT0FBT2dHLEtBQUssQ0FBQ0Q7Z0JBQ2IsSUFBSSxDQUFDRSxrQkFBa0IsQ0FBQ2pHLE9BQU9VLEVBQUUsRUFBRXNDLE1BQU00QztnQkFDekM1RixPQUFPMEIsSUFBSSxDQUFDLHNCQUFzQjtvQkFDaENzQjtvQkFDQTRDO29CQUNBckUsUUFBUTtnQkFDVjtZQUNGLE9BQU8sSUFBSXlCLE1BQU07Z0JBQ2Ysd0RBQXdEO2dCQUN4RCxJQUFJLENBQUNrRCxpQkFBaUIsQ0FBQ2xHLE9BQU9VLEVBQUUsRUFBRXNDO2dCQUNsQ2hELE9BQU8wQixJQUFJLENBQUMsc0JBQXNCO29CQUNoQ3NCO29CQUNBekIsUUFBUTtvQkFDUmlFLFNBQVMsQ0FBQyxzQkFBc0IsRUFBRXhDLEtBQUssT0FBTyxDQUFDO2dCQUNqRDtZQUNGO1FBQ0Y7UUFFQSw4Q0FBOEM7UUFDOUNoRCxPQUFPRCxFQUFFLENBQUMsUUFBUSxDQUFDd0M7WUFDakIsTUFBTTRELFNBQVMsSUFBSSxDQUFDakssZ0JBQWdCLENBQUNrSyxHQUFHLENBQUNwRyxPQUFPVSxFQUFFO1lBQ2xELE1BQU01QyxNQUFNRCxLQUFLQyxHQUFHO1lBRXBCLElBQUlxSSxRQUFRO2dCQUNWQSxPQUFPcEYsWUFBWSxHQUFHLElBQUlsRDtnQkFDMUJzSSxPQUFPbEYsWUFBWTtnQkFDbkJrRixPQUFPL0UsUUFBUSxHQUFHdEQ7WUFDcEI7WUFFQSxvQkFBb0I7WUFDcEIsTUFBTTBELFVBQVVlLE1BQU1YLFlBQVk5RCxNQUFNeUUsS0FBS1gsU0FBUyxHQUFHO1lBQ3pELElBQUksQ0FBQzNELGdCQUFnQixDQUFDcUQsR0FBRyxDQUFDdEIsT0FBT1UsRUFBRSxFQUFFO2dCQUNuQ2EsUUFBUTtnQkFDUkM7Z0JBQ0FDLFVBQVUzRDtZQUNaO1lBRUFrQyxPQUFPMEIsSUFBSSxDQUFDLFFBQVE7Z0JBQ2xCRSxXQUFXOUQ7Z0JBQ1h1SSxjQUFjdkksTUFBTSxJQUFJLENBQUNSLE9BQU8sQ0FBQ00sU0FBUztnQkFDMUM0RDtnQkFDQWIsWUFBWXdGLFNBQ1I7b0JBQ0V0RixlQUFlc0YsT0FBT25GLGlCQUFpQjtvQkFDdkNzRixVQUFVSCxPQUFPbEYsWUFBWTtvQkFDN0JzRixjQUFjekksTUFBTXFJLE9BQU92RixXQUFXLENBQUM0RixPQUFPO2dCQUNoRCxJQUNBO1lBQ047UUFDRjtRQUVBLHFDQUFxQztRQUNyQ3hHLE9BQU9ELEVBQUUsQ0FBQyxlQUFlO1lBQ3ZCLE1BQU1vRyxTQUFTLElBQUksQ0FBQ2pLLGdCQUFnQixDQUFDa0ssR0FBRyxDQUFDcEcsT0FBT1UsRUFBRTtZQUNsRCxNQUFNK0YsU0FBUyxJQUFJLENBQUN4SSxnQkFBZ0IsQ0FBQ21JLEdBQUcsQ0FBQ3BHLE9BQU9VLEVBQUU7WUFFbEQsSUFBSXlGLFFBQVE7Z0JBQ1ZuRyxPQUFPMEIsSUFBSSxDQUFDLGVBQWU7b0JBQ3pCQyxVQUFVM0IsT0FBT1UsRUFBRTtvQkFDbkJFLGFBQWF1RixPQUFPdkYsV0FBVztvQkFDL0JDLGVBQWU2RixNQUFNQyxJQUFJLENBQUNSLE9BQU90RixhQUFhO29CQUM5Q0csbUJBQW1CbUYsT0FBT25GLGlCQUFpQjtvQkFDM0NDLGNBQWNrRixPQUFPbEYsWUFBWTtvQkFDakNULFdBQVcyRixPQUFPM0YsU0FBUztvQkFDM0JVLFdBQVdpRixPQUFPakYsU0FBUztvQkFDM0J1RixRQUFRQSxVQUFVO3dCQUFFbEYsUUFBUTtvQkFBVTtvQkFDdENxRixlQUFlO3dCQUNickosa0JBQWtCLElBQUksQ0FBQ0QsT0FBTyxDQUFDRSxrQkFBa0I7d0JBQ2pENkksY0FBY3hJLEtBQUtDLEdBQUcsS0FBSyxJQUFJLENBQUNSLE9BQU8sQ0FBQ00sU0FBUztvQkFDbkQ7Z0JBQ0Y7WUFDRjtRQUNGO1FBRUEsNEJBQTRCO1FBQzVCb0MsT0FBT0QsRUFBRSxDQUFDLGdCQUFnQjtZQUN4QixJQUFJLElBQUksQ0FBQzhHLFlBQVksQ0FBQzdHLFNBQVM7Z0JBQzdCLDhCQUE4QjtnQkFDOUIsTUFBTThHLFFBQVEsSUFBSSxDQUFDQyxnQkFBZ0I7Z0JBQ25DL0csT0FBTzBCLElBQUksQ0FBQyxnQkFBZ0JvRjtZQUM5QixPQUFPO2dCQUNMOUcsT0FBTzBCLElBQUksQ0FBQyxTQUFTO29CQUNuQnNCLE1BQU07b0JBQ053QyxTQUFTO2dCQUNYO1lBQ0Y7UUFDRjtRQUVBLGlCQUFpQjtRQUNqQnhGLE9BQU9ELEVBQUUsQ0FBQyxTQUFTLENBQUNSO1lBQ2xCRixRQUFRRSxLQUFLLENBQUMsQ0FBQyxvQkFBb0IsRUFBRVMsT0FBT1UsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFbkI7WUFDbkQsSUFBSSxDQUFDakMsT0FBTyxDQUFDSyxNQUFNO1lBRW5CLE1BQU13SSxTQUFTLElBQUksQ0FBQ2pLLGdCQUFnQixDQUFDa0ssR0FBRyxDQUFDcEcsT0FBT1UsRUFBRTtZQUNsRCxJQUFJeUYsUUFBUTtnQkFDVkEsT0FBT2hGLFNBQVMsR0FBRztZQUNyQjtZQUVBLElBQUksQ0FBQ2xELGdCQUFnQixDQUFDcUQsR0FBRyxDQUFDdEIsT0FBT1UsRUFBRSxFQUFFO2dCQUNuQ2EsUUFBUTtnQkFDUmhDLE9BQU9BLE1BQU1pRyxPQUFPO2dCQUNwQi9ELFVBQVU1RCxLQUFLQyxHQUFHO1lBQ3BCO1FBQ0Y7UUFFQSxtQ0FBbUM7UUFDbkNrQyxPQUFPRCxFQUFFLENBQUMsY0FBYyxDQUFDaUg7WUFDdkIzSCxRQUFRQyxHQUFHLENBQUMsQ0FBQyx3QkFBd0IsRUFBRVUsT0FBT1UsRUFBRSxDQUFDLFVBQVUsRUFBRXNHLE9BQU8sQ0FBQztZQUVyRSxNQUFNYixTQUFTLElBQUksQ0FBQ2pLLGdCQUFnQixDQUFDa0ssR0FBRyxDQUFDcEcsT0FBT1UsRUFBRTtZQUNsRCxJQUFJeUYsUUFBUTtnQkFDVixzREFBc0Q7Z0JBQ3RELElBQUksQ0FBQ2MseUJBQXlCLENBQUNqSCxPQUFPVSxFQUFFLEVBQUVzRztZQUM1QztZQUVBLElBQUksQ0FBQ0UsYUFBYSxDQUFDbEgsT0FBT1UsRUFBRTtZQUM1QixJQUFJLENBQUNwRCxPQUFPLENBQUNFLGtCQUFrQjtRQUNqQztRQUVBLHdCQUF3QjtRQUN4QndDLE9BQU9ELEVBQUUsQ0FBQyxhQUFhLENBQUN3QztZQUN0QmxELFFBQVFDLEdBQUcsQ0FBQyxDQUFDLHVCQUF1QixFQUFFVSxPQUFPVSxFQUFFLENBQUMsQ0FBQztZQUNqRCxNQUFNeUYsU0FBUyxJQUFJLENBQUNqSyxnQkFBZ0IsQ0FBQ2tLLEdBQUcsQ0FBQ3BHLE9BQU9VLEVBQUU7WUFDbEQsSUFBSXlGLFFBQVE7Z0JBQ1ZBLE9BQU85RSxjQUFjO2dCQUNyQjhFLE9BQU9wRixZQUFZLEdBQUcsSUFBSWxEO2dCQUUxQix1QkFBdUI7Z0JBQ3ZCLElBQUksQ0FBQ3lFLGtCQUFrQixDQUFDdEMsT0FBT1UsRUFBRTtZQUNuQztRQUNGO0lBQ0Y7SUFFQSxpREFBaUQ7SUFDakQsTUFBTThCLG1CQUFtQnhDLE1BQU0sRUFBRWdELElBQUksRUFBRVQsSUFBSSxFQUFFNEUsaUJBQWlCLEVBQUU7UUFDOUQsSUFBSTtZQUNGLE1BQU1oQixTQUFTLElBQUksQ0FBQ2pLLGdCQUFnQixDQUFDa0ssR0FBRyxDQUFDcEcsT0FBT1UsRUFBRTtZQUVsRCxJQUFJLENBQUN5RixRQUFRO2dCQUNYLE1BQU0sSUFBSWlCLE1BQU07WUFDbEI7WUFFQSw0QkFBNEI7WUFDNUIsSUFBSWpCLE9BQU9uRixpQkFBaUIsSUFBSSxJQUFJLENBQUMzRCx5QkFBeUIsRUFBRTtnQkFDOUQsTUFBTSxJQUFJK0osTUFDUixDQUFDLHFDQUFxQyxFQUFFLElBQUksQ0FBQy9KLHlCQUF5QixDQUFDLENBQUMsQ0FBQztZQUU3RTtZQUVBLG9CQUFvQjtZQUNwQixJQUFJLENBQUMsSUFBSSxDQUFDZ0ssY0FBYyxDQUFDckgsT0FBT1UsRUFBRSxFQUFFc0MsT0FBTztnQkFDekMsTUFBTSxJQUFJb0UsTUFBTTtZQUNsQjtZQUVBLDZCQUE2QjtZQUM3QixJQUFJLENBQUNFLHdCQUF3QixDQUFDdEUsTUFBTVQ7WUFFcEMsNkJBQTZCO1lBQzdCLE1BQU00RTtZQUVOLHFCQUFxQjtZQUNyQmhCLE9BQU9wRixZQUFZLEdBQUcsSUFBSWxEO1lBQzFCc0ksT0FBT2xGLFlBQVk7WUFFbkIsNEJBQTRCO1lBQzVCakIsT0FBTzBCLElBQUksQ0FBQyxxQkFBcUI7Z0JBQy9Cc0I7Z0JBQ0FUO2dCQUNBWCxXQUFXL0QsS0FBS0MsR0FBRztnQkFDbkJrRCxtQkFBbUJtRixPQUFPbkYsaUJBQWlCO1lBQzdDO1FBQ0YsRUFBRSxPQUFPekIsT0FBTztZQUNkRixRQUFRRSxLQUFLLENBQUMsQ0FBQyx3QkFBd0IsRUFBRVMsT0FBT1UsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFbkIsTUFBTWlHLE9BQU87WUFDcEV4RixPQUFPMEIsSUFBSSxDQUFDLG1CQUFtQjtnQkFDN0JzQixNQUFNO2dCQUNOd0MsU0FBU2pHLE1BQU1pRyxPQUFPO2dCQUN0QitCLGtCQUFrQnZFO2dCQUNsQlQ7Z0JBQ0FYLFdBQVcvRCxLQUFLQyxHQUFHO1lBQ3JCO1FBQ0Y7SUFDRjtJQUVBLDZCQUE2QjtJQUM3QndKLHlCQUF5QnRFLElBQUksRUFBRVQsSUFBSSxFQUFFO1FBQ25DLE9BQVFTO1lBQ04sS0FBSztnQkFDSCxJQUFJLENBQUNULEtBQUtFLEtBQUssSUFBSSxDQUFDRixLQUFLRyxNQUFNLEVBQUU7b0JBQy9CLE1BQU0sSUFBSTBFLE1BQ1I7Z0JBRUo7Z0JBQ0E7WUFDRixLQUFLO2dCQUNILElBQUksQ0FBQzdFLEtBQUtFLEtBQUssSUFBSSxDQUFDRixLQUFLRyxNQUFNLEVBQUU7b0JBQy9CLE1BQU0sSUFBSTBFLE1BQ1I7Z0JBRUo7Z0JBQ0E7WUFDRixLQUFLO1lBQ0wsS0FBSztnQkFDSCxJQUFJLENBQUM3RSxLQUFLRyxNQUFNLEVBQUU7b0JBQ2hCLE1BQU0sSUFBSTBFLE1BQU07Z0JBQ2xCO2dCQUNBO1lBQ0YsS0FBSztnQkFDSCxJQUFJLENBQUM3RSxLQUFLRSxLQUFLLEVBQUU7b0JBQ2YsTUFBTSxJQUFJMkUsTUFBTTtnQkFDbEI7Z0JBQ0E7UUFDSjtJQUNGO0lBRUEsb0RBQW9EO0lBQ3BELE1BQU05Qix5QkFDSnRGLE1BQU0sRUFDTixFQUFFZ0QsSUFBSSxFQUFFUCxLQUFLLEVBQUVDLE1BQU0sRUFBRXNDLFVBQVUsQ0FBQyxDQUFDLEVBQUUsRUFDckM7UUFDQSxPQUFRaEM7WUFDTixLQUFLO2dCQUNILElBQUlQLE9BQU87b0JBQ1R6QyxPQUFPNEMsSUFBSSxDQUFDLENBQUMsSUFBSSxFQUFFSCxNQUFNLENBQUM7b0JBQzFCLElBQUksQ0FBQ0ksZUFBZSxDQUFDN0MsT0FBT1UsRUFBRSxFQUFFLE9BQU8rQjtnQkFDekM7Z0JBQ0E7WUFDRixLQUFLO2dCQUNILElBQUlBLE9BQU87b0JBQ1R6QyxPQUFPNEMsSUFBSSxDQUFDLENBQUMsSUFBSSxFQUFFSCxNQUFNLENBQUM7b0JBQzFCLElBQUksQ0FBQ0ksZUFBZSxDQUFDN0MsT0FBT1UsRUFBRSxFQUFFLE9BQU8rQjtnQkFDekM7Z0JBQ0E7WUFDRixLQUFLO2dCQUNILElBQUlDLFFBQVE7b0JBQ1YxQyxPQUFPNEMsSUFBSSxDQUFDLENBQUMsYUFBYSxFQUFFRixPQUFPLENBQUM7b0JBQ3BDLElBQUksQ0FBQ0csZUFBZSxDQUFDN0MsT0FBT1UsRUFBRSxFQUFFLGdCQUFnQmdDO2dCQUNsRDtnQkFDQTtZQUNGLEtBQUs7Z0JBQ0gsSUFBSUEsUUFBUTtvQkFDVjFDLE9BQU80QyxJQUFJLENBQUMsQ0FBQyxPQUFPLEVBQUVGLE9BQU8sQ0FBQztvQkFDOUIsSUFBSSxDQUFDRyxlQUFlLENBQUM3QyxPQUFPVSxFQUFFLEVBQUUsVUFBVWdDO2dCQUM1QztnQkFDQTtZQUNGLEtBQUs7Z0JBQ0gsSUFBSUQsT0FBTztvQkFDVHpDLE9BQU80QyxJQUFJLENBQUMsQ0FBQyxVQUFVLEVBQUVILE1BQU0sQ0FBQztvQkFDaEMsSUFBSSxDQUFDSSxlQUFlLENBQUM3QyxPQUFPVSxFQUFFLEVBQUUsYUFBYStCO2dCQUMvQztnQkFDQTtZQUNGO2dCQUNFLE1BQU0sSUFBSTJFLE1BQU0sQ0FBQywyQkFBMkIsRUFBRXBFLEtBQUssQ0FBQztRQUN4RDtJQUNGO0lBRUEseUJBQXlCO0lBQ3pCcUUsZUFBZTFGLFFBQVEsRUFBRTZGLFNBQVMsRUFBRTtRQUNsQyxNQUFNQyxNQUFNLENBQUMsRUFBRTlGLFNBQVMsQ0FBQyxFQUFFNkYsVUFBVSxDQUFDO1FBQ3RDLE1BQU0xSixNQUFNRCxLQUFLQyxHQUFHO1FBQ3BCLE1BQU00SixjQUFjdkgsS0FBS3dILEtBQUssQ0FBQzdKLE1BQU0sUUFBUTtRQUU3QyxJQUFJLENBQUMsSUFBSSxDQUFDWCxVQUFVLENBQUN5SyxHQUFHLENBQUNILE1BQU07WUFDN0IsSUFBSSxDQUFDdEssVUFBVSxDQUFDbUUsR0FBRyxDQUFDbUcsS0FBSztnQkFBRUksT0FBTztnQkFBR0g7WUFBWTtRQUNuRDtRQUVBLE1BQU1JLFFBQVEsSUFBSSxDQUFDM0ssVUFBVSxDQUFDaUosR0FBRyxDQUFDcUI7UUFFbEMsSUFBSUssTUFBTUosV0FBVyxLQUFLQSxhQUFhO1lBQ3JDSSxNQUFNRCxLQUFLLEdBQUc7WUFDZEMsTUFBTUosV0FBVyxHQUFHQTtRQUN0QjtRQUVBLElBQUlJLE1BQU1ELEtBQUssSUFBSSxJQUFJLENBQUN6SyxrQkFBa0IsRUFBRTtZQUMxQyxPQUFPO1FBQ1Q7UUFFQTBLLE1BQU1ELEtBQUs7UUFDWCxPQUFPO0lBQ1Q7SUFFQSwwQkFBMEI7SUFDMUJoRixnQkFBZ0JsQixRQUFRLEVBQUVxQixJQUFJLEVBQUU0QyxVQUFVLEVBQUU7UUFDMUMsTUFBTU8sU0FBUyxJQUFJLENBQUNqSyxnQkFBZ0IsQ0FBQ2tLLEdBQUcsQ0FBQ3pFO1FBQ3pDLElBQUl3RSxRQUFRO1lBQ1YsTUFBTTRCLGtCQUFrQixDQUFDLEVBQUUvRSxLQUFLLENBQUMsRUFBRTRDLFdBQVcsQ0FBQztZQUMvQ08sT0FBT3RGLGFBQWEsQ0FBQ21ILEdBQUcsQ0FBQ0Q7WUFDekI1QixPQUFPbkYsaUJBQWlCLEdBQUdtRixPQUFPdEYsYUFBYSxDQUFDb0gsSUFBSTtZQUVwRCwyQkFBMkI7WUFDM0IsSUFBSSxDQUFDLElBQUksQ0FBQzdMLGlCQUFpQixDQUFDd0wsR0FBRyxDQUFDRyxrQkFBa0I7Z0JBQ2hELElBQUksQ0FBQzNMLGlCQUFpQixDQUFDa0YsR0FBRyxDQUFDeUcsaUJBQWlCLElBQUlqSDtZQUNsRDtZQUNBLElBQUksQ0FBQzFFLGlCQUFpQixDQUFDZ0ssR0FBRyxDQUFDMkIsaUJBQWlCQyxHQUFHLENBQUNyRztZQUVoRCxJQUFJLENBQUNyRSxPQUFPLENBQUNJLGtCQUFrQjtRQUNqQztJQUNGO0lBRUF1SSxtQkFBbUJ0RSxRQUFRLEVBQUVxQixJQUFJLEVBQUU0QyxVQUFVLEVBQUU7UUFDN0MsTUFBTU8sU0FBUyxJQUFJLENBQUNqSyxnQkFBZ0IsQ0FBQ2tLLEdBQUcsQ0FBQ3pFO1FBQ3pDLElBQUl3RSxRQUFRO1lBQ1YsTUFBTTRCLGtCQUFrQixDQUFDLEVBQUUvRSxLQUFLLENBQUMsRUFBRTRDLFdBQVcsQ0FBQztZQUMvQ08sT0FBT3RGLGFBQWEsQ0FBQ3FILE1BQU0sQ0FBQ0g7WUFDNUI1QixPQUFPbkYsaUJBQWlCLEdBQUdtRixPQUFPdEYsYUFBYSxDQUFDb0gsSUFBSTtZQUVwRCxpQ0FBaUM7WUFDakMsTUFBTUUsV0FBVyxJQUFJLENBQUMvTCxpQkFBaUIsQ0FBQ2dLLEdBQUcsQ0FBQzJCO1lBQzVDLElBQUlJLFVBQVU7Z0JBQ1pBLFNBQVNELE1BQU0sQ0FBQ3ZHO2dCQUNoQixJQUFJd0csU0FBU0YsSUFBSSxLQUFLLEdBQUc7b0JBQ3ZCLElBQUksQ0FBQzdMLGlCQUFpQixDQUFDOEwsTUFBTSxDQUFDSDtnQkFDaEM7WUFDRjtRQUNGO0lBQ0Y7SUFFQWpDLGVBQWVuRSxRQUFRLEVBQUU7UUFDdkIsTUFBTXdFLFNBQVMsSUFBSSxDQUFDakssZ0JBQWdCLENBQUNrSyxHQUFHLENBQUN6RTtRQUN6QyxJQUFJd0UsUUFBUTtZQUNWLEtBQUssTUFBTWlDLGdCQUFnQmpDLE9BQU90RixhQUFhLENBQUU7Z0JBQy9DLE1BQU0sQ0FBQ21DLE1BQU00QyxXQUFXLEdBQUd3QyxhQUFhQyxLQUFLLENBQUM7Z0JBQzlDbEMsT0FBT25HLE1BQU0sQ0FBQ2dHLEtBQUssQ0FBQ29DO2dCQUNwQixJQUFJLENBQUNuQyxrQkFBa0IsQ0FBQ3RFLFVBQVVxQixNQUFNNEM7WUFDMUM7UUFDRjtJQUNGO0lBRUFNLGtCQUFrQnZFLFFBQVEsRUFBRXFCLElBQUksRUFBRTtRQUNoQyxNQUFNbUQsU0FBUyxJQUFJLENBQUNqSyxnQkFBZ0IsQ0FBQ2tLLEdBQUcsQ0FBQ3pFO1FBQ3pDLElBQUl3RSxRQUFRO1lBQ1YsTUFBTW1DLHdCQUF3QjVCLE1BQU1DLElBQUksQ0FBQ1IsT0FBT3RGLGFBQWEsRUFBRWlELE1BQU0sQ0FDbkUsQ0FBQ3VCLE1BQVFBLElBQUlrRCxVQUFVLENBQUMsQ0FBQyxFQUFFdkYsS0FBSyxDQUFDLENBQUM7WUFHcEMsS0FBSyxNQUFNb0YsZ0JBQWdCRSxzQkFBdUI7Z0JBQ2hELE1BQU0sR0FBRzFDLFdBQVcsR0FBR3dDLGFBQWFDLEtBQUssQ0FBQztnQkFDMUNsQyxPQUFPbkcsTUFBTSxDQUFDZ0csS0FBSyxDQUFDb0M7Z0JBQ3BCLElBQUksQ0FBQ25DLGtCQUFrQixDQUFDdEUsVUFBVXFCLE1BQU00QztZQUMxQztRQUNGO0lBQ0Y7SUFFQSxnQ0FBZ0M7SUFDaEMsTUFBTTRDLG1CQUFtQi9GLEtBQUssRUFBRWdHLFVBQVUsRUFBRXpELFVBQVUsQ0FBQyxDQUFDLEVBQUU7UUFDeEQsSUFBSTtZQUNGLE1BQU0sRUFDSjBELFdBQVcsUUFBUSxFQUNuQkMsZ0JBQWdCLElBQUksRUFDcEJoRyxtQkFBbUIsS0FBSyxFQUN6QixHQUFHcUM7WUFFSixJQUFJLENBQUMsSUFBSSxDQUFDNEQsdUJBQXVCLENBQUMsT0FBT25HLFFBQVE7Z0JBQy9DO1lBQ0Y7WUFFQSxNQUFNb0csT0FBTyxDQUFDLElBQUksRUFBRXBHLE1BQU0sQ0FBQztZQUMzQixNQUFNcUcsa0JBQWtCLElBQUksQ0FBQzFNLGlCQUFpQixDQUFDZ0ssR0FBRyxDQUFDeUMsT0FBT1osUUFBUTtZQUVsRSxJQUFJYSxrQkFBa0IsR0FBRztnQkFDdkIsTUFBTUMsZUFBZTtvQkFDbkJ0RztvQkFDQUYsTUFBTWtHO29CQUNON0csV0FBVy9ELEtBQUtDLEdBQUc7b0JBQ25CNEs7b0JBQ0F6TSxRQUFRSyxRQUFRQyxHQUFHLENBQUN5TSxTQUFTLElBQUk7b0JBQ2pDaEcsTUFBTTtnQkFDUjtnQkFFQSxJQUFJTCxvQkFBb0I4RixXQUFXcEcsU0FBUyxFQUFFO29CQUM1QzBHLGFBQWExRyxTQUFTLEdBQUdvRyxXQUFXcEcsU0FBUztnQkFDL0M7Z0JBRUEsSUFBSXNHLGVBQWU7b0JBQ2pCLElBQUksQ0FBQzNNLEVBQUUsQ0FDSmlOLEVBQUUsQ0FBQ0osTUFDSEssTUFBTSxDQUFDUCxlQUNQakgsSUFBSSxDQUFDLElBQUksQ0FBQ2pGLE1BQU0sQ0FBQ0MsVUFBVSxFQUFFcU07Z0JBQ2xDLE9BQU87b0JBQ0wsSUFBSSxDQUFDL00sRUFBRSxDQUFDaU4sRUFBRSxDQUFDSixNQUFNbkgsSUFBSSxDQUFDLElBQUksQ0FBQ2pGLE1BQU0sQ0FBQ0MsVUFBVSxFQUFFcU07Z0JBQ2hEO2dCQUVBMUosUUFBUUMsR0FBRyxDQUNULENBQUMsMkJBQTJCLEVBQUV3SixnQkFBZ0IsaUJBQWlCLEVBQUVyRyxNQUFNLENBQUM7Z0JBRTFFLElBQUksQ0FBQ25GLE9BQU8sQ0FBQ0csYUFBYTtnQkFFMUIsZ0RBQWdEO2dCQUNoRCxJQUFJaUwsYUFBYSxRQUFRO29CQUN2QixJQUFJLENBQUNTLDZCQUE2QixDQUFDTixNQUFNRTtnQkFDM0M7WUFDRjtRQUNGLEVBQUUsT0FBT3hKLE9BQU87WUFDZEYsUUFBUUUsS0FBSyxDQUFDLGtDQUFrQ0E7WUFDaEQsSUFBSSxDQUFDakMsT0FBTyxDQUFDSyxNQUFNO1FBQ3JCO0lBQ0Y7SUFFQSxNQUFNeUwsbUJBQW1CM0csS0FBSyxFQUFFVSxPQUFPLEVBQUU2QixVQUFVLENBQUMsQ0FBQyxFQUFFO1FBQ3JELElBQUk7WUFDRixNQUFNLEVBQUUvQixhQUFhLEtBQUssRUFBRW9HLGFBQWEsSUFBSSxFQUFFLEdBQUdyRTtZQUVsRCxJQUFJLENBQUMsSUFBSSxDQUFDNEQsdUJBQXVCLENBQUMsT0FBT25HLFFBQVE7Z0JBQy9DO1lBQ0Y7WUFFQSxNQUFNb0csT0FBTyxDQUFDLElBQUksRUFBRXBHLE1BQU0sQ0FBQztZQUMzQixNQUFNcUcsa0JBQWtCLElBQUksQ0FBQzFNLGlCQUFpQixDQUFDZ0ssR0FBRyxDQUFDeUMsT0FBT1osUUFBUTtZQUVsRSxJQUFJYSxrQkFBa0IsR0FBRztnQkFDdkIsTUFBTVEsU0FBUyxNQUFNLElBQUksQ0FBQ0Msa0JBQWtCLENBQUM5RyxPQUFPVSxRQUFRcUcsS0FBSztnQkFDakUsTUFBTVQsZUFBZTtvQkFDbkJ0RztvQkFDQUYsTUFBTVk7b0JBQ052QixXQUFXL0QsS0FBS0MsR0FBRztvQkFDbkJtRjtvQkFDQXFHO29CQUNBRyxPQUFPLElBQUksQ0FBQ0MsaUJBQWlCLENBQUNKO29CQUM5QkssWUFBWSxNQUFNLElBQUksQ0FBQ0Msc0JBQXNCLENBQUNuSDtnQkFDaEQ7Z0JBRUEsSUFBSSxDQUFDekcsRUFBRSxDQUFDaU4sRUFBRSxDQUFDSixNQUFNbkgsSUFBSSxDQUFDLElBQUksQ0FBQ2pGLE1BQU0sQ0FBQ0UsVUFBVSxFQUFFb007Z0JBQzlDMUosUUFBUUMsR0FBRyxDQUNULENBQUMsMkJBQTJCLEVBQUV3SixnQkFBZ0IsaUJBQWlCLEVBQUVyRyxNQUFNLFNBQVMsRUFBRVUsUUFBUXFHLEtBQUssQ0FBQyxDQUFDLENBQUM7Z0JBRXBHLElBQUksQ0FBQ2xNLE9BQU8sQ0FBQ0csYUFBYTtnQkFFMUIsdUJBQXVCO2dCQUN2QixJQUFJNEwsWUFBWTtvQkFDZCxJQUFJLENBQUNRLGNBQWMsQ0FBQ3BILE9BQU9VLFFBQVFxRyxLQUFLO2dCQUMxQztZQUNGO1FBQ0YsRUFBRSxPQUFPakssT0FBTztZQUNkRixRQUFRRSxLQUFLLENBQUMsa0NBQWtDQTtZQUNoRCxJQUFJLENBQUNqQyxPQUFPLENBQUNLLE1BQU07UUFDckI7SUFDRjtJQUVBLE1BQU1tTSw0QkFBNEJwSCxNQUFNLEVBQUVxSCxnQkFBZ0IsRUFBRS9FLFVBQVUsQ0FBQyxDQUFDLEVBQUU7UUFDeEUsSUFBSTtZQUNGLE1BQU0sRUFBRWYsV0FBVyxJQUFJLEVBQUUrRiwwQkFBMEIsSUFBSSxFQUFFLEdBQUdoRjtZQUU1RCxJQUFJLENBQUMsSUFBSSxDQUFDNEQsdUJBQXVCLENBQUMsZ0JBQWdCbEcsU0FBUztnQkFDekQ7WUFDRjtZQUVBLE1BQU1tRyxPQUFPLENBQUMsYUFBYSxFQUFFbkcsT0FBTyxDQUFDO1lBQ3JDLE1BQU1vRyxrQkFBa0IsSUFBSSxDQUFDMU0saUJBQWlCLENBQUNnSyxHQUFHLENBQUN5QyxPQUFPWixRQUFRO1lBRWxFLElBQUlhLGtCQUFrQixHQUFHO2dCQUN2QixNQUFNQyxlQUFlO29CQUNuQnJHO29CQUNBSCxNQUFNd0g7b0JBQ05uSSxXQUFXL0QsS0FBS0MsR0FBRztvQkFDbkJtRztvQkFDQWdHLHFCQUNFLElBQUksQ0FBQ0MsNEJBQTRCLENBQUNIO29CQUNwQ0ksa0JBQWtCLElBQUksQ0FBQ0EsZ0JBQWdCLENBQUNKO2dCQUMxQztnQkFFQSxJQUFJLENBQUMvTixFQUFFLENBQUNpTixFQUFFLENBQUNKLE1BQU1uSCxJQUFJLENBQUMsSUFBSSxDQUFDakYsTUFBTSxDQUFDRyxtQkFBbUIsRUFBRW1NO2dCQUN2RDFKLFFBQVFDLEdBQUcsQ0FDVCxDQUFDLG9DQUFvQyxFQUFFd0osZ0JBQWdCLGFBQWEsRUFBRXBHLE9BQU8sQ0FBQztnQkFFaEYsSUFBSSxDQUFDcEYsT0FBTyxDQUFDRyxhQUFhO2dCQUUxQiw0QkFBNEI7Z0JBQzVCLElBQUl1TSwyQkFBMkJqQixhQUFhb0IsZ0JBQWdCLEVBQUU7b0JBQzVELElBQUksQ0FBQ0MsY0FBYyxDQUFDLG9CQUFvQjt3QkFDdEMxSDt3QkFDQTBGLGNBQWNXLGFBQWFrQixtQkFBbUI7d0JBQzlDckksV0FBVy9ELEtBQUtDLEdBQUc7b0JBQ3JCO2dCQUNGO1lBQ0Y7UUFDRixFQUFFLE9BQU95QixPQUFPO1lBQ2RGLFFBQVFFLEtBQUssQ0FBQywyQ0FBMkNBO1lBQ3pELElBQUksQ0FBQ2pDLE9BQU8sQ0FBQ0ssTUFBTTtRQUNyQjtJQUNGO0lBRUEsTUFBTTBNLHNCQUFzQjNILE1BQU0sRUFBRTBCLFVBQVUsRUFBRVksVUFBVSxDQUFDLENBQUMsRUFBRTtRQUM1RCxJQUFJO1lBQ0YsTUFBTSxFQUFFc0YsYUFBYSxJQUFJLEVBQUUsR0FBR3RGO1lBRTlCLElBQUksQ0FBQyxJQUFJLENBQUM0RCx1QkFBdUIsQ0FBQyxVQUFVbEcsU0FBUztnQkFDbkQ7WUFDRjtZQUVBLE1BQU1tRyxPQUFPLENBQUMsT0FBTyxFQUFFbkcsT0FBTyxDQUFDO1lBQy9CLE1BQU1vRyxrQkFBa0IsSUFBSSxDQUFDMU0saUJBQWlCLENBQUNnSyxHQUFHLENBQUN5QyxPQUFPWixRQUFRO1lBRWxFLElBQUlhLGtCQUFrQixHQUFHO2dCQUN2QixNQUFNQyxlQUFlO29CQUNuQnJHO29CQUNBSCxNQUFNNkI7b0JBQ054QyxXQUFXL0QsS0FBS0MsR0FBRztvQkFDbkJ3TTtvQkFDQUMsYUFBYSxJQUFJLENBQUNDLG9CQUFvQixDQUFDcEc7b0JBQ3ZDcUcsY0FBYyxJQUFJLENBQUNDLHFCQUFxQixDQUFDdEc7Z0JBQzNDO2dCQUVBLElBQUksQ0FBQ3BJLEVBQUUsQ0FBQ2lOLEVBQUUsQ0FBQ0osTUFBTW5ILElBQUksQ0FBQyxJQUFJLENBQUNqRixNQUFNLENBQUNJLGFBQWEsRUFBRWtNO2dCQUNqRDFKLFFBQVFDLEdBQUcsQ0FDVCxDQUFDLDhCQUE4QixFQUFFd0osZ0JBQWdCLGFBQWEsRUFBRXBHLE9BQU8sQ0FBQztnQkFFMUUsSUFBSSxDQUFDcEYsT0FBTyxDQUFDRyxhQUFhO1lBQzVCO1FBQ0YsRUFBRSxPQUFPOEIsT0FBTztZQUNkRixRQUFRRSxLQUFLLENBQUMscUNBQXFDQTtZQUNuRCxJQUFJLENBQUNqQyxPQUFPLENBQUNLLE1BQU07UUFDckI7SUFDRjtJQUVBLE1BQU1nTix5QkFBeUJsSSxLQUFLLEVBQUVtSSxhQUFhLEVBQUU1RixVQUFVLENBQUMsQ0FBQyxFQUFFO1FBQ2pFLElBQUk7WUFDRixNQUFNLEVBQUVoQyxPQUFPLFNBQVMsRUFBRTFGLFVBQVUsSUFBSSxFQUFFLEdBQUcwSDtZQUU3QyxJQUFJLENBQUMsSUFBSSxDQUFDNEQsdUJBQXVCLENBQUMsYUFBYW5HLFFBQVE7Z0JBQ3JEO1lBQ0Y7WUFFQSxNQUFNb0csT0FBTyxDQUFDLFVBQVUsRUFBRXBHLE1BQU0sQ0FBQztZQUNqQyxNQUFNcUcsa0JBQWtCLElBQUksQ0FBQzFNLGlCQUFpQixDQUFDZ0ssR0FBRyxDQUFDeUMsT0FBT1osUUFBUTtZQUVsRSxJQUFJYSxrQkFBa0IsR0FBRztnQkFDdkIsTUFBTUMsZUFBZTtvQkFDbkJ0RztvQkFDQU87b0JBQ0FULE1BQU1xSTtvQkFDTnROO29CQUNBc0UsV0FBVy9ELEtBQUtDLEdBQUc7b0JBQ25CK00sVUFBVSxNQUFNLElBQUksQ0FBQ0MseUJBQXlCLENBQUNGO2dCQUNqRDtnQkFFQSxJQUFJLENBQUM1TyxFQUFFLENBQUNpTixFQUFFLENBQUNKLE1BQU1uSCxJQUFJLENBQUMsSUFBSSxDQUFDakYsTUFBTSxDQUFDTyxnQkFBZ0IsRUFBRStMO2dCQUNwRDFKLFFBQVFDLEdBQUcsQ0FDVCxDQUFDLGlDQUFpQyxFQUFFd0osZ0JBQWdCLGlCQUFpQixFQUFFckcsTUFBTSxDQUFDO2dCQUVoRixJQUFJLENBQUNuRixPQUFPLENBQUNHLGFBQWE7WUFDNUI7UUFDRixFQUFFLE9BQU84QixPQUFPO1lBQ2RGLFFBQVFFLEtBQUssQ0FBQyx3Q0FBd0NBO1lBQ3RELElBQUksQ0FBQ2pDLE9BQU8sQ0FBQ0ssTUFBTTtRQUNyQjtJQUNGO0lBRUEsMEJBQTBCO0lBQzFCLE1BQU1vTixzQkFBc0J4SixNQUFNLEVBQUV5RCxVQUFVLENBQUMsQ0FBQyxFQUFFO1FBQ2hELElBQUk7WUFDRixNQUFNLEVBQUUwRCxXQUFXLFFBQVEsRUFBRUcsT0FBTyxlQUFlLEVBQUUsR0FBRzdEO1lBQ3hELE1BQU04RCxrQkFBa0IsSUFBSSxDQUFDMU0saUJBQWlCLENBQUNnSyxHQUFHLENBQUN5QyxPQUFPWixRQUFRO1lBRWxFLElBQUlhLGtCQUFrQixHQUFHO2dCQUN2QixNQUFNa0MsaUJBQWlCO29CQUNyQixHQUFHekosTUFBTTtvQkFDVEssV0FBVy9ELEtBQUtDLEdBQUc7b0JBQ25CN0IsUUFBUUssUUFBUUMsR0FBRyxDQUFDeU0sU0FBUyxJQUFJO29CQUNqQ047b0JBQ0F1QyxhQUFhLElBQUksQ0FBQzNOLE9BQU8sQ0FBQ0Usa0JBQWtCO2dCQUM5QztnQkFFQSxJQUFJLENBQUN4QixFQUFFLENBQUNpTixFQUFFLENBQUNKLE1BQU1uSCxJQUFJLENBQUMsSUFBSSxDQUFDakYsTUFBTSxDQUFDTSxhQUFhLEVBQUVpTztnQkFDakQzTCxRQUFRQyxHQUFHLENBQUMsQ0FBQyw4QkFBOEIsRUFBRXdKLGdCQUFnQixRQUFRLENBQUM7Z0JBQ3RFLElBQUksQ0FBQ3hMLE9BQU8sQ0FBQ0csYUFBYTtZQUM1QjtRQUNGLEVBQUUsT0FBTzhCLE9BQU87WUFDZEYsUUFBUUUsS0FBSyxDQUFDLHFDQUFxQ0E7WUFDbkQsSUFBSSxDQUFDakMsT0FBTyxDQUFDSyxNQUFNO1FBQ3JCO0lBQ0Y7SUFFQSxtQkFBbUI7SUFDbkIsTUFBTXlNLGVBQWVjLFNBQVMsRUFBRUMsU0FBUyxFQUFFO1FBQ3pDLElBQUk7WUFDRixNQUFNQyxnQkFBZ0I7Z0JBQ3BCcEksTUFBTWtJO2dCQUNOM0ksTUFBTTRJO2dCQUNOdkosV0FBVy9ELEtBQUtDLEdBQUc7Z0JBQ25CN0IsUUFBUUssUUFBUUMsR0FBRyxDQUFDeU0sU0FBUyxJQUFJO2dCQUNqQ3FDLFVBQVUsSUFBSSxDQUFDQyxnQkFBZ0IsQ0FBQ0o7WUFDbEM7WUFFQSxxQ0FBcUM7WUFDckMsSUFBSSxDQUFDbFAsRUFBRSxDQUFDMEYsSUFBSSxDQUFDLElBQUksQ0FBQ2pGLE1BQU0sQ0FBQ1MsZUFBZSxFQUFFa087WUFDMUMvTCxRQUFRQyxHQUFHLENBQUMsQ0FBQyxvQkFBb0IsRUFBRTRMLFVBQVUsQ0FBQztZQUM5QyxJQUFJLENBQUM1TixPQUFPLENBQUNHLGFBQWE7WUFFMUIsMEJBQTBCO1lBQzFCLElBQUksQ0FBQzBMLDZCQUE2QixDQUFDLFVBQVVpQztRQUMvQyxFQUFFLE9BQU83TCxPQUFPO1lBQ2RGLFFBQVFFLEtBQUssQ0FBQyw2QkFBNkJBO1lBQzNDLElBQUksQ0FBQ2pDLE9BQU8sQ0FBQ0ssTUFBTTtRQUNyQjtJQUNGO0lBRUEsMEJBQTBCO0lBQzFCaUwsd0JBQXdCcEIsU0FBUyxFQUFFNUIsVUFBVSxFQUFFO1FBQzdDLE1BQU02QixNQUFNLENBQUMsVUFBVSxFQUFFRCxVQUFVLENBQUMsRUFBRTVCLFdBQVcsQ0FBQztRQUNsRCxNQUFNOUgsTUFBTUQsS0FBS0MsR0FBRztRQUNwQixNQUFNNEosY0FBY3ZILEtBQUt3SCxLQUFLLENBQUM3SixNQUFNLFFBQVEsTUFBTSxrQkFBa0I7UUFFckUsSUFBSSxDQUFDLElBQUksQ0FBQ1gsVUFBVSxDQUFDeUssR0FBRyxDQUFDSCxNQUFNO1lBQzdCLElBQUksQ0FBQ3RLLFVBQVUsQ0FBQ21FLEdBQUcsQ0FBQ21HLEtBQUs7Z0JBQUVJLE9BQU87Z0JBQUdIO1lBQVk7UUFDbkQ7UUFFQSxNQUFNSSxRQUFRLElBQUksQ0FBQzNLLFVBQVUsQ0FBQ2lKLEdBQUcsQ0FBQ3FCO1FBRWxDLElBQUlLLE1BQU1KLFdBQVcsS0FBS0EsYUFBYTtZQUNyQ0ksTUFBTUQsS0FBSyxHQUFHO1lBQ2RDLE1BQU1KLFdBQVcsR0FBR0E7UUFDdEI7UUFFQSxpREFBaUQ7UUFDakQsSUFBSUksTUFBTUQsS0FBSyxJQUFJLElBQUk7WUFDckIsT0FBTztRQUNUO1FBRUFDLE1BQU1ELEtBQUs7UUFDWCxPQUFPO0lBQ1Q7SUFFQSxpQ0FBaUM7SUFDakMsTUFBTTBCLG1CQUFtQjlHLEtBQUssRUFBRThJLFlBQVksRUFBRTtRQUM1QyxJQUFJO1lBQ0YsSUFBSSxDQUFDLElBQUksQ0FBQ0MsaUJBQWlCLEVBQUU7Z0JBQzNCLElBQUksQ0FBQ0EsaUJBQWlCLEdBQUcsSUFBSXJQO1lBQy9CO1lBRUEsTUFBTXNQLGdCQUFnQixJQUFJLENBQUNELGlCQUFpQixDQUFDcEYsR0FBRyxDQUFDM0QsVUFBVThJO1lBQzNELElBQUksQ0FBQ0MsaUJBQWlCLENBQUNsSyxHQUFHLENBQUNtQixPQUFPOEk7WUFFbEMsT0FBTztnQkFDTEcsVUFBVUgsZUFBZUU7Z0JBQ3pCRSxZQUNFRixnQkFBZ0IsSUFDWkcsV0FDRSxDQUNFLENBQUVMLGVBQWVFLGFBQVksSUFBS0EsZ0JBQ2xDLEdBQUUsRUFDRkksT0FBTyxDQUFDLE1BRVo7Z0JBQ05DLFdBQ0VQLGVBQWVFLGdCQUNYLE9BQ0FGLGVBQWVFLGdCQUNiLFNBQ0E7WUFDVjtRQUNGLEVBQUUsT0FBT2xNLE9BQU87WUFDZCxPQUFPO2dCQUFFbU0sVUFBVTtnQkFBR0MsWUFBWTtnQkFBR0csV0FBVztZQUFTO1FBQzNEO0lBQ0Y7SUFFQXBDLGtCQUFrQkosTUFBTSxFQUFFO1FBQ3hCLElBQUluSixLQUFLNEwsR0FBRyxDQUFDekMsT0FBT3FDLFVBQVUsSUFBSSxHQUFHLE9BQU87UUFDNUMsSUFBSXJDLE9BQU9xQyxVQUFVLEdBQUcsR0FBRyxPQUFPO1FBQ2xDLElBQUlyQyxPQUFPcUMsVUFBVSxHQUFHLENBQUMsR0FBRyxPQUFPO1FBQ25DLE9BQU9yQyxPQUFPd0MsU0FBUztJQUN6QjtJQUVBLE1BQU1sQyx1QkFBdUJuSCxLQUFLLEVBQUU7UUFDbEMsSUFBSTtZQUNGLE1BQU11SixZQUFZLE1BQU1uUSwwQ0FBTUEsQ0FBQ29RLEdBQUcsQ0FBQ0MsUUFBUSxDQUFDO2dCQUMxQ0MsT0FBTztvQkFBRTFKO2dCQUFNO2dCQUNmMkosU0FBUztvQkFBRXhLLFdBQVc7Z0JBQU87Z0JBQzdCeUssTUFBTTtZQUNSO1lBRUEsSUFBSUwsVUFBVW5JLE1BQU0sR0FBRyxHQUFHLE9BQU87WUFFakMsTUFBTTdCLFNBQVNnSyxVQUFVTSxHQUFHLENBQUMsQ0FBQ0MsSUFBTUEsRUFBRS9DLEtBQUs7WUFDM0MsTUFBTWdELE9BQU94SyxPQUFPeUssTUFBTSxDQUFDLENBQUNDLEdBQUdDLElBQU1ELElBQUlDLEtBQUszSyxPQUFPNkIsTUFBTTtZQUMzRCxNQUFNK0ksV0FDSjVLLE9BQU95SyxNQUFNLENBQUMsQ0FBQ0ksS0FBS0MsTUFBUUQsTUFBTTFNLEtBQUs0TSxHQUFHLENBQUNELE1BQU1OLE1BQU0sSUFBSSxLQUMzRHhLLE9BQU82QixNQUFNO1lBRWYsT0FBTzFELEtBQUs2TSxLQUFLLENBQUM3TSxLQUFLOE0sSUFBSSxDQUFDTCxZQUFZLE9BQU87UUFDakQsRUFBRSxPQUFPck4sT0FBTztZQUNkLE9BQU87UUFDVDtJQUNGO0lBRUEscUNBQXFDO0lBQ3JDMkssNkJBQTZCSCxnQkFBZ0IsRUFBRTtRQUM3QyxJQUFJLENBQUNyRCxNQUFNd0csT0FBTyxDQUFDbkQsbUJBQW1CLE9BQU87UUFFN0MsTUFBTW9ELFNBQVNwRCxpQkFBaUJ1QyxHQUFHLENBQUMsQ0FBQ3ZJLE9BQ25DNkgsV0FBVzdILEtBQUtxSixpQkFBaUIsSUFBSTtRQUV2QyxPQUFPRCxPQUFPdEosTUFBTSxHQUFHLElBQUkxRCxLQUFLQyxHQUFHLElBQUkrTSxVQUFVO0lBQ25EO0lBRUFoRCxpQkFBaUJKLGdCQUFnQixFQUFFO1FBQ2pDLE9BQU8sSUFBSSxDQUFDRyw0QkFBNEIsQ0FBQ0gsb0JBQW9CO0lBQy9EO0lBRUFTLHFCQUFxQnBHLFVBQVUsRUFBRTtRQUMvQixJQUFJLENBQUNzQyxNQUFNd0csT0FBTyxDQUFDOUksYUFBYSxPQUFPO1FBRXZDLE9BQU9BLFdBQVdxSSxNQUFNLENBQ3RCLENBQUNZLE9BQU90SixPQUFTc0osUUFBUUMsU0FBU3ZKLEtBQUt3SixnQkFBZ0IsSUFBSSxJQUMzRDtJQUVKO0lBRUE3QyxzQkFBc0J0RyxVQUFVLEVBQUU7UUFDaEMsSUFBSSxDQUFDc0MsTUFBTXdHLE9BQU8sQ0FBQzlJLGFBQWEsT0FBTztRQUV2QyxPQUFPQSxXQUNKTixNQUFNLENBQUMsQ0FBQ0MsT0FBU0EsS0FBS00sZUFBZSxFQUNyQ29JLE1BQU0sQ0FBQyxDQUFDWSxPQUFPdEosT0FBU3NKLFFBQVFDLFNBQVN2SixLQUFLd0osZ0JBQWdCLElBQUksSUFBSTtJQUMzRTtJQUVBLDhCQUE4QjtJQUM5QixNQUFNekMsMEJBQTBCRixhQUFhLEVBQUU7UUFDN0MsTUFBTUMsV0FBVyxFQUFFO1FBRW5CLElBQUk7WUFDRixJQUFJRCxjQUFjNEMsYUFBYSxHQUFHLElBQUk7Z0JBQ3BDM0MsU0FBU3RGLElBQUksQ0FBQztvQkFDWnZDLE1BQU07b0JBQ053QyxTQUFTO29CQUNUZ0UsT0FBT29CLGNBQWM0QyxhQUFhO2dCQUNwQztZQUNGO1lBRUEsSUFBSTVDLGNBQWM2QyxpQkFBaUIsR0FBRyxHQUFHO2dCQUN2QzVDLFNBQVN0RixJQUFJLENBQUM7b0JBQ1p2QyxNQUFNO29CQUNOd0MsU0FBUztvQkFDVGdFLE9BQU9vQixjQUFjNkMsaUJBQWlCO2dCQUN4QztZQUNGO1lBRUEsSUFBSTdDLGNBQWM4QyxTQUFTLEdBQUcsSUFBSTtnQkFDaEM3QyxTQUFTdEYsSUFBSSxDQUFDO29CQUNadkMsTUFBTTtvQkFDTndDLFNBQVM7b0JBQ1RnRSxPQUFPb0IsY0FBYzhDLFNBQVM7Z0JBQ2hDO1lBQ0Y7UUFDRixFQUFFLE9BQU9uTyxPQUFPO1lBQ2RGLFFBQVFFLEtBQUssQ0FBQyw4QkFBOEJBO1FBQzlDO1FBRUEsT0FBT3NMO0lBQ1Q7SUFFQSx3QkFBd0I7SUFDeEIsTUFBTTlILGtCQUFrQk4sS0FBSyxFQUFFO1FBQzdCLElBQUk7WUFDRixNQUFNa0wsTUFBTSxNQUFNOVIsMENBQU1BLENBQUMrUixHQUFHLENBQUNDLFVBQVUsQ0FBQztnQkFDdEMxQixPQUFPO29CQUFFekwsSUFBSStCO2dCQUFNO2dCQUNuQnFMLFNBQVM7b0JBQ1BDLEtBQUs7d0JBQ0gxQixNQUFNO3dCQUNORCxTQUFTOzRCQUFFeEssV0FBVzt3QkFBTztvQkFDL0I7b0JBQ0F3RyxjQUFjO3dCQUNaZ0UsU0FBUzs0QkFBRXhLLFdBQVc7d0JBQU87d0JBQzdCeUssTUFBTTtvQkFDUjtvQkFDQWhLLFdBQVc7b0JBQ1hvQixZQUFZO2dCQUNkO1lBQ0Y7WUFFQSxPQUFPa0s7UUFDVCxFQUFFLE9BQU9wTyxPQUFPO1lBQ2RGLFFBQVFFLEtBQUssQ0FBQyxvQ0FBb0NBO1lBQ2xELE9BQU87UUFDVDtJQUNGO0lBRUEsTUFBTStELHFCQUFxQmIsS0FBSyxFQUFFYyxPQUFPLEVBQUUsRUFBRTtRQUMzQyxJQUFJO1lBQ0YsTUFBTXlLLFlBQVksSUFBSW5RO1lBQ3RCbVEsVUFBVUMsT0FBTyxDQUFDRCxVQUFVRSxPQUFPLEtBQUszSztZQUV4QyxNQUFNSixVQUFVLE1BQU10SCwwQ0FBTUEsQ0FBQ29RLEdBQUcsQ0FBQ0MsUUFBUSxDQUFDO2dCQUN4Q0MsT0FBTztvQkFDTDFKO29CQUNBYixXQUFXO3dCQUNUdU0sS0FBS0g7b0JBQ1A7Z0JBQ0Y7Z0JBQ0E1QixTQUFTO29CQUFFeEssV0FBVztnQkFBTTtnQkFDNUJ5SyxNQUFNO1lBQ1I7WUFFQSxPQUFPbEo7UUFDVCxFQUFFLE9BQU81RCxPQUFPO1lBQ2RGLFFBQVFFLEtBQUssQ0FBQyx1Q0FBdUNBO1lBQ3JELE9BQU8sRUFBRTtRQUNYO0lBQ0Y7SUFFQSxNQUFNb0Ysb0JBQW9CbEMsS0FBSyxFQUFFTyxPQUFPLEtBQUssRUFBRTtRQUM3QyxJQUFJO1lBQ0YsTUFBTVgsWUFBWSxNQUFNeEcsMENBQU1BLENBQUN1UyxZQUFZLENBQUNQLFVBQVUsQ0FBQztnQkFDckQxQixPQUFPO29CQUFFMUo7Z0JBQU07WUFDakI7WUFFQSxJQUFJTyxTQUFTLE9BQU87Z0JBQ2xCLE9BQU9YO1lBQ1Q7WUFFQSwwQ0FBMEM7WUFDMUMsTUFBTWdNLGNBQWM7Z0JBQ2xCTixLQUFLO29CQUFDO29CQUFVO29CQUFVO29CQUFVO2lCQUFnQjtnQkFDcEQzRixjQUFjO29CQUNaO29CQUNBO29CQUNBO2lCQUNEO2dCQUNEa0csWUFBWTtvQkFDVjtvQkFDQTtvQkFDQTtpQkFDRDtZQUNIO1lBRUEsSUFBSUQsV0FBVyxDQUFDckwsS0FBSyxJQUFJWCxXQUFXO2dCQUNsQyxNQUFNdUMsb0JBQW9CLENBQUM7Z0JBQzNCeUosV0FBVyxDQUFDckwsS0FBSyxDQUFDdUwsT0FBTyxDQUFDLENBQUM5RztvQkFDekIsSUFBSXBGLFNBQVMsQ0FBQ29GLElBQUksS0FBS2xELFdBQVc7d0JBQ2hDSyxpQkFBaUIsQ0FBQzZDLElBQUksR0FBR3BGLFNBQVMsQ0FBQ29GLElBQUk7b0JBQ3pDO2dCQUNGO2dCQUNBLE9BQU83QztZQUNUO1lBRUEsT0FBT3ZDO1FBQ1QsRUFBRSxPQUFPOUMsT0FBTztZQUNkRixRQUFRRSxLQUFLLENBQUMsNkJBQTZCQTtZQUMzQyxPQUFPO1FBQ1Q7SUFDRjtJQUVBLGdCQUFnQjtJQUNoQixNQUFNd0Ysa0JBQWtCO1FBQ3RCLElBQUk7WUFDRixNQUFNLENBQUN5SixVQUFVQyxZQUFZLEdBQUcsTUFBTWhQLFFBQVFpUCxVQUFVLENBQUM7Z0JBQ3ZEN1MsMENBQU1BLENBQUM4UyxTQUFTLENBQUMsUUFBUSxDQUFDO2dCQUMxQi9TLDRDQUFLQSxDQUFDZ1QsV0FBVzthQUNsQjtZQUVELE9BQU87Z0JBQ0xyTixRQUFRO2dCQUNSMEosYUFBYSxJQUFJLENBQUMzTixPQUFPLENBQUNFLGtCQUFrQjtnQkFDNUNxUixRQUFRaFIsS0FBS0MsR0FBRyxLQUFLLElBQUksQ0FBQ1IsT0FBTyxDQUFDTSxTQUFTO2dCQUMzQ2tSLFVBQVVOLFNBQVNqTixNQUFNLEtBQUssY0FBYyxZQUFZO2dCQUN4RDNGLE9BQ0U2UyxZQUFZbE4sTUFBTSxLQUFLLGVBQ3ZCa04sWUFBWWpGLEtBQUssQ0FBQ2pJLE1BQU0sS0FBSyxZQUN6QixZQUNBO2dCQUNOd04sV0FBVztnQkFDWEMsU0FBUztZQUNYO1FBQ0YsRUFBRSxPQUFPelAsT0FBTztZQUNkLE9BQU87Z0JBQ0xnQyxRQUFRO2dCQUNSaEMsT0FBT0EsTUFBTWlHLE9BQU87Z0JBQ3BCcUosUUFBUWhSLEtBQUtDLEdBQUcsS0FBSyxJQUFJLENBQUNSLE9BQU8sQ0FBQ00sU0FBUztZQUM3QztRQUNGO0lBQ0Y7SUFFQSx1Q0FBdUM7SUFDdkNpSCx5QkFBeUJ4QyxTQUFTLEVBQUUvRSxPQUFPLEVBQUU7UUFDM0MsSUFBSSxDQUFDK0UsYUFBYSxDQUFDcUUsTUFBTXdHLE9BQU8sQ0FBQzVQLFVBQVUsT0FBTytFO1FBRWxELE1BQU00TSxXQUFXLENBQUM7UUFDbEIzUixRQUFRaVIsT0FBTyxDQUFDLENBQUNXO1lBQ2YsSUFBSTdNLFNBQVMsQ0FBQzZNLE9BQU8sS0FBSzNLLFdBQVc7Z0JBQ25DMEssUUFBUSxDQUFDQyxPQUFPLEdBQUc3TSxTQUFTLENBQUM2TSxPQUFPO1lBQ3RDO1FBQ0Y7UUFFQSxPQUFPRDtJQUNUO0lBRUEsdUJBQXVCO0lBQ3ZCekwsY0FBYzdCLFFBQVEsRUFBRWMsS0FBSyxFQUFFME0sU0FBUyxFQUFFO1FBQ3hDLElBQUksQ0FBQyxJQUFJLENBQUNDLFNBQVMsRUFBRTtZQUNuQixJQUFJLENBQUNBLFNBQVMsR0FBRyxJQUFJalQ7UUFDdkI7UUFFQSxNQUFNa1QsV0FBVyxDQUFDLEVBQUUxTixTQUFTLENBQUMsRUFBRWMsTUFBTSxDQUFDO1FBQ3ZDLElBQUksQ0FBQzJNLFNBQVMsQ0FBQzlOLEdBQUcsQ0FBQytOLFVBQVU7WUFDM0JGO1lBQ0FHLFdBQVc7WUFDWEMsV0FBVzFSLEtBQUtDLEdBQUc7UUFDckI7SUFDRjtJQUVBK0wsZUFBZXBILEtBQUssRUFBRStNLFVBQVUsRUFBRTtRQUNoQyxJQUFJLENBQUMsSUFBSSxDQUFDSixTQUFTLEVBQUU7UUFFckIsS0FBSyxNQUFNLENBQUNDLFVBQVVJLE1BQU0sSUFBSSxJQUFJLENBQUNMLFNBQVMsQ0FBRTtZQUM5QyxNQUFNLENBQUN6TixVQUFVK04sV0FBVyxHQUFHTCxTQUFTaEgsS0FBSyxDQUFDO1lBRTlDLElBQUlxSCxlQUFlak4sU0FBUyxDQUFDZ04sTUFBTUgsU0FBUyxFQUFFO2dCQUM1QyxJQUFJRSxjQUFjQyxNQUFNTixTQUFTLEVBQUU7b0JBQ2pDLE1BQU1oSixTQUFTLElBQUksQ0FBQ2pLLGdCQUFnQixDQUFDa0ssR0FBRyxDQUFDekU7b0JBQ3pDLElBQUl3RSxRQUFRO3dCQUNWQSxPQUFPbkcsTUFBTSxDQUFDMEIsSUFBSSxDQUFDLElBQUksQ0FBQ2pGLE1BQU0sQ0FBQ1MsZUFBZSxFQUFFOzRCQUM5QzhGLE1BQU07NEJBQ05QOzRCQUNBME0sV0FBV00sTUFBTU4sU0FBUzs0QkFDMUI1RCxjQUFjaUU7NEJBQ2Q1TixXQUFXL0QsS0FBS0MsR0FBRzt3QkFDckI7d0JBRUEyUixNQUFNSCxTQUFTLEdBQUc7d0JBQ2xCalEsUUFBUUMsR0FBRyxDQUNULENBQUMsMkJBQTJCLEVBQUVxQyxTQUFTLEVBQUUsRUFBRWMsTUFBTSxTQUFTLEVBQUUrTSxXQUFXLENBQUM7b0JBRTVFO2dCQUNGO1lBQ0Y7UUFDRjtJQUNGO0lBRUEscUJBQXFCO0lBQ3JCbEUsaUJBQWlCSixTQUFTLEVBQUU7UUFDMUIsTUFBTXlFLGNBQWM7WUFDbEJDLGVBQWU7WUFDZkMsa0JBQWtCO1lBQ2xCQyxjQUFjO1lBQ2RDLGtCQUFrQjtZQUNsQkMsWUFBWTtRQUNkO1FBRUEsT0FBT0wsV0FBVyxDQUFDekUsVUFBVSxJQUFJO0lBQ25DO0lBRUEsc0NBQXNDO0lBQ3RDL0IsOEJBQThCTixJQUFJLEVBQUVyRCxPQUFPLEVBQUU7UUFDM0MsSUFBSSxDQUFDLElBQUksQ0FBQ3RILFlBQVksQ0FBQzBKLEdBQUcsQ0FBQ2lCLE9BQU87WUFDaEMsSUFBSSxDQUFDM0ssWUFBWSxDQUFDb0QsR0FBRyxDQUFDdUgsTUFBTSxFQUFFO1FBQ2hDO1FBRUEsTUFBTW9ILFFBQVEsSUFBSSxDQUFDL1IsWUFBWSxDQUFDa0ksR0FBRyxDQUFDeUM7UUFDcENvSCxNQUFNMUssSUFBSSxDQUFDO1lBQ1RDO1lBQ0E1RCxXQUFXL0QsS0FBS0MsR0FBRztRQUNyQjtRQUVBLGdDQUFnQztRQUNoQyxJQUFJbVMsTUFBTXBNLE1BQU0sR0FBRyxJQUFJLENBQUMxRixZQUFZLEVBQUU7WUFDcEM4UixNQUFNQyxNQUFNLENBQUMsR0FBR0QsTUFBTXBNLE1BQU0sR0FBRyxJQUFJLENBQUMxRixZQUFZO1FBQ2xEO0lBQ0Y7SUFFQW1FLG1CQUFtQlgsUUFBUSxFQUFFO1FBQzNCLE1BQU13RSxTQUFTLElBQUksQ0FBQ2pLLGdCQUFnQixDQUFDa0ssR0FBRyxDQUFDekU7UUFDekMsSUFBSSxDQUFDd0UsUUFBUTtRQUViLDRDQUE0QztRQUM1QyxLQUFLLE1BQU1pQyxnQkFBZ0JqQyxPQUFPdEYsYUFBYSxDQUFFO1lBQy9DLE1BQU1zUCxpQkFBaUIsSUFBSSxDQUFDalMsWUFBWSxDQUFDa0ksR0FBRyxDQUFDZ0M7WUFDN0MsSUFBSStILGtCQUFrQkEsZUFBZXRNLE1BQU0sR0FBRyxHQUFHO2dCQUMvQ3NDLE9BQU9uRyxNQUFNLENBQUMwQixJQUFJLENBQUMsbUJBQW1CO29CQUNwQ21ILE1BQU1UO29CQUNOOUIsVUFBVTZKO29CQUNWdEksT0FBT3NJLGVBQWV0TSxNQUFNO2dCQUM5QjtnQkFFQSxnQ0FBZ0M7Z0JBQ2hDLElBQUksQ0FBQzNGLFlBQVksQ0FBQ2dLLE1BQU0sQ0FBQ0U7WUFDM0I7UUFDRjtJQUNGO0lBRUEsZ0NBQWdDO0lBQ2hDbkIsMEJBQTBCdEYsUUFBUSxFQUFFcUYsTUFBTSxFQUFFO1FBQzFDLE1BQU1iLFNBQVMsSUFBSSxDQUFDakssZ0JBQWdCLENBQUNrSyxHQUFHLENBQUN6RTtRQUN6QyxJQUFJd0UsUUFBUTtZQUNWLDJCQUEyQjtZQUMzQixJQUFJLENBQUNpSyxnQkFBZ0IsR0FBRyxJQUFJLENBQUNBLGdCQUFnQixJQUFJLElBQUlqVTtZQUNyRCxJQUFJLENBQUNpVSxnQkFBZ0IsQ0FBQzlPLEdBQUcsQ0FBQ0ssVUFBVTtnQkFDbENxRjtnQkFDQXFKLGdCQUFnQnhTLEtBQUtDLEdBQUc7Z0JBQ3hCK0MsZUFBZTZGLE1BQU1DLElBQUksQ0FBQ1IsT0FBT3RGLGFBQWE7Z0JBQzlDUSxnQkFBZ0I4RSxPQUFPOUUsY0FBYztZQUN2QztZQUVBLGtDQUFrQztZQUNsQyxJQUFJLElBQUksQ0FBQytPLGdCQUFnQixDQUFDbkksSUFBSSxHQUFHLE1BQU07Z0JBQ3JDLE1BQU1xSSxVQUFVNUosTUFBTUMsSUFBSSxDQUFDLElBQUksQ0FBQ3lKLGdCQUFnQixDQUFDRSxPQUFPO2dCQUN4REEsUUFBUUMsSUFBSSxDQUFDLENBQUM3RCxHQUFHQyxJQUFNQSxDQUFDLENBQUMsRUFBRSxDQUFDMEQsY0FBYyxHQUFHM0QsQ0FBQyxDQUFDLEVBQUUsQ0FBQzJELGNBQWM7Z0JBQ2hFLElBQUksQ0FBQ0QsZ0JBQWdCLEdBQUcsSUFBSWpVLElBQUltVSxRQUFRbEwsS0FBSyxDQUFDLEdBQUc7WUFDbkQ7UUFDRjtJQUNGO0lBRUEsNERBQTREO0lBQzVEeUIsYUFBYTdHLE1BQU0sRUFBRTtRQUNuQiwwQ0FBMEM7UUFDMUMsK0NBQStDO1FBQy9DLE9BQU87SUFDVDtJQUVBLDRDQUE0QztJQUM1Q2QsaUJBQWlCO1FBQ2ZzUixZQUFZO1lBQ1YsTUFBTTFTLE1BQU1ELEtBQUtDLEdBQUc7WUFDcEIsTUFBTTJTLGlCQUFpQixJQUFJLEtBQUssTUFBTSxZQUFZO1lBQ2xELE1BQU1DLGVBQWUsRUFBRTtZQUV2QixLQUFLLE1BQU0sQ0FBQy9PLFVBQVV3RSxPQUFPLElBQUksSUFBSSxDQUFDakssZ0JBQWdCLENBQUU7Z0JBQ3RELE1BQU15VSx3QkFBd0I3UyxNQUFNcUksT0FBT3BGLFlBQVksQ0FBQ3lGLE9BQU87Z0JBRS9ELElBQUltSyx3QkFBd0JGLGdCQUFnQjtvQkFDMUNwUixRQUFRQyxHQUFHLENBQ1QsQ0FBQywrQkFBK0IsRUFBRXFDLFNBQVMsZUFBZSxFQUFFeEIsS0FBSzZNLEtBQUssQ0FBQzJELHdCQUF3QixNQUFNLEVBQUUsQ0FBQztvQkFFMUd4SyxPQUFPbkcsTUFBTSxDQUFDNFEsVUFBVSxDQUFDO29CQUN6QkYsYUFBYW5MLElBQUksQ0FBQzVEO2dCQUNwQjtZQUNGO1lBRUEsSUFBSStPLGFBQWE3TSxNQUFNLEdBQUcsR0FBRztnQkFDM0J4RSxRQUFRQyxHQUFHLENBQUMsQ0FBQyxjQUFjLEVBQUVvUixhQUFhN00sTUFBTSxDQUFDLGtCQUFrQixDQUFDO1lBQ3RFO1lBRUEsNkNBQTZDO1lBQzdDLElBQUkvRixNQUFPLEtBQUksS0FBSyxJQUFHLElBQUssT0FBTztnQkFDakMsbUNBQW1DO2dCQUNuQyxJQUFJLENBQUNpTixxQkFBcUIsQ0FBQztvQkFDekIvSCxNQUFNO29CQUNOekIsUUFBUTtvQkFDUnNOLFFBQVEvUSxNQUFNLElBQUksQ0FBQ1IsT0FBTyxDQUFDTSxTQUFTO29CQUNwQ3FOLGFBQWEsSUFBSSxDQUFDM04sT0FBTyxDQUFDRSxrQkFBa0I7b0JBQzVDZ0ksU0FBUztnQkFDWDtZQUNGO1FBQ0YsR0FBRyxRQUFRLHFCQUFxQjtJQUNsQztJQUVBLG9CQUFvQjtJQUNwQnBHLHdCQUF3QjtRQUN0Qm9SLFlBQVk7WUFDVixNQUFNMVMsTUFBTUQsS0FBS0MsR0FBRztZQUVwQiw0QkFBNEI7WUFDNUIsS0FBSyxNQUFNLENBQUM2RCxVQUFVOEUsT0FBTyxJQUFJLElBQUksQ0FBQ3hJLGdCQUFnQixDQUFFO2dCQUN0RCxJQUFJSCxNQUFNMkksT0FBT2hGLFFBQVEsR0FBRyxJQUFJLEtBQUssTUFBTTtvQkFDekMsWUFBWTtvQkFDWmdGLE9BQU9sRixNQUFNLEdBQUc7Z0JBQ2xCO2dCQUVBLElBQUlrRixPQUFPakYsT0FBTyxHQUFHLE1BQU07b0JBQ3pCLGVBQWU7b0JBQ2ZpRixPQUFPbEYsTUFBTSxHQUFHO2dCQUNsQjtZQUNGO1lBRUEsOEJBQThCO1lBQzlCLE1BQU1zUCxnQkFBZ0JuSyxNQUFNQyxJQUFJLENBQUMsSUFBSSxDQUFDMUksZ0JBQWdCLENBQUNxUyxPQUFPO1lBQzlELE1BQU1RLGdCQUFnQixJQUFJaFEsSUFBSSxJQUFJLENBQUM1RSxnQkFBZ0IsQ0FBQzZVLElBQUk7WUFFeEQsS0FBSyxNQUFNLENBQUNwUCxTQUFTLElBQUlrUCxjQUFlO2dCQUN0QyxJQUFJLENBQUNDLGNBQWNsSixHQUFHLENBQUNqRyxXQUFXO29CQUNoQyxJQUFJLENBQUMxRCxnQkFBZ0IsQ0FBQ2lLLE1BQU0sQ0FBQ3ZHO2dCQUMvQjtZQUNGO1FBQ0YsR0FBRyxRQUFRLG1CQUFtQjtJQUNoQztJQUVBLHFCQUFxQjtJQUNyQnhDLHlCQUF5QjtRQUN2QnFSLFlBQVk7WUFDVixNQUFNMUosUUFBUSxJQUFJLENBQUNDLGdCQUFnQjtZQUNuQzFILFFBQVFDLEdBQUcsQ0FDVCxDQUFDLG1DQUFtQyxFQUFFd0gsTUFBTW1FLFdBQVcsQ0FBQyxZQUFZLEVBQUVuRSxNQUFNckosYUFBYSxDQUFDLFVBQVUsRUFBRTBDLEtBQUs2TSxLQUFLLENBQUNsRyxNQUFNK0gsTUFBTSxHQUFHLE1BQU0sQ0FBQyxDQUFDO1lBRzFJLG1EQUFtRDtZQUNuRGpULDRDQUFLQSxDQUFDMEYsR0FBRyxDQUFDLHFCQUFxQndGLE9BQU8sTUFBTSxZQUFZO1lBRXhELHdCQUF3QjtZQUN4QixNQUFNaEosTUFBTUQsS0FBS0MsR0FBRztZQUNwQixJQUFJQSxNQUFNLElBQUksQ0FBQ1IsT0FBTyxDQUFDTSxTQUFTLEdBQUcsS0FBSyxLQUFLLE1BQU07Z0JBQ2pELGFBQWE7Z0JBQ2IsSUFBSSxDQUFDb1Qsa0JBQWtCO1lBQ3pCO1FBQ0YsR0FBRyxRQUFRLG1CQUFtQjtJQUNoQztJQUVBLG1CQUFtQjtJQUNuQmxSLHVCQUF1QjtRQUNyQjBRLFlBQ0U7WUFDRSx1QkFBdUI7WUFDdkIsTUFBTTFTLE1BQU1ELEtBQUtDLEdBQUc7WUFDcEIsS0FBSyxNQUFNLENBQUMySixLQUFLSyxNQUFNLElBQUksSUFBSSxDQUFDM0ssVUFBVSxDQUFFO2dCQUMxQyxJQUFJVyxNQUFNZ0ssTUFBTUosV0FBVyxHQUFHLE9BQU87b0JBQ25DLGVBQWU7b0JBQ2YsSUFBSSxDQUFDdkssVUFBVSxDQUFDK0ssTUFBTSxDQUFDVDtnQkFDekI7WUFDRjtZQUVBLDBCQUEwQjtZQUMxQixJQUFJLElBQUksQ0FBQzJILFNBQVMsRUFBRTtnQkFDbEIsS0FBSyxNQUFNLENBQUMzSCxLQUFLZ0ksTUFBTSxJQUFJLElBQUksQ0FBQ0wsU0FBUyxDQUFFO29CQUN6QyxJQUFJdFIsTUFBTTJSLE1BQU1GLFNBQVMsR0FBRyxLQUFLLEtBQUssS0FBSyxNQUFNO3dCQUMvQyxlQUFlO3dCQUNmLElBQUksQ0FBQ0gsU0FBUyxDQUFDbEgsTUFBTSxDQUFDVDtvQkFDeEI7Z0JBQ0Y7WUFDRjtZQUVBLDBCQUEwQjtZQUMxQixLQUFLLE1BQU0sQ0FBQ29CLE1BQU12QyxTQUFTLElBQUksSUFBSSxDQUFDcEksWUFBWSxDQUFFO2dCQUNoRCxNQUFNK1MsZ0JBQWdCM0ssU0FBU3hDLE1BQU0sQ0FDbkMsQ0FBQ29OLE1BQVFwVCxNQUFNb1QsSUFBSXRQLFNBQVMsR0FBRyxLQUFLLEtBQUssS0FBSywyQkFBMkI7O2dCQUczRSxJQUFJcVAsY0FBY3BOLE1BQU0sS0FBSyxHQUFHO29CQUM5QixJQUFJLENBQUMzRixZQUFZLENBQUNnSyxNQUFNLENBQUNXO2dCQUMzQixPQUFPO29CQUNMLElBQUksQ0FBQzNLLFlBQVksQ0FBQ29ELEdBQUcsQ0FBQ3VILE1BQU1vSTtnQkFDOUI7WUFDRjtRQUNGLEdBQ0EsSUFBSSxLQUFLLE9BQ1Isa0JBQWtCO0lBQ3ZCO0lBRUEsdUJBQXVCO0lBQ3ZCRCxxQkFBcUI7UUFDbkIsSUFBSSxDQUFDMVQsT0FBTyxDQUFDRyxhQUFhLEdBQUc7UUFDN0IsSUFBSSxDQUFDSCxPQUFPLENBQUNLLE1BQU0sR0FBRztRQUN0QjBCLFFBQVFDLEdBQUcsQ0FBQztJQUNkO0lBRUEsc0JBQXNCO0lBQ3RCeUgsbUJBQW1CO1FBQ2pCLE1BQU1rRSxjQUFjLElBQUksQ0FBQy9PLGdCQUFnQixDQUFDK0wsSUFBSTtRQUM5QyxNQUFNa0osUUFBUXpLLE1BQU1DLElBQUksQ0FBQyxJQUFJLENBQUN2SyxpQkFBaUIsQ0FBQzJVLElBQUk7UUFDcEQsTUFBTXJULHFCQUFxQmdKLE1BQU1DLElBQUksQ0FDbkMsSUFBSSxDQUFDdkssaUJBQWlCLENBQUM0RixNQUFNLElBQzdCeUssTUFBTSxDQUFDLENBQUMyRSxLQUFLQyxPQUFTRCxNQUFNQyxLQUFLcEosSUFBSSxFQUFFO1FBRXpDLHFCQUFxQjtRQUNyQixNQUFNcUosNEJBQ0pyRyxjQUFjLElBQ1ZXLFdBQVcsQ0FBQ2xPLHFCQUFxQnVOLFdBQVUsRUFBR1ksT0FBTyxDQUFDLE1BQ3REO1FBRU4sbUJBQW1CO1FBQ25CLE1BQU0wRixjQUFjalYsUUFBUWlWLFdBQVc7UUFFdkMseUJBQXlCO1FBQ3pCLE1BQU1DLHFCQUFxQjlLLE1BQU1DLElBQUksQ0FDbkMsSUFBSSxDQUFDMUksZ0JBQWdCLENBQUMrRCxNQUFNLElBQzVCOEIsTUFBTSxDQUFDLENBQUMyTixJQUFNQSxFQUFFbFEsTUFBTSxLQUFLLFdBQVdzQyxNQUFNO1FBRTlDLE9BQU87WUFDTG9IO1lBQ0FrRyxPQUFPQSxNQUFNdE4sTUFBTTtZQUNuQmhELGVBQWVuRDtZQUNmNFQ7WUFDQTdULGVBQWUsSUFBSSxDQUFDSCxPQUFPLENBQUNHLGFBQWE7WUFDekNGLGtCQUFrQixJQUFJLENBQUNELE9BQU8sQ0FBQ0MsZ0JBQWdCO1lBQy9DUyxpQkFBaUIsSUFBSSxDQUFDVixPQUFPLENBQUNVLGVBQWU7WUFDN0NMLFFBQVEsSUFBSSxDQUFDTCxPQUFPLENBQUNLLE1BQU07WUFDM0JrUixRQUFRaFIsS0FBS0MsR0FBRyxLQUFLLElBQUksQ0FBQ1IsT0FBTyxDQUFDTSxTQUFTO1lBQzNDOFQsa0JBQWtCLElBQUksQ0FBQ3ZVLFVBQVUsQ0FBQzhLLElBQUk7WUFDdENrSSxnQkFBZ0J6SixNQUFNQyxJQUFJLENBQUMsSUFBSSxDQUFDekksWUFBWSxDQUFDOEQsTUFBTSxJQUFJeUssTUFBTSxDQUMzRCxDQUFDMkUsS0FBS08sT0FBU1AsTUFBTU8sS0FBSzlOLE1BQU0sRUFDaEM7WUFFRjRDLFFBQVE7Z0JBQ05tTCxTQUFTSjtnQkFDVEssVUFBVSxJQUFJLENBQUM1VCxnQkFBZ0IsQ0FBQ2dLLElBQUksR0FBR3VKO2dCQUN2Q00sWUFDRSxJQUFJLENBQUM3VCxnQkFBZ0IsQ0FBQ2dLLElBQUksR0FBRyxJQUN6QjJELFdBQ0UsQ0FDRSxxQkFBc0IsSUFBSSxDQUFDM04sZ0JBQWdCLENBQUNnSyxJQUFJLEdBQ2hELEdBQUUsRUFDRjRELE9BQU8sQ0FBQyxNQUVaO1lBQ1I7WUFDQWtHLFFBQVE7Z0JBQ05DLEtBQUs3UixLQUFLNk0sS0FBSyxDQUFDdUUsWUFBWVMsR0FBRyxHQUFHLE9BQU8sUUFBUTtnQkFDakRDLFVBQVU5UixLQUFLNk0sS0FBSyxDQUFDdUUsWUFBWVUsUUFBUSxHQUFHLE9BQU8sUUFBUTtnQkFDM0RDLFdBQVcvUixLQUFLNk0sS0FBSyxDQUFDdUUsWUFBWVcsU0FBUyxHQUFHLE9BQU8sUUFBUTtnQkFDN0RDLFVBQVVoUyxLQUFLNk0sS0FBSyxDQUFDdUUsWUFBWVksUUFBUSxHQUFHLE9BQU8sUUFBUTtZQUM3RDtZQUNBQyxhQUFhclEsT0FBT3NRLFdBQVcsQ0FDN0IzTCxNQUFNQyxJQUFJLENBQUMsSUFBSSxDQUFDdkssaUJBQWlCLENBQUNrVSxPQUFPLElBQUloRSxHQUFHLENBQUMsQ0FBQyxDQUFDekQsTUFBTXdJLEtBQUssR0FBSztvQkFDakV4STtvQkFDQXdJLEtBQUtwSixJQUFJO2lCQUNWO1lBRUhyRyxXQUFXL0QsS0FBS0MsR0FBRztRQUNyQjtJQUNGO0lBRUEsZUFBZTtJQUNmd1UsaUJBQWlCO1FBQ2YsTUFBTXhMLFFBQVEsSUFBSSxDQUFDQyxnQkFBZ0I7UUFDbkMsTUFBTTVGLFlBQVksSUFBSSxDQUFDbkYsRUFBRSxJQUFJOEssTUFBTW1FLFdBQVcsSUFBSSxLQUFLLENBQUMsSUFBSSxDQUFDc0gsWUFBWTtRQUV6RSxPQUFPO1lBQ0xoUixRQUFRSixZQUFZLFlBQVk7WUFDaEMwTixRQUFRL0gsTUFBTStILE1BQU07WUFDcEI1RCxhQUFhbkUsTUFBTW1FLFdBQVc7WUFDOUJrRyxPQUFPckssTUFBTXFLLEtBQUs7WUFDbEJ0USxlQUFlaUcsTUFBTWpHLGFBQWE7WUFDbEMyUixhQUFhLElBQUksQ0FBQ0Msb0JBQW9CO1lBQ3RDbEIsYUFBYXpLLE1BQU1pTCxNQUFNO1lBQ3pCdEwsUUFBUUssTUFBTUwsTUFBTTtZQUNwQjlJLFFBQVFtSixNQUFNbkosTUFBTTtZQUNwQitVLFlBQVksSUFBSSxDQUFDQyxlQUFlO1lBQ2hDL1EsV0FBVy9ELEtBQUtDLEdBQUc7UUFDckI7SUFDRjtJQUVBeVUsZUFBZTtRQUNiLE1BQU16TCxRQUFRLElBQUksQ0FBQ0MsZ0JBQWdCO1FBQ25DLE1BQU13SyxjQUFjalYsUUFBUWlWLFdBQVc7UUFFdkMsNkJBQTZCO1FBQzdCLE1BQU1xQixpQkFBaUJ0RixTQUFTaFIsUUFBUUMsR0FBRyxDQUFDc1csa0JBQWtCLEtBQUs7UUFDbkUsTUFBTUMsY0FBY3hGLFNBQVNoUixRQUFRQyxHQUFHLENBQUN3VyxnQkFBZ0IsS0FBSztRQUM5RCxNQUFNOVEsbUJBQ0pxTCxTQUFTaFIsUUFBUUMsR0FBRyxDQUFDeVcsb0JBQW9CLEtBQUs7UUFFaEQsT0FDRWxNLE1BQU1tRSxXQUFXLEdBQUcySCxrQkFDcEJyQixZQUFZVSxRQUFRLEdBQUcsT0FBTyxPQUFPYSxlQUNyQ2hNLE1BQU1qRyxhQUFhLEdBQUdvQixvQkFDdEI2RSxNQUFNbkosTUFBTSxHQUFHLElBQUksa0JBQWtCOztJQUV6QztJQUVBOFUsdUJBQXVCO1FBQ3JCLE1BQU1RLFdBQVcsQ0FBQ3BWLEtBQUtDLEdBQUcsS0FBSyxJQUFJLENBQUNSLE9BQU8sQ0FBQ00sU0FBUyxJQUFJO1FBQ3pELE1BQU1zVixvQkFDSkQsV0FBVyxJQUFJLElBQUksQ0FBQzNWLE9BQU8sQ0FBQ0csYUFBYSxHQUFHd1YsV0FBVztRQUN6RCxNQUFNRSxtQkFBbUIsSUFBSSxDQUFDalgsZ0JBQWdCLENBQUMrTCxJQUFJLEdBQUcsTUFBTSxnQ0FBZ0M7UUFFNUYsT0FBTzJELFdBQVcsQ0FBQ3NILG9CQUFvQkMsZ0JBQWUsRUFBR3RILE9BQU8sQ0FBQztJQUNuRTtJQUVBOEcsa0JBQWtCO1FBQ2hCLG9FQUFvRTtRQUNwRSxPQUFPO1lBQ0w5SyxPQUFPLElBQUksQ0FBQ3ZLLE9BQU8sQ0FBQ0ssTUFBTTtZQUMxQnlWLGVBQWUsSUFBSSxDQUFDQSxhQUFhLElBQUk7UUFDdkM7SUFDRjtJQUVBLGlCQUFpQjtJQUNqQmxNLGNBQWN2RixRQUFRLEVBQUU7UUFDdEIsTUFBTXdFLFNBQVMsSUFBSSxDQUFDakssZ0JBQWdCLENBQUNrSyxHQUFHLENBQUN6RTtRQUN6QyxJQUFJd0UsUUFBUTtZQUNWLHFDQUFxQztZQUNyQyxLQUFLLE1BQU1pQyxnQkFBZ0JqQyxPQUFPdEYsYUFBYSxDQUFFO2dCQUMvQyxNQUFNc0gsV0FBVyxJQUFJLENBQUMvTCxpQkFBaUIsQ0FBQ2dLLEdBQUcsQ0FBQ2dDO2dCQUM1QyxJQUFJRCxVQUFVO29CQUNaQSxTQUFTRCxNQUFNLENBQUN2RztvQkFDaEIsSUFBSXdHLFNBQVNGLElBQUksS0FBSyxHQUFHO3dCQUN2QixJQUFJLENBQUM3TCxpQkFBaUIsQ0FBQzhMLE1BQU0sQ0FBQ0U7b0JBQ2hDO2dCQUNGO1lBQ0Y7WUFDQSxJQUFJLENBQUNsTSxnQkFBZ0IsQ0FBQ2dNLE1BQU0sQ0FBQ3ZHO1FBQy9CO1FBRUEsNkJBQTZCO1FBQzdCLElBQUksQ0FBQzFELGdCQUFnQixDQUFDaUssTUFBTSxDQUFDdkc7UUFFN0IsdUNBQXVDO1FBQ3ZDLE1BQU0wUixlQUFlLEVBQUU7UUFDdkIsS0FBSyxNQUFNLENBQUM1TCxJQUFJLElBQUksSUFBSSxDQUFDdEssVUFBVSxDQUFFO1lBQ25DLElBQUlzSyxJQUFJYyxVQUFVLENBQUM1RyxXQUFXO2dCQUM1QjBSLGFBQWE5TixJQUFJLENBQUNrQztZQUNwQjtRQUNGO1FBQ0E0TCxhQUFhOUUsT0FBTyxDQUFDLENBQUM5RyxNQUFRLElBQUksQ0FBQ3RLLFVBQVUsQ0FBQytLLE1BQU0sQ0FBQ1Q7UUFFckQsc0JBQXNCO1FBQ3RCLElBQUksSUFBSSxDQUFDMkgsU0FBUyxFQUFFO1lBQ2xCLE1BQU1rRSxvQkFBb0IsRUFBRTtZQUM1QixLQUFLLE1BQU0sQ0FBQzdMLElBQUksSUFBSSxJQUFJLENBQUMySCxTQUFTLENBQUU7Z0JBQ2xDLElBQUkzSCxJQUFJYyxVQUFVLENBQUM1RyxXQUFXO29CQUM1QjJSLGtCQUFrQi9OLElBQUksQ0FBQ2tDO2dCQUN6QjtZQUNGO1lBQ0E2TCxrQkFBa0IvRSxPQUFPLENBQUMsQ0FBQzlHLE1BQVEsSUFBSSxDQUFDMkgsU0FBUyxDQUFDbEgsTUFBTSxDQUFDVDtRQUMzRDtJQUNGO0lBRUEsb0JBQW9CO0lBQ3BCLE1BQU04TCxXQUFXO1FBQ2ZsVSxRQUFRQyxHQUFHLENBQUM7UUFFWixJQUFJLElBQUksQ0FBQ3RELEVBQUUsRUFBRTtZQUNYLG9DQUFvQztZQUNwQyxNQUFNLElBQUksQ0FBQytPLHFCQUFxQixDQUM5QjtnQkFDRS9ILE1BQU07Z0JBQ053QyxTQUFTO2dCQUNUZ08sbUJBQW1CO1lBQ3JCLEdBQ0E7Z0JBQUU5SyxVQUFVO1lBQU87WUFHckIsMkNBQTJDO1lBQzNDLE1BQU0sSUFBSWpKLFFBQVEsQ0FBQ0MsVUFBWStULFdBQVcvVCxTQUFTO1lBRW5ELG9DQUFvQztZQUNwQyxLQUFLLE1BQU0sQ0FBQ2lDLFVBQVV3RSxPQUFPLElBQUksSUFBSSxDQUFDakssZ0JBQWdCLENBQUU7Z0JBQ3RELElBQUk7b0JBQ0ZpSyxPQUFPbkcsTUFBTSxDQUFDMEIsSUFBSSxDQUFDLG1CQUFtQjt3QkFDcEM4RCxTQUFTO3dCQUNUa08sYUFBYTtvQkFDZjtvQkFDQXZOLE9BQU9uRyxNQUFNLENBQUM0USxVQUFVLENBQUM7Z0JBQzNCLEVBQUUsT0FBT3JSLE9BQU87b0JBQ2RGLFFBQVFzVSxJQUFJLENBQ1YsQ0FBQywyQkFBMkIsRUFBRWhTLFNBQVMsQ0FBQyxDQUFDLEVBQ3pDcEMsTUFBTWlHLE9BQU87Z0JBRWpCO1lBQ0Y7WUFFQSxtQkFBbUI7WUFDbkIsSUFBSSxDQUFDeEosRUFBRSxDQUFDNFgsS0FBSztRQUNmO1FBRUEsSUFBSSxJQUFJLENBQUMzWCxNQUFNLEVBQUU7WUFDZixJQUFJLENBQUNBLE1BQU0sQ0FBQzJYLEtBQUs7UUFDbkI7UUFFQSw0QkFBNEI7UUFDNUIsSUFBSSxDQUFDMVgsZ0JBQWdCLENBQUMyWCxLQUFLO1FBQzNCLElBQUksQ0FBQ3pYLGlCQUFpQixDQUFDeVgsS0FBSztRQUM1QixJQUFJLENBQUMxVyxVQUFVLENBQUMwVyxLQUFLO1FBQ3JCLElBQUksQ0FBQzVWLGdCQUFnQixDQUFDNFYsS0FBSztRQUMzQixJQUFJLENBQUMzVixZQUFZLENBQUMyVixLQUFLO1FBRXZCLElBQUksSUFBSSxDQUFDekUsU0FBUyxFQUFFO1lBQ2xCLElBQUksQ0FBQ0EsU0FBUyxDQUFDeUUsS0FBSztRQUN0QjtRQUVBeFUsUUFBUUMsR0FBRyxDQUFDO0lBQ2Q7QUFDRjtBQUVBLDRCQUE0QjtBQUNyQixNQUFNd1UsbUJBQW1CLElBQUloWSxtQkFBbUI7QUFFdkQsa0RBQWtEO0FBQ2xELElBQUlRLElBQStCLEVBQUU7SUFDbkN3WCxpQkFBaUIxVixVQUFVO0lBRTNCLElBQUk5QixRQUFRQyxHQUFHLENBQUN3WCxvQkFBb0IsS0FBSyxTQUFTO1FBQ2hERCxpQkFBaUJ0VSxLQUFLLEdBQUd3VSxLQUFLLENBQUMsQ0FBQ3pVO1lBQzlCRixRQUFRRSxLQUFLLENBQUMsc0NBQXNDQTtZQUNwRGpELFFBQVEyWCxJQUFJLENBQUM7UUFDZjtJQUNGO0FBQ0Y7QUFFQSw2QkFBNkI7QUFDN0IzWCxRQUFReUQsRUFBRSxDQUFDLFdBQVc7SUFDcEJWLFFBQVFDLEdBQUcsQ0FDVDtJQUVGLE1BQU13VSxpQkFBaUJQLFFBQVE7SUFDL0JqWCxRQUFRMlgsSUFBSSxDQUFDO0FBQ2Y7QUFFQTNYLFFBQVF5RCxFQUFFLENBQUMsVUFBVTtJQUNuQlYsUUFBUUMsR0FBRyxDQUFDO0lBQ1osTUFBTXdVLGlCQUFpQlAsUUFBUTtJQUMvQmpYLFFBQVEyWCxJQUFJLENBQUM7QUFDZjtBQUVBLDJCQUEyQjtBQUMzQjNYLFFBQVF5RCxFQUFFLENBQUMscUJBQXFCLE9BQU9SO0lBQ3JDRixRQUFRRSxLQUFLLENBQUMsNENBQTRDQTtJQUMxRHVVLGlCQUFpQlYsYUFBYSxHQUFHdlYsS0FBS0MsR0FBRztJQUN6Q2dXLGlCQUFpQnhXLE9BQU8sQ0FBQ0ssTUFBTTtJQUUvQiw0QkFBNEI7SUFDNUIsSUFBSTtRQUNGLE1BQU1tVyxpQkFBaUJQLFFBQVE7SUFDakMsRUFBRSxPQUFPVyxlQUFlO1FBQ3RCN1UsUUFBUUUsS0FBSyxDQUFDLG9DQUFvQzJVO0lBQ3BEO0lBRUE1WCxRQUFRMlgsSUFBSSxDQUFDO0FBQ2Y7QUFFQSxrREFBa0Q7QUFDM0MsTUFBTWpZLEtBQUs4WCxpQkFBaUI5WCxFQUFFLENBQUM7QUFFdEMsaUJBQWlCO0FBQ2pCLGlFQUFlOFgsZ0JBQWdCQSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaXBvLXRyYWNrZXIvLi9zcmMvbGliL3dlYnNvY2tldC5qcz8zYzc1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFNlcnZlciB9IGZyb20gXCJzb2NrZXQuaW9cIjtcclxuaW1wb3J0IHsgY3JlYXRlU2VydmVyIH0gZnJvbSBcImh0dHBcIjtcclxuaW1wb3J0IHsgY2FjaGUgfSBmcm9tIFwiLi9jYWNoZS5qc1wiO1xyXG5pbXBvcnQgeyBwcmlzbWEgfSBmcm9tIFwiLi9kYi5qc1wiO1xyXG5cclxuY2xhc3MgV2ViU29ja2V0U2VydmljZSB7XHJcbiAgY29uc3RydWN0b3IoKSB7XHJcbiAgICB0aGlzLmlvID0gbnVsbDtcclxuICAgIHRoaXMuc2VydmVyID0gbnVsbDtcclxuICAgIHRoaXMuY29ubmVjdGVkQ2xpZW50cyA9IG5ldyBNYXAoKTtcclxuICAgIHRoaXMucm9vbVN1YnNjcmlwdGlvbnMgPSBuZXcgTWFwKCk7XHJcbiAgICB0aGlzLnBvcnQgPSBwcm9jZXNzLmVudi5XRUJTT0NLRVRfUE9SVCB8fCAzMDAxO1xyXG5cclxuICAgIC8vIEV2ZW50IHR5cGVzIGZvciByZWFsLXRpbWUgdXBkYXRlc1xyXG4gICAgdGhpcy5ldmVudHMgPSB7XHJcbiAgICAgIElQT19VUERBVEU6IFwiaXBvOnVwZGF0ZVwiLFxyXG4gICAgICBHTVBfVVBEQVRFOiBcImdtcDp1cGRhdGVcIixcclxuICAgICAgU1VCU0NSSVBUSU9OX1VQREFURTogXCJzdWJzY3JpcHRpb246dXBkYXRlXCIsXHJcbiAgICAgIERFTUFORF9VUERBVEU6IFwiZGVtYW5kOnVwZGF0ZVwiLFxyXG4gICAgICBBTExPVE1FTlRfVVBEQVRFOiBcImFsbG90bWVudDp1cGRhdGVcIixcclxuICAgICAgU1lTVEVNX1NUQVRVUzogXCJzeXN0ZW06c3RhdHVzXCIsXHJcbiAgICAgIEFOQUxZVElDU19VUERBVEU6IFwiYW5hbHl0aWNzOnVwZGF0ZVwiLFxyXG4gICAgICBORVdTX1VQREFURTogXCJuZXdzOnVwZGF0ZVwiLFxyXG4gICAgICBBTEVSVF9UUklHR0VSRUQ6IFwiYWxlcnQ6dHJpZ2dlcmVkXCIsXHJcbiAgICB9O1xyXG5cclxuICAgIC8vIFJhdGUgbGltaXRpbmcgY29uZmlndXJhdGlvblxyXG4gICAgdGhpcy5yYXRlTGltaXRzID0gbmV3IE1hcCgpO1xyXG4gICAgdGhpcy5tYXhFdmVudHNQZXJTZWNvbmQgPSAyMDtcclxuICAgIHRoaXMubWF4U3Vic2NyaXB0aW9uc1BlckNsaWVudCA9IDEwMDtcclxuXHJcbiAgICAvLyBQZXJmb3JtYW5jZSBtb25pdG9yaW5nXHJcbiAgICB0aGlzLm1ldHJpY3MgPSB7XHJcbiAgICAgIHRvdGFsQ29ubmVjdGlvbnM6IDAsXHJcbiAgICAgIGN1cnJlbnRDb25uZWN0aW9uczogMCxcclxuICAgICAgdG90YWxNZXNzYWdlczogMCxcclxuICAgICAgdG90YWxTdWJzY3JpcHRpb25zOiAwLFxyXG4gICAgICBlcnJvcnM6IDAsXHJcbiAgICAgIHN0YXJ0VGltZTogRGF0ZS5ub3coKSxcclxuICAgICAgYXZlcmFnZVJlc3BvbnNlVGltZTogMCxcclxuICAgICAgcGVha0Nvbm5lY3Rpb25zOiAwLFxyXG4gICAgfTtcclxuXHJcbiAgICAvLyBDb25uZWN0aW9uIGhlYWx0aCB0cmFja2luZ1xyXG4gICAgdGhpcy5jb25uZWN0aW9uSGVhbHRoID0gbmV3IE1hcCgpO1xyXG5cclxuICAgIC8vIE1lc3NhZ2UgcXVldWUgZm9yIG9mZmxpbmUgY2xpZW50c1xyXG4gICAgdGhpcy5tZXNzYWdlUXVldWUgPSBuZXcgTWFwKCk7XHJcbiAgICB0aGlzLm1heFF1ZXVlU2l6ZSA9IDUwO1xyXG4gIH1cclxuXHJcbiAgLy8gSW5pdGlhbGl6ZSBXZWJTb2NrZXQgc2VydmVyIHdpdGggZW5oYW5jZWQgY29uZmlndXJhdGlvblxyXG4gIGluaXRpYWxpemUoKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICB0aGlzLnNlcnZlciA9IGNyZWF0ZVNlcnZlcigpO1xyXG4gICAgICB0aGlzLmlvID0gbmV3IFNlcnZlcih0aGlzLnNlcnZlciwge1xyXG4gICAgICAgIGNvcnM6IHtcclxuICAgICAgICAgIG9yaWdpbjogcHJvY2Vzcy5lbnYuRlJPTlRFTkRfVVJMIHx8IFwiaHR0cDovL2xvY2FsaG9zdDozMDAwXCIsXHJcbiAgICAgICAgICBtZXRob2RzOiBbXCJHRVRcIiwgXCJQT1NUXCJdLFxyXG4gICAgICAgICAgY3JlZGVudGlhbHM6IHRydWUsXHJcbiAgICAgICAgfSxcclxuICAgICAgICBwaW5nVGltZW91dDogNjAwMDAsXHJcbiAgICAgICAgcGluZ0ludGVydmFsOiAyNTAwMCxcclxuICAgICAgICBtYXhIdHRwQnVmZmVyU2l6ZTogMmU2LCAvLyAyTUJcclxuICAgICAgICB0cmFuc3BvcnRzOiBbXCJ3ZWJzb2NrZXRcIiwgXCJwb2xsaW5nXCJdLFxyXG4gICAgICAgIGFsbG93RUlPMzogdHJ1ZSxcclxuICAgICAgICAvLyBDb25uZWN0aW9uIHJhdGUgbGltaXRpbmdcclxuICAgICAgICBjb25uZWN0VGltZW91dDogNDUwMDAsXHJcbiAgICAgICAgdXBncmFkZVRpbWVvdXQ6IDEwMDAwLFxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIHRoaXMuc2V0dXBFdmVudEhhbmRsZXJzKCk7XHJcbiAgICAgIHRoaXMuc3RhcnRIZWFydGJlYXQoKTtcclxuICAgICAgdGhpcy5zdGFydE1ldHJpY3NDb2xsZWN0aW9uKCk7XHJcbiAgICAgIHRoaXMuc3RhcnRIZWFsdGhNb25pdG9yaW5nKCk7XHJcblxyXG4gICAgICBjb25zb2xlLmxvZyhcIvCflIwgV2ViU29ja2V0IHNlcnZpY2UgaW5pdGlhbGl6ZWQgc3VjY2Vzc2Z1bGx5XCIpO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCLinYwgRmFpbGVkIHRvIGluaXRpYWxpemUgV2ViU29ja2V0IHNlcnZpY2U6XCIsIGVycm9yKTtcclxuICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBTdGFydCB0aGUgV2ViU29ja2V0IHNlcnZlclxyXG4gIGFzeW5jIHN0YXJ0KCkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgIHRoaXMuc2VydmVyLmxpc3Rlbih0aGlzLnBvcnQsIChlcnIpID0+IHtcclxuICAgICAgICAgIGlmIChlcnIpIHtcclxuICAgICAgICAgICAgcmVqZWN0KGVycik7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhg8J+agCBXZWJTb2NrZXQgc2VydmVyIHJ1bm5pbmcgb24gcG9ydCAke3RoaXMucG9ydH1gKTtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXHJcbiAgICAgICAgICAgICAgYPCfjJAgQWNjZXB0aW5nIGNvbm5lY3Rpb25zIGZyb206ICR7cHJvY2Vzcy5lbnYuRlJPTlRFTkRfVVJMIHx8IFwiaHR0cDovL2xvY2FsaG9zdDozMDAwXCJ9YFxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgLy8gU3RhcnQgcGVyaW9kaWMgY2xlYW51cFxyXG4gICAgICB0aGlzLnN0YXJ0UGVyaW9kaWNDbGVhbnVwKCk7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKFwi4p2MIEZhaWxlZCB0byBzdGFydCBXZWJTb2NrZXQgc2VydmVyOlwiLCBlcnJvcik7XHJcbiAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gRW5oYW5jZWQgZXZlbnQgaGFuZGxlcnNcclxuICBzZXR1cEV2ZW50SGFuZGxlcnMoKSB7XHJcbiAgICB0aGlzLmlvLm9uKFwiY29ubmVjdGlvblwiLCAoc29ja2V0KSA9PiB7XHJcbiAgICAgIHRoaXMuaGFuZGxlQ2xpZW50Q29ubmVjdGlvbihzb2NrZXQpO1xyXG4gICAgICB0aGlzLnNldHVwQ2xpZW50RXZlbnRMaXN0ZW5lcnMoc29ja2V0KTtcclxuXHJcbiAgICAgIC8vIFRyYWNrIG1ldHJpY3NcclxuICAgICAgdGhpcy5tZXRyaWNzLnRvdGFsQ29ubmVjdGlvbnMrKztcclxuICAgICAgdGhpcy5tZXRyaWNzLmN1cnJlbnRDb25uZWN0aW9ucysrO1xyXG4gICAgICB0aGlzLm1ldHJpY3MucGVha0Nvbm5lY3Rpb25zID0gTWF0aC5tYXgoXHJcbiAgICAgICAgdGhpcy5tZXRyaWNzLnBlYWtDb25uZWN0aW9ucyxcclxuICAgICAgICB0aGlzLm1ldHJpY3MuY3VycmVudENvbm5lY3Rpb25zXHJcbiAgICAgICk7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBIYW5kbGUgc2VydmVyIGVycm9yc1xyXG4gICAgdGhpcy5pby5vbihcImVycm9yXCIsIChlcnJvcikgPT4ge1xyXG4gICAgICBjb25zb2xlLmVycm9yKFwi8J+UjCBXZWJTb2NrZXQgc2VydmVyIGVycm9yOlwiLCBlcnJvcik7XHJcbiAgICAgIHRoaXMubWV0cmljcy5lcnJvcnMrKztcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgaGFuZGxlQ2xpZW50Q29ubmVjdGlvbihzb2NrZXQpIHtcclxuICAgIGNvbnN0IGNsaWVudElQID0gc29ja2V0LmhhbmRzaGFrZS5hZGRyZXNzO1xyXG4gICAgY29uc3QgdXNlckFnZW50ID0gc29ja2V0LmhhbmRzaGFrZS5oZWFkZXJzW1widXNlci1hZ2VudFwiXSB8fCBcIlVua25vd25cIjtcclxuXHJcbiAgICBjb25zb2xlLmxvZyhg8J+UjCBDbGllbnQgY29ubmVjdGVkOiAke3NvY2tldC5pZH0gZnJvbSAke2NsaWVudElQfWApO1xyXG5cclxuICAgIGNvbnN0IGNsaWVudEluZm8gPSB7XHJcbiAgICAgIHNvY2tldCxcclxuICAgICAgY29ubmVjdGVkQXQ6IG5ldyBEYXRlKCksXHJcbiAgICAgIHN1YnNjcmlwdGlvbnM6IG5ldyBTZXQoKSxcclxuICAgICAgbGFzdEFjdGl2aXR5OiBuZXcgRGF0ZSgpLFxyXG4gICAgICBzdWJzY3JpcHRpb25Db3VudDogMCxcclxuICAgICAgbWVzc2FnZUNvdW50OiAwLFxyXG4gICAgICB1c2VyQWdlbnQsXHJcbiAgICAgIGlwQWRkcmVzczogY2xpZW50SVAsXHJcbiAgICAgIGlzSGVhbHRoeTogdHJ1ZSxcclxuICAgICAgbGFzdFBpbmc6IERhdGUubm93KCksXHJcbiAgICAgIHJlY29ubmVjdENvdW50OiAwLFxyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLmNvbm5lY3RlZENsaWVudHMuc2V0KHNvY2tldC5pZCwgY2xpZW50SW5mbyk7XHJcbiAgICB0aGlzLmNvbm5lY3Rpb25IZWFsdGguc2V0KHNvY2tldC5pZCwge1xyXG4gICAgICBzdGF0dXM6IFwiY29ubmVjdGVkXCIsXHJcbiAgICAgIGxhdGVuY3k6IDAsXHJcbiAgICAgIGxhc3RTZWVuOiBEYXRlLm5vdygpLFxyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gU2VuZCBjb25uZWN0aW9uIGNvbmZpcm1hdGlvbiB3aXRoIHNlcnZlciBpbmZvXHJcbiAgICBzb2NrZXQuZW1pdChcImNvbm5lY3RlZFwiLCB7XHJcbiAgICAgIHNvY2tldElkOiBzb2NrZXQuaWQsXHJcbiAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcclxuICAgICAgc2VydmVyVmVyc2lvbjogXCIxLjAuMFwiLFxyXG4gICAgICBhdmFpbGFibGVFdmVudHM6IE9iamVjdC52YWx1ZXModGhpcy5ldmVudHMpLFxyXG4gICAgICBtYXhTdWJzY3JpcHRpb25zOiB0aGlzLm1heFN1YnNjcmlwdGlvbnNQZXJDbGllbnQsXHJcbiAgICAgIHJhdGVMaW1pdHM6IHtcclxuICAgICAgICBtYXhFdmVudHNQZXJTZWNvbmQ6IHRoaXMubWF4RXZlbnRzUGVyU2Vjb25kLFxyXG4gICAgICB9LFxyXG4gICAgICBmZWF0dXJlczoge1xyXG4gICAgICAgIHJlYWxUaW1lVXBkYXRlczogdHJ1ZSxcclxuICAgICAgICBiYXRjaFN1YnNjcmlwdGlvbnM6IHRydWUsXHJcbiAgICAgICAgbWVzc2FnZVF1ZXVlOiB0cnVlLFxyXG4gICAgICAgIGFuYWx5dGljczogdHJ1ZSxcclxuICAgICAgfSxcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIFNlbmQgcXVldWVkIG1lc3NhZ2VzIGlmIGFueVxyXG4gICAgdGhpcy5zZW5kUXVldWVkTWVzc2FnZXMoc29ja2V0LmlkKTtcclxuICB9XHJcblxyXG4gIHNldHVwQ2xpZW50RXZlbnRMaXN0ZW5lcnMoc29ja2V0KSB7XHJcbiAgICAvLyBJUE8gc3Vic2NyaXB0aW9uIHdpdGggZW5oYW5jZWQgZmVhdHVyZXNcclxuICAgIHNvY2tldC5vbihcInN1YnNjcmliZTppcG9cIiwgYXN5bmMgKGRhdGEpID0+IHtcclxuICAgICAgYXdhaXQgdGhpcy5oYW5kbGVTdWJzY3JpcHRpb24oc29ja2V0LCBcImlwb1wiLCBkYXRhLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgY29uc3QgeyBpcG9JZCwgc3ltYm9sLCBpbmNsdWRlQW5hbHl0aWNzID0gZmFsc2UgfSA9IGRhdGE7XHJcblxyXG4gICAgICAgIGlmIChpcG9JZCkge1xyXG4gICAgICAgICAgc29ja2V0LmpvaW4oYGlwbzoke2lwb0lkfWApO1xyXG4gICAgICAgICAgdGhpcy5hZGRTdWJzY3JpcHRpb24oc29ja2V0LmlkLCBcImlwb1wiLCBpcG9JZCk7XHJcblxyXG4gICAgICAgICAgLy8gU2VuZCBjdXJyZW50IGRhdGEgaW1tZWRpYXRlbHlcclxuICAgICAgICAgIGNvbnN0IGlwb0RhdGEgPSBhd2FpdCB0aGlzLmdldEN1cnJlbnRJUE9EYXRhKGlwb0lkKTtcclxuICAgICAgICAgIGlmIChpcG9EYXRhKSB7XHJcbiAgICAgICAgICAgIHNvY2tldC5lbWl0KHRoaXMuZXZlbnRzLklQT19VUERBVEUsIHtcclxuICAgICAgICAgICAgICBpcG9JZCxcclxuICAgICAgICAgICAgICBkYXRhOiBpcG9EYXRhLFxyXG4gICAgICAgICAgICAgIHR5cGU6IFwiaW5pdGlhbF9kYXRhXCIsXHJcbiAgICAgICAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIC8vIFNlbmQgYW5hbHl0aWNzIGlmIHJlcXVlc3RlZFxyXG4gICAgICAgICAgICBpZiAoaW5jbHVkZUFuYWx5dGljcyAmJiBpcG9EYXRhLmFuYWx5dGljcykge1xyXG4gICAgICAgICAgICAgIHNvY2tldC5lbWl0KHRoaXMuZXZlbnRzLkFOQUxZVElDU19VUERBVEUsIHtcclxuICAgICAgICAgICAgICAgIGlwb0lkLFxyXG4gICAgICAgICAgICAgICAgZGF0YTogaXBvRGF0YS5hbmFseXRpY3MsXHJcbiAgICAgICAgICAgICAgICB0eXBlOiBcImluaXRpYWxfYW5hbHl0aWNzXCIsXHJcbiAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXHJcbiAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gRW5oYW5jZWQgR01QIHN1YnNjcmlwdGlvblxyXG4gICAgc29ja2V0Lm9uKFwic3Vic2NyaWJlOmdtcFwiLCBhc3luYyAoZGF0YSkgPT4ge1xyXG4gICAgICBhd2FpdCB0aGlzLmhhbmRsZVN1YnNjcmlwdGlvbihzb2NrZXQsIFwiZ21wXCIsIGRhdGEsIGFzeW5jICgpID0+IHtcclxuICAgICAgICBjb25zdCB7XHJcbiAgICAgICAgICBpcG9JZCxcclxuICAgICAgICAgIHN5bWJvbCxcclxuICAgICAgICAgIGhpc3RvcmljYWwgPSBmYWxzZSxcclxuICAgICAgICAgIGFsZXJ0VGhyZXNob2xkID0gbnVsbCxcclxuICAgICAgICB9ID0gZGF0YTtcclxuXHJcbiAgICAgICAgaWYgKGlwb0lkKSB7XHJcbiAgICAgICAgICBzb2NrZXQuam9pbihgZ21wOiR7aXBvSWR9YCk7XHJcbiAgICAgICAgICB0aGlzLmFkZFN1YnNjcmlwdGlvbihzb2NrZXQuaWQsIFwiZ21wXCIsIGlwb0lkKTtcclxuXHJcbiAgICAgICAgICAvLyBTZW5kIGN1cnJlbnQgR01QIGRhdGFcclxuICAgICAgICAgIGNvbnN0IGdtcERhdGEgPSBhd2FpdCBjYWNoZS5nZXRSZWFsVGltZURhdGEoXCJHTVBcIiwgaXBvSWQpO1xyXG4gICAgICAgICAgaWYgKGdtcERhdGEpIHtcclxuICAgICAgICAgICAgc29ja2V0LmVtaXQodGhpcy5ldmVudHMuR01QX1VQREFURSwge1xyXG4gICAgICAgICAgICAgIGlwb0lkLFxyXG4gICAgICAgICAgICAgIGRhdGE6IGdtcERhdGEsXHJcbiAgICAgICAgICAgICAgdHlwZTogXCJjdXJyZW50XCIsXHJcbiAgICAgICAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBTZW5kIGhpc3RvcmljYWwgZGF0YSBpZiByZXF1ZXN0ZWRcclxuICAgICAgICAgIGlmIChoaXN0b3JpY2FsKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGhpc3RvcmljYWxHTVAgPSBhd2FpdCB0aGlzLmdldEhpc3RvcmljYWxHTVBEYXRhKGlwb0lkLCAzMCk7XHJcbiAgICAgICAgICAgIHNvY2tldC5lbWl0KFwiZ21wOmhpc3RvcmljYWxcIiwge1xyXG4gICAgICAgICAgICAgIGlwb0lkLFxyXG4gICAgICAgICAgICAgIGRhdGE6IGhpc3RvcmljYWxHTVAsXHJcbiAgICAgICAgICAgICAgdHlwZTogXCJoaXN0b3JpY2FsXCIsXHJcbiAgICAgICAgICAgICAgZGF5czogMzAsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIFNldCB1cCBhbGVydCB0aHJlc2hvbGQgaWYgcHJvdmlkZWRcclxuICAgICAgICAgIGlmIChhbGVydFRocmVzaG9sZCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLnNldHVwR01QQWxlcnQoc29ja2V0LmlkLCBpcG9JZCwgYWxlcnRUaHJlc2hvbGQpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBSZWFsLXRpbWUgc3Vic2NyaXB0aW9uIGRhdGEgdXBkYXRlc1xyXG4gICAgc29ja2V0Lm9uKFwic3Vic2NyaWJlOnN1YnNjcmlwdGlvblwiLCBhc3luYyAoZGF0YSkgPT4ge1xyXG4gICAgICBhd2FpdCB0aGlzLmhhbmRsZVN1YnNjcmlwdGlvbihzb2NrZXQsIFwic3Vic2NyaXB0aW9uXCIsIGRhdGEsIGFzeW5jICgpID0+IHtcclxuICAgICAgICBjb25zdCB7IHN5bWJvbCwgY2F0ZWdvcmllcyA9IFtdLCByZWFsVGltZSA9IHRydWUgfSA9IGRhdGE7XHJcblxyXG4gICAgICAgIHNvY2tldC5qb2luKGBzdWJzY3JpcHRpb246JHtzeW1ib2x9YCk7XHJcbiAgICAgICAgdGhpcy5hZGRTdWJzY3JpcHRpb24oc29ja2V0LmlkLCBcInN1YnNjcmlwdGlvblwiLCBzeW1ib2wpO1xyXG5cclxuICAgICAgICAvLyBTZW5kIGN1cnJlbnQgc3Vic2NyaXB0aW9uIGRhdGFcclxuICAgICAgICBjb25zdCBzdWJEYXRhID0gYXdhaXQgY2FjaGUuZ2V0UmVhbFRpbWVEYXRhKFwiU1VCU0NSSVBUSU9OXCIsIHN5bWJvbCk7XHJcbiAgICAgICAgaWYgKHN1YkRhdGEpIHtcclxuICAgICAgICAgIGNvbnN0IGZpbHRlcmVkRGF0YSA9XHJcbiAgICAgICAgICAgIGNhdGVnb3JpZXMubGVuZ3RoID4gMFxyXG4gICAgICAgICAgICAgID8gc3ViRGF0YS5kYXRhPy5maWx0ZXIoKGl0ZW0pID0+XHJcbiAgICAgICAgICAgICAgICAgIGNhdGVnb3JpZXMuaW5jbHVkZXMoaXRlbS5jYXRlZ29yeSlcclxuICAgICAgICAgICAgICAgIClcclxuICAgICAgICAgICAgICA6IHN1YkRhdGE7XHJcblxyXG4gICAgICAgICAgc29ja2V0LmVtaXQodGhpcy5ldmVudHMuU1VCU0NSSVBUSU9OX1VQREFURSwge1xyXG4gICAgICAgICAgICBzeW1ib2wsXHJcbiAgICAgICAgICAgIGRhdGE6IGZpbHRlcmVkRGF0YSxcclxuICAgICAgICAgICAgY2F0ZWdvcmllczogY2F0ZWdvcmllcy5sZW5ndGggPiAwID8gY2F0ZWdvcmllcyA6IFwiYWxsXCIsXHJcbiAgICAgICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBNYXJrZXQgZGVtYW5kIHVwZGF0ZXMgd2l0aCBwcmljZSBmaWx0ZXJpbmdcclxuICAgIHNvY2tldC5vbihcInN1YnNjcmliZTpkZW1hbmRcIiwgYXN5bmMgKGRhdGEpID0+IHtcclxuICAgICAgYXdhaXQgdGhpcy5oYW5kbGVTdWJzY3JpcHRpb24oc29ja2V0LCBcImRlbWFuZFwiLCBkYXRhLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgY29uc3QgeyBzeW1ib2wsIHByaWNlUmFuZ2UgPSBudWxsLCBjdXRPZmZPbmx5ID0gZmFsc2UgfSA9IGRhdGE7XHJcblxyXG4gICAgICAgIHNvY2tldC5qb2luKGBkZW1hbmQ6JHtzeW1ib2x9YCk7XHJcbiAgICAgICAgdGhpcy5hZGRTdWJzY3JpcHRpb24oc29ja2V0LmlkLCBcImRlbWFuZFwiLCBzeW1ib2wpO1xyXG5cclxuICAgICAgICAvLyBTZW5kIGN1cnJlbnQgZGVtYW5kIGRhdGFcclxuICAgICAgICBjb25zdCBkZW1hbmREYXRhID0gYXdhaXQgY2FjaGUuZ2V0UmVhbFRpbWVEYXRhKFwiREVNQU5EXCIsIHN5bWJvbCk7XHJcbiAgICAgICAgaWYgKGRlbWFuZERhdGEpIHtcclxuICAgICAgICAgIGxldCBmaWx0ZXJlZERhdGEgPSBkZW1hbmREYXRhLmRhdGEgfHwgW107XHJcblxyXG4gICAgICAgICAgLy8gQXBwbHkgZmlsdGVyc1xyXG4gICAgICAgICAgaWYgKGN1dE9mZk9ubHkpIHtcclxuICAgICAgICAgICAgZmlsdGVyZWREYXRhID0gZmlsdGVyZWREYXRhLmZpbHRlcigoaXRlbSkgPT4gaXRlbS5jdXRPZmZJbmRpY2F0b3IpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGlmIChcclxuICAgICAgICAgICAgcHJpY2VSYW5nZSAmJlxyXG4gICAgICAgICAgICBwcmljZVJhbmdlLm1pbiAhPT0gdW5kZWZpbmVkICYmXHJcbiAgICAgICAgICAgIHByaWNlUmFuZ2UubWF4ICE9PSB1bmRlZmluZWRcclxuICAgICAgICAgICkge1xyXG4gICAgICAgICAgICBmaWx0ZXJlZERhdGEgPSBmaWx0ZXJlZERhdGEuZmlsdGVyKFxyXG4gICAgICAgICAgICAgIChpdGVtKSA9PlxyXG4gICAgICAgICAgICAgICAgaXRlbS5wcmljZSA+PSBwcmljZVJhbmdlLm1pbiAmJiBpdGVtLnByaWNlIDw9IHByaWNlUmFuZ2UubWF4XHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgc29ja2V0LmVtaXQodGhpcy5ldmVudHMuREVNQU5EX1VQREFURSwge1xyXG4gICAgICAgICAgICBzeW1ib2wsXHJcbiAgICAgICAgICAgIGRhdGE6IGZpbHRlcmVkRGF0YSxcclxuICAgICAgICAgICAgZmlsdGVyczogeyBwcmljZVJhbmdlLCBjdXRPZmZPbmx5IH0sXHJcbiAgICAgICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBBbmFseXRpY3Mgc3Vic2NyaXB0aW9uIHdpdGggY3VzdG9taXphYmxlIG1ldHJpY3NcclxuICAgIHNvY2tldC5vbihcInN1YnNjcmliZTphbmFseXRpY3NcIiwgYXN5bmMgKGRhdGEpID0+IHtcclxuICAgICAgYXdhaXQgdGhpcy5oYW5kbGVTdWJzY3JpcHRpb24oc29ja2V0LCBcImFuYWx5dGljc1wiLCBkYXRhLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgY29uc3Qge1xyXG4gICAgICAgICAgaXBvSWQsXHJcbiAgICAgICAgICB0eXBlID0gXCJhbGxcIixcclxuICAgICAgICAgIG1ldHJpY3MgPSBbXSxcclxuICAgICAgICAgIHVwZGF0ZUludGVydmFsID0gMzAwMDAsXHJcbiAgICAgICAgfSA9IGRhdGE7XHJcblxyXG4gICAgICAgIHNvY2tldC5qb2luKGBhbmFseXRpY3M6JHtpcG9JZH1gKTtcclxuICAgICAgICB0aGlzLmFkZFN1YnNjcmlwdGlvbihzb2NrZXQuaWQsIFwiYW5hbHl0aWNzXCIsIGlwb0lkKTtcclxuXHJcbiAgICAgICAgLy8gU2VuZCBjdXJyZW50IGFuYWx5dGljc1xyXG4gICAgICAgIGNvbnN0IGFuYWx5dGljcyA9IGF3YWl0IHRoaXMuZ2V0Q3VycmVudEFuYWx5dGljcyhpcG9JZCwgdHlwZSk7XHJcbiAgICAgICAgaWYgKGFuYWx5dGljcykge1xyXG4gICAgICAgICAgY29uc3QgZmlsdGVyZWRBbmFseXRpY3MgPVxyXG4gICAgICAgICAgICBtZXRyaWNzLmxlbmd0aCA+IDBcclxuICAgICAgICAgICAgICA/IHRoaXMuZmlsdGVyQW5hbHl0aWNzQnlNZXRyaWNzKGFuYWx5dGljcywgbWV0cmljcylcclxuICAgICAgICAgICAgICA6IGFuYWx5dGljcztcclxuXHJcbiAgICAgICAgICBzb2NrZXQuZW1pdCh0aGlzLmV2ZW50cy5BTkFMWVRJQ1NfVVBEQVRFLCB7XHJcbiAgICAgICAgICAgIGlwb0lkLFxyXG4gICAgICAgICAgICB0eXBlLFxyXG4gICAgICAgICAgICBkYXRhOiBmaWx0ZXJlZEFuYWx5dGljcyxcclxuICAgICAgICAgICAgbWV0cmljczogbWV0cmljcy5sZW5ndGggPiAwID8gbWV0cmljcyA6IFwiYWxsXCIsXHJcbiAgICAgICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBTeXN0ZW0gc3RhdHVzIHN1YnNjcmlwdGlvblxyXG4gICAgc29ja2V0Lm9uKFwic3Vic2NyaWJlOnN5c3RlbVwiLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgIHNvY2tldC5qb2luKFwic3lzdGVtOnN0YXR1c1wiKTtcclxuICAgICAgdGhpcy5hZGRTdWJzY3JpcHRpb24oc29ja2V0LmlkLCBcInN5c3RlbVwiLCBcInN0YXR1c1wiKTtcclxuXHJcbiAgICAgIC8vIFNlbmQgY3VycmVudCBzeXN0ZW0gc3RhdHVzXHJcbiAgICAgIGNvbnN0IHN5c3RlbVN0YXR1cyA9IGF3YWl0IHRoaXMuZ2V0U3lzdGVtU3RhdHVzKCk7XHJcbiAgICAgIHNvY2tldC5lbWl0KHRoaXMuZXZlbnRzLlNZU1RFTV9TVEFUVVMsIHtcclxuICAgICAgICAuLi5zeXN0ZW1TdGF0dXMsXHJcbiAgICAgICAgdHlwZTogXCJjdXJyZW50X3N0YXR1c1wiLFxyXG4gICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBCYXRjaCBzdWJzY3JpcHRpb24gZm9yIG11bHRpcGxlIElQT3Mgd2l0aCBhZHZhbmNlZCBvcHRpb25zXHJcbiAgICBzb2NrZXQub24oXCJzdWJzY3JpYmU6YmF0Y2hcIiwgYXN5bmMgKGRhdGEpID0+IHtcclxuICAgICAgY29uc3QgeyBzdWJzY3JpcHRpb25zID0gW10sIG9wdGlvbnMgPSB7fSB9ID0gZGF0YTtcclxuICAgICAgY29uc3QgeyBtYXhTdWJzY3JpcHRpb25zID0gMjAsIHNraXBFcnJvcnMgPSB0cnVlIH0gPSBvcHRpb25zO1xyXG4gICAgICBjb25zdCByZXN1bHRzID0gW107XHJcblxyXG4gICAgICAvLyBMaW1pdCBiYXRjaCBzaXplXHJcbiAgICAgIGNvbnN0IGxpbWl0ZWRTdWJzY3JpcHRpb25zID0gc3Vic2NyaXB0aW9ucy5zbGljZSgwLCBtYXhTdWJzY3JpcHRpb25zKTtcclxuXHJcbiAgICAgIGZvciAoY29uc3Qgc3ViIG9mIGxpbWl0ZWRTdWJzY3JpcHRpb25zKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIGF3YWl0IHRoaXMuaGFuZGxlU2luZ2xlU3Vic2NyaXB0aW9uKHNvY2tldCwgc3ViKTtcclxuICAgICAgICAgIHJlc3VsdHMucHVzaCh7IC4uLnN1Yiwgc3RhdHVzOiBcInN1Y2Nlc3NcIiB9KTtcclxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgcmVzdWx0cy5wdXNoKHsgLi4uc3ViLCBzdGF0dXM6IFwiZXJyb3JcIiwgZXJyb3I6IGVycm9yLm1lc3NhZ2UgfSk7XHJcbiAgICAgICAgICBpZiAoIXNraXBFcnJvcnMpIHtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBzb2NrZXQuZW1pdChcInN1YnNjcmliZTpiYXRjaDpyZXN1bHRcIiwge1xyXG4gICAgICAgIHJlc3VsdHMsXHJcbiAgICAgICAgcHJvY2Vzc2VkOiByZXN1bHRzLmxlbmd0aCxcclxuICAgICAgICBzdWNjZXNzZnVsOiByZXN1bHRzLmZpbHRlcigocikgPT4gci5zdGF0dXMgPT09IFwic3VjY2Vzc1wiKS5sZW5ndGgsXHJcbiAgICAgICAgZXJyb3JzOiByZXN1bHRzLmZpbHRlcigocikgPT4gci5zdGF0dXMgPT09IFwiZXJyb3JcIikubGVuZ3RoLFxyXG4gICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBFbmhhbmNlZCB1bnN1YnNjcmliZSB3aXRoIHBhdHRlcm5zXHJcbiAgICBzb2NrZXQub24oXCJ1bnN1YnNjcmliZVwiLCAoZGF0YSkgPT4ge1xyXG4gICAgICBjb25zdCB7IHR5cGUsIGlkZW50aWZpZXIsIHBhdHRlcm4gfSA9IGRhdGE7XHJcblxyXG4gICAgICBpZiAocGF0dGVybiA9PT0gXCJhbGxcIikge1xyXG4gICAgICAgIHRoaXMudW5zdWJzY3JpYmVBbGwoc29ja2V0LmlkKTtcclxuICAgICAgICBzb2NrZXQuZW1pdChcInVuc3Vic2NyaWJlOnJlc3VsdFwiLCB7XHJcbiAgICAgICAgICBwYXR0ZXJuOiBcImFsbFwiLFxyXG4gICAgICAgICAgc3RhdHVzOiBcInN1Y2Nlc3NcIixcclxuICAgICAgICAgIG1lc3NhZ2U6IFwiVW5zdWJzY3JpYmVkIGZyb20gYWxsIGV2ZW50c1wiLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9IGVsc2UgaWYgKHR5cGUgJiYgaWRlbnRpZmllcikge1xyXG4gICAgICAgIGNvbnN0IHJvb21LZXkgPSBgJHt0eXBlfToke2lkZW50aWZpZXJ9YDtcclxuICAgICAgICBzb2NrZXQubGVhdmUocm9vbUtleSk7XHJcbiAgICAgICAgdGhpcy5yZW1vdmVTdWJzY3JpcHRpb24oc29ja2V0LmlkLCB0eXBlLCBpZGVudGlmaWVyKTtcclxuICAgICAgICBzb2NrZXQuZW1pdChcInVuc3Vic2NyaWJlOnJlc3VsdFwiLCB7XHJcbiAgICAgICAgICB0eXBlLFxyXG4gICAgICAgICAgaWRlbnRpZmllcixcclxuICAgICAgICAgIHN0YXR1czogXCJzdWNjZXNzXCIsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0gZWxzZSBpZiAodHlwZSkge1xyXG4gICAgICAgIC8vIFVuc3Vic2NyaWJlIGZyb20gYWxsIHN1YnNjcmlwdGlvbnMgb2YgYSBzcGVjaWZpYyB0eXBlXHJcbiAgICAgICAgdGhpcy51bnN1YnNjcmliZUJ5VHlwZShzb2NrZXQuaWQsIHR5cGUpO1xyXG4gICAgICAgIHNvY2tldC5lbWl0KFwidW5zdWJzY3JpYmU6cmVzdWx0XCIsIHtcclxuICAgICAgICAgIHR5cGUsXHJcbiAgICAgICAgICBzdGF0dXM6IFwic3VjY2Vzc1wiLFxyXG4gICAgICAgICAgbWVzc2FnZTogYFVuc3Vic2NyaWJlZCBmcm9tIGFsbCAke3R5cGV9IGV2ZW50c2AsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIC8vIEVuaGFuY2VkIGhlYXJ0YmVhdCB3aXRoIHBlcmZvcm1hbmNlIG1ldHJpY3NcclxuICAgIHNvY2tldC5vbihcInBpbmdcIiwgKGRhdGEpID0+IHtcclxuICAgICAgY29uc3QgY2xpZW50ID0gdGhpcy5jb25uZWN0ZWRDbGllbnRzLmdldChzb2NrZXQuaWQpO1xyXG4gICAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xyXG5cclxuICAgICAgaWYgKGNsaWVudCkge1xyXG4gICAgICAgIGNsaWVudC5sYXN0QWN0aXZpdHkgPSBuZXcgRGF0ZSgpO1xyXG4gICAgICAgIGNsaWVudC5tZXNzYWdlQ291bnQrKztcclxuICAgICAgICBjbGllbnQubGFzdFBpbmcgPSBub3c7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIENhbGN1bGF0ZSBsYXRlbmN5XHJcbiAgICAgIGNvbnN0IGxhdGVuY3kgPSBkYXRhPy50aW1lc3RhbXAgPyBub3cgLSBkYXRhLnRpbWVzdGFtcCA6IDA7XHJcbiAgICAgIHRoaXMuY29ubmVjdGlvbkhlYWx0aC5zZXQoc29ja2V0LmlkLCB7XHJcbiAgICAgICAgc3RhdHVzOiBcImhlYWx0aHlcIixcclxuICAgICAgICBsYXRlbmN5LFxyXG4gICAgICAgIGxhc3RTZWVuOiBub3csXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgc29ja2V0LmVtaXQoXCJwb25nXCIsIHtcclxuICAgICAgICB0aW1lc3RhbXA6IG5vdyxcclxuICAgICAgICBzZXJ2ZXJVcHRpbWU6IG5vdyAtIHRoaXMubWV0cmljcy5zdGFydFRpbWUsXHJcbiAgICAgICAgbGF0ZW5jeSxcclxuICAgICAgICBjbGllbnRJbmZvOiBjbGllbnRcclxuICAgICAgICAgID8ge1xyXG4gICAgICAgICAgICAgIHN1YnNjcmlwdGlvbnM6IGNsaWVudC5zdWJzY3JpcHRpb25Db3VudCxcclxuICAgICAgICAgICAgICBtZXNzYWdlczogY2xpZW50Lm1lc3NhZ2VDb3VudCxcclxuICAgICAgICAgICAgICBjb25uZWN0ZWRGb3I6IG5vdyAtIGNsaWVudC5jb25uZWN0ZWRBdC5nZXRUaW1lKCksXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIDogbnVsbCxcclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBDbGllbnQgaW5mbyBhbmQgc3RhdGlzdGljcyByZXF1ZXN0XHJcbiAgICBzb2NrZXQub24oXCJjbGllbnQ6aW5mb1wiLCAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuY29ubmVjdGVkQ2xpZW50cy5nZXQoc29ja2V0LmlkKTtcclxuICAgICAgY29uc3QgaGVhbHRoID0gdGhpcy5jb25uZWN0aW9uSGVhbHRoLmdldChzb2NrZXQuaWQpO1xyXG5cclxuICAgICAgaWYgKGNsaWVudCkge1xyXG4gICAgICAgIHNvY2tldC5lbWl0KFwiY2xpZW50OmluZm9cIiwge1xyXG4gICAgICAgICAgc29ja2V0SWQ6IHNvY2tldC5pZCxcclxuICAgICAgICAgIGNvbm5lY3RlZEF0OiBjbGllbnQuY29ubmVjdGVkQXQsXHJcbiAgICAgICAgICBzdWJzY3JpcHRpb25zOiBBcnJheS5mcm9tKGNsaWVudC5zdWJzY3JpcHRpb25zKSxcclxuICAgICAgICAgIHN1YnNjcmlwdGlvbkNvdW50OiBjbGllbnQuc3Vic2NyaXB0aW9uQ291bnQsXHJcbiAgICAgICAgICBtZXNzYWdlQ291bnQ6IGNsaWVudC5tZXNzYWdlQ291bnQsXHJcbiAgICAgICAgICB1c2VyQWdlbnQ6IGNsaWVudC51c2VyQWdlbnQsXHJcbiAgICAgICAgICBpcEFkZHJlc3M6IGNsaWVudC5pcEFkZHJlc3MsXHJcbiAgICAgICAgICBoZWFsdGg6IGhlYWx0aCB8fCB7IHN0YXR1czogXCJ1bmtub3duXCIgfSxcclxuICAgICAgICAgIHNlcnZlck1ldHJpY3M6IHtcclxuICAgICAgICAgICAgdG90YWxDb25uZWN0aW9uczogdGhpcy5tZXRyaWNzLmN1cnJlbnRDb25uZWN0aW9ucyxcclxuICAgICAgICAgICAgc2VydmVyVXB0aW1lOiBEYXRlLm5vdygpIC0gdGhpcy5tZXRyaWNzLnN0YXJ0VGltZSxcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIC8vIFJlcXVlc3Qgc2VydmVyIHN0YXRpc3RpY3NcclxuICAgIHNvY2tldC5vbihcInNlcnZlcjpzdGF0c1wiLCAoKSA9PiB7XHJcbiAgICAgIGlmICh0aGlzLmlzQXV0aG9yaXplZChzb2NrZXQpKSB7XHJcbiAgICAgICAgLy8gT25seSBmb3IgYXV0aG9yaXplZCBjbGllbnRzXHJcbiAgICAgICAgY29uc3Qgc3RhdHMgPSB0aGlzLmdldERldGFpbGVkU3RhdHMoKTtcclxuICAgICAgICBzb2NrZXQuZW1pdChcInNlcnZlcjpzdGF0c1wiLCBzdGF0cyk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgc29ja2V0LmVtaXQoXCJlcnJvclwiLCB7XHJcbiAgICAgICAgICB0eXBlOiBcInVuYXV0aG9yaXplZFwiLFxyXG4gICAgICAgICAgbWVzc2FnZTogXCJOb3QgYXV0aG9yaXplZCB0byB2aWV3IHNlcnZlciBzdGF0aXN0aWNzXCIsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIC8vIEVycm9yIGhhbmRsaW5nXHJcbiAgICBzb2NrZXQub24oXCJlcnJvclwiLCAoZXJyb3IpID0+IHtcclxuICAgICAgY29uc29sZS5lcnJvcihg8J+UjCBTb2NrZXQgZXJyb3IgZm9yICR7c29ja2V0LmlkfTpgLCBlcnJvcik7XHJcbiAgICAgIHRoaXMubWV0cmljcy5lcnJvcnMrKztcclxuXHJcbiAgICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuY29ubmVjdGVkQ2xpZW50cy5nZXQoc29ja2V0LmlkKTtcclxuICAgICAgaWYgKGNsaWVudCkge1xyXG4gICAgICAgIGNsaWVudC5pc0hlYWx0aHkgPSBmYWxzZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy5jb25uZWN0aW9uSGVhbHRoLnNldChzb2NrZXQuaWQsIHtcclxuICAgICAgICBzdGF0dXM6IFwiZXJyb3JcIixcclxuICAgICAgICBlcnJvcjogZXJyb3IubWVzc2FnZSxcclxuICAgICAgICBsYXN0U2VlbjogRGF0ZS5ub3coKSxcclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBEaXNjb25uZWN0IGhhbmRsaW5nIHdpdGggY2xlYW51cFxyXG4gICAgc29ja2V0Lm9uKFwiZGlzY29ubmVjdFwiLCAocmVhc29uKSA9PiB7XHJcbiAgICAgIGNvbnNvbGUubG9nKGDwn5SMIENsaWVudCBkaXNjb25uZWN0ZWQ6ICR7c29ja2V0LmlkfSwgcmVhc29uOiAke3JlYXNvbn1gKTtcclxuXHJcbiAgICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuY29ubmVjdGVkQ2xpZW50cy5nZXQoc29ja2V0LmlkKTtcclxuICAgICAgaWYgKGNsaWVudCkge1xyXG4gICAgICAgIC8vIFN0b3JlIGRpc2Nvbm5lY3Rpb24gaW5mbyBmb3IgcG90ZW50aWFsIHJlY29ubmVjdGlvblxyXG4gICAgICAgIHRoaXMuaGFuZGxlQ2xpZW50RGlzY29ubmVjdGlvbihzb2NrZXQuaWQsIHJlYXNvbik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMuY2xlYW51cENsaWVudChzb2NrZXQuaWQpO1xyXG4gICAgICB0aGlzLm1ldHJpY3MuY3VycmVudENvbm5lY3Rpb25zLS07XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBSZWNvbm5lY3Rpb24gaGFuZGxpbmdcclxuICAgIHNvY2tldC5vbihcInJlY29ubmVjdFwiLCAoZGF0YSkgPT4ge1xyXG4gICAgICBjb25zb2xlLmxvZyhg8J+UhCBDbGllbnQgcmVjb25uZWN0ZWQ6ICR7c29ja2V0LmlkfWApO1xyXG4gICAgICBjb25zdCBjbGllbnQgPSB0aGlzLmNvbm5lY3RlZENsaWVudHMuZ2V0KHNvY2tldC5pZCk7XHJcbiAgICAgIGlmIChjbGllbnQpIHtcclxuICAgICAgICBjbGllbnQucmVjb25uZWN0Q291bnQrKztcclxuICAgICAgICBjbGllbnQubGFzdEFjdGl2aXR5ID0gbmV3IERhdGUoKTtcclxuXHJcbiAgICAgICAgLy8gU2VuZCBxdWV1ZWQgbWVzc2FnZXNcclxuICAgICAgICB0aGlzLnNlbmRRdWV1ZWRNZXNzYWdlcyhzb2NrZXQuaWQpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8vIEVuaGFuY2VkIHN1YnNjcmlwdGlvbiBoYW5kbGluZyB3aXRoIHZhbGlkYXRpb25cclxuICBhc3luYyBoYW5kbGVTdWJzY3JpcHRpb24oc29ja2V0LCB0eXBlLCBkYXRhLCBzdWJzY3JpcHRpb25Mb2dpYykge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgY2xpZW50ID0gdGhpcy5jb25uZWN0ZWRDbGllbnRzLmdldChzb2NrZXQuaWQpO1xyXG5cclxuICAgICAgaWYgKCFjbGllbnQpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDbGllbnQgbm90IGZvdW5kXCIpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBDaGVjayBzdWJzY3JpcHRpb24gbGltaXRzXHJcbiAgICAgIGlmIChjbGllbnQuc3Vic2NyaXB0aW9uQ291bnQgPj0gdGhpcy5tYXhTdWJzY3JpcHRpb25zUGVyQ2xpZW50KSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICAgICAgYE1heGltdW0gc3Vic2NyaXB0aW9ucyBsaW1pdCByZWFjaGVkICgke3RoaXMubWF4U3Vic2NyaXB0aW9uc1BlckNsaWVudH0pYFxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIENoZWNrIHJhdGUgbGltaXRzXHJcbiAgICAgIGlmICghdGhpcy5jaGVja1JhdGVMaW1pdChzb2NrZXQuaWQsIHR5cGUpKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUmF0ZSBsaW1pdCBleGNlZWRlZC4gUGxlYXNlIHNsb3cgZG93bi5cIik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFZhbGlkYXRlIHN1YnNjcmlwdGlvbiBkYXRhXHJcbiAgICAgIHRoaXMudmFsaWRhdGVTdWJzY3JpcHRpb25EYXRhKHR5cGUsIGRhdGEpO1xyXG5cclxuICAgICAgLy8gRXhlY3V0ZSBzdWJzY3JpcHRpb24gbG9naWNcclxuICAgICAgYXdhaXQgc3Vic2NyaXB0aW9uTG9naWMoKTtcclxuXHJcbiAgICAgIC8vIFVwZGF0ZSBjbGllbnQgaW5mb1xyXG4gICAgICBjbGllbnQubGFzdEFjdGl2aXR5ID0gbmV3IERhdGUoKTtcclxuICAgICAgY2xpZW50Lm1lc3NhZ2VDb3VudCsrO1xyXG5cclxuICAgICAgLy8gU2VuZCBzdWNjZXNzIGNvbmZpcm1hdGlvblxyXG4gICAgICBzb2NrZXQuZW1pdChcInN1YnNjcmliZTpzdWNjZXNzXCIsIHtcclxuICAgICAgICB0eXBlLFxyXG4gICAgICAgIGRhdGEsXHJcbiAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxyXG4gICAgICAgIHN1YnNjcmlwdGlvbkNvdW50OiBjbGllbnQuc3Vic2NyaXB0aW9uQ291bnQsXHJcbiAgICAgIH0pO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcihgU3Vic2NyaXB0aW9uIGZhaWxlZCBmb3IgJHtzb2NrZXQuaWR9OmAsIGVycm9yLm1lc3NhZ2UpO1xyXG4gICAgICBzb2NrZXQuZW1pdChcInN1YnNjcmliZTplcnJvclwiLCB7XHJcbiAgICAgICAgdHlwZTogXCJzdWJzY3JpcHRpb25fZmFpbGVkXCIsXHJcbiAgICAgICAgbWVzc2FnZTogZXJyb3IubWVzc2FnZSxcclxuICAgICAgICBzdWJzY3JpcHRpb25UeXBlOiB0eXBlLFxyXG4gICAgICAgIGRhdGEsXHJcbiAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIFZhbGlkYXRlIHN1YnNjcmlwdGlvbiBkYXRhXHJcbiAgdmFsaWRhdGVTdWJzY3JpcHRpb25EYXRhKHR5cGUsIGRhdGEpIHtcclxuICAgIHN3aXRjaCAodHlwZSkge1xyXG4gICAgICBjYXNlIFwiaXBvXCI6XHJcbiAgICAgICAgaWYgKCFkYXRhLmlwb0lkICYmICFkYXRhLnN5bWJvbCkge1xyXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICAgICAgICBcIkVpdGhlciBpcG9JZCBvciBzeW1ib2wgaXMgcmVxdWlyZWQgZm9yIElQTyBzdWJzY3JpcHRpb25cIlxyXG4gICAgICAgICAgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgXCJnbXBcIjpcclxuICAgICAgICBpZiAoIWRhdGEuaXBvSWQgJiYgIWRhdGEuc3ltYm9sKSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXHJcbiAgICAgICAgICAgIFwiRWl0aGVyIGlwb0lkIG9yIHN5bWJvbCBpcyByZXF1aXJlZCBmb3IgR01QIHN1YnNjcmlwdGlvblwiXHJcbiAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSBcInN1YnNjcmlwdGlvblwiOlxyXG4gICAgICBjYXNlIFwiZGVtYW5kXCI6XHJcbiAgICAgICAgaWYgKCFkYXRhLnN5bWJvbCkge1xyXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU3ltYm9sIGlzIHJlcXVpcmVkIGZvciBzdWJzY3JpcHRpb24vZGVtYW5kIGRhdGFcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIFwiYW5hbHl0aWNzXCI6XHJcbiAgICAgICAgaWYgKCFkYXRhLmlwb0lkKSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJUE8gSUQgaXMgcmVxdWlyZWQgZm9yIGFuYWx5dGljcyBzdWJzY3JpcHRpb25cIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gSGFuZGxlIHNpbmdsZSBzdWJzY3JpcHRpb24gKGZvciBiYXRjaCBvcGVyYXRpb25zKVxyXG4gIGFzeW5jIGhhbmRsZVNpbmdsZVN1YnNjcmlwdGlvbihcclxuICAgIHNvY2tldCxcclxuICAgIHsgdHlwZSwgaXBvSWQsIHN5bWJvbCwgb3B0aW9ucyA9IHt9IH1cclxuICApIHtcclxuICAgIHN3aXRjaCAodHlwZSkge1xyXG4gICAgICBjYXNlIFwiaXBvXCI6XHJcbiAgICAgICAgaWYgKGlwb0lkKSB7XHJcbiAgICAgICAgICBzb2NrZXQuam9pbihgaXBvOiR7aXBvSWR9YCk7XHJcbiAgICAgICAgICB0aGlzLmFkZFN1YnNjcmlwdGlvbihzb2NrZXQuaWQsIFwiaXBvXCIsIGlwb0lkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgXCJnbXBcIjpcclxuICAgICAgICBpZiAoaXBvSWQpIHtcclxuICAgICAgICAgIHNvY2tldC5qb2luKGBnbXA6JHtpcG9JZH1gKTtcclxuICAgICAgICAgIHRoaXMuYWRkU3Vic2NyaXB0aW9uKHNvY2tldC5pZCwgXCJnbXBcIiwgaXBvSWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSBcInN1YnNjcmlwdGlvblwiOlxyXG4gICAgICAgIGlmIChzeW1ib2wpIHtcclxuICAgICAgICAgIHNvY2tldC5qb2luKGBzdWJzY3JpcHRpb246JHtzeW1ib2x9YCk7XHJcbiAgICAgICAgICB0aGlzLmFkZFN1YnNjcmlwdGlvbihzb2NrZXQuaWQsIFwic3Vic2NyaXB0aW9uXCIsIHN5bWJvbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIFwiZGVtYW5kXCI6XHJcbiAgICAgICAgaWYgKHN5bWJvbCkge1xyXG4gICAgICAgICAgc29ja2V0LmpvaW4oYGRlbWFuZDoke3N5bWJvbH1gKTtcclxuICAgICAgICAgIHRoaXMuYWRkU3Vic2NyaXB0aW9uKHNvY2tldC5pZCwgXCJkZW1hbmRcIiwgc3ltYm9sKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgXCJhbmFseXRpY3NcIjpcclxuICAgICAgICBpZiAoaXBvSWQpIHtcclxuICAgICAgICAgIHNvY2tldC5qb2luKGBhbmFseXRpY3M6JHtpcG9JZH1gKTtcclxuICAgICAgICAgIHRoaXMuYWRkU3Vic2NyaXB0aW9uKHNvY2tldC5pZCwgXCJhbmFseXRpY3NcIiwgaXBvSWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBicmVhaztcclxuICAgICAgZGVmYXVsdDpcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gc3Vic2NyaXB0aW9uIHR5cGU6ICR7dHlwZX1gKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIEVuaGFuY2VkIHJhdGUgbGltaXRpbmdcclxuICBjaGVja1JhdGVMaW1pdChzb2NrZXRJZCwgZXZlbnRUeXBlKSB7XHJcbiAgICBjb25zdCBrZXkgPSBgJHtzb2NrZXRJZH06JHtldmVudFR5cGV9YDtcclxuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XHJcbiAgICBjb25zdCB3aW5kb3dTdGFydCA9IE1hdGguZmxvb3Iobm93IC8gMTAwMCkgKiAxMDAwO1xyXG5cclxuICAgIGlmICghdGhpcy5yYXRlTGltaXRzLmhhcyhrZXkpKSB7XHJcbiAgICAgIHRoaXMucmF0ZUxpbWl0cy5zZXQoa2V5LCB7IGNvdW50OiAwLCB3aW5kb3dTdGFydCB9KTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBsaW1pdCA9IHRoaXMucmF0ZUxpbWl0cy5nZXQoa2V5KTtcclxuXHJcbiAgICBpZiAobGltaXQud2luZG93U3RhcnQgIT09IHdpbmRvd1N0YXJ0KSB7XHJcbiAgICAgIGxpbWl0LmNvdW50ID0gMDtcclxuICAgICAgbGltaXQud2luZG93U3RhcnQgPSB3aW5kb3dTdGFydDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAobGltaXQuY291bnQgPj0gdGhpcy5tYXhFdmVudHNQZXJTZWNvbmQpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIGxpbWl0LmNvdW50Kys7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcblxyXG4gIC8vIFN1YnNjcmlwdGlvbiBtYW5hZ2VtZW50XHJcbiAgYWRkU3Vic2NyaXB0aW9uKHNvY2tldElkLCB0eXBlLCBpZGVudGlmaWVyKSB7XHJcbiAgICBjb25zdCBjbGllbnQgPSB0aGlzLmNvbm5lY3RlZENsaWVudHMuZ2V0KHNvY2tldElkKTtcclxuICAgIGlmIChjbGllbnQpIHtcclxuICAgICAgY29uc3Qgc3Vic2NyaXB0aW9uS2V5ID0gYCR7dHlwZX06JHtpZGVudGlmaWVyfWA7XHJcbiAgICAgIGNsaWVudC5zdWJzY3JpcHRpb25zLmFkZChzdWJzY3JpcHRpb25LZXkpO1xyXG4gICAgICBjbGllbnQuc3Vic2NyaXB0aW9uQ291bnQgPSBjbGllbnQuc3Vic2NyaXB0aW9ucy5zaXplO1xyXG5cclxuICAgICAgLy8gVHJhY2sgcm9vbSBzdWJzY3JpcHRpb25zXHJcbiAgICAgIGlmICghdGhpcy5yb29tU3Vic2NyaXB0aW9ucy5oYXMoc3Vic2NyaXB0aW9uS2V5KSkge1xyXG4gICAgICAgIHRoaXMucm9vbVN1YnNjcmlwdGlvbnMuc2V0KHN1YnNjcmlwdGlvbktleSwgbmV3IFNldCgpKTtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLnJvb21TdWJzY3JpcHRpb25zLmdldChzdWJzY3JpcHRpb25LZXkpLmFkZChzb2NrZXRJZCk7XHJcblxyXG4gICAgICB0aGlzLm1ldHJpY3MudG90YWxTdWJzY3JpcHRpb25zKys7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZW1vdmVTdWJzY3JpcHRpb24oc29ja2V0SWQsIHR5cGUsIGlkZW50aWZpZXIpIHtcclxuICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuY29ubmVjdGVkQ2xpZW50cy5nZXQoc29ja2V0SWQpO1xyXG4gICAgaWYgKGNsaWVudCkge1xyXG4gICAgICBjb25zdCBzdWJzY3JpcHRpb25LZXkgPSBgJHt0eXBlfToke2lkZW50aWZpZXJ9YDtcclxuICAgICAgY2xpZW50LnN1YnNjcmlwdGlvbnMuZGVsZXRlKHN1YnNjcmlwdGlvbktleSk7XHJcbiAgICAgIGNsaWVudC5zdWJzY3JpcHRpb25Db3VudCA9IGNsaWVudC5zdWJzY3JpcHRpb25zLnNpemU7XHJcblxyXG4gICAgICAvLyBSZW1vdmUgZnJvbSByb29tIHN1YnNjcmlwdGlvbnNcclxuICAgICAgY29uc3Qgcm9vbVN1YnMgPSB0aGlzLnJvb21TdWJzY3JpcHRpb25zLmdldChzdWJzY3JpcHRpb25LZXkpO1xyXG4gICAgICBpZiAocm9vbVN1YnMpIHtcclxuICAgICAgICByb29tU3Vicy5kZWxldGUoc29ja2V0SWQpO1xyXG4gICAgICAgIGlmIChyb29tU3Vicy5zaXplID09PSAwKSB7XHJcbiAgICAgICAgICB0aGlzLnJvb21TdWJzY3JpcHRpb25zLmRlbGV0ZShzdWJzY3JpcHRpb25LZXkpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgdW5zdWJzY3JpYmVBbGwoc29ja2V0SWQpIHtcclxuICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuY29ubmVjdGVkQ2xpZW50cy5nZXQoc29ja2V0SWQpO1xyXG4gICAgaWYgKGNsaWVudCkge1xyXG4gICAgICBmb3IgKGNvbnN0IHN1YnNjcmlwdGlvbiBvZiBjbGllbnQuc3Vic2NyaXB0aW9ucykge1xyXG4gICAgICAgIGNvbnN0IFt0eXBlLCBpZGVudGlmaWVyXSA9IHN1YnNjcmlwdGlvbi5zcGxpdChcIjpcIik7XHJcbiAgICAgICAgY2xpZW50LnNvY2tldC5sZWF2ZShzdWJzY3JpcHRpb24pO1xyXG4gICAgICAgIHRoaXMucmVtb3ZlU3Vic2NyaXB0aW9uKHNvY2tldElkLCB0eXBlLCBpZGVudGlmaWVyKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgdW5zdWJzY3JpYmVCeVR5cGUoc29ja2V0SWQsIHR5cGUpIHtcclxuICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuY29ubmVjdGVkQ2xpZW50cy5nZXQoc29ja2V0SWQpO1xyXG4gICAgaWYgKGNsaWVudCkge1xyXG4gICAgICBjb25zdCBzdWJzY3JpcHRpb25zVG9SZW1vdmUgPSBBcnJheS5mcm9tKGNsaWVudC5zdWJzY3JpcHRpb25zKS5maWx0ZXIoXHJcbiAgICAgICAgKHN1YikgPT4gc3ViLnN0YXJ0c1dpdGgoYCR7dHlwZX06YClcclxuICAgICAgKTtcclxuXHJcbiAgICAgIGZvciAoY29uc3Qgc3Vic2NyaXB0aW9uIG9mIHN1YnNjcmlwdGlvbnNUb1JlbW92ZSkge1xyXG4gICAgICAgIGNvbnN0IFssIGlkZW50aWZpZXJdID0gc3Vic2NyaXB0aW9uLnNwbGl0KFwiOlwiKTtcclxuICAgICAgICBjbGllbnQuc29ja2V0LmxlYXZlKHN1YnNjcmlwdGlvbik7XHJcbiAgICAgICAgdGhpcy5yZW1vdmVTdWJzY3JpcHRpb24oc29ja2V0SWQsIHR5cGUsIGlkZW50aWZpZXIpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBFbmhhbmNlZCBicm9hZGNhc3RpbmcgbWV0aG9kc1xyXG4gIGFzeW5jIGJyb2FkY2FzdElQT1VwZGF0ZShpcG9JZCwgdXBkYXRlRGF0YSwgb3B0aW9ucyA9IHt9KSB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCB7XHJcbiAgICAgICAgcHJpb3JpdHkgPSBcIm5vcm1hbFwiLFxyXG4gICAgICAgIGV4Y2x1ZGVTb2NrZXQgPSBudWxsLFxyXG4gICAgICAgIGluY2x1ZGVBbmFseXRpY3MgPSBmYWxzZSxcclxuICAgICAgfSA9IG9wdGlvbnM7XHJcblxyXG4gICAgICBpZiAoIXRoaXMuY2hlY2tCcm9hZGNhc3RSYXRlTGltaXQoXCJpcG9cIiwgaXBvSWQpKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCByb29tID0gYGlwbzoke2lwb0lkfWA7XHJcbiAgICAgIGNvbnN0IHN1YnNjcmliZXJDb3VudCA9IHRoaXMucm9vbVN1YnNjcmlwdGlvbnMuZ2V0KHJvb20pPy5zaXplIHx8IDA7XHJcblxyXG4gICAgICBpZiAoc3Vic2NyaWJlckNvdW50ID4gMCkge1xyXG4gICAgICAgIGNvbnN0IGVucmljaGVkRGF0YSA9IHtcclxuICAgICAgICAgIGlwb0lkLFxyXG4gICAgICAgICAgZGF0YTogdXBkYXRlRGF0YSxcclxuICAgICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcclxuICAgICAgICAgIHByaW9yaXR5LFxyXG4gICAgICAgICAgc2VydmVyOiBwcm9jZXNzLmVudi5TRVJWRVJfSUQgfHwgXCJ3cy0xXCIsXHJcbiAgICAgICAgICB0eXBlOiBcInVwZGF0ZVwiLFxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGlmIChpbmNsdWRlQW5hbHl0aWNzICYmIHVwZGF0ZURhdGEuYW5hbHl0aWNzKSB7XHJcbiAgICAgICAgICBlbnJpY2hlZERhdGEuYW5hbHl0aWNzID0gdXBkYXRlRGF0YS5hbmFseXRpY3M7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoZXhjbHVkZVNvY2tldCkge1xyXG4gICAgICAgICAgdGhpcy5pb1xyXG4gICAgICAgICAgICAudG8ocm9vbSlcclxuICAgICAgICAgICAgLmV4Y2VwdChleGNsdWRlU29ja2V0KVxyXG4gICAgICAgICAgICAuZW1pdCh0aGlzLmV2ZW50cy5JUE9fVVBEQVRFLCBlbnJpY2hlZERhdGEpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB0aGlzLmlvLnRvKHJvb20pLmVtaXQodGhpcy5ldmVudHMuSVBPX1VQREFURSwgZW5yaWNoZWREYXRhKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICAgICAgYPCfk6EgSVBPIHVwZGF0ZSBicm9hZGNhc3QgdG8gJHtzdWJzY3JpYmVyQ291bnR9IGNsaWVudHMgZm9yIElQTyAke2lwb0lkfWBcclxuICAgICAgICApO1xyXG4gICAgICAgIHRoaXMubWV0cmljcy50b3RhbE1lc3NhZ2VzKys7XHJcblxyXG4gICAgICAgIC8vIFF1ZXVlIG1lc3NhZ2UgZm9yIG9mZmxpbmUgY2xpZW50cyBpZiBjcml0aWNhbFxyXG4gICAgICAgIGlmIChwcmlvcml0eSA9PT0gXCJoaWdoXCIpIHtcclxuICAgICAgICAgIHRoaXMucXVldWVNZXNzYWdlRm9yT2ZmbGluZUNsaWVudHMocm9vbSwgZW5yaWNoZWREYXRhKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBicm9hZGNhc3RpbmcgSVBPIHVwZGF0ZTpcIiwgZXJyb3IpO1xyXG4gICAgICB0aGlzLm1ldHJpY3MuZXJyb3JzKys7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBhc3luYyBicm9hZGNhc3RHTVBVcGRhdGUoaXBvSWQsIGdtcERhdGEsIG9wdGlvbnMgPSB7fSkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgeyBoaXN0b3JpY2FsID0gZmFsc2UsIGFsZXJ0Q2hlY2sgPSB0cnVlIH0gPSBvcHRpb25zO1xyXG5cclxuICAgICAgaWYgKCF0aGlzLmNoZWNrQnJvYWRjYXN0UmF0ZUxpbWl0KFwiZ21wXCIsIGlwb0lkKSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3Qgcm9vbSA9IGBnbXA6JHtpcG9JZH1gO1xyXG4gICAgICBjb25zdCBzdWJzY3JpYmVyQ291bnQgPSB0aGlzLnJvb21TdWJzY3JpcHRpb25zLmdldChyb29tKT8uc2l6ZSB8fCAwO1xyXG5cclxuICAgICAgaWYgKHN1YnNjcmliZXJDb3VudCA+IDApIHtcclxuICAgICAgICBjb25zdCBjaGFuZ2UgPSBhd2FpdCB0aGlzLmNhbGN1bGF0ZUdNUENoYW5nZShpcG9JZCwgZ21wRGF0YS52YWx1ZSk7XHJcbiAgICAgICAgY29uc3QgZW5yaWNoZWREYXRhID0ge1xyXG4gICAgICAgICAgaXBvSWQsXHJcbiAgICAgICAgICBkYXRhOiBnbXBEYXRhLFxyXG4gICAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxyXG4gICAgICAgICAgaGlzdG9yaWNhbCxcclxuICAgICAgICAgIGNoYW5nZSxcclxuICAgICAgICAgIHRyZW5kOiB0aGlzLmNhbGN1bGF0ZUdNUFRyZW5kKGNoYW5nZSksXHJcbiAgICAgICAgICB2b2xhdGlsaXR5OiBhd2FpdCB0aGlzLmNhbGN1bGF0ZUdNUFZvbGF0aWxpdHkoaXBvSWQpLFxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHRoaXMuaW8udG8ocm9vbSkuZW1pdCh0aGlzLmV2ZW50cy5HTVBfVVBEQVRFLCBlbnJpY2hlZERhdGEpO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICAgICAgYPCfkrAgR01QIHVwZGF0ZSBicm9hZGNhc3QgdG8gJHtzdWJzY3JpYmVyQ291bnR9IGNsaWVudHMgZm9yIElQTyAke2lwb0lkfSAoVmFsdWU6ICR7Z21wRGF0YS52YWx1ZX0pYFxyXG4gICAgICAgICk7XHJcbiAgICAgICAgdGhpcy5tZXRyaWNzLnRvdGFsTWVzc2FnZXMrKztcclxuXHJcbiAgICAgICAgLy8gQ2hlY2sgZm9yIEdNUCBhbGVydHNcclxuICAgICAgICBpZiAoYWxlcnRDaGVjaykge1xyXG4gICAgICAgICAgdGhpcy5jaGVja0dNUEFsZXJ0cyhpcG9JZCwgZ21wRGF0YS52YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgYnJvYWRjYXN0aW5nIEdNUCB1cGRhdGU6XCIsIGVycm9yKTtcclxuICAgICAgdGhpcy5tZXRyaWNzLmVycm9ycysrO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgYXN5bmMgYnJvYWRjYXN0U3Vic2NyaXB0aW9uVXBkYXRlKHN5bWJvbCwgc3Vic2NyaXB0aW9uRGF0YSwgb3B0aW9ucyA9IHt9KSB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCB7IGNhdGVnb3J5ID0gbnVsbCwgYWxlcnRPbk92ZXJzdWJzY3JpcHRpb24gPSB0cnVlIH0gPSBvcHRpb25zO1xyXG5cclxuICAgICAgaWYgKCF0aGlzLmNoZWNrQnJvYWRjYXN0UmF0ZUxpbWl0KFwic3Vic2NyaXB0aW9uXCIsIHN5bWJvbCkpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IHJvb20gPSBgc3Vic2NyaXB0aW9uOiR7c3ltYm9sfWA7XHJcbiAgICAgIGNvbnN0IHN1YnNjcmliZXJDb3VudCA9IHRoaXMucm9vbVN1YnNjcmlwdGlvbnMuZ2V0KHJvb20pPy5zaXplIHx8IDA7XHJcblxyXG4gICAgICBpZiAoc3Vic2NyaWJlckNvdW50ID4gMCkge1xyXG4gICAgICAgIGNvbnN0IGVucmljaGVkRGF0YSA9IHtcclxuICAgICAgICAgIHN5bWJvbCxcclxuICAgICAgICAgIGRhdGE6IHN1YnNjcmlwdGlvbkRhdGEsXHJcbiAgICAgICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXHJcbiAgICAgICAgICBjYXRlZ29yeSxcclxuICAgICAgICAgIG92ZXJhbGxTdWJzY3JpcHRpb246XHJcbiAgICAgICAgICAgIHRoaXMuY2FsY3VsYXRlT3ZlcmFsbFN1YnNjcmlwdGlvbihzdWJzY3JpcHRpb25EYXRhKSxcclxuICAgICAgICAgIGlzT3ZlcnN1YnNjcmliZWQ6IHRoaXMuaXNPdmVyc3Vic2NyaWJlZChzdWJzY3JpcHRpb25EYXRhKSxcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICB0aGlzLmlvLnRvKHJvb20pLmVtaXQodGhpcy5ldmVudHMuU1VCU0NSSVBUSU9OX1VQREFURSwgZW5yaWNoZWREYXRhKTtcclxuICAgICAgICBjb25zb2xlLmxvZyhcclxuICAgICAgICAgIGDwn5OKIFN1YnNjcmlwdGlvbiB1cGRhdGUgYnJvYWRjYXN0IHRvICR7c3Vic2NyaWJlckNvdW50fSBjbGllbnRzIGZvciAke3N5bWJvbH1gXHJcbiAgICAgICAgKTtcclxuICAgICAgICB0aGlzLm1ldHJpY3MudG90YWxNZXNzYWdlcysrO1xyXG5cclxuICAgICAgICAvLyBBbGVydCBvbiBvdmVyc3Vic2NyaXB0aW9uXHJcbiAgICAgICAgaWYgKGFsZXJ0T25PdmVyc3Vic2NyaXB0aW9uICYmIGVucmljaGVkRGF0YS5pc092ZXJzdWJzY3JpYmVkKSB7XHJcbiAgICAgICAgICB0aGlzLmJyb2FkY2FzdEFsZXJ0KFwib3ZlcnN1YnNjcmlwdGlvblwiLCB7XHJcbiAgICAgICAgICAgIHN5bWJvbCxcclxuICAgICAgICAgICAgc3Vic2NyaXB0aW9uOiBlbnJpY2hlZERhdGEub3ZlcmFsbFN1YnNjcmlwdGlvbixcclxuICAgICAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgYnJvYWRjYXN0aW5nIHN1YnNjcmlwdGlvbiB1cGRhdGU6XCIsIGVycm9yKTtcclxuICAgICAgdGhpcy5tZXRyaWNzLmVycm9ycysrO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgYXN5bmMgYnJvYWRjYXN0RGVtYW5kVXBkYXRlKHN5bWJvbCwgZGVtYW5kRGF0YSwgb3B0aW9ucyA9IHt9KSB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCB7IHByaWNlTGV2ZWwgPSBudWxsIH0gPSBvcHRpb25zO1xyXG5cclxuICAgICAgaWYgKCF0aGlzLmNoZWNrQnJvYWRjYXN0UmF0ZUxpbWl0KFwiZGVtYW5kXCIsIHN5bWJvbCkpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IHJvb20gPSBgZGVtYW5kOiR7c3ltYm9sfWA7XHJcbiAgICAgIGNvbnN0IHN1YnNjcmliZXJDb3VudCA9IHRoaXMucm9vbVN1YnNjcmlwdGlvbnMuZ2V0KHJvb20pPy5zaXplIHx8IDA7XHJcblxyXG4gICAgICBpZiAoc3Vic2NyaWJlckNvdW50ID4gMCkge1xyXG4gICAgICAgIGNvbnN0IGVucmljaGVkRGF0YSA9IHtcclxuICAgICAgICAgIHN5bWJvbCxcclxuICAgICAgICAgIGRhdGE6IGRlbWFuZERhdGEsXHJcbiAgICAgICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXHJcbiAgICAgICAgICBwcmljZUxldmVsLFxyXG4gICAgICAgICAgdG90YWxEZW1hbmQ6IHRoaXMuY2FsY3VsYXRlVG90YWxEZW1hbmQoZGVtYW5kRGF0YSksXHJcbiAgICAgICAgICBjdXRPZmZEZW1hbmQ6IHRoaXMuY2FsY3VsYXRlQ3V0T2ZmRGVtYW5kKGRlbWFuZERhdGEpLFxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHRoaXMuaW8udG8ocm9vbSkuZW1pdCh0aGlzLmV2ZW50cy5ERU1BTkRfVVBEQVRFLCBlbnJpY2hlZERhdGEpO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICAgICAgYPCfk4ggRGVtYW5kIHVwZGF0ZSBicm9hZGNhc3QgdG8gJHtzdWJzY3JpYmVyQ291bnR9IGNsaWVudHMgZm9yICR7c3ltYm9sfWBcclxuICAgICAgICApO1xyXG4gICAgICAgIHRoaXMubWV0cmljcy50b3RhbE1lc3NhZ2VzKys7XHJcbiAgICAgIH1cclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBicm9hZGNhc3RpbmcgZGVtYW5kIHVwZGF0ZTpcIiwgZXJyb3IpO1xyXG4gICAgICB0aGlzLm1ldHJpY3MuZXJyb3JzKys7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBhc3luYyBicm9hZGNhc3RBbmFseXRpY3NVcGRhdGUoaXBvSWQsIGFuYWx5dGljc0RhdGEsIG9wdGlvbnMgPSB7fSkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgeyB0eXBlID0gXCJnZW5lcmFsXCIsIG1ldHJpY3MgPSBudWxsIH0gPSBvcHRpb25zO1xyXG5cclxuICAgICAgaWYgKCF0aGlzLmNoZWNrQnJvYWRjYXN0UmF0ZUxpbWl0KFwiYW5hbHl0aWNzXCIsIGlwb0lkKSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3Qgcm9vbSA9IGBhbmFseXRpY3M6JHtpcG9JZH1gO1xyXG4gICAgICBjb25zdCBzdWJzY3JpYmVyQ291bnQgPSB0aGlzLnJvb21TdWJzY3JpcHRpb25zLmdldChyb29tKT8uc2l6ZSB8fCAwO1xyXG5cclxuICAgICAgaWYgKHN1YnNjcmliZXJDb3VudCA+IDApIHtcclxuICAgICAgICBjb25zdCBlbnJpY2hlZERhdGEgPSB7XHJcbiAgICAgICAgICBpcG9JZCxcclxuICAgICAgICAgIHR5cGUsXHJcbiAgICAgICAgICBkYXRhOiBhbmFseXRpY3NEYXRhLFxyXG4gICAgICAgICAgbWV0cmljcyxcclxuICAgICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcclxuICAgICAgICAgIGluc2lnaHRzOiBhd2FpdCB0aGlzLmdlbmVyYXRlQW5hbHl0aWNzSW5zaWdodHMoYW5hbHl0aWNzRGF0YSksXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgdGhpcy5pby50byhyb29tKS5lbWl0KHRoaXMuZXZlbnRzLkFOQUxZVElDU19VUERBVEUsIGVucmljaGVkRGF0YSk7XHJcbiAgICAgICAgY29uc29sZS5sb2coXHJcbiAgICAgICAgICBg8J+TiiBBbmFseXRpY3MgdXBkYXRlIGJyb2FkY2FzdCB0byAke3N1YnNjcmliZXJDb3VudH0gY2xpZW50cyBmb3IgSVBPICR7aXBvSWR9YFxyXG4gICAgICAgICk7XHJcbiAgICAgICAgdGhpcy5tZXRyaWNzLnRvdGFsTWVzc2FnZXMrKztcclxuICAgICAgfVxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGJyb2FkY2FzdGluZyBhbmFseXRpY3MgdXBkYXRlOlwiLCBlcnJvcik7XHJcbiAgICAgIHRoaXMubWV0cmljcy5lcnJvcnMrKztcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIEJyb2FkY2FzdCBzeXN0ZW0gc3RhdHVzXHJcbiAgYXN5bmMgYnJvYWRjYXN0U3lzdGVtU3RhdHVzKHN0YXR1cywgb3B0aW9ucyA9IHt9KSB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCB7IHByaW9yaXR5ID0gXCJub3JtYWxcIiwgcm9vbSA9IFwic3lzdGVtOnN0YXR1c1wiIH0gPSBvcHRpb25zO1xyXG4gICAgICBjb25zdCBzdWJzY3JpYmVyQ291bnQgPSB0aGlzLnJvb21TdWJzY3JpcHRpb25zLmdldChyb29tKT8uc2l6ZSB8fCAwO1xyXG5cclxuICAgICAgaWYgKHN1YnNjcmliZXJDb3VudCA+IDApIHtcclxuICAgICAgICBjb25zdCBlbnJpY2hlZFN0YXR1cyA9IHtcclxuICAgICAgICAgIC4uLnN0YXR1cyxcclxuICAgICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcclxuICAgICAgICAgIHNlcnZlcjogcHJvY2Vzcy5lbnYuU0VSVkVSX0lEIHx8IFwid3MtMVwiLFxyXG4gICAgICAgICAgcHJpb3JpdHksXHJcbiAgICAgICAgICBjb25uZWN0aW9uczogdGhpcy5tZXRyaWNzLmN1cnJlbnRDb25uZWN0aW9ucyxcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICB0aGlzLmlvLnRvKHJvb20pLmVtaXQodGhpcy5ldmVudHMuU1lTVEVNX1NUQVRVUywgZW5yaWNoZWRTdGF0dXMpO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGDwn5SUIFN5c3RlbSBzdGF0dXMgYnJvYWRjYXN0IHRvICR7c3Vic2NyaWJlckNvdW50fSBjbGllbnRzYCk7XHJcbiAgICAgICAgdGhpcy5tZXRyaWNzLnRvdGFsTWVzc2FnZXMrKztcclxuICAgICAgfVxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGJyb2FkY2FzdGluZyBzeXN0ZW0gc3RhdHVzOlwiLCBlcnJvcik7XHJcbiAgICAgIHRoaXMubWV0cmljcy5lcnJvcnMrKztcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIEJyb2FkY2FzdCBhbGVydHNcclxuICBhc3luYyBicm9hZGNhc3RBbGVydChhbGVydFR5cGUsIGFsZXJ0RGF0YSkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgZW5yaWNoZWRBbGVydCA9IHtcclxuICAgICAgICB0eXBlOiBhbGVydFR5cGUsXHJcbiAgICAgICAgZGF0YTogYWxlcnREYXRhLFxyXG4gICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcclxuICAgICAgICBzZXJ2ZXI6IHByb2Nlc3MuZW52LlNFUlZFUl9JRCB8fCBcIndzLTFcIixcclxuICAgICAgICBzZXZlcml0eTogdGhpcy5nZXRBbGVydFNldmVyaXR5KGFsZXJ0VHlwZSksXHJcbiAgICAgIH07XHJcblxyXG4gICAgICAvLyBCcm9hZGNhc3QgdG8gYWxsIGNvbm5lY3RlZCBjbGllbnRzXHJcbiAgICAgIHRoaXMuaW8uZW1pdCh0aGlzLmV2ZW50cy5BTEVSVF9UUklHR0VSRUQsIGVucmljaGVkQWxlcnQpO1xyXG4gICAgICBjb25zb2xlLmxvZyhg8J+aqCBBbGVydCBicm9hZGNhc3Q6ICR7YWxlcnRUeXBlfWApO1xyXG4gICAgICB0aGlzLm1ldHJpY3MudG90YWxNZXNzYWdlcysrO1xyXG5cclxuICAgICAgLy8gU3RvcmUgYWxlcnQgZm9yIHF1ZXVpbmdcclxuICAgICAgdGhpcy5xdWV1ZU1lc3NhZ2VGb3JPZmZsaW5lQ2xpZW50cyhcImdsb2JhbFwiLCBlbnJpY2hlZEFsZXJ0KTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBicm9hZGNhc3RpbmcgYWxlcnQ6XCIsIGVycm9yKTtcclxuICAgICAgdGhpcy5tZXRyaWNzLmVycm9ycysrO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gQnJvYWRjYXN0IHJhdGUgbGltaXRpbmdcclxuICBjaGVja0Jyb2FkY2FzdFJhdGVMaW1pdChldmVudFR5cGUsIGlkZW50aWZpZXIpIHtcclxuICAgIGNvbnN0IGtleSA9IGBicm9hZGNhc3Q6JHtldmVudFR5cGV9OiR7aWRlbnRpZmllcn1gO1xyXG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcclxuICAgIGNvbnN0IHdpbmRvd1N0YXJ0ID0gTWF0aC5mbG9vcihub3cgLyA1MDAwKSAqIDUwMDA7IC8vIDUtc2Vjb25kIHdpbmRvd1xyXG5cclxuICAgIGlmICghdGhpcy5yYXRlTGltaXRzLmhhcyhrZXkpKSB7XHJcbiAgICAgIHRoaXMucmF0ZUxpbWl0cy5zZXQoa2V5LCB7IGNvdW50OiAwLCB3aW5kb3dTdGFydCB9KTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBsaW1pdCA9IHRoaXMucmF0ZUxpbWl0cy5nZXQoa2V5KTtcclxuXHJcbiAgICBpZiAobGltaXQud2luZG93U3RhcnQgIT09IHdpbmRvd1N0YXJ0KSB7XHJcbiAgICAgIGxpbWl0LmNvdW50ID0gMDtcclxuICAgICAgbGltaXQud2luZG93U3RhcnQgPSB3aW5kb3dTdGFydDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBNYXggMTAgYnJvYWRjYXN0cyBwZXIgNSBzZWNvbmRzIHBlciBldmVudCB0eXBlXHJcbiAgICBpZiAobGltaXQuY291bnQgPj0gMTApIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIGxpbWl0LmNvdW50Kys7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcblxyXG4gIC8vIENhbGN1bGF0ZSBHTVAgY2hhbmdlIGFuZCB0cmVuZFxyXG4gIGFzeW5jIGNhbGN1bGF0ZUdNUENoYW5nZShpcG9JZCwgY3VycmVudFZhbHVlKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICBpZiAoIXRoaXMucHJldmlvdXNHTVBWYWx1ZXMpIHtcclxuICAgICAgICB0aGlzLnByZXZpb3VzR01QVmFsdWVzID0gbmV3IE1hcCgpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCBwcmV2aW91c1ZhbHVlID0gdGhpcy5wcmV2aW91c0dNUFZhbHVlcy5nZXQoaXBvSWQpIHx8IGN1cnJlbnRWYWx1ZTtcclxuICAgICAgdGhpcy5wcmV2aW91c0dNUFZhbHVlcy5zZXQoaXBvSWQsIGN1cnJlbnRWYWx1ZSk7XHJcblxyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIGFic29sdXRlOiBjdXJyZW50VmFsdWUgLSBwcmV2aW91c1ZhbHVlLFxyXG4gICAgICAgIHBlcmNlbnRhZ2U6XHJcbiAgICAgICAgICBwcmV2aW91c1ZhbHVlID4gMFxyXG4gICAgICAgICAgICA/IHBhcnNlRmxvYXQoXHJcbiAgICAgICAgICAgICAgICAoXHJcbiAgICAgICAgICAgICAgICAgICgoY3VycmVudFZhbHVlIC0gcHJldmlvdXNWYWx1ZSkgLyBwcmV2aW91c1ZhbHVlKSAqXHJcbiAgICAgICAgICAgICAgICAgIDEwMFxyXG4gICAgICAgICAgICAgICAgKS50b0ZpeGVkKDIpXHJcbiAgICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICA6IDAsXHJcbiAgICAgICAgZGlyZWN0aW9uOlxyXG4gICAgICAgICAgY3VycmVudFZhbHVlID4gcHJldmlvdXNWYWx1ZVxyXG4gICAgICAgICAgICA/IFwidXBcIlxyXG4gICAgICAgICAgICA6IGN1cnJlbnRWYWx1ZSA8IHByZXZpb3VzVmFsdWVcclxuICAgICAgICAgICAgICA/IFwiZG93blwiXHJcbiAgICAgICAgICAgICAgOiBcInN0YWJsZVwiLFxyXG4gICAgICB9O1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgcmV0dXJuIHsgYWJzb2x1dGU6IDAsIHBlcmNlbnRhZ2U6IDAsIGRpcmVjdGlvbjogXCJzdGFibGVcIiB9O1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgY2FsY3VsYXRlR01QVHJlbmQoY2hhbmdlKSB7XHJcbiAgICBpZiAoTWF0aC5hYnMoY2hhbmdlLnBlcmNlbnRhZ2UpIDwgMSkgcmV0dXJuIFwic3RhYmxlXCI7XHJcbiAgICBpZiAoY2hhbmdlLnBlcmNlbnRhZ2UgPiA1KSByZXR1cm4gXCJidWxsaXNoXCI7XHJcbiAgICBpZiAoY2hhbmdlLnBlcmNlbnRhZ2UgPCAtNSkgcmV0dXJuIFwiYmVhcmlzaFwiO1xyXG4gICAgcmV0dXJuIGNoYW5nZS5kaXJlY3Rpb247XHJcbiAgfVxyXG5cclxuICBhc3luYyBjYWxjdWxhdGVHTVBWb2xhdGlsaXR5KGlwb0lkKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCByZWNlbnRHTVAgPSBhd2FpdCBwcmlzbWEuZ01QLmZpbmRNYW55KHtcclxuICAgICAgICB3aGVyZTogeyBpcG9JZCB9LFxyXG4gICAgICAgIG9yZGVyQnk6IHsgdGltZXN0YW1wOiBcImRlc2NcIiB9LFxyXG4gICAgICAgIHRha2U6IDEwLFxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGlmIChyZWNlbnRHTVAubGVuZ3RoIDwgMikgcmV0dXJuIDA7XHJcblxyXG4gICAgICBjb25zdCB2YWx1ZXMgPSByZWNlbnRHTVAubWFwKChnKSA9PiBnLnZhbHVlKTtcclxuICAgICAgY29uc3QgbWVhbiA9IHZhbHVlcy5yZWR1Y2UoKGEsIGIpID0+IGEgKyBiKSAvIHZhbHVlcy5sZW5ndGg7XHJcbiAgICAgIGNvbnN0IHZhcmlhbmNlID1cclxuICAgICAgICB2YWx1ZXMucmVkdWNlKChhY2MsIHZhbCkgPT4gYWNjICsgTWF0aC5wb3codmFsIC0gbWVhbiwgMiksIDApIC9cclxuICAgICAgICB2YWx1ZXMubGVuZ3RoO1xyXG5cclxuICAgICAgcmV0dXJuIE1hdGgucm91bmQoTWF0aC5zcXJ0KHZhcmlhbmNlKSAqIDEwMCkgLyAxMDA7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICByZXR1cm4gMDtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIFN1YnNjcmlwdGlvbiBjYWxjdWxhdGlvbiB1dGlsaXRpZXNcclxuICBjYWxjdWxhdGVPdmVyYWxsU3Vic2NyaXB0aW9uKHN1YnNjcmlwdGlvbkRhdGEpIHtcclxuICAgIGlmICghQXJyYXkuaXNBcnJheShzdWJzY3JpcHRpb25EYXRhKSkgcmV0dXJuIDA7XHJcblxyXG4gICAgY29uc3QgcmF0aW9zID0gc3Vic2NyaXB0aW9uRGF0YS5tYXAoKGl0ZW0pID0+XHJcbiAgICAgIHBhcnNlRmxvYXQoaXRlbS5zdWJzY3JpcHRpb25SYXRpbyB8fCAwKVxyXG4gICAgKTtcclxuICAgIHJldHVybiByYXRpb3MubGVuZ3RoID4gMCA/IE1hdGgubWF4KC4uLnJhdGlvcykgOiAwO1xyXG4gIH1cclxuXHJcbiAgaXNPdmVyc3Vic2NyaWJlZChzdWJzY3JpcHRpb25EYXRhKSB7XHJcbiAgICByZXR1cm4gdGhpcy5jYWxjdWxhdGVPdmVyYWxsU3Vic2NyaXB0aW9uKHN1YnNjcmlwdGlvbkRhdGEpID4gMTtcclxuICB9XHJcblxyXG4gIGNhbGN1bGF0ZVRvdGFsRGVtYW5kKGRlbWFuZERhdGEpIHtcclxuICAgIGlmICghQXJyYXkuaXNBcnJheShkZW1hbmREYXRhKSkgcmV0dXJuIDA7XHJcblxyXG4gICAgcmV0dXJuIGRlbWFuZERhdGEucmVkdWNlKFxyXG4gICAgICAodG90YWwsIGl0ZW0pID0+IHRvdGFsICsgcGFyc2VJbnQoaXRlbS5hYnNvbHV0ZVF1YW50aXR5IHx8IDApLFxyXG4gICAgICAwXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgY2FsY3VsYXRlQ3V0T2ZmRGVtYW5kKGRlbWFuZERhdGEpIHtcclxuICAgIGlmICghQXJyYXkuaXNBcnJheShkZW1hbmREYXRhKSkgcmV0dXJuIDA7XHJcblxyXG4gICAgcmV0dXJuIGRlbWFuZERhdGFcclxuICAgICAgLmZpbHRlcigoaXRlbSkgPT4gaXRlbS5jdXRPZmZJbmRpY2F0b3IpXHJcbiAgICAgIC5yZWR1Y2UoKHRvdGFsLCBpdGVtKSA9PiB0b3RhbCArIHBhcnNlSW50KGl0ZW0uYWJzb2x1dGVRdWFudGl0eSB8fCAwKSwgMCk7XHJcbiAgfVxyXG5cclxuICAvLyBHZW5lcmF0ZSBhbmFseXRpY3MgaW5zaWdodHNcclxuICBhc3luYyBnZW5lcmF0ZUFuYWx5dGljc0luc2lnaHRzKGFuYWx5dGljc0RhdGEpIHtcclxuICAgIGNvbnN0IGluc2lnaHRzID0gW107XHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgaWYgKGFuYWx5dGljc0RhdGEuZ21wVm9sYXRpbGl0eSA+IDIwKSB7XHJcbiAgICAgICAgaW5zaWdodHMucHVzaCh7XHJcbiAgICAgICAgICB0eXBlOiBcIndhcm5pbmdcIixcclxuICAgICAgICAgIG1lc3NhZ2U6IFwiSGlnaCBHTVAgdm9sYXRpbGl0eSBkZXRlY3RlZFwiLFxyXG4gICAgICAgICAgdmFsdWU6IGFuYWx5dGljc0RhdGEuZ21wVm9sYXRpbGl0eSxcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGFuYWx5dGljc0RhdGEuZmluYWxTdWJzY3JpcHRpb24gPiA1KSB7XHJcbiAgICAgICAgaW5zaWdodHMucHVzaCh7XHJcbiAgICAgICAgICB0eXBlOiBcInBvc2l0aXZlXCIsXHJcbiAgICAgICAgICBtZXNzYWdlOiBcIlN0cm9uZyBzdWJzY3JpcHRpb24gZGVtYW5kXCIsXHJcbiAgICAgICAgICB2YWx1ZTogYW5hbHl0aWNzRGF0YS5maW5hbFN1YnNjcmlwdGlvbixcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGFuYWx5dGljc0RhdGEucmlza1Njb3JlID4gNzApIHtcclxuICAgICAgICBpbnNpZ2h0cy5wdXNoKHtcclxuICAgICAgICAgIHR5cGU6IFwiY2F1dGlvblwiLFxyXG4gICAgICAgICAgbWVzc2FnZTogXCJIaWdoIHJpc2sgc2NvcmVcIixcclxuICAgICAgICAgIHZhbHVlOiBhbmFseXRpY3NEYXRhLnJpc2tTY29yZSxcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGdlbmVyYXRpbmcgaW5zaWdodHM6XCIsIGVycm9yKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gaW5zaWdodHM7XHJcbiAgfVxyXG5cclxuICAvLyBEYXRhIGZldGNoaW5nIG1ldGhvZHNcclxuICBhc3luYyBnZXRDdXJyZW50SVBPRGF0YShpcG9JZCkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgaXBvID0gYXdhaXQgcHJpc21hLmlQTy5maW5kVW5pcXVlKHtcclxuICAgICAgICB3aGVyZTogeyBpZDogaXBvSWQgfSxcclxuICAgICAgICBpbmNsdWRlOiB7XHJcbiAgICAgICAgICBnbXA6IHtcclxuICAgICAgICAgICAgdGFrZTogNSxcclxuICAgICAgICAgICAgb3JkZXJCeTogeyB0aW1lc3RhbXA6IFwiZGVzY1wiIH0sXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgc3Vic2NyaXB0aW9uOiB7XHJcbiAgICAgICAgICAgIG9yZGVyQnk6IHsgdGltZXN0YW1wOiBcImRlc2NcIiB9LFxyXG4gICAgICAgICAgICB0YWtlOiAxMCxcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBhbmFseXRpY3M6IHRydWUsXHJcbiAgICAgICAgICBjYXRlZ29yaWVzOiB0cnVlLFxyXG4gICAgICAgIH0sXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgcmV0dXJuIGlwbztcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBmZXRjaGluZyBjdXJyZW50IElQTyBkYXRhOlwiLCBlcnJvcik7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgYXN5bmMgZ2V0SGlzdG9yaWNhbEdNUERhdGEoaXBvSWQsIGRheXMgPSAzMCkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3Qgc3RhcnREYXRlID0gbmV3IERhdGUoKTtcclxuICAgICAgc3RhcnREYXRlLnNldERhdGUoc3RhcnREYXRlLmdldERhdGUoKSAtIGRheXMpO1xyXG5cclxuICAgICAgY29uc3QgZ21wRGF0YSA9IGF3YWl0IHByaXNtYS5nTVAuZmluZE1hbnkoe1xyXG4gICAgICAgIHdoZXJlOiB7XHJcbiAgICAgICAgICBpcG9JZCxcclxuICAgICAgICAgIHRpbWVzdGFtcDoge1xyXG4gICAgICAgICAgICBndGU6IHN0YXJ0RGF0ZSxcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgfSxcclxuICAgICAgICBvcmRlckJ5OiB7IHRpbWVzdGFtcDogXCJhc2NcIiB9LFxyXG4gICAgICAgIHRha2U6IDEwMDAsIC8vIExpbWl0IGZvciBwZXJmb3JtYW5jZVxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIHJldHVybiBnbXBEYXRhO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGZldGNoaW5nIGhpc3RvcmljYWwgR01QIGRhdGE6XCIsIGVycm9yKTtcclxuICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgYXN5bmMgZ2V0Q3VycmVudEFuYWx5dGljcyhpcG9JZCwgdHlwZSA9IFwiYWxsXCIpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IGFuYWx5dGljcyA9IGF3YWl0IHByaXNtYS5pUE9BbmFseXRpY3MuZmluZFVuaXF1ZSh7XHJcbiAgICAgICAgd2hlcmU6IHsgaXBvSWQgfSxcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBpZiAodHlwZSA9PT0gXCJhbGxcIikge1xyXG4gICAgICAgIHJldHVybiBhbmFseXRpY3M7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFJldHVybiBzcGVjaWZpYyBhbmFseXRpY3MgYmFzZWQgb24gdHlwZVxyXG4gICAgICBjb25zdCB0eXBlTWFwcGluZyA9IHtcclxuICAgICAgICBnbXA6IFtcImF2Z0dNUFwiLCBcIm1heEdNUFwiLCBcIm1pbkdNUFwiLCBcImdtcFZvbGF0aWxpdHlcIl0sXHJcbiAgICAgICAgc3Vic2NyaXB0aW9uOiBbXHJcbiAgICAgICAgICBcImZpbmFsU3Vic2NyaXB0aW9uXCIsXHJcbiAgICAgICAgICBcInJldGFpbFN1YnNjcmlwdGlvblwiLFxyXG4gICAgICAgICAgXCJxaWJTdWJzY3JpcHRpb25cIixcclxuICAgICAgICBdLFxyXG4gICAgICAgIHByZWRpY3Rpb246IFtcclxuICAgICAgICAgIFwicHJlZGljdGVkTGlzdGluZ0dhaW5cIixcclxuICAgICAgICAgIFwiYWxsb3RtZW50UHJvYmFiaWxpdHlcIixcclxuICAgICAgICAgIFwicmlza1Njb3JlXCIsXHJcbiAgICAgICAgXSxcclxuICAgICAgfTtcclxuXHJcbiAgICAgIGlmICh0eXBlTWFwcGluZ1t0eXBlXSAmJiBhbmFseXRpY3MpIHtcclxuICAgICAgICBjb25zdCBmaWx0ZXJlZEFuYWx5dGljcyA9IHt9O1xyXG4gICAgICAgIHR5cGVNYXBwaW5nW3R5cGVdLmZvckVhY2goKGtleSkgPT4ge1xyXG4gICAgICAgICAgaWYgKGFuYWx5dGljc1trZXldICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgZmlsdGVyZWRBbmFseXRpY3Nba2V5XSA9IGFuYWx5dGljc1trZXldO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBmaWx0ZXJlZEFuYWx5dGljcztcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIGFuYWx5dGljcztcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBmZXRjaGluZyBhbmFseXRpY3M6XCIsIGVycm9yKTtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBTeXN0ZW0gc3RhdHVzXHJcbiAgYXN5bmMgZ2V0U3lzdGVtU3RhdHVzKCkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgW2RiSGVhbHRoLCBjYWNoZUhlYWx0aF0gPSBhd2FpdCBQcm9taXNlLmFsbFNldHRsZWQoW1xyXG4gICAgICAgIHByaXNtYS4kcXVlcnlSYXdgU0VMRUNUIDFgLFxyXG4gICAgICAgIGNhY2hlLmhlYWx0aENoZWNrKCksXHJcbiAgICAgIF0pO1xyXG5cclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBzdGF0dXM6IFwib3BlcmF0aW9uYWxcIixcclxuICAgICAgICBjb25uZWN0aW9uczogdGhpcy5tZXRyaWNzLmN1cnJlbnRDb25uZWN0aW9ucyxcclxuICAgICAgICB1cHRpbWU6IERhdGUubm93KCkgLSB0aGlzLm1ldHJpY3Muc3RhcnRUaW1lLFxyXG4gICAgICAgIGRhdGFiYXNlOiBkYkhlYWx0aC5zdGF0dXMgPT09IFwiZnVsZmlsbGVkXCIgPyBcImhlYWx0aHlcIiA6IFwiZGVncmFkZWRcIixcclxuICAgICAgICBjYWNoZTpcclxuICAgICAgICAgIGNhY2hlSGVhbHRoLnN0YXR1cyA9PT0gXCJmdWxmaWxsZWRcIiAmJlxyXG4gICAgICAgICAgY2FjaGVIZWFsdGgudmFsdWUuc3RhdHVzID09PSBcImhlYWx0aHlcIlxyXG4gICAgICAgICAgICA/IFwiaGVhbHRoeVwiXHJcbiAgICAgICAgICAgIDogXCJkZWdyYWRlZFwiLFxyXG4gICAgICAgIHdlYnNvY2tldDogXCJoZWFsdGh5XCIsXHJcbiAgICAgICAgdmVyc2lvbjogXCIxLjAuMFwiLFxyXG4gICAgICB9O1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBzdGF0dXM6IFwiZGVncmFkZWRcIixcclxuICAgICAgICBlcnJvcjogZXJyb3IubWVzc2FnZSxcclxuICAgICAgICB1cHRpbWU6IERhdGUubm93KCkgLSB0aGlzLm1ldHJpY3Muc3RhcnRUaW1lLFxyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gRmlsdGVyIGFuYWx5dGljcyBieSBzcGVjaWZpYyBtZXRyaWNzXHJcbiAgZmlsdGVyQW5hbHl0aWNzQnlNZXRyaWNzKGFuYWx5dGljcywgbWV0cmljcykge1xyXG4gICAgaWYgKCFhbmFseXRpY3MgfHwgIUFycmF5LmlzQXJyYXkobWV0cmljcykpIHJldHVybiBhbmFseXRpY3M7XHJcblxyXG4gICAgY29uc3QgZmlsdGVyZWQgPSB7fTtcclxuICAgIG1ldHJpY3MuZm9yRWFjaCgobWV0cmljKSA9PiB7XHJcbiAgICAgIGlmIChhbmFseXRpY3NbbWV0cmljXSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgZmlsdGVyZWRbbWV0cmljXSA9IGFuYWx5dGljc1ttZXRyaWNdO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gZmlsdGVyZWQ7XHJcbiAgfVxyXG5cclxuICAvLyBHTVAgQWxlcnQgbWFuYWdlbWVudFxyXG4gIHNldHVwR01QQWxlcnQoc29ja2V0SWQsIGlwb0lkLCB0aHJlc2hvbGQpIHtcclxuICAgIGlmICghdGhpcy5nbXBBbGVydHMpIHtcclxuICAgICAgdGhpcy5nbXBBbGVydHMgPSBuZXcgTWFwKCk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgYWxlcnRLZXkgPSBgJHtzb2NrZXRJZH06JHtpcG9JZH1gO1xyXG4gICAgdGhpcy5nbXBBbGVydHMuc2V0KGFsZXJ0S2V5LCB7XHJcbiAgICAgIHRocmVzaG9sZCxcclxuICAgICAgdHJpZ2dlcmVkOiBmYWxzZSxcclxuICAgICAgY3JlYXRlZEF0OiBEYXRlLm5vdygpLFxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBjaGVja0dNUEFsZXJ0cyhpcG9JZCwgY3VycmVudEdNUCkge1xyXG4gICAgaWYgKCF0aGlzLmdtcEFsZXJ0cykgcmV0dXJuO1xyXG5cclxuICAgIGZvciAoY29uc3QgW2FsZXJ0S2V5LCBhbGVydF0gb2YgdGhpcy5nbXBBbGVydHMpIHtcclxuICAgICAgY29uc3QgW3NvY2tldElkLCBhbGVydElwb0lkXSA9IGFsZXJ0S2V5LnNwbGl0KFwiOlwiKTtcclxuXHJcbiAgICAgIGlmIChhbGVydElwb0lkID09PSBpcG9JZCAmJiAhYWxlcnQudHJpZ2dlcmVkKSB7XHJcbiAgICAgICAgaWYgKGN1cnJlbnRHTVAgPj0gYWxlcnQudGhyZXNob2xkKSB7XHJcbiAgICAgICAgICBjb25zdCBjbGllbnQgPSB0aGlzLmNvbm5lY3RlZENsaWVudHMuZ2V0KHNvY2tldElkKTtcclxuICAgICAgICAgIGlmIChjbGllbnQpIHtcclxuICAgICAgICAgICAgY2xpZW50LnNvY2tldC5lbWl0KHRoaXMuZXZlbnRzLkFMRVJUX1RSSUdHRVJFRCwge1xyXG4gICAgICAgICAgICAgIHR5cGU6IFwiZ21wX3RocmVzaG9sZFwiLFxyXG4gICAgICAgICAgICAgIGlwb0lkLFxyXG4gICAgICAgICAgICAgIHRocmVzaG9sZDogYWxlcnQudGhyZXNob2xkLFxyXG4gICAgICAgICAgICAgIGN1cnJlbnRWYWx1ZTogY3VycmVudEdNUCxcclxuICAgICAgICAgICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgYWxlcnQudHJpZ2dlcmVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXHJcbiAgICAgICAgICAgICAgYPCfmqggR01QIGFsZXJ0IHRyaWdnZXJlZCBmb3IgJHtzb2NrZXRJZH06ICR7aXBvSWR9IHJlYWNoZWQgJHtjdXJyZW50R01QfWBcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIEdldCBhbGVydCBzZXZlcml0eVxyXG4gIGdldEFsZXJ0U2V2ZXJpdHkoYWxlcnRUeXBlKSB7XHJcbiAgICBjb25zdCBzZXZlcml0eU1hcCA9IHtcclxuICAgICAgZ21wX3RocmVzaG9sZDogXCJtZWRpdW1cIixcclxuICAgICAgb3ZlcnN1YnNjcmlwdGlvbjogXCJoaWdoXCIsXHJcbiAgICAgIHN5c3RlbV9lcnJvcjogXCJjcml0aWNhbFwiLFxyXG4gICAgICBjb25uZWN0aW9uX2lzc3VlOiBcImxvd1wiLFxyXG4gICAgICByYXRlX2xpbWl0OiBcIm1lZGl1bVwiLFxyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gc2V2ZXJpdHlNYXBbYWxlcnRUeXBlXSB8fCBcImxvd1wiO1xyXG4gIH1cclxuXHJcbiAgLy8gTWVzc2FnZSBxdWV1aW5nIGZvciBvZmZsaW5lIGNsaWVudHNcclxuICBxdWV1ZU1lc3NhZ2VGb3JPZmZsaW5lQ2xpZW50cyhyb29tLCBtZXNzYWdlKSB7XHJcbiAgICBpZiAoIXRoaXMubWVzc2FnZVF1ZXVlLmhhcyhyb29tKSkge1xyXG4gICAgICB0aGlzLm1lc3NhZ2VRdWV1ZS5zZXQocm9vbSwgW10pO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHF1ZXVlID0gdGhpcy5tZXNzYWdlUXVldWUuZ2V0KHJvb20pO1xyXG4gICAgcXVldWUucHVzaCh7XHJcbiAgICAgIG1lc3NhZ2UsXHJcbiAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIEtlZXAgb25seSB0aGUgbGF0ZXN0IG1lc3NhZ2VzXHJcbiAgICBpZiAocXVldWUubGVuZ3RoID4gdGhpcy5tYXhRdWV1ZVNpemUpIHtcclxuICAgICAgcXVldWUuc3BsaWNlKDAsIHF1ZXVlLmxlbmd0aCAtIHRoaXMubWF4UXVldWVTaXplKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHNlbmRRdWV1ZWRNZXNzYWdlcyhzb2NrZXRJZCkge1xyXG4gICAgY29uc3QgY2xpZW50ID0gdGhpcy5jb25uZWN0ZWRDbGllbnRzLmdldChzb2NrZXRJZCk7XHJcbiAgICBpZiAoIWNsaWVudCkgcmV0dXJuO1xyXG5cclxuICAgIC8vIFNlbmQgcXVldWVkIG1lc3NhZ2VzIGZvciBzdWJzY3JpYmVkIHJvb21zXHJcbiAgICBmb3IgKGNvbnN0IHN1YnNjcmlwdGlvbiBvZiBjbGllbnQuc3Vic2NyaXB0aW9ucykge1xyXG4gICAgICBjb25zdCBxdWV1ZWRNZXNzYWdlcyA9IHRoaXMubWVzc2FnZVF1ZXVlLmdldChzdWJzY3JpcHRpb24pO1xyXG4gICAgICBpZiAocXVldWVkTWVzc2FnZXMgJiYgcXVldWVkTWVzc2FnZXMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIGNsaWVudC5zb2NrZXQuZW1pdChcInF1ZXVlZDptZXNzYWdlc1wiLCB7XHJcbiAgICAgICAgICByb29tOiBzdWJzY3JpcHRpb24sXHJcbiAgICAgICAgICBtZXNzYWdlczogcXVldWVkTWVzc2FnZXMsXHJcbiAgICAgICAgICBjb3VudDogcXVldWVkTWVzc2FnZXMubGVuZ3RoLFxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICAvLyBDbGVhciB0aGUgcXVldWUgYWZ0ZXIgc2VuZGluZ1xyXG4gICAgICAgIHRoaXMubWVzc2FnZVF1ZXVlLmRlbGV0ZShzdWJzY3JpcHRpb24pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBDbGllbnQgZGlzY29ubmVjdGlvbiBoYW5kbGluZ1xyXG4gIGhhbmRsZUNsaWVudERpc2Nvbm5lY3Rpb24oc29ja2V0SWQsIHJlYXNvbikge1xyXG4gICAgY29uc3QgY2xpZW50ID0gdGhpcy5jb25uZWN0ZWRDbGllbnRzLmdldChzb2NrZXRJZCk7XHJcbiAgICBpZiAoY2xpZW50KSB7XHJcbiAgICAgIC8vIFN0b3JlIGRpc2Nvbm5lY3Rpb24gaW5mb1xyXG4gICAgICB0aGlzLmRpc2Nvbm5lY3Rpb25Mb2cgPSB0aGlzLmRpc2Nvbm5lY3Rpb25Mb2cgfHwgbmV3IE1hcCgpO1xyXG4gICAgICB0aGlzLmRpc2Nvbm5lY3Rpb25Mb2cuc2V0KHNvY2tldElkLCB7XHJcbiAgICAgICAgcmVhc29uLFxyXG4gICAgICAgIGRpc2Nvbm5lY3RlZEF0OiBEYXRlLm5vdygpLFxyXG4gICAgICAgIHN1YnNjcmlwdGlvbnM6IEFycmF5LmZyb20oY2xpZW50LnN1YnNjcmlwdGlvbnMpLFxyXG4gICAgICAgIHJlY29ubmVjdENvdW50OiBjbGllbnQucmVjb25uZWN0Q291bnQsXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgLy8gS2VlcCBvbmx5IHJlY2VudCBkaXNjb25uZWN0aW9uc1xyXG4gICAgICBpZiAodGhpcy5kaXNjb25uZWN0aW9uTG9nLnNpemUgPiAxMDAwKSB7XHJcbiAgICAgICAgY29uc3QgZW50cmllcyA9IEFycmF5LmZyb20odGhpcy5kaXNjb25uZWN0aW9uTG9nLmVudHJpZXMoKSk7XHJcbiAgICAgICAgZW50cmllcy5zb3J0KChhLCBiKSA9PiBiWzFdLmRpc2Nvbm5lY3RlZEF0IC0gYVsxXS5kaXNjb25uZWN0ZWRBdCk7XHJcbiAgICAgICAgdGhpcy5kaXNjb25uZWN0aW9uTG9nID0gbmV3IE1hcChlbnRyaWVzLnNsaWNlKDAsIDUwMCkpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBBdXRob3JpemF0aW9uIGNoZWNrIChpbXBsZW1lbnQgYmFzZWQgb24geW91ciBhdXRoIHN5c3RlbSlcclxuICBpc0F1dGhvcml6ZWQoc29ja2V0KSB7XHJcbiAgICAvLyBJbXBsZW1lbnQgeW91ciBhdXRob3JpemF0aW9uIGxvZ2ljIGhlcmVcclxuICAgIC8vIEZvciBub3csIHJldHVybiB0cnVlIGZvciBiYXNpYyBmdW5jdGlvbmFsaXR5XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcblxyXG4gIC8vIEVuaGFuY2VkIGhlYXJ0YmVhdCB3aXRoIGhlYWx0aCBtb25pdG9yaW5nXHJcbiAgc3RhcnRIZWFydGJlYXQoKSB7XHJcbiAgICBzZXRJbnRlcnZhbCgoKSA9PiB7XHJcbiAgICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XHJcbiAgICAgIGNvbnN0IHN0YWxlVGhyZXNob2xkID0gNSAqIDYwICogMTAwMDsgLy8gNSBtaW51dGVzXHJcbiAgICAgIGNvbnN0IHN0YWxlQ2xpZW50cyA9IFtdO1xyXG5cclxuICAgICAgZm9yIChjb25zdCBbc29ja2V0SWQsIGNsaWVudF0gb2YgdGhpcy5jb25uZWN0ZWRDbGllbnRzKSB7XHJcbiAgICAgICAgY29uc3QgdGltZVNpbmNlTGFzdEFjdGl2aXR5ID0gbm93IC0gY2xpZW50Lmxhc3RBY3Rpdml0eS5nZXRUaW1lKCk7XHJcblxyXG4gICAgICAgIGlmICh0aW1lU2luY2VMYXN0QWN0aXZpdHkgPiBzdGFsZVRocmVzaG9sZCkge1xyXG4gICAgICAgICAgY29uc29sZS5sb2coXHJcbiAgICAgICAgICAgIGDwn6e5IERpc2Nvbm5lY3Rpbmcgc3RhbGUgY2xpZW50OiAke3NvY2tldElkfSAoaW5hY3RpdmUgZm9yICR7TWF0aC5yb3VuZCh0aW1lU2luY2VMYXN0QWN0aXZpdHkgLyAxMDAwKX1zKWBcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgICBjbGllbnQuc29ja2V0LmRpc2Nvbm5lY3QodHJ1ZSk7XHJcbiAgICAgICAgICBzdGFsZUNsaWVudHMucHVzaChzb2NrZXRJZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoc3RhbGVDbGllbnRzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICBjb25zb2xlLmxvZyhg8J+nuSBDbGVhbmVkIHVwICR7c3RhbGVDbGllbnRzLmxlbmd0aH0gc3RhbGUgY29ubmVjdGlvbnNgKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQnJvYWRjYXN0IHN5c3RlbSBoZWFydGJlYXQgZXZlcnkgNSBtaW51dGVzXHJcbiAgICAgIGlmIChub3cgJSAoNSAqIDYwICogMTAwMCkgPCA2MDAwMCkge1xyXG4gICAgICAgIC8vIFdpdGhpbiAxIG1pbnV0ZSBvZiA1LW1pbnV0ZSBtYXJrXHJcbiAgICAgICAgdGhpcy5icm9hZGNhc3RTeXN0ZW1TdGF0dXMoe1xyXG4gICAgICAgICAgdHlwZTogXCJoZWFydGJlYXRcIixcclxuICAgICAgICAgIHN0YXR1czogXCJoZWFsdGh5XCIsXHJcbiAgICAgICAgICB1cHRpbWU6IG5vdyAtIHRoaXMubWV0cmljcy5zdGFydFRpbWUsXHJcbiAgICAgICAgICBjb25uZWN0aW9uczogdGhpcy5tZXRyaWNzLmN1cnJlbnRDb25uZWN0aW9ucyxcclxuICAgICAgICAgIG1lc3NhZ2U6IFwiU3lzdGVtIHJ1bm5pbmcgbm9ybWFsbHlcIixcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfSwgNjAwMDApOyAvLyBDaGVjayBldmVyeSBtaW51dGVcclxuICB9XHJcblxyXG4gIC8vIEhlYWx0aCBtb25pdG9yaW5nXHJcbiAgc3RhcnRIZWFsdGhNb25pdG9yaW5nKCkge1xyXG4gICAgc2V0SW50ZXJ2YWwoKCkgPT4ge1xyXG4gICAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xyXG5cclxuICAgICAgLy8gTW9uaXRvciBjb25uZWN0aW9uIGhlYWx0aFxyXG4gICAgICBmb3IgKGNvbnN0IFtzb2NrZXRJZCwgaGVhbHRoXSBvZiB0aGlzLmNvbm5lY3Rpb25IZWFsdGgpIHtcclxuICAgICAgICBpZiAobm93IC0gaGVhbHRoLmxhc3RTZWVuID4gMiAqIDYwICogMTAwMCkge1xyXG4gICAgICAgICAgLy8gMiBtaW51dGVzXHJcbiAgICAgICAgICBoZWFsdGguc3RhdHVzID0gXCJzdGFsZVwiO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGhlYWx0aC5sYXRlbmN5ID4gMTAwMCkge1xyXG4gICAgICAgICAgLy8gSGlnaCBsYXRlbmN5XHJcbiAgICAgICAgICBoZWFsdGguc3RhdHVzID0gXCJkZWdyYWRlZFwiO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQ2xlYW4gdXAgb2xkIGhlYWx0aCByZWNvcmRzXHJcbiAgICAgIGNvbnN0IGhlYWx0aEVudHJpZXMgPSBBcnJheS5mcm9tKHRoaXMuY29ubmVjdGlvbkhlYWx0aC5lbnRyaWVzKCkpO1xyXG4gICAgICBjb25zdCBhY3RpdmVDbGllbnRzID0gbmV3IFNldCh0aGlzLmNvbm5lY3RlZENsaWVudHMua2V5cygpKTtcclxuXHJcbiAgICAgIGZvciAoY29uc3QgW3NvY2tldElkXSBvZiBoZWFsdGhFbnRyaWVzKSB7XHJcbiAgICAgICAgaWYgKCFhY3RpdmVDbGllbnRzLmhhcyhzb2NrZXRJZCkpIHtcclxuICAgICAgICAgIHRoaXMuY29ubmVjdGlvbkhlYWx0aC5kZWxldGUoc29ja2V0SWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSwgMzAwMDApOyAvLyBFdmVyeSAzMCBzZWNvbmRzXHJcbiAgfVxyXG5cclxuICAvLyBNZXRyaWNzIGNvbGxlY3Rpb25cclxuICBzdGFydE1ldHJpY3NDb2xsZWN0aW9uKCkge1xyXG4gICAgc2V0SW50ZXJ2YWwoKCkgPT4ge1xyXG4gICAgICBjb25zdCBzdGF0cyA9IHRoaXMuZ2V0RGV0YWlsZWRTdGF0cygpO1xyXG4gICAgICBjb25zb2xlLmxvZyhcclxuICAgICAgICBg8J+TiiBXZWJTb2NrZXQgTWV0cmljczogQ29ubmVjdGlvbnM6ICR7c3RhdHMuY29ubmVjdGlvbnN9LCBNZXNzYWdlczogJHtzdGF0cy50b3RhbE1lc3NhZ2VzfSwgVXB0aW1lOiAke01hdGgucm91bmQoc3RhdHMudXB0aW1lIC8gMTAwMCl9c2BcclxuICAgICAgKTtcclxuXHJcbiAgICAgIC8vIFN0b3JlIG1ldHJpY3MgaW4gY2FjaGUgZm9yIG1vbml0b3JpbmcgZGFzaGJvYXJkc1xyXG4gICAgICBjYWNoZS5zZXQoXCJ3ZWJzb2NrZXRfbWV0cmljc1wiLCBzdGF0cywgMzAwKTsgLy8gNSBtaW51dGVzXHJcblxyXG4gICAgICAvLyBSZXNldCBob3VybHkgY291bnRlcnNcclxuICAgICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcclxuICAgICAgaWYgKG5vdyAtIHRoaXMubWV0cmljcy5zdGFydFRpbWUgPiA2MCAqIDYwICogMTAwMCkge1xyXG4gICAgICAgIC8vIEV2ZXJ5IGhvdXJcclxuICAgICAgICB0aGlzLnJlc2V0SG91cmx5TWV0cmljcygpO1xyXG4gICAgICB9XHJcbiAgICB9LCAzMDAwMCk7IC8vIEV2ZXJ5IDMwIHNlY29uZHNcclxuICB9XHJcblxyXG4gIC8vIFBlcmlvZGljIGNsZWFudXBcclxuICBzdGFydFBlcmlvZGljQ2xlYW51cCgpIHtcclxuICAgIHNldEludGVydmFsKFxyXG4gICAgICAoKSA9PiB7XHJcbiAgICAgICAgLy8gQ2xlYW4gdXAgcmF0ZSBsaW1pdHNcclxuICAgICAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xyXG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgbGltaXRdIG9mIHRoaXMucmF0ZUxpbWl0cykge1xyXG4gICAgICAgICAgaWYgKG5vdyAtIGxpbWl0LndpbmRvd1N0YXJ0ID4gNjAwMDApIHtcclxuICAgICAgICAgICAgLy8gMSBtaW51dGUgb2xkXHJcbiAgICAgICAgICAgIHRoaXMucmF0ZUxpbWl0cy5kZWxldGUoa2V5KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIENsZWFuIHVwIG9sZCBHTVAgYWxlcnRzXHJcbiAgICAgICAgaWYgKHRoaXMuZ21wQWxlcnRzKSB7XHJcbiAgICAgICAgICBmb3IgKGNvbnN0IFtrZXksIGFsZXJ0XSBvZiB0aGlzLmdtcEFsZXJ0cykge1xyXG4gICAgICAgICAgICBpZiAobm93IC0gYWxlcnQuY3JlYXRlZEF0ID4gMjQgKiA2MCAqIDYwICogMTAwMCkge1xyXG4gICAgICAgICAgICAgIC8vIDI0IGhvdXJzIG9sZFxyXG4gICAgICAgICAgICAgIHRoaXMuZ21wQWxlcnRzLmRlbGV0ZShrZXkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDbGVhbiB1cCBtZXNzYWdlIHF1ZXVlc1xyXG4gICAgICAgIGZvciAoY29uc3QgW3Jvb20sIG1lc3NhZ2VzXSBvZiB0aGlzLm1lc3NhZ2VRdWV1ZSkge1xyXG4gICAgICAgICAgY29uc3QgdmFsaWRNZXNzYWdlcyA9IG1lc3NhZ2VzLmZpbHRlcihcclxuICAgICAgICAgICAgKG1zZykgPT4gbm93IC0gbXNnLnRpbWVzdGFtcCA8IDYwICogNjAgKiAxMDAwIC8vIEtlZXAgbWVzc2FnZXMgZm9yIDEgaG91clxyXG4gICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICBpZiAodmFsaWRNZXNzYWdlcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgdGhpcy5tZXNzYWdlUXVldWUuZGVsZXRlKHJvb20pO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5tZXNzYWdlUXVldWUuc2V0KHJvb20sIHZhbGlkTWVzc2FnZXMpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfSxcclxuICAgICAgNSAqIDYwICogMTAwMFxyXG4gICAgKTsgLy8gRXZlcnkgNSBtaW51dGVzXHJcbiAgfVxyXG5cclxuICAvLyBSZXNldCBob3VybHkgbWV0cmljc1xyXG4gIHJlc2V0SG91cmx5TWV0cmljcygpIHtcclxuICAgIHRoaXMubWV0cmljcy50b3RhbE1lc3NhZ2VzID0gMDtcclxuICAgIHRoaXMubWV0cmljcy5lcnJvcnMgPSAwO1xyXG4gICAgY29uc29sZS5sb2coXCLwn5OKIEhvdXJseSBtZXRyaWNzIHJlc2V0XCIpO1xyXG4gIH1cclxuXHJcbiAgLy8gRW5oYW5jZWQgc3RhdGlzdGljc1xyXG4gIGdldERldGFpbGVkU3RhdHMoKSB7XHJcbiAgICBjb25zdCBjb25uZWN0aW9ucyA9IHRoaXMuY29ubmVjdGVkQ2xpZW50cy5zaXplO1xyXG4gICAgY29uc3Qgcm9vbXMgPSBBcnJheS5mcm9tKHRoaXMucm9vbVN1YnNjcmlwdGlvbnMua2V5cygpKTtcclxuICAgIGNvbnN0IHRvdGFsU3Vic2NyaXB0aW9ucyA9IEFycmF5LmZyb20oXHJcbiAgICAgIHRoaXMucm9vbVN1YnNjcmlwdGlvbnMudmFsdWVzKClcclxuICAgICkucmVkdWNlKChzdW0sIHN1YnMpID0+IHN1bSArIHN1YnMuc2l6ZSwgMCk7XHJcblxyXG4gICAgLy8gQ2FsY3VsYXRlIGF2ZXJhZ2VzXHJcbiAgICBjb25zdCBhdmdTdWJzY3JpcHRpb25zUGVyQ2xpZW50ID1cclxuICAgICAgY29ubmVjdGlvbnMgPiAwXHJcbiAgICAgICAgPyBwYXJzZUZsb2F0KCh0b3RhbFN1YnNjcmlwdGlvbnMgLyBjb25uZWN0aW9ucykudG9GaXhlZCgyKSlcclxuICAgICAgICA6IDA7XHJcblxyXG4gICAgLy8gR2V0IG1lbW9yeSB1c2FnZVxyXG4gICAgY29uc3QgbWVtb3J5VXNhZ2UgPSBwcm9jZXNzLm1lbW9yeVVzYWdlKCk7XHJcblxyXG4gICAgLy8gQ2FsY3VsYXRlIGhlYWx0aCBzdGF0c1xyXG4gICAgY29uc3QgaGVhbHRoeUNvbm5lY3Rpb25zID0gQXJyYXkuZnJvbShcclxuICAgICAgdGhpcy5jb25uZWN0aW9uSGVhbHRoLnZhbHVlcygpXHJcbiAgICApLmZpbHRlcigoaCkgPT4gaC5zdGF0dXMgPT09IFwiaGVhbHRoeVwiKS5sZW5ndGg7XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgY29ubmVjdGlvbnMsXHJcbiAgICAgIHJvb21zOiByb29tcy5sZW5ndGgsXHJcbiAgICAgIHN1YnNjcmlwdGlvbnM6IHRvdGFsU3Vic2NyaXB0aW9ucyxcclxuICAgICAgYXZnU3Vic2NyaXB0aW9uc1BlckNsaWVudCxcclxuICAgICAgdG90YWxNZXNzYWdlczogdGhpcy5tZXRyaWNzLnRvdGFsTWVzc2FnZXMsXHJcbiAgICAgIHRvdGFsQ29ubmVjdGlvbnM6IHRoaXMubWV0cmljcy50b3RhbENvbm5lY3Rpb25zLFxyXG4gICAgICBwZWFrQ29ubmVjdGlvbnM6IHRoaXMubWV0cmljcy5wZWFrQ29ubmVjdGlvbnMsXHJcbiAgICAgIGVycm9yczogdGhpcy5tZXRyaWNzLmVycm9ycyxcclxuICAgICAgdXB0aW1lOiBEYXRlLm5vdygpIC0gdGhpcy5tZXRyaWNzLnN0YXJ0VGltZSxcclxuICAgICAgcmF0ZUxpbWl0RW50cmllczogdGhpcy5yYXRlTGltaXRzLnNpemUsXHJcbiAgICAgIHF1ZXVlZE1lc3NhZ2VzOiBBcnJheS5mcm9tKHRoaXMubWVzc2FnZVF1ZXVlLnZhbHVlcygpKS5yZWR1Y2UoXHJcbiAgICAgICAgKHN1bSwgbXNncykgPT4gc3VtICsgbXNncy5sZW5ndGgsXHJcbiAgICAgICAgMFxyXG4gICAgICApLFxyXG4gICAgICBoZWFsdGg6IHtcclxuICAgICAgICBoZWFsdGh5OiBoZWFsdGh5Q29ubmVjdGlvbnMsXHJcbiAgICAgICAgZGVncmFkZWQ6IHRoaXMuY29ubmVjdGlvbkhlYWx0aC5zaXplIC0gaGVhbHRoeUNvbm5lY3Rpb25zLFxyXG4gICAgICAgIGhlYWx0aFJhdGU6XHJcbiAgICAgICAgICB0aGlzLmNvbm5lY3Rpb25IZWFsdGguc2l6ZSA+IDBcclxuICAgICAgICAgICAgPyBwYXJzZUZsb2F0KFxyXG4gICAgICAgICAgICAgICAgKFxyXG4gICAgICAgICAgICAgICAgICAoaGVhbHRoeUNvbm5lY3Rpb25zIC8gdGhpcy5jb25uZWN0aW9uSGVhbHRoLnNpemUpICpcclxuICAgICAgICAgICAgICAgICAgMTAwXHJcbiAgICAgICAgICAgICAgICApLnRvRml4ZWQoMilcclxuICAgICAgICAgICAgICApXHJcbiAgICAgICAgICAgIDogMTAwLFxyXG4gICAgICB9LFxyXG4gICAgICBtZW1vcnk6IHtcclxuICAgICAgICByc3M6IE1hdGgucm91bmQobWVtb3J5VXNhZ2UucnNzIC8gMTAyNCAvIDEwMjQpICsgXCJNQlwiLFxyXG4gICAgICAgIGhlYXBVc2VkOiBNYXRoLnJvdW5kKG1lbW9yeVVzYWdlLmhlYXBVc2VkIC8gMTAyNCAvIDEwMjQpICsgXCJNQlwiLFxyXG4gICAgICAgIGhlYXBUb3RhbDogTWF0aC5yb3VuZChtZW1vcnlVc2FnZS5oZWFwVG90YWwgLyAxMDI0IC8gMTAyNCkgKyBcIk1CXCIsXHJcbiAgICAgICAgZXh0ZXJuYWw6IE1hdGgucm91bmQobWVtb3J5VXNhZ2UuZXh0ZXJuYWwgLyAxMDI0IC8gMTAyNCkgKyBcIk1CXCIsXHJcbiAgICAgIH0sXHJcbiAgICAgIHJvb21EZXRhaWxzOiBPYmplY3QuZnJvbUVudHJpZXMoXHJcbiAgICAgICAgQXJyYXkuZnJvbSh0aGlzLnJvb21TdWJzY3JpcHRpb25zLmVudHJpZXMoKSkubWFwKChbcm9vbSwgc3Vic10pID0+IFtcclxuICAgICAgICAgIHJvb20sXHJcbiAgICAgICAgICBzdWJzLnNpemUsXHJcbiAgICAgICAgXSlcclxuICAgICAgKSxcclxuICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIC8vIEhlYWx0aCBjaGVja1xyXG4gIGdldEhlYWx0aENoZWNrKCkge1xyXG4gICAgY29uc3Qgc3RhdHMgPSB0aGlzLmdldERldGFpbGVkU3RhdHMoKTtcclxuICAgIGNvbnN0IGlzSGVhbHRoeSA9IHRoaXMuaW8gJiYgc3RhdHMuY29ubmVjdGlvbnMgPj0gMCAmJiAhdGhpcy5pc092ZXJsb2FkZWQoKTtcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBzdGF0dXM6IGlzSGVhbHRoeSA/IFwiaGVhbHRoeVwiIDogXCJ1bmhlYWx0aHlcIixcclxuICAgICAgdXB0aW1lOiBzdGF0cy51cHRpbWUsXHJcbiAgICAgIGNvbm5lY3Rpb25zOiBzdGF0cy5jb25uZWN0aW9ucyxcclxuICAgICAgcm9vbXM6IHN0YXRzLnJvb21zLFxyXG4gICAgICBzdWJzY3JpcHRpb25zOiBzdGF0cy5zdWJzY3JpcHRpb25zLFxyXG4gICAgICBhdmVyYWdlTG9hZDogdGhpcy5jYWxjdWxhdGVBdmVyYWdlTG9hZCgpLFxyXG4gICAgICBtZW1vcnlVc2FnZTogc3RhdHMubWVtb3J5LFxyXG4gICAgICBoZWFsdGg6IHN0YXRzLmhlYWx0aCxcclxuICAgICAgZXJyb3JzOiBzdGF0cy5lcnJvcnMsXHJcbiAgICAgIGxhc3RFcnJvcnM6IHRoaXMuZ2V0UmVjZW50RXJyb3JzKCksXHJcbiAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICBpc092ZXJsb2FkZWQoKSB7XHJcbiAgICBjb25zdCBzdGF0cyA9IHRoaXMuZ2V0RGV0YWlsZWRTdGF0cygpO1xyXG4gICAgY29uc3QgbWVtb3J5VXNhZ2UgPSBwcm9jZXNzLm1lbW9yeVVzYWdlKCk7XHJcblxyXG4gICAgLy8gRGVmaW5lIG92ZXJsb2FkIHRocmVzaG9sZHNcclxuICAgIGNvbnN0IG1heENvbm5lY3Rpb25zID0gcGFyc2VJbnQocHJvY2Vzcy5lbnYuV1NfTUFYX0NPTk5FQ1RJT05TKSB8fCAxMDAwMDtcclxuICAgIGNvbnN0IG1heE1lbW9yeU1CID0gcGFyc2VJbnQocHJvY2Vzcy5lbnYuV1NfTUFYX01FTU9SWV9NQikgfHwgMTAyNDtcclxuICAgIGNvbnN0IG1heFN1YnNjcmlwdGlvbnMgPVxyXG4gICAgICBwYXJzZUludChwcm9jZXNzLmVudi5XU19NQVhfU1VCU0NSSVBUSU9OUykgfHwgNTAwMDA7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgc3RhdHMuY29ubmVjdGlvbnMgPiBtYXhDb25uZWN0aW9ucyB8fFxyXG4gICAgICBtZW1vcnlVc2FnZS5oZWFwVXNlZCAvIDEwMjQgLyAxMDI0ID4gbWF4TWVtb3J5TUIgfHxcclxuICAgICAgc3RhdHMuc3Vic2NyaXB0aW9ucyA+IG1heFN1YnNjcmlwdGlvbnMgfHxcclxuICAgICAgc3RhdHMuZXJyb3JzID4gMTAwIC8vIEhpZ2ggZXJyb3IgcmF0ZVxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIGNhbGN1bGF0ZUF2ZXJhZ2VMb2FkKCkge1xyXG4gICAgY29uc3QgdGltZURpZmYgPSAoRGF0ZS5ub3coKSAtIHRoaXMubWV0cmljcy5zdGFydFRpbWUpIC8gMTAwMDtcclxuICAgIGNvbnN0IG1lc3NhZ2VzUGVyU2Vjb25kID1cclxuICAgICAgdGltZURpZmYgPiAwID8gdGhpcy5tZXRyaWNzLnRvdGFsTWVzc2FnZXMgLyB0aW1lRGlmZiA6IDA7XHJcbiAgICBjb25zdCBjb25uZWN0aW9uc1JhdGlvID0gdGhpcy5jb25uZWN0ZWRDbGllbnRzLnNpemUgLyAxMDAwOyAvLyBOb3JtYWxpemUgdG8gMTAwMCBjb25uZWN0aW9uc1xyXG5cclxuICAgIHJldHVybiBwYXJzZUZsb2F0KChtZXNzYWdlc1BlclNlY29uZCAqIGNvbm5lY3Rpb25zUmF0aW8pLnRvRml4ZWQoMikpO1xyXG4gIH1cclxuXHJcbiAgZ2V0UmVjZW50RXJyb3JzKCkge1xyXG4gICAgLy8gSW4gYSBwcm9kdWN0aW9uIGVudmlyb25tZW50LCB5b3UnZCBpbXBsZW1lbnQgcHJvcGVyIGVycm9yIGxvZ2dpbmdcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGNvdW50OiB0aGlzLm1ldHJpY3MuZXJyb3JzLFxyXG4gICAgICBsYXN0RXJyb3JUaW1lOiB0aGlzLmxhc3RFcnJvclRpbWUgfHwgbnVsbCxcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICAvLyBDbGllbnQgY2xlYW51cFxyXG4gIGNsZWFudXBDbGllbnQoc29ja2V0SWQpIHtcclxuICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuY29ubmVjdGVkQ2xpZW50cy5nZXQoc29ja2V0SWQpO1xyXG4gICAgaWYgKGNsaWVudCkge1xyXG4gICAgICAvLyBSZW1vdmUgZnJvbSBhbGwgcm9vbSBzdWJzY3JpcHRpb25zXHJcbiAgICAgIGZvciAoY29uc3Qgc3Vic2NyaXB0aW9uIG9mIGNsaWVudC5zdWJzY3JpcHRpb25zKSB7XHJcbiAgICAgICAgY29uc3Qgcm9vbVN1YnMgPSB0aGlzLnJvb21TdWJzY3JpcHRpb25zLmdldChzdWJzY3JpcHRpb24pO1xyXG4gICAgICAgIGlmIChyb29tU3Vicykge1xyXG4gICAgICAgICAgcm9vbVN1YnMuZGVsZXRlKHNvY2tldElkKTtcclxuICAgICAgICAgIGlmIChyb29tU3Vicy5zaXplID09PSAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMucm9vbVN1YnNjcmlwdGlvbnMuZGVsZXRlKHN1YnNjcmlwdGlvbik7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuY29ubmVjdGVkQ2xpZW50cy5kZWxldGUoc29ja2V0SWQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIENsZWFuIHVwIGNvbm5lY3Rpb24gaGVhbHRoXHJcbiAgICB0aGlzLmNvbm5lY3Rpb25IZWFsdGguZGVsZXRlKHNvY2tldElkKTtcclxuXHJcbiAgICAvLyBDbGVhbiB1cCByYXRlIGxpbWl0cyBmb3IgdGhpcyBjbGllbnRcclxuICAgIGNvbnN0IGtleXNUb0RlbGV0ZSA9IFtdO1xyXG4gICAgZm9yIChjb25zdCBba2V5XSBvZiB0aGlzLnJhdGVMaW1pdHMpIHtcclxuICAgICAgaWYgKGtleS5zdGFydHNXaXRoKHNvY2tldElkKSkge1xyXG4gICAgICAgIGtleXNUb0RlbGV0ZS5wdXNoKGtleSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGtleXNUb0RlbGV0ZS5mb3JFYWNoKChrZXkpID0+IHRoaXMucmF0ZUxpbWl0cy5kZWxldGUoa2V5KSk7XHJcblxyXG4gICAgLy8gQ2xlYW4gdXAgR01QIGFsZXJ0c1xyXG4gICAgaWYgKHRoaXMuZ21wQWxlcnRzKSB7XHJcbiAgICAgIGNvbnN0IGFsZXJ0S2V5c1RvRGVsZXRlID0gW107XHJcbiAgICAgIGZvciAoY29uc3QgW2tleV0gb2YgdGhpcy5nbXBBbGVydHMpIHtcclxuICAgICAgICBpZiAoa2V5LnN0YXJ0c1dpdGgoc29ja2V0SWQpKSB7XHJcbiAgICAgICAgICBhbGVydEtleXNUb0RlbGV0ZS5wdXNoKGtleSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGFsZXJ0S2V5c1RvRGVsZXRlLmZvckVhY2goKGtleSkgPT4gdGhpcy5nbXBBbGVydHMuZGVsZXRlKGtleSkpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gR3JhY2VmdWwgc2h1dGRvd25cclxuICBhc3luYyBzaHV0ZG93bigpIHtcclxuICAgIGNvbnNvbGUubG9nKFwi8J+UjCBTaHV0dGluZyBkb3duIFdlYlNvY2tldCBzZXJ2aWNlLi4uXCIpO1xyXG5cclxuICAgIGlmICh0aGlzLmlvKSB7XHJcbiAgICAgIC8vIE5vdGlmeSBhbGwgY2xpZW50cyBhYm91dCBzaHV0ZG93blxyXG4gICAgICBhd2FpdCB0aGlzLmJyb2FkY2FzdFN5c3RlbVN0YXR1cyhcclxuICAgICAgICB7XHJcbiAgICAgICAgICB0eXBlOiBcInNodXRkb3duXCIsXHJcbiAgICAgICAgICBtZXNzYWdlOiBcIlNlcnZlciBpcyBzaHV0dGluZyBkb3duIGZvciBtYWludGVuYW5jZVwiLFxyXG4gICAgICAgICAgZXN0aW1hdGVkRG93bnRpbWU6IFwiNSBtaW51dGVzXCIsXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7IHByaW9yaXR5OiBcImhpZ2hcIiB9XHJcbiAgICAgICk7XHJcblxyXG4gICAgICAvLyBHaXZlIGNsaWVudHMgdGltZSB0byByZWNlaXZlIHRoZSBtZXNzYWdlXHJcbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDMwMDApKTtcclxuXHJcbiAgICAgIC8vIEdyYWNlZnVsbHkgZGlzY29ubmVjdCBhbGwgY2xpZW50c1xyXG4gICAgICBmb3IgKGNvbnN0IFtzb2NrZXRJZCwgY2xpZW50XSBvZiB0aGlzLmNvbm5lY3RlZENsaWVudHMpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgY2xpZW50LnNvY2tldC5lbWl0KFwic2VydmVyOnNodXRkb3duXCIsIHtcclxuICAgICAgICAgICAgbWVzc2FnZTogXCJTZXJ2ZXIgc2h1dHRpbmcgZG93blwiLFxyXG4gICAgICAgICAgICByZWNvbm5lY3RJbjogMTAwMDAsIC8vIFN1Z2dlc3QgcmVjb25uZWN0IGluIDEwIHNlY29uZHNcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgY2xpZW50LnNvY2tldC5kaXNjb25uZWN0KHRydWUpO1xyXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICBjb25zb2xlLndhcm4oXHJcbiAgICAgICAgICAgIGBFcnJvciBkaXNjb25uZWN0aW5nIGNsaWVudCAke3NvY2tldElkfTpgLFxyXG4gICAgICAgICAgICBlcnJvci5tZXNzYWdlXHJcbiAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQ2xvc2UgdGhlIHNlcnZlclxyXG4gICAgICB0aGlzLmlvLmNsb3NlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMuc2VydmVyKSB7XHJcbiAgICAgIHRoaXMuc2VydmVyLmNsb3NlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ2xlYXIgYWxsIGRhdGEgc3RydWN0dXJlc1xyXG4gICAgdGhpcy5jb25uZWN0ZWRDbGllbnRzLmNsZWFyKCk7XHJcbiAgICB0aGlzLnJvb21TdWJzY3JpcHRpb25zLmNsZWFyKCk7XHJcbiAgICB0aGlzLnJhdGVMaW1pdHMuY2xlYXIoKTtcclxuICAgIHRoaXMuY29ubmVjdGlvbkhlYWx0aC5jbGVhcigpO1xyXG4gICAgdGhpcy5tZXNzYWdlUXVldWUuY2xlYXIoKTtcclxuXHJcbiAgICBpZiAodGhpcy5nbXBBbGVydHMpIHtcclxuICAgICAgdGhpcy5nbXBBbGVydHMuY2xlYXIoKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zb2xlLmxvZyhcIuKchSBXZWJTb2NrZXQgc2VydmljZSBzaHV0ZG93biBjb21wbGV0ZVwiKTtcclxuICB9XHJcbn1cclxuXHJcbi8vIEV4cG9ydCBzaW5nbGV0b24gaW5zdGFuY2VcclxuZXhwb3J0IGNvbnN0IHdlYlNvY2tldFNlcnZpY2UgPSBuZXcgV2ViU29ja2V0U2VydmljZSgpO1xyXG5cclxuLy8gSW5pdGlhbGl6ZSBhbmQgc3RhcnQgaWYgbm90IGluIHRlc3QgZW52aXJvbm1lbnRcclxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInRlc3RcIikge1xyXG4gIHdlYlNvY2tldFNlcnZpY2UuaW5pdGlhbGl6ZSgpO1xyXG5cclxuICBpZiAocHJvY2Vzcy5lbnYuQVVUT19TVEFSVF9XRUJTT0NLRVQgIT09IFwiZmFsc2VcIikge1xyXG4gICAgd2ViU29ja2V0U2VydmljZS5zdGFydCgpLmNhdGNoKChlcnJvcikgPT4ge1xyXG4gICAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIHN0YXJ0IFdlYlNvY2tldCBzZXJ2aWNlOlwiLCBlcnJvcik7XHJcbiAgICAgIHByb2Nlc3MuZXhpdCgxKTtcclxuICAgIH0pO1xyXG4gIH1cclxufVxyXG5cclxuLy8gR3JhY2VmdWwgc2h1dGRvd24gaGFuZGxlcnNcclxucHJvY2Vzcy5vbihcIlNJR1RFUk1cIiwgYXN5bmMgKCkgPT4ge1xyXG4gIGNvbnNvbGUubG9nKFxyXG4gICAgXCJSZWNlaXZlZCBTSUdURVJNLCBzaHV0dGluZyBkb3duIFdlYlNvY2tldCBzZXJ2aWNlIGdyYWNlZnVsbHkuLi5cIlxyXG4gICk7XHJcbiAgYXdhaXQgd2ViU29ja2V0U2VydmljZS5zaHV0ZG93bigpO1xyXG4gIHByb2Nlc3MuZXhpdCgwKTtcclxufSk7XHJcblxyXG5wcm9jZXNzLm9uKFwiU0lHSU5UXCIsIGFzeW5jICgpID0+IHtcclxuICBjb25zb2xlLmxvZyhcIlJlY2VpdmVkIFNJR0lOVCwgc2h1dHRpbmcgZG93biBXZWJTb2NrZXQgc2VydmljZSBncmFjZWZ1bGx5Li4uXCIpO1xyXG4gIGF3YWl0IHdlYlNvY2tldFNlcnZpY2Uuc2h1dGRvd24oKTtcclxuICBwcm9jZXNzLmV4aXQoMCk7XHJcbn0pO1xyXG5cclxuLy8gVW5oYW5kbGVkIGVycm9yIGhhbmRsaW5nXHJcbnByb2Nlc3Mub24oXCJ1bmNhdWdodEV4Y2VwdGlvblwiLCBhc3luYyAoZXJyb3IpID0+IHtcclxuICBjb25zb2xlLmVycm9yKFwiVW5jYXVnaHQgRXhjZXB0aW9uIGluIFdlYlNvY2tldCBzZXJ2aWNlOlwiLCBlcnJvcik7XHJcbiAgd2ViU29ja2V0U2VydmljZS5sYXN0RXJyb3JUaW1lID0gRGF0ZS5ub3coKTtcclxuICB3ZWJTb2NrZXRTZXJ2aWNlLm1ldHJpY3MuZXJyb3JzKys7XHJcblxyXG4gIC8vIEF0dGVtcHQgZ3JhY2VmdWwgc2h1dGRvd25cclxuICB0cnkge1xyXG4gICAgYXdhaXQgd2ViU29ja2V0U2VydmljZS5zaHV0ZG93bigpO1xyXG4gIH0gY2F0Y2ggKHNodXRkb3duRXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBkdXJpbmcgZW1lcmdlbmN5IHNodXRkb3duOlwiLCBzaHV0ZG93bkVycm9yKTtcclxuICB9XHJcblxyXG4gIHByb2Nlc3MuZXhpdCgxKTtcclxufSk7XHJcblxyXG4vLyBFeHBvcnQgdGhlIGlvIGluc3RhbmNlIGZvciB1c2UgaW4gb3RoZXIgbW9kdWxlc1xyXG5leHBvcnQgY29uc3QgaW8gPSB3ZWJTb2NrZXRTZXJ2aWNlLmlvO1xyXG5cclxuLy8gRXhwb3J0IGRlZmF1bHRcclxuZXhwb3J0IGRlZmF1bHQgd2ViU29ja2V0U2VydmljZTtcclxuIl0sIm5hbWVzIjpbIlNlcnZlciIsImNyZWF0ZVNlcnZlciIsImNhY2hlIiwicHJpc21hIiwiV2ViU29ja2V0U2VydmljZSIsImNvbnN0cnVjdG9yIiwiaW8iLCJzZXJ2ZXIiLCJjb25uZWN0ZWRDbGllbnRzIiwiTWFwIiwicm9vbVN1YnNjcmlwdGlvbnMiLCJwb3J0IiwicHJvY2VzcyIsImVudiIsIldFQlNPQ0tFVF9QT1JUIiwiZXZlbnRzIiwiSVBPX1VQREFURSIsIkdNUF9VUERBVEUiLCJTVUJTQ1JJUFRJT05fVVBEQVRFIiwiREVNQU5EX1VQREFURSIsIkFMTE9UTUVOVF9VUERBVEUiLCJTWVNURU1fU1RBVFVTIiwiQU5BTFlUSUNTX1VQREFURSIsIk5FV1NfVVBEQVRFIiwiQUxFUlRfVFJJR0dFUkVEIiwicmF0ZUxpbWl0cyIsIm1heEV2ZW50c1BlclNlY29uZCIsIm1heFN1YnNjcmlwdGlvbnNQZXJDbGllbnQiLCJtZXRyaWNzIiwidG90YWxDb25uZWN0aW9ucyIsImN1cnJlbnRDb25uZWN0aW9ucyIsInRvdGFsTWVzc2FnZXMiLCJ0b3RhbFN1YnNjcmlwdGlvbnMiLCJlcnJvcnMiLCJzdGFydFRpbWUiLCJEYXRlIiwibm93IiwiYXZlcmFnZVJlc3BvbnNlVGltZSIsInBlYWtDb25uZWN0aW9ucyIsImNvbm5lY3Rpb25IZWFsdGgiLCJtZXNzYWdlUXVldWUiLCJtYXhRdWV1ZVNpemUiLCJpbml0aWFsaXplIiwiY29ycyIsIm9yaWdpbiIsIkZST05URU5EX1VSTCIsIm1ldGhvZHMiLCJjcmVkZW50aWFscyIsInBpbmdUaW1lb3V0IiwicGluZ0ludGVydmFsIiwibWF4SHR0cEJ1ZmZlclNpemUiLCJ0cmFuc3BvcnRzIiwiYWxsb3dFSU8zIiwiY29ubmVjdFRpbWVvdXQiLCJ1cGdyYWRlVGltZW91dCIsInNldHVwRXZlbnRIYW5kbGVycyIsInN0YXJ0SGVhcnRiZWF0Iiwic3RhcnRNZXRyaWNzQ29sbGVjdGlvbiIsInN0YXJ0SGVhbHRoTW9uaXRvcmluZyIsImNvbnNvbGUiLCJsb2ciLCJlcnJvciIsInN0YXJ0IiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJsaXN0ZW4iLCJlcnIiLCJzdGFydFBlcmlvZGljQ2xlYW51cCIsIm9uIiwic29ja2V0IiwiaGFuZGxlQ2xpZW50Q29ubmVjdGlvbiIsInNldHVwQ2xpZW50RXZlbnRMaXN0ZW5lcnMiLCJNYXRoIiwibWF4IiwiY2xpZW50SVAiLCJoYW5kc2hha2UiLCJhZGRyZXNzIiwidXNlckFnZW50IiwiaGVhZGVycyIsImlkIiwiY2xpZW50SW5mbyIsImNvbm5lY3RlZEF0Iiwic3Vic2NyaXB0aW9ucyIsIlNldCIsImxhc3RBY3Rpdml0eSIsInN1YnNjcmlwdGlvbkNvdW50IiwibWVzc2FnZUNvdW50IiwiaXBBZGRyZXNzIiwiaXNIZWFsdGh5IiwibGFzdFBpbmciLCJyZWNvbm5lY3RDb3VudCIsInNldCIsInN0YXR1cyIsImxhdGVuY3kiLCJsYXN0U2VlbiIsImVtaXQiLCJzb2NrZXRJZCIsInRpbWVzdGFtcCIsInNlcnZlclZlcnNpb24iLCJhdmFpbGFibGVFdmVudHMiLCJPYmplY3QiLCJ2YWx1ZXMiLCJtYXhTdWJzY3JpcHRpb25zIiwiZmVhdHVyZXMiLCJyZWFsVGltZVVwZGF0ZXMiLCJiYXRjaFN1YnNjcmlwdGlvbnMiLCJhbmFseXRpY3MiLCJzZW5kUXVldWVkTWVzc2FnZXMiLCJkYXRhIiwiaGFuZGxlU3Vic2NyaXB0aW9uIiwiaXBvSWQiLCJzeW1ib2wiLCJpbmNsdWRlQW5hbHl0aWNzIiwiam9pbiIsImFkZFN1YnNjcmlwdGlvbiIsImlwb0RhdGEiLCJnZXRDdXJyZW50SVBPRGF0YSIsInR5cGUiLCJoaXN0b3JpY2FsIiwiYWxlcnRUaHJlc2hvbGQiLCJnbXBEYXRhIiwiZ2V0UmVhbFRpbWVEYXRhIiwiaGlzdG9yaWNhbEdNUCIsImdldEhpc3RvcmljYWxHTVBEYXRhIiwiZGF5cyIsInNldHVwR01QQWxlcnQiLCJjYXRlZ29yaWVzIiwicmVhbFRpbWUiLCJzdWJEYXRhIiwiZmlsdGVyZWREYXRhIiwibGVuZ3RoIiwiZmlsdGVyIiwiaXRlbSIsImluY2x1ZGVzIiwiY2F0ZWdvcnkiLCJwcmljZVJhbmdlIiwiY3V0T2ZmT25seSIsImRlbWFuZERhdGEiLCJjdXRPZmZJbmRpY2F0b3IiLCJtaW4iLCJ1bmRlZmluZWQiLCJwcmljZSIsImZpbHRlcnMiLCJ1cGRhdGVJbnRlcnZhbCIsImdldEN1cnJlbnRBbmFseXRpY3MiLCJmaWx0ZXJlZEFuYWx5dGljcyIsImZpbHRlckFuYWx5dGljc0J5TWV0cmljcyIsInN5c3RlbVN0YXR1cyIsImdldFN5c3RlbVN0YXR1cyIsIm9wdGlvbnMiLCJza2lwRXJyb3JzIiwicmVzdWx0cyIsImxpbWl0ZWRTdWJzY3JpcHRpb25zIiwic2xpY2UiLCJzdWIiLCJoYW5kbGVTaW5nbGVTdWJzY3JpcHRpb24iLCJwdXNoIiwibWVzc2FnZSIsInByb2Nlc3NlZCIsInN1Y2Nlc3NmdWwiLCJyIiwiaWRlbnRpZmllciIsInBhdHRlcm4iLCJ1bnN1YnNjcmliZUFsbCIsInJvb21LZXkiLCJsZWF2ZSIsInJlbW92ZVN1YnNjcmlwdGlvbiIsInVuc3Vic2NyaWJlQnlUeXBlIiwiY2xpZW50IiwiZ2V0Iiwic2VydmVyVXB0aW1lIiwibWVzc2FnZXMiLCJjb25uZWN0ZWRGb3IiLCJnZXRUaW1lIiwiaGVhbHRoIiwiQXJyYXkiLCJmcm9tIiwic2VydmVyTWV0cmljcyIsImlzQXV0aG9yaXplZCIsInN0YXRzIiwiZ2V0RGV0YWlsZWRTdGF0cyIsInJlYXNvbiIsImhhbmRsZUNsaWVudERpc2Nvbm5lY3Rpb24iLCJjbGVhbnVwQ2xpZW50Iiwic3Vic2NyaXB0aW9uTG9naWMiLCJFcnJvciIsImNoZWNrUmF0ZUxpbWl0IiwidmFsaWRhdGVTdWJzY3JpcHRpb25EYXRhIiwic3Vic2NyaXB0aW9uVHlwZSIsImV2ZW50VHlwZSIsImtleSIsIndpbmRvd1N0YXJ0IiwiZmxvb3IiLCJoYXMiLCJjb3VudCIsImxpbWl0Iiwic3Vic2NyaXB0aW9uS2V5IiwiYWRkIiwic2l6ZSIsImRlbGV0ZSIsInJvb21TdWJzIiwic3Vic2NyaXB0aW9uIiwic3BsaXQiLCJzdWJzY3JpcHRpb25zVG9SZW1vdmUiLCJzdGFydHNXaXRoIiwiYnJvYWRjYXN0SVBPVXBkYXRlIiwidXBkYXRlRGF0YSIsInByaW9yaXR5IiwiZXhjbHVkZVNvY2tldCIsImNoZWNrQnJvYWRjYXN0UmF0ZUxpbWl0Iiwicm9vbSIsInN1YnNjcmliZXJDb3VudCIsImVucmljaGVkRGF0YSIsIlNFUlZFUl9JRCIsInRvIiwiZXhjZXB0IiwicXVldWVNZXNzYWdlRm9yT2ZmbGluZUNsaWVudHMiLCJicm9hZGNhc3RHTVBVcGRhdGUiLCJhbGVydENoZWNrIiwiY2hhbmdlIiwiY2FsY3VsYXRlR01QQ2hhbmdlIiwidmFsdWUiLCJ0cmVuZCIsImNhbGN1bGF0ZUdNUFRyZW5kIiwidm9sYXRpbGl0eSIsImNhbGN1bGF0ZUdNUFZvbGF0aWxpdHkiLCJjaGVja0dNUEFsZXJ0cyIsImJyb2FkY2FzdFN1YnNjcmlwdGlvblVwZGF0ZSIsInN1YnNjcmlwdGlvbkRhdGEiLCJhbGVydE9uT3ZlcnN1YnNjcmlwdGlvbiIsIm92ZXJhbGxTdWJzY3JpcHRpb24iLCJjYWxjdWxhdGVPdmVyYWxsU3Vic2NyaXB0aW9uIiwiaXNPdmVyc3Vic2NyaWJlZCIsImJyb2FkY2FzdEFsZXJ0IiwiYnJvYWRjYXN0RGVtYW5kVXBkYXRlIiwicHJpY2VMZXZlbCIsInRvdGFsRGVtYW5kIiwiY2FsY3VsYXRlVG90YWxEZW1hbmQiLCJjdXRPZmZEZW1hbmQiLCJjYWxjdWxhdGVDdXRPZmZEZW1hbmQiLCJicm9hZGNhc3RBbmFseXRpY3NVcGRhdGUiLCJhbmFseXRpY3NEYXRhIiwiaW5zaWdodHMiLCJnZW5lcmF0ZUFuYWx5dGljc0luc2lnaHRzIiwiYnJvYWRjYXN0U3lzdGVtU3RhdHVzIiwiZW5yaWNoZWRTdGF0dXMiLCJjb25uZWN0aW9ucyIsImFsZXJ0VHlwZSIsImFsZXJ0RGF0YSIsImVucmljaGVkQWxlcnQiLCJzZXZlcml0eSIsImdldEFsZXJ0U2V2ZXJpdHkiLCJjdXJyZW50VmFsdWUiLCJwcmV2aW91c0dNUFZhbHVlcyIsInByZXZpb3VzVmFsdWUiLCJhYnNvbHV0ZSIsInBlcmNlbnRhZ2UiLCJwYXJzZUZsb2F0IiwidG9GaXhlZCIsImRpcmVjdGlvbiIsImFicyIsInJlY2VudEdNUCIsImdNUCIsImZpbmRNYW55Iiwid2hlcmUiLCJvcmRlckJ5IiwidGFrZSIsIm1hcCIsImciLCJtZWFuIiwicmVkdWNlIiwiYSIsImIiLCJ2YXJpYW5jZSIsImFjYyIsInZhbCIsInBvdyIsInJvdW5kIiwic3FydCIsImlzQXJyYXkiLCJyYXRpb3MiLCJzdWJzY3JpcHRpb25SYXRpbyIsInRvdGFsIiwicGFyc2VJbnQiLCJhYnNvbHV0ZVF1YW50aXR5IiwiZ21wVm9sYXRpbGl0eSIsImZpbmFsU3Vic2NyaXB0aW9uIiwicmlza1Njb3JlIiwiaXBvIiwiaVBPIiwiZmluZFVuaXF1ZSIsImluY2x1ZGUiLCJnbXAiLCJzdGFydERhdGUiLCJzZXREYXRlIiwiZ2V0RGF0ZSIsImd0ZSIsImlQT0FuYWx5dGljcyIsInR5cGVNYXBwaW5nIiwicHJlZGljdGlvbiIsImZvckVhY2giLCJkYkhlYWx0aCIsImNhY2hlSGVhbHRoIiwiYWxsU2V0dGxlZCIsIiRxdWVyeVJhdyIsImhlYWx0aENoZWNrIiwidXB0aW1lIiwiZGF0YWJhc2UiLCJ3ZWJzb2NrZXQiLCJ2ZXJzaW9uIiwiZmlsdGVyZWQiLCJtZXRyaWMiLCJ0aHJlc2hvbGQiLCJnbXBBbGVydHMiLCJhbGVydEtleSIsInRyaWdnZXJlZCIsImNyZWF0ZWRBdCIsImN1cnJlbnRHTVAiLCJhbGVydCIsImFsZXJ0SXBvSWQiLCJzZXZlcml0eU1hcCIsImdtcF90aHJlc2hvbGQiLCJvdmVyc3Vic2NyaXB0aW9uIiwic3lzdGVtX2Vycm9yIiwiY29ubmVjdGlvbl9pc3N1ZSIsInJhdGVfbGltaXQiLCJxdWV1ZSIsInNwbGljZSIsInF1ZXVlZE1lc3NhZ2VzIiwiZGlzY29ubmVjdGlvbkxvZyIsImRpc2Nvbm5lY3RlZEF0IiwiZW50cmllcyIsInNvcnQiLCJzZXRJbnRlcnZhbCIsInN0YWxlVGhyZXNob2xkIiwic3RhbGVDbGllbnRzIiwidGltZVNpbmNlTGFzdEFjdGl2aXR5IiwiZGlzY29ubmVjdCIsImhlYWx0aEVudHJpZXMiLCJhY3RpdmVDbGllbnRzIiwia2V5cyIsInJlc2V0SG91cmx5TWV0cmljcyIsInZhbGlkTWVzc2FnZXMiLCJtc2ciLCJyb29tcyIsInN1bSIsInN1YnMiLCJhdmdTdWJzY3JpcHRpb25zUGVyQ2xpZW50IiwibWVtb3J5VXNhZ2UiLCJoZWFsdGh5Q29ubmVjdGlvbnMiLCJoIiwicmF0ZUxpbWl0RW50cmllcyIsIm1zZ3MiLCJoZWFsdGh5IiwiZGVncmFkZWQiLCJoZWFsdGhSYXRlIiwibWVtb3J5IiwicnNzIiwiaGVhcFVzZWQiLCJoZWFwVG90YWwiLCJleHRlcm5hbCIsInJvb21EZXRhaWxzIiwiZnJvbUVudHJpZXMiLCJnZXRIZWFsdGhDaGVjayIsImlzT3ZlcmxvYWRlZCIsImF2ZXJhZ2VMb2FkIiwiY2FsY3VsYXRlQXZlcmFnZUxvYWQiLCJsYXN0RXJyb3JzIiwiZ2V0UmVjZW50RXJyb3JzIiwibWF4Q29ubmVjdGlvbnMiLCJXU19NQVhfQ09OTkVDVElPTlMiLCJtYXhNZW1vcnlNQiIsIldTX01BWF9NRU1PUllfTUIiLCJXU19NQVhfU1VCU0NSSVBUSU9OUyIsInRpbWVEaWZmIiwibWVzc2FnZXNQZXJTZWNvbmQiLCJjb25uZWN0aW9uc1JhdGlvIiwibGFzdEVycm9yVGltZSIsImtleXNUb0RlbGV0ZSIsImFsZXJ0S2V5c1RvRGVsZXRlIiwic2h1dGRvd24iLCJlc3RpbWF0ZWREb3dudGltZSIsInNldFRpbWVvdXQiLCJyZWNvbm5lY3RJbiIsIndhcm4iLCJjbG9zZSIsImNsZWFyIiwid2ViU29ja2V0U2VydmljZSIsIkFVVE9fU1RBUlRfV0VCU09DS0VUIiwiY2F0Y2giLCJleGl0Iiwic2h1dGRvd25FcnJvciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./src/lib/websocket.js\n");

/***/ })

};
;

// load runtime
var __webpack_require__ = require("../../../../webpack-runtime.js");
__webpack_require__.C(exports);
var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
var __webpack_exports__ = __webpack_require__.X(0, ["vendor-chunks/next","vendor-chunks/@upstash","vendor-chunks/object-assign","vendor-chunks/ms","vendor-chunks/uncrypto","vendor-chunks/engine.io","vendor-chunks/socket.io","vendor-chunks/socket.io-adapter","vendor-chunks/socket.io-parser","vendor-chunks/engine.io-parser","vendor-chunks/cookie","vendor-chunks/cors","vendor-chunks/@socket.io","vendor-chunks/vary","vendor-chunks/supports-color","vendor-chunks/base64id","vendor-chunks/has-flag"], () => (__webpack_exec__("(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fgmp%2Flive%2Froute&page=%2Fapi%2Fgmp%2Flive%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fgmp%2Flive%2Froute.js&appDir=C%3A%5CUsers%5Chp%5COneDrive%5CDesktop%5CIPOs%5Cipo-tracker%5Csrc%5Capp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=C%3A%5CUsers%5Chp%5COneDrive%5CDesktop%5CIPOs%5Cipo-tracker&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D!")));
module.exports = __webpack_exports__;

})();