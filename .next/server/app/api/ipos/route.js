/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(() => {
var exports = {};
exports.id = "app/api/ipos/route";
exports.ids = ["app/api/ipos/route"];
exports.modules = {

/***/ "@prisma/client":
/*!*********************************!*\
  !*** external "@prisma/client" ***!
  \*********************************/
/***/ ((module) => {

"use strict";
module.exports = require("@prisma/client");

/***/ }),

/***/ "next/dist/compiled/next-server/app-page.runtime.dev.js":
/*!*************************************************************************!*\
  !*** external "next/dist/compiled/next-server/app-page.runtime.dev.js" ***!
  \*************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/compiled/next-server/app-page.runtime.dev.js");

/***/ }),

/***/ "next/dist/compiled/next-server/app-route.runtime.dev.js":
/*!**************************************************************************!*\
  !*** external "next/dist/compiled/next-server/app-route.runtime.dev.js" ***!
  \**************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/compiled/next-server/app-route.runtime.dev.js");

/***/ }),

/***/ "buffer":
/*!*************************!*\
  !*** external "buffer" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("buffer");

/***/ }),

/***/ "crypto":
/*!*************************!*\
  !*** external "crypto" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("crypto");

/***/ }),

/***/ "events":
/*!*************************!*\
  !*** external "events" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("events");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/***/ ((module) => {

"use strict";
module.exports = require("fs");

/***/ }),

/***/ "http":
/*!***********************!*\
  !*** external "http" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("http");

/***/ }),

/***/ "https":
/*!************************!*\
  !*** external "https" ***!
  \************************/
/***/ ((module) => {

"use strict";
module.exports = require("https");

/***/ }),

/***/ "net":
/*!**********************!*\
  !*** external "net" ***!
  \**********************/
/***/ ((module) => {

"use strict";
module.exports = require("net");

/***/ }),

/***/ "os":
/*!*********************!*\
  !*** external "os" ***!
  \*********************/
/***/ ((module) => {

"use strict";
module.exports = require("os");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("path");

/***/ }),

/***/ "querystring":
/*!******************************!*\
  !*** external "querystring" ***!
  \******************************/
/***/ ((module) => {

"use strict";
module.exports = require("querystring");

/***/ }),

/***/ "stream":
/*!*************************!*\
  !*** external "stream" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("stream");

/***/ }),

/***/ "timers":
/*!*************************!*\
  !*** external "timers" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("timers");

/***/ }),

/***/ "tls":
/*!**********************!*\
  !*** external "tls" ***!
  \**********************/
/***/ ((module) => {

"use strict";
module.exports = require("tls");

/***/ }),

/***/ "tty":
/*!**********************!*\
  !*** external "tty" ***!
  \**********************/
/***/ ((module) => {

"use strict";
module.exports = require("tty");

/***/ }),

/***/ "url":
/*!**********************!*\
  !*** external "url" ***!
  \**********************/
/***/ ((module) => {

"use strict";
module.exports = require("url");

/***/ }),

/***/ "util":
/*!***********************!*\
  !*** external "util" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("util");

/***/ }),

/***/ "zlib":
/*!***********************!*\
  !*** external "zlib" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("zlib");

/***/ }),

/***/ "node:crypto":
/*!******************************!*\
  !*** external "node:crypto" ***!
  \******************************/
/***/ ((module) => {

"use strict";
module.exports = require("node:crypto");

/***/ }),

/***/ "?c6f9":
/*!****************************!*\
  !*** bufferutil (ignored) ***!
  \****************************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?ae40":
/*!********************************!*\
  !*** utf-8-validate (ignored) ***!
  \********************************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?4410":
/*!****************************!*\
  !*** bufferutil (ignored) ***!
  \****************************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?c757":
/*!********************************!*\
  !*** utf-8-validate (ignored) ***!
  \********************************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fipos%2Froute&page=%2Fapi%2Fipos%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fipos%2Froute.js&appDir=C%3A%5CUsers%5Chp%5COneDrive%5CDesktop%5CIPOs%5Cipo-tracker%5Csrc%5Capp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=C%3A%5CUsers%5Chp%5COneDrive%5CDesktop%5CIPOs%5Cipo-tracker&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D!":
/*!********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fipos%2Froute&page=%2Fapi%2Fipos%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fipos%2Froute.js&appDir=C%3A%5CUsers%5Chp%5COneDrive%5CDesktop%5CIPOs%5Cipo-tracker%5Csrc%5Capp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=C%3A%5CUsers%5Chp%5COneDrive%5CDesktop%5CIPOs%5Cipo-tracker&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D! ***!
  \********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   originalPathname: () => (/* binding */ originalPathname),\n/* harmony export */   patchFetch: () => (/* binding */ patchFetch),\n/* harmony export */   requestAsyncStorage: () => (/* binding */ requestAsyncStorage),\n/* harmony export */   routeModule: () => (/* binding */ routeModule),\n/* harmony export */   serverHooks: () => (/* binding */ serverHooks),\n/* harmony export */   staticGenerationAsyncStorage: () => (/* binding */ staticGenerationAsyncStorage)\n/* harmony export */ });\n/* harmony import */ var next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/dist/server/future/route-modules/app-route/module.compiled */ \"(rsc)/./node_modules/next/dist/server/future/route-modules/app-route/module.compiled.js\");\n/* harmony import */ var next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/dist/server/future/route-kind */ \"(rsc)/./node_modules/next/dist/server/future/route-kind.js\");\n/* harmony import */ var next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/dist/server/lib/patch-fetch */ \"(rsc)/./node_modules/next/dist/server/lib/patch-fetch.js\");\n/* harmony import */ var next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var C_Users_hp_OneDrive_Desktop_IPOs_ipo_tracker_src_app_api_ipos_route_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./src/app/api/ipos/route.js */ \"(rsc)/./src/app/api/ipos/route.js\");\n\n\n\n\n// We inject the nextConfigOutput here so that we can use them in the route\n// module.\nconst nextConfigOutput = \"\"\nconst routeModule = new next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__.AppRouteRouteModule({\n    definition: {\n        kind: next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__.RouteKind.APP_ROUTE,\n        page: \"/api/ipos/route\",\n        pathname: \"/api/ipos\",\n        filename: \"route\",\n        bundlePath: \"app/api/ipos/route\"\n    },\n    resolvedPagePath: \"C:\\\\Users\\\\hp\\\\OneDrive\\\\Desktop\\\\IPOs\\\\ipo-tracker\\\\src\\\\app\\\\api\\\\ipos\\\\route.js\",\n    nextConfigOutput,\n    userland: C_Users_hp_OneDrive_Desktop_IPOs_ipo_tracker_src_app_api_ipos_route_js__WEBPACK_IMPORTED_MODULE_3__\n});\n// Pull out the exports that we need to expose from the module. This should\n// be eliminated when we've moved the other routes to the new format. These\n// are used to hook into the route.\nconst { requestAsyncStorage, staticGenerationAsyncStorage, serverHooks } = routeModule;\nconst originalPathname = \"/api/ipos/route\";\nfunction patchFetch() {\n    return (0,next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__.patchFetch)({\n        serverHooks,\n        staticGenerationAsyncStorage\n    });\n}\n\n\n//# sourceMappingURL=app-route.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LWFwcC1sb2FkZXIuanM/bmFtZT1hcHAlMkZhcGklMkZpcG9zJTJGcm91dGUmcGFnZT0lMkZhcGklMkZpcG9zJTJGcm91dGUmYXBwUGF0aHM9JnBhZ2VQYXRoPXByaXZhdGUtbmV4dC1hcHAtZGlyJTJGYXBpJTJGaXBvcyUyRnJvdXRlLmpzJmFwcERpcj1DJTNBJTVDVXNlcnMlNUNocCU1Q09uZURyaXZlJTVDRGVza3RvcCU1Q0lQT3MlNUNpcG8tdHJhY2tlciU1Q3NyYyU1Q2FwcCZwYWdlRXh0ZW5zaW9ucz10c3gmcGFnZUV4dGVuc2lvbnM9dHMmcGFnZUV4dGVuc2lvbnM9anN4JnBhZ2VFeHRlbnNpb25zPWpzJnJvb3REaXI9QyUzQSU1Q1VzZXJzJTVDaHAlNUNPbmVEcml2ZSU1Q0Rlc2t0b3AlNUNJUE9zJTVDaXBvLXRyYWNrZXImaXNEZXY9dHJ1ZSZ0c2NvbmZpZ1BhdGg9dHNjb25maWcuanNvbiZiYXNlUGF0aD0mYXNzZXRQcmVmaXg9Jm5leHRDb25maWdPdXRwdXQ9JnByZWZlcnJlZFJlZ2lvbj0mbWlkZGxld2FyZUNvbmZpZz1lMzAlM0QhIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFzRztBQUN2QztBQUNjO0FBQ2tDO0FBQy9HO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnSEFBbUI7QUFDM0M7QUFDQSxjQUFjLHlFQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxZQUFZO0FBQ1osQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLFFBQVEsaUVBQWlFO0FBQ3pFO0FBQ0E7QUFDQSxXQUFXLDRFQUFXO0FBQ3RCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDdUg7O0FBRXZIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaXBvLXRyYWNrZXIvPzc4YmEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQXBwUm91dGVSb3V0ZU1vZHVsZSB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL2Z1dHVyZS9yb3V0ZS1tb2R1bGVzL2FwcC1yb3V0ZS9tb2R1bGUuY29tcGlsZWRcIjtcbmltcG9ydCB7IFJvdXRlS2luZCB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL2Z1dHVyZS9yb3V0ZS1raW5kXCI7XG5pbXBvcnQgeyBwYXRjaEZldGNoIGFzIF9wYXRjaEZldGNoIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvbGliL3BhdGNoLWZldGNoXCI7XG5pbXBvcnQgKiBhcyB1c2VybGFuZCBmcm9tIFwiQzpcXFxcVXNlcnNcXFxcaHBcXFxcT25lRHJpdmVcXFxcRGVza3RvcFxcXFxJUE9zXFxcXGlwby10cmFja2VyXFxcXHNyY1xcXFxhcHBcXFxcYXBpXFxcXGlwb3NcXFxccm91dGUuanNcIjtcbi8vIFdlIGluamVjdCB0aGUgbmV4dENvbmZpZ091dHB1dCBoZXJlIHNvIHRoYXQgd2UgY2FuIHVzZSB0aGVtIGluIHRoZSByb3V0ZVxuLy8gbW9kdWxlLlxuY29uc3QgbmV4dENvbmZpZ091dHB1dCA9IFwiXCJcbmNvbnN0IHJvdXRlTW9kdWxlID0gbmV3IEFwcFJvdXRlUm91dGVNb2R1bGUoe1xuICAgIGRlZmluaXRpb246IHtcbiAgICAgICAga2luZDogUm91dGVLaW5kLkFQUF9ST1VURSxcbiAgICAgICAgcGFnZTogXCIvYXBpL2lwb3Mvcm91dGVcIixcbiAgICAgICAgcGF0aG5hbWU6IFwiL2FwaS9pcG9zXCIsXG4gICAgICAgIGZpbGVuYW1lOiBcInJvdXRlXCIsXG4gICAgICAgIGJ1bmRsZVBhdGg6IFwiYXBwL2FwaS9pcG9zL3JvdXRlXCJcbiAgICB9LFxuICAgIHJlc29sdmVkUGFnZVBhdGg6IFwiQzpcXFxcVXNlcnNcXFxcaHBcXFxcT25lRHJpdmVcXFxcRGVza3RvcFxcXFxJUE9zXFxcXGlwby10cmFja2VyXFxcXHNyY1xcXFxhcHBcXFxcYXBpXFxcXGlwb3NcXFxccm91dGUuanNcIixcbiAgICBuZXh0Q29uZmlnT3V0cHV0LFxuICAgIHVzZXJsYW5kXG59KTtcbi8vIFB1bGwgb3V0IHRoZSBleHBvcnRzIHRoYXQgd2UgbmVlZCB0byBleHBvc2UgZnJvbSB0aGUgbW9kdWxlLiBUaGlzIHNob3VsZFxuLy8gYmUgZWxpbWluYXRlZCB3aGVuIHdlJ3ZlIG1vdmVkIHRoZSBvdGhlciByb3V0ZXMgdG8gdGhlIG5ldyBmb3JtYXQuIFRoZXNlXG4vLyBhcmUgdXNlZCB0byBob29rIGludG8gdGhlIHJvdXRlLlxuY29uc3QgeyByZXF1ZXN0QXN5bmNTdG9yYWdlLCBzdGF0aWNHZW5lcmF0aW9uQXN5bmNTdG9yYWdlLCBzZXJ2ZXJIb29rcyB9ID0gcm91dGVNb2R1bGU7XG5jb25zdCBvcmlnaW5hbFBhdGhuYW1lID0gXCIvYXBpL2lwb3Mvcm91dGVcIjtcbmZ1bmN0aW9uIHBhdGNoRmV0Y2goKSB7XG4gICAgcmV0dXJuIF9wYXRjaEZldGNoKHtcbiAgICAgICAgc2VydmVySG9va3MsXG4gICAgICAgIHN0YXRpY0dlbmVyYXRpb25Bc3luY1N0b3JhZ2VcbiAgICB9KTtcbn1cbmV4cG9ydCB7IHJvdXRlTW9kdWxlLCByZXF1ZXN0QXN5bmNTdG9yYWdlLCBzdGF0aWNHZW5lcmF0aW9uQXN5bmNTdG9yYWdlLCBzZXJ2ZXJIb29rcywgb3JpZ2luYWxQYXRobmFtZSwgcGF0Y2hGZXRjaCwgIH07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFwcC1yb3V0ZS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fipos%2Froute&page=%2Fapi%2Fipos%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fipos%2Froute.js&appDir=C%3A%5CUsers%5Chp%5COneDrive%5CDesktop%5CIPOs%5Cipo-tracker%5Csrc%5Capp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=C%3A%5CUsers%5Chp%5COneDrive%5CDesktop%5CIPOs%5Cipo-tracker&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D!\n");

/***/ }),

/***/ "(rsc)/./src/app/api/ipos/route.js":
/*!***********************************!*\
  !*** ./src/app/api/ipos/route.js ***!
  \***********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GET: () => (/* binding */ GET),\n/* harmony export */   POST: () => (/* binding */ POST),\n/* harmony export */   dynamic: () => (/* binding */ dynamic),\n/* harmony export */   runtime: () => (/* binding */ runtime)\n/* harmony export */ });\n/* harmony import */ var next_server__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/server */ \"(rsc)/./node_modules/next/dist/api/server.js\");\n/* harmony import */ var _lib_db_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../lib/db.js */ \"(rsc)/./src/lib/db.js\");\n/* harmony import */ var _lib_cache_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../lib/cache.js */ \"(rsc)/./src/lib/cache.js\");\n/* harmony import */ var _lib_analytics_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../lib/analytics.js */ \"(rsc)/./src/lib/analytics.js\");\n/* harmony import */ var _services_prediction_service_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../services/prediction-service.js */ \"(rsc)/./src/services/prediction-service.js\");\n\n\n\n\n\n// Advanced IPO search endpoint with full-text search, filters, and AI-powered suggestions\nasync function GET(request) {\n    try {\n        const { searchParams } = new URL(request.url);\n        // Extract search parameters\n        const query = searchParams.get(\"q\") || searchParams.get(\"query\") || \"\";\n        const type = searchParams.get(\"type\") || \"all\"; // all, symbol, name, sector, registrar\n        const status = searchParams.get(\"status\");\n        const sector = searchParams.get(\"sector\");\n        const registrar = searchParams.get(\"registrar\");\n        const minPrice = parseFloat(searchParams.get(\"minPrice\"));\n        const maxPrice = parseFloat(searchParams.get(\"maxPrice\"));\n        const minIssueSize = parseFloat(searchParams.get(\"minIssueSize\"));\n        const maxIssueSize = parseFloat(searchParams.get(\"maxIssueSize\"));\n        const minGMP = parseFloat(searchParams.get(\"minGMP\"));\n        const maxGMP = parseFloat(searchParams.get(\"maxGMP\"));\n        const subscriptionMin = parseFloat(searchParams.get(\"subscriptionMin\"));\n        const subscriptionMax = parseFloat(searchParams.get(\"subscriptionMax\"));\n        const dateFrom = searchParams.get(\"dateFrom\");\n        const dateTo = searchParams.get(\"dateTo\");\n        const sortBy = searchParams.get(\"sortBy\") || \"relevance\";\n        const sortOrder = searchParams.get(\"sortOrder\") || \"desc\";\n        const page = parseInt(searchParams.get(\"page\")) || 1;\n        const limit = Math.min(parseInt(searchParams.get(\"limit\")) || 20, 100);\n        const fuzzy = searchParams.get(\"fuzzy\") !== \"false\"; // Default true\n        const suggestions = searchParams.get(\"suggestions\") === \"true\";\n        const highlight = searchParams.get(\"highlight\") !== \"false\"; // Default true\n        const includeAnalytics = searchParams.get(\"includeAnalytics\") === \"true\";\n        const includePredictions = searchParams.get(\"includePredictions\") === \"true\";\n        const advanced = searchParams.get(\"advanced\") === \"true\";\n        // Validate query length\n        if (query.length > 0 && query.length < 2) {\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                success: false,\n                error: \"Search query must be at least 2 characters long\"\n            }, {\n                status: 400\n            });\n        }\n        // Build cache key\n        const cacheKey = _lib_cache_js__WEBPACK_IMPORTED_MODULE_2__.cache.key(\"SEARCH\", `ipos:${JSON.stringify({\n            query: query.toLowerCase(),\n            type,\n            status,\n            sector,\n            registrar,\n            minPrice,\n            maxPrice,\n            minIssueSize,\n            maxIssueSize,\n            minGMP,\n            maxGMP,\n            subscriptionMin,\n            subscriptionMax,\n            dateFrom,\n            dateTo,\n            sortBy,\n            sortOrder,\n            page,\n            limit,\n            fuzzy,\n            includeAnalytics,\n            includePredictions,\n            advanced\n        })}`);\n        // Try cache first\n        const cached = await _lib_cache_js__WEBPACK_IMPORTED_MODULE_2__.cache.get(cacheKey);\n        if (cached) {\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                ...cached,\n                cached: true,\n                cacheTime: new Date().toISOString()\n            });\n        }\n        // Build search results\n        let searchResults;\n        if (query.trim() === \"\") {\n            // If no query, return filtered results\n            searchResults = await performFilteredSearch({\n                status,\n                sector,\n                registrar,\n                minPrice,\n                maxPrice,\n                minIssueSize,\n                maxIssueSize,\n                minGMP,\n                maxGMP,\n                subscriptionMin,\n                subscriptionMax,\n                dateFrom,\n                dateTo,\n                sortBy,\n                sortOrder,\n                page,\n                limit,\n                includeAnalytics,\n                includePredictions\n            });\n        } else {\n            // Perform text search\n            searchResults = await performTextSearch({\n                query,\n                type,\n                status,\n                sector,\n                registrar,\n                minPrice,\n                maxPrice,\n                minIssueSize,\n                maxIssueSize,\n                minGMP,\n                maxGMP,\n                subscriptionMin,\n                subscriptionMax,\n                dateFrom,\n                dateTo,\n                sortBy,\n                sortOrder,\n                page,\n                limit,\n                fuzzy,\n                highlight,\n                includeAnalytics,\n                includePredictions,\n                advanced\n            });\n        }\n        // Generate search suggestions if requested\n        let searchSuggestions = [];\n        if (suggestions && query.length >= 2) {\n            searchSuggestions = await generateSearchSuggestions(query, {\n                type,\n                status,\n                sector,\n                limit: 10\n            });\n        }\n        // Generate search analytics\n        const searchAnalytics = await generateSearchAnalytics(query, searchResults.data);\n        // Build comprehensive response\n        const response = {\n            success: true,\n            query: {\n                original: query,\n                processed: processSearchQuery(query),\n                type,\n                fuzzy,\n                advanced\n            },\n            results: searchResults.data,\n            pagination: searchResults.pagination,\n            suggestions: searchSuggestions,\n            analytics: searchAnalytics,\n            filters: {\n                applied: getAppliedFilters({\n                    status,\n                    sector,\n                    registrar,\n                    minPrice,\n                    maxPrice,\n                    minIssueSize,\n                    maxIssueSize,\n                    minGMP,\n                    maxGMP,\n                    subscriptionMin,\n                    subscriptionMax,\n                    dateFrom,\n                    dateTo\n                }),\n                available: await getAvailableFilters(searchResults.data)\n            },\n            sorting: {\n                sortBy,\n                sortOrder,\n                options: getSortingOptions()\n            },\n            metadata: {\n                searchTime: Date.now() - (searchResults.startTime || Date.now()),\n                totalResults: searchResults.pagination.totalCount,\n                hasMore: searchResults.pagination.hasNextPage,\n                relevanceScoring: query.length > 0,\n                highlighting: highlight && query.length > 0\n            },\n            timestamp: new Date().toISOString()\n        };\n        // Cache response for 5 minutes\n        await _lib_cache_js__WEBPACK_IMPORTED_MODULE_2__.cache.set(cacheKey, response, 300);\n        // Log search for analytics\n        logSearchQuery(request, {\n            query,\n            type,\n            resultCount: searchResults.data.length,\n            filters: response.filters.applied\n        });\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json(response);\n    } catch (error) {\n        console.error(\"GET /api/ipos/search error:\", error);\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n            success: false,\n            error: \"Search failed\",\n            message:  true ? error.message : 0,\n            timestamp: new Date().toISOString()\n        }, {\n            status: 500\n        });\n    }\n}\n// Advanced search with query processing and ML-powered ranking\nasync function POST(request) {\n    try {\n        const body = await request.json();\n        const { queries, searchType = \"semantic\", rankingModel = \"relevance\", boost = {}, filters = {}, options = {} } = body;\n        // Validate complex search request\n        if (!queries || !Array.isArray(queries) && typeof queries !== \"string\") {\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                success: false,\n                error: \"Queries parameter is required\"\n            }, {\n                status: 400\n            });\n        }\n        // Process multiple queries or complex query\n        const searchQueries = Array.isArray(queries) ? queries : [\n            queries\n        ];\n        const searchResults = await performAdvancedSearch({\n            queries: searchQueries,\n            searchType,\n            rankingModel,\n            boost,\n            filters,\n            options\n        });\n        // Generate advanced analytics\n        const advancedAnalytics = await generateAdvancedSearchAnalytics(searchQueries, searchResults);\n        const response = {\n            success: true,\n            searchType,\n            rankingModel,\n            queries: searchQueries,\n            results: searchResults.data,\n            pagination: searchResults.pagination,\n            analytics: advancedAnalytics,\n            relevanceScores: searchResults.relevanceScores,\n            queryProcessing: {\n                normalizedQueries: searchQueries.map((q)=>processSearchQuery(q)),\n                semanticAnalysis: searchType === \"semantic\" ? await performSemanticAnalysis(searchQueries) : null,\n                entityExtraction: await extractEntities(searchQueries)\n            },\n            recommendations: await generateSearchRecommendations(searchResults.data, searchQueries),\n            timestamp: new Date().toISOString()\n        };\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json(response);\n    } catch (error) {\n        console.error(\"POST /api/ipos/search error:\", error);\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n            success: false,\n            error: \"Advanced search failed\",\n            message:  true ? error.message : 0,\n            timestamp: new Date().toISOString()\n        }, {\n            status: 500\n        });\n    }\n}\n// Perform filtered search without text query\nasync function performFilteredSearch(params) {\n    const startTime = Date.now();\n    try {\n        const { status, sector, registrar, minPrice, maxPrice, minIssueSize, maxIssueSize, minGMP, maxGMP, subscriptionMin, subscriptionMax, dateFrom, dateTo, sortBy, sortOrder, page, limit, includeAnalytics, includePredictions } = params;\n        // Build where clause\n        const whereClause = {\n            isActive: true\n        };\n        // Apply basic filters\n        if (status && status !== \"all\") {\n            whereClause.status = status.includes(\",\") ? {\n                in: status.split(\",\")\n            } : status;\n        }\n        if (sector) {\n            whereClause.sector = sector.includes(\",\") ? {\n                in: sector.split(\",\")\n            } : {\n                contains: sector,\n                mode: \"insensitive\"\n            };\n        }\n        if (registrar) {\n            whereClause.registrar = {\n                contains: registrar,\n                mode: \"insensitive\"\n            };\n        }\n        // Price range filters\n        if (minPrice && !isNaN(minPrice)) {\n            whereClause.maxPrice = {\n                gte: minPrice\n            };\n        }\n        if (maxPrice && !isNaN(maxPrice)) {\n            whereClause.minPrice = {\n                lte: maxPrice\n            };\n        }\n        // Issue size filters\n        if (minIssueSize && !isNaN(minIssueSize)) {\n            whereClause.issueSize = {\n                ...whereClause.issueSize || {},\n                gte: minIssueSize * 10000000\n            };\n        }\n        if (maxIssueSize && !isNaN(maxIssueSize)) {\n            whereClause.issueSize = {\n                ...whereClause.issueSize || {},\n                lte: maxIssueSize * 10000000\n            };\n        }\n        // Date filters\n        if (dateFrom || dateTo) {\n            const dateFilter = {};\n            if (dateFrom) dateFilter.gte = new Date(dateFrom);\n            if (dateTo) dateFilter.lte = new Date(dateTo);\n            whereClause.openDate = dateFilter;\n        }\n        // Include clause for related data\n        // Add this at the beginning of your performFilteredSearch function\n        const includeClause = {\n            gmpData: {\n                orderBy: {\n                    timestamp: \"desc\"\n                },\n                take: 5\n            },\n            subscriptionData: {\n                orderBy: {\n                    timestamp: \"desc\"\n                },\n                take: 5\n            },\n            allotmentData: true,\n            analytics: true,\n            watchlists: true,\n            alerts: true\n        };\n        // Add GMP data for GMP-based filtering\n        if (minGMP || maxGMP || subscriptionMin || subscriptionMax) {\n            includeClause.gmp = {\n                orderBy: {\n                    timestamp: \"desc\"\n                },\n                take: 1\n            };\n            includeClause.subscription = {\n                orderBy: {\n                    timestamp: \"desc\"\n                },\n                take: 5\n            };\n        }\n        if (includeAnalytics) {\n            includeClause.analytics = true;\n        }\n        // Build order clause\n        const orderBy = buildOrderClause(sortBy, sortOrder);\n        // Calculate pagination\n        const offset = (page - 1) * limit;\n        // Execute query\n        const [ipos, totalCount] = await Promise.all([\n            _lib_db_js__WEBPACK_IMPORTED_MODULE_1__.prisma.iPO.findMany({\n                where: whereClause,\n                include: includeClause,\n                orderBy,\n                skip: offset,\n                take: limit\n            }),\n            _lib_db_js__WEBPACK_IMPORTED_MODULE_1__.prisma.iPO.count({\n                where: whereClause\n            })\n        ]);\n        // Post-process results for GMP and subscription filters\n        let filteredResults = ipos;\n        if (minGMP || maxGMP || subscriptionMin || subscriptionMax) {\n            filteredResults = await applyAdvancedFilters(ipos, {\n                minGMP,\n                maxGMP,\n                subscriptionMin,\n                subscriptionMax\n            });\n        }\n        // Process results\n        const processedResults = await Promise.all(filteredResults.map((ipo)=>processSearchResult(ipo, {\n                includeAnalytics,\n                includePredictions,\n                highlight: false,\n                relevanceScore: 1.0\n            })));\n        return {\n            data: processedResults,\n            pagination: {\n                currentPage: page,\n                totalPages: Math.ceil(totalCount / limit),\n                totalCount,\n                limit,\n                hasNextPage: page < Math.ceil(totalCount / limit),\n                hasPrevPage: page > 1\n            },\n            startTime\n        };\n    } catch (error) {\n        console.error(\"Error in performFilteredSearch:\", error);\n        throw error;\n    }\n}\n// Perform text-based search with relevance scoring\nasync function performTextSearch(params) {\n    const startTime = Date.now();\n    try {\n        const { query, type, status, sector, registrar, minPrice, maxPrice, minIssueSize, maxIssueSize, minGMP, maxGMP, subscriptionMin, subscriptionMax, dateFrom, dateTo, sortBy, sortOrder, page, limit, fuzzy, highlight, includeAnalytics, includePredictions, advanced } = params;\n        // Process and normalize query\n        const processedQuery = processSearchQuery(query);\n        const searchTerms = extractSearchTerms(processedQuery);\n        // Build base where clause\n        const baseWhereClause = {\n            isActive: true\n        };\n        // Apply additional filters\n        applyAdditionalFilters(baseWhereClause, {\n            status,\n            sector,\n            registrar,\n            minPrice,\n            maxPrice,\n            minIssueSize,\n            maxIssueSize,\n            dateFrom,\n            dateTo\n        });\n        // Build search conditions based on search type\n        let searchConditions = [];\n        switch(type){\n            case \"symbol\":\n                searchConditions = buildSymbolSearch(searchTerms, fuzzy);\n                break;\n            case \"name\":\n                searchConditions = buildNameSearch(searchTerms, fuzzy);\n                break;\n            case \"sector\":\n                searchConditions = buildSectorSearch(searchTerms, fuzzy);\n                break;\n            case \"registrar\":\n                searchConditions = buildRegistrarSearch(searchTerms, fuzzy);\n                break;\n            default:\n                searchConditions = buildUniversalSearch(searchTerms, fuzzy);\n        }\n        // Combine base filters with search conditions\n        const whereClause = {\n            ...baseWhereClause,\n            AND: [\n                {\n                    OR: searchConditions\n                }\n            ]\n        };\n        // Include related data\n        const includeClause = {\n            categories: true,\n            gmp: {\n                orderBy: {\n                    timestamp: \"desc\"\n                },\n                take: 5\n            },\n            subscription: {\n                orderBy: {\n                    timestamp: \"desc\"\n                },\n                take: 5\n            }\n        };\n        if (includeAnalytics) {\n            includeClause.analytics = true;\n        }\n        // Execute search\n        const [searchResults, totalCount] = await Promise.all([\n            _lib_db_js__WEBPACK_IMPORTED_MODULE_1__.prisma.iPO.findMany({\n                where: whereClause,\n                include: includeClause\n            }),\n            _lib_db_js__WEBPACK_IMPORTED_MODULE_1__.prisma.iPO.count({\n                where: whereClause\n            })\n        ]);\n        // Apply advanced filters if needed\n        let filteredResults = searchResults;\n        if (minGMP || maxGMP || subscriptionMin || subscriptionMax) {\n            filteredResults = await applyAdvancedFilters(searchResults, {\n                minGMP,\n                maxGMP,\n                subscriptionMin,\n                subscriptionMax\n            });\n        }\n        // Calculate relevance scores\n        const scoredResults = filteredResults.map((ipo)=>{\n            const relevanceScore = calculateRelevanceScore(ipo, searchTerms, type);\n            return {\n                ...ipo,\n                relevanceScore\n            };\n        });\n        // Sort results\n        let sortedResults;\n        if (sortBy === \"relevance\") {\n            sortedResults = scoredResults.sort((a, b)=>sortOrder === \"desc\" ? b.relevanceScore - a.relevanceScore : a.relevanceScore - b.relevanceScore);\n        } else {\n            const orderBy = buildOrderClause(sortBy, sortOrder);\n            sortedResults = sortResults(scoredResults, orderBy);\n        }\n        // Apply pagination\n        const offset = (page - 1) * limit;\n        const paginatedResults = sortedResults.slice(offset, offset + limit);\n        // Process final results\n        const processedResults = await Promise.all(paginatedResults.map((ipo)=>processSearchResult(ipo, {\n                includeAnalytics,\n                includePredictions,\n                highlight,\n                searchTerms,\n                relevanceScore: ipo.relevanceScore\n            })));\n        return {\n            data: processedResults,\n            pagination: {\n                currentPage: page,\n                totalPages: Math.ceil(filteredResults.length / limit),\n                totalCount: filteredResults.length,\n                originalCount: totalCount,\n                limit,\n                hasNextPage: page < Math.ceil(filteredResults.length / limit),\n                hasPrevPage: page > 1\n            },\n            startTime\n        };\n    } catch (error) {\n        console.error(\"Error in performTextSearch:\", error);\n        throw error;\n    }\n}\n// Perform advanced search with ML ranking\nasync function performAdvancedSearch(params) {\n    const startTime = Date.now();\n    try {\n        const { queries, searchType, rankingModel, boost, filters, options } = params;\n        // Process all queries\n        const processedQueries = queries.map((q)=>processSearchQuery(q));\n        const allSearchTerms = processedQueries.flatMap((q)=>extractSearchTerms(q));\n        const uniqueTerms = [\n            ...new Set(allSearchTerms)\n        ];\n        // Build advanced search conditions\n        const searchConditions = buildAdvancedSearchConditions(processedQueries, searchType);\n        // Apply filters\n        const whereClause = {\n            isActive: true,\n            AND: [\n                {\n                    OR: searchConditions\n                },\n                ...buildAdvancedFilters(filters)\n            ]\n        };\n        // Execute search with comprehensive includes\n        const searchResults = await _lib_db_js__WEBPACK_IMPORTED_MODULE_1__.prisma.iPO.findMany({\n            where: whereClause,\n            include: {\n                categories: true,\n                gmp: {\n                    orderBy: {\n                        timestamp: \"desc\"\n                    },\n                    take: 10\n                },\n                subscription: {\n                    orderBy: {\n                        timestamp: \"desc\"\n                    },\n                    take: 10\n                },\n                analytics: true,\n                allotmentResults: {\n                    take: 5,\n                    select: {\n                        category: true,\n                        allotmentStatus: true,\n                        allottedQuantity: true\n                    }\n                }\n            }\n        });\n        // Apply ML-powered ranking\n        const rankedResults = await applyMLRanking(searchResults, {\n            queries: processedQueries,\n            rankingModel,\n            boost,\n            searchType\n        });\n        // Generate relevance scores\n        const relevanceScores = rankedResults.map((ipo, index)=>({\n                ipoId: ipo.id,\n                symbol: ipo.symbol,\n                score: ipo.mlScore || 1.0,\n                rank: index + 1,\n                factors: ipo.rankingFactors || {}\n            }));\n        // Apply pagination\n        const page = options.page || 1;\n        const limit = Math.min(options.limit || 20, 100);\n        const offset = (page - 1) * limit;\n        const paginatedResults = rankedResults.slice(offset, offset + limit);\n        // Process final results\n        const processedResults = await Promise.all(paginatedResults.map((ipo)=>processAdvancedSearchResult(ipo, {\n                queries: processedQueries,\n                searchType,\n                highlight: options.highlight !== false,\n                includeAnalytics: options.includeAnalytics === true,\n                includePredictions: options.includePredictions === true\n            })));\n        return {\n            data: processedResults,\n            pagination: {\n                currentPage: page,\n                totalPages: Math.ceil(rankedResults.length / limit),\n                totalCount: rankedResults.length,\n                limit,\n                hasNextPage: page < Math.ceil(rankedResults.length / limit),\n                hasPrevPage: page > 1\n            },\n            relevanceScores,\n            startTime\n        };\n    } catch (error) {\n        console.error(\"Error in performAdvancedSearch:\", error);\n        throw error;\n    }\n}\n// Process search query and normalize\nfunction processSearchQuery(query) {\n    if (!query || typeof query !== \"string\") return \"\";\n    return query.toLowerCase().trim().replace(/[^\\w\\s]/g, \" \") // Remove special characters\n    .replace(/\\s+/g, \" \") // Normalize whitespace\n    .trim();\n}\n// Extract search terms from processed query\nfunction extractSearchTerms(processedQuery) {\n    if (!processedQuery) return [];\n    const terms = processedQuery.split(\" \").filter((term)=>term.length >= 2);\n    // Add partial terms for fuzzy matching\n    const expandedTerms = [\n        ...terms\n    ];\n    terms.forEach((term)=>{\n        if (term.length >= 4) {\n            expandedTerms.push(term.substring(0, term.length - 1)); // Partial match\n        }\n    });\n    return [\n        ...new Set(expandedTerms)\n    ];\n}\n// Build search conditions for different types\nfunction buildSymbolSearch(searchTerms, fuzzy) {\n    const conditions = [];\n    searchTerms.forEach((term)=>{\n        if (fuzzy) {\n            conditions.push({\n                symbol: {\n                    contains: term,\n                    mode: \"insensitive\"\n                }\n            });\n        } else {\n            conditions.push({\n                symbol: {\n                    startsWith: term.toUpperCase()\n                }\n            });\n        }\n    });\n    return conditions;\n}\nfunction buildNameSearch(searchTerms, fuzzy) {\n    const conditions = [];\n    searchTerms.forEach((term)=>{\n        conditions.push({\n            name: {\n                contains: term,\n                mode: \"insensitive\"\n            }\n        });\n    });\n    return conditions;\n}\nfunction buildSectorSearch(searchTerms, fuzzy) {\n    const conditions = [];\n    searchTerms.forEach((term)=>{\n        conditions.push({\n            sector: {\n                contains: term,\n                mode: \"insensitive\"\n            }\n        });\n    });\n    return conditions;\n}\nfunction buildRegistrarSearch(searchTerms, fuzzy) {\n    const conditions = [];\n    searchTerms.forEach((term)=>{\n        conditions.push({\n            registrar: {\n                contains: term,\n                mode: \"insensitive\"\n            }\n        });\n    });\n    return conditions;\n}\nfunction buildUniversalSearch(searchTerms, fuzzy) {\n    const conditions = [];\n    searchTerms.forEach((term)=>{\n        conditions.push({\n            symbol: {\n                contains: term,\n                mode: \"insensitive\"\n            }\n        }, {\n            name: {\n                contains: term,\n                mode: \"insensitive\"\n            }\n        }, {\n            sector: {\n                contains: term,\n                mode: \"insensitive\"\n            }\n        }, {\n            registrar: {\n                contains: term,\n                mode: \"insensitive\"\n            }\n        });\n        // Add lead managers search\n        if (term.length >= 3) {\n            conditions.push({\n                leadManagers: {\n                    array_contains: [\n                        term\n                    ]\n                }\n            });\n        }\n    });\n    return conditions;\n}\n// Calculate relevance score for search results\nfunction calculateRelevanceScore(ipo, searchTerms, searchType) {\n    let score = 0;\n    const weights = {\n        symbol: 10,\n        name: 8,\n        sector: 5,\n        registrar: 3,\n        leadManagers: 2\n    };\n    searchTerms.forEach((term)=>{\n        const termRegex = new RegExp(term, \"i\");\n        // Symbol matching (highest weight)\n        if (ipo.symbol && termRegex.test(ipo.symbol)) {\n            score += weights.symbol;\n            if (ipo.symbol.toLowerCase().startsWith(term.toLowerCase())) {\n                score += weights.symbol * 0.5; // Bonus for prefix match\n            }\n        }\n        // Name matching\n        if (ipo.name && termRegex.test(ipo.name)) {\n            score += weights.name;\n            const nameWords = ipo.name.toLowerCase().split(\" \");\n            if (nameWords.some((word)=>word.startsWith(term.toLowerCase()))) {\n                score += weights.name * 0.3; // Bonus for word start match\n            }\n        }\n        // Sector matching\n        if (ipo.sector && termRegex.test(ipo.sector)) {\n            score += weights.sector;\n        }\n        // Registrar matching\n        if (ipo.registrar && termRegex.test(ipo.registrar)) {\n            score += weights.registrar;\n        }\n        // Lead managers matching\n        if (ipo.leadManagers && Array.isArray(ipo.leadManagers)) {\n            ipo.leadManagers.forEach((manager)=>{\n                if (termRegex.test(manager)) {\n                    score += weights.leadManagers;\n                }\n            });\n        }\n    });\n    // Apply search type boost\n    if (searchType !== \"all\") {\n        const typeBoosts = {\n            symbol: ipo.symbol ? 1.5 : 0.5,\n            name: ipo.name ? 1.3 : 0.7,\n            sector: ipo.sector ? 1.2 : 0.8,\n            registrar: ipo.registrar ? 1.1 : 0.9\n        };\n        score *= typeBoosts[searchType] || 1.0;\n    }\n    // Apply status boost (open IPOs get higher relevance)\n    const statusBoosts = {\n        open: 1.5,\n        upcoming: 1.2,\n        closed: 1.0,\n        listed: 0.8\n    };\n    score *= statusBoosts[ipo.status] || 1.0;\n    return Math.round(score * 100) / 100;\n}\n// Apply additional filters to where clause\nfunction applyAdditionalFilters(whereClause, filters) {\n    const { status, sector, registrar, minPrice, maxPrice, minIssueSize, maxIssueSize, dateFrom, dateTo } = filters;\n    if (status && status !== \"all\") {\n        whereClause.status = status.includes(\",\") ? {\n            in: status.split(\",\")\n        } : status;\n    }\n    if (sector) {\n        whereClause.sector = sector.includes(\",\") ? {\n            in: sector.split(\",\")\n        } : {\n            contains: sector,\n            mode: \"insensitive\"\n        };\n    }\n    if (registrar) {\n        whereClause.registrar = {\n            contains: registrar,\n            mode: \"insensitive\"\n        };\n    }\n    if (minPrice && !isNaN(minPrice)) {\n        whereClause.maxPrice = {\n            gte: minPrice\n        };\n    }\n    if (maxPrice && !isNaN(maxPrice)) {\n        whereClause.minPrice = {\n            lte: maxPrice\n        };\n    }\n    if (minIssueSize && !isNaN(minIssueSize)) {\n        whereClause.issueSize = {\n            ...whereClause.issueSize || {},\n            gte: minIssueSize * 10000000\n        };\n    }\n    if (maxIssueSize && !isNaN(maxIssueSize)) {\n        whereClause.issueSize = {\n            ...whereClause.issueSize || {},\n            lte: maxIssueSize * 10000000\n        };\n    }\n    if (dateFrom || dateTo) {\n        const dateFilter = {};\n        if (dateFrom) dateFilter.gte = new Date(dateFrom);\n        if (dateTo) dateFilter.lte = new Date(dateTo);\n        whereClause.openDate = dateFilter;\n    }\n}\n// Apply advanced filters (GMP, subscription)\nasync function applyAdvancedFilters(ipos, filters) {\n    const { minGMP, maxGMP, subscriptionMin, subscriptionMax } = filters;\n    return ipos.filter((ipo)=>{\n        // GMP filtering\n        if (minGMP || maxGMP) {\n            const latestGMP = ipo.gmp?.[0];\n            if (!latestGMP) return false;\n            if (minGMP && latestGMP.value < minGMP) return false;\n            if (maxGMP && latestGMP.value > maxGMP) return false;\n        }\n        // Subscription filtering\n        if (subscriptionMin || subscriptionMax) {\n            if (!ipo.subscription || ipo.subscription.length === 0) return false;\n            const maxSubscription = Math.max(...ipo.subscription.map((s)=>s.subscriptionRatio));\n            if (subscriptionMin && maxSubscription < subscriptionMin) return false;\n            if (subscriptionMax && maxSubscription > subscriptionMax) return false;\n        }\n        return true;\n    });\n}\n// Build order clause for sorting\nfunction buildOrderClause(sortBy, sortOrder) {\n    const orderDirection = sortOrder === \"asc\" ? \"asc\" : \"desc\";\n    switch(sortBy){\n        case \"openDate\":\n            return {\n                openDate: orderDirection\n            };\n        case \"closeDate\":\n            return {\n                closeDate: orderDirection\n            };\n        case \"listingDate\":\n            return {\n                listingDate: orderDirection\n            };\n        case \"issueSize\":\n            return {\n                issueSize: orderDirection\n            };\n        case \"maxPrice\":\n            return {\n                maxPrice: orderDirection\n            };\n        case \"name\":\n            return {\n                name: orderDirection\n            };\n        case \"symbol\":\n            return {\n                symbol: orderDirection\n            };\n        case \"status\":\n            return {\n                status: orderDirection\n            };\n        case \"sector\":\n            return {\n                sector: orderDirection\n            };\n        case \"createdAt\":\n            return {\n                createdAt: orderDirection\n            };\n        default:\n            return {\n                updatedAt: \"desc\"\n            };\n    }\n}\n// Sort results manually (for relevance-based sorting)\nfunction sortResults(results, orderBy) {\n    if (!orderBy || typeof orderBy !== \"object\") return results;\n    const [field, direction] = Object.entries(orderBy)[0];\n    return results.sort((a, b)=>{\n        let aVal = a[field];\n        let bVal = b[field];\n        // Handle different data types\n        if (aVal instanceof Date) aVal = aVal.getTime();\n        if (bVal instanceof Date) bVal = bVal.getTime();\n        if (typeof aVal === \"string\") aVal = aVal.toLowerCase();\n        if (typeof bVal === \"string\") bVal = bVal.toLowerCase();\n        // Handle null/undefined values\n        if (aVal == null && bVal == null) return 0;\n        if (aVal == null) return direction === \"asc\" ? -1 : 1;\n        if (bVal == null) return direction === \"asc\" ? 1 : -1;\n        // Compare values\n        if (aVal < bVal) return direction === \"asc\" ? -1 : 1;\n        if (aVal > bVal) return direction === \"asc\" ? 1 : -1;\n        return 0;\n    });\n}\n// Process search result with highlighting and enhancements\nasync function processSearchResult(ipo, options) {\n    const { includeAnalytics, includePredictions, highlight, searchTerms, relevanceScore } = options;\n    // Base result\n    const result = {\n        id: ipo.id,\n        symbol: ipo.symbol,\n        name: ipo.name,\n        sector: ipo.sector,\n        status: ipo.status,\n        openDate: ipo.openDate,\n        closeDate: ipo.closeDate,\n        listingDate: ipo.listingDate,\n        minPrice: ipo.minPrice,\n        maxPrice: ipo.maxPrice,\n        lotSize: ipo.lotSize,\n        issueSize: ipo.issueSize?.toString(),\n        registrar: ipo.registrar,\n        leadManagers: ipo.leadManagers,\n        categories: ipo.categories,\n        relevanceScore,\n        // Current metrics\n        currentMetrics: {\n            gmp: ipo.gmp?.[0] ? {\n                value: ipo.gmp[0].value,\n                percentage: ipo.gmp[0].percentage,\n                timestamp: ipo.gmp[0].timestamp\n            } : null,\n            subscription: getLatestSubscription(ipo.subscription)\n        }\n    };\n    // Add highlighting if requested\n    if (highlight && searchTerms && searchTerms.length > 0) {\n        result.highlights = generateHighlights(ipo, searchTerms);\n    }\n    // Add analytics if requested\n    if (includeAnalytics && ipo.analytics) {\n        result.analytics = {\n            riskScore: ipo.analytics.riskScore,\n            predictedListingGain: ipo.analytics.predictedListingGain,\n            avgGMP: ipo.analytics.avgGMP,\n            finalSubscription: ipo.analytics.finalSubscription\n        };\n    }\n    // Add predictions if requested\n    if (includePredictions) {\n        try {\n            const [listingGain, marketSentiment] = await Promise.allSettled([\n                _services_prediction_service_js__WEBPACK_IMPORTED_MODULE_4__.predictionService.predictListingGain(ipo.id),\n                _services_prediction_service_js__WEBPACK_IMPORTED_MODULE_4__.predictionService.predictMarketSentiment(ipo.id)\n            ]);\n            result.predictions = {\n                listingGain: listingGain.status === \"fulfilled\" ? listingGain.value : null,\n                marketSentiment: marketSentiment.status === \"fulfilled\" ? marketSentiment.value : null\n            };\n        } catch (error) {\n            result.predictions = null;\n        }\n    }\n    return result;\n}\n// Generate text highlights for search terms\nfunction generateHighlights(ipo, searchTerms) {\n    const highlights = {};\n    const highlightText = (text, terms)=>{\n        if (!text || !terms.length) return text;\n        let highlightedText = text;\n        terms.forEach((term)=>{\n            const regex = new RegExp(`(${term})`, \"gi\");\n            highlightedText = highlightedText.replace(regex, \"<mark>$1</mark>\");\n        });\n        return highlightedText;\n    };\n    // Highlight different fields\n    if (ipo.symbol) {\n        const highlighted = highlightText(ipo.symbol, searchTerms);\n        if (highlighted !== ipo.symbol) {\n            highlights.symbol = highlighted;\n        }\n    }\n    if (ipo.name) {\n        const highlighted = highlightText(ipo.name, searchTerms);\n        if (highlighted !== ipo.name) {\n            highlights.name = highlighted;\n        }\n    }\n    if (ipo.sector) {\n        const highlighted = highlightText(ipo.sector, searchTerms);\n        if (highlighted !== ipo.sector) {\n            highlights.sector = highlighted;\n        }\n    }\n    if (ipo.registrar) {\n        const highlighted = highlightText(ipo.registrar, searchTerms);\n        if (highlighted !== ipo.registrar) {\n            highlights.registrar = highlighted;\n        }\n    }\n    return highlights;\n}\n// Get latest subscription data\nfunction getLatestSubscription(subscriptionData) {\n    if (!subscriptionData || subscriptionData.length === 0) return null;\n    const latest = subscriptionData.reduce((latest, current)=>{\n        return current.timestamp > latest.timestamp ? current : latest;\n    });\n    return {\n        category: latest.category,\n        subscriptionRatio: latest.subscriptionRatio,\n        quantity: latest.quantity?.toString(),\n        bidCount: latest.bidCount,\n        timestamp: latest.timestamp\n    };\n}\n// Generate search suggestions\nasync function generateSearchSuggestions(query, options) {\n    try {\n        const { type, status, sector, limit } = options;\n        const processedQuery = processSearchQuery(query);\n        if (processedQuery.length < 2) return [];\n        // Get suggestions from different sources\n        const suggestions = [];\n        // Symbol suggestions\n        const symbolSuggestions = await _lib_db_js__WEBPACK_IMPORTED_MODULE_1__.prisma.iPO.findMany({\n            where: {\n                isActive: true,\n                symbol: {\n                    contains: processedQuery.toUpperCase()\n                },\n                ...status && status !== \"all\" ? {\n                    status\n                } : {}\n            },\n            select: {\n                symbol: true,\n                name: true\n            },\n            take: 5\n        });\n        symbolSuggestions.forEach((ipo)=>{\n            suggestions.push({\n                type: \"symbol\",\n                value: ipo.symbol,\n                display: `${ipo.symbol} - ${ipo.name}`,\n                category: \"Symbol\"\n            });\n        });\n        // Name suggestions\n        const nameSuggestions = await _lib_db_js__WEBPACK_IMPORTED_MODULE_1__.prisma.iPO.findMany({\n            where: {\n                isActive: true,\n                name: {\n                    contains: processedQuery,\n                    mode: \"insensitive\"\n                },\n                ...status && status !== \"all\" ? {\n                    status\n                } : {}\n            },\n            select: {\n                symbol: true,\n                name: true\n            },\n            take: 5\n        });\n        nameSuggestions.forEach((ipo)=>{\n            if (!suggestions.some((s)=>s.value === ipo.symbol)) {\n                suggestions.push({\n                    type: \"name\",\n                    value: ipo.name,\n                    display: `${ipo.name} (${ipo.symbol})`,\n                    category: \"Company\"\n                });\n            }\n        });\n        // Sector suggestions\n        const sectorSuggestions = await _lib_db_js__WEBPACK_IMPORTED_MODULE_1__.prisma.iPO.groupBy({\n            by: [\n                \"sector\"\n            ],\n            where: {\n                isActive: true,\n                sector: {\n                    contains: processedQuery,\n                    mode: \"insensitive\"\n                },\n                ...status && status !== \"all\" ? {\n                    status\n                } : {}\n            },\n            _count: {\n                sector: true\n            },\n            take: 3\n        });\n        sectorSuggestions.forEach((item)=>{\n            if (item.sector) {\n                suggestions.push({\n                    type: \"sector\",\n                    value: item.sector,\n                    display: `${item.sector} (${item._count.sector} IPOs)`,\n                    category: \"Sector\"\n                });\n            }\n        });\n        // Registrar suggestions\n        const registrarSuggestions = await _lib_db_js__WEBPACK_IMPORTED_MODULE_1__.prisma.iPO.groupBy({\n            by: [\n                \"registrar\"\n            ],\n            where: {\n                isActive: true,\n                registrar: {\n                    contains: processedQuery,\n                    mode: \"insensitive\"\n                },\n                ...status && status !== \"all\" ? {\n                    status\n                } : {}\n            },\n            _count: {\n                registrar: true\n            },\n            take: 3\n        });\n        registrarSuggestions.forEach((item)=>{\n            if (item.registrar) {\n                suggestions.push({\n                    type: \"registrar\",\n                    value: item.registrar,\n                    display: `${item.registrar} (${item._count.registrar} IPOs)`,\n                    category: \"Registrar\"\n                });\n            }\n        });\n        // Sort by relevance and limit\n        return suggestions.sort((a, b)=>{\n            const typeOrder = {\n                symbol: 0,\n                name: 1,\n                sector: 2,\n                registrar: 3\n            };\n            return typeOrder[a.type] - typeOrder[b.type];\n        }).slice(0, limit);\n    } catch (error) {\n        console.error(\"Error generating search suggestions:\", error);\n        return [];\n    }\n}\n// Generate search analytics\nasync function generateSearchAnalytics(query, results) {\n    try {\n        const analytics = {\n            query: {\n                length: query.length,\n                wordCount: query.split(\" \").filter((w)=>w.length > 0).length,\n                hasNumbers: /\\d/.test(query),\n                hasSpecialChars: /[^a-zA-Z0-9\\s]/.test(query)\n            },\n            results: {\n                total: results.length,\n                byStatus: {},\n                bySector: {},\n                relevanceDistribution: {\n                    high: 0,\n                    medium: 0,\n                    low: 0\n                }\n            },\n            performance: {\n                searchTime: Date.now() % 1000,\n                cacheHit: false\n            }\n        };\n        // Analyze results\n        if (results.length > 0) {\n            const maxRelevance = Math.max(...results.map((r)=>r.relevanceScore || 0));\n            results.forEach((result)=>{\n                // Status distribution\n                analytics.results.byStatus[result.status] = (analytics.results.byStatus[result.status] || 0) + 1;\n                // Sector distribution\n                if (result.sector) {\n                    analytics.results.bySector[result.sector] = (analytics.results.bySector[result.sector] || 0) + 1;\n                }\n                // Relevance distribution\n                const relevancePercent = maxRelevance > 0 ? (result.relevanceScore || 0) / maxRelevance : 0;\n                if (relevancePercent > 0.75) {\n                    analytics.results.relevanceDistribution.high++;\n                } else if (relevancePercent > 0.25) {\n                    analytics.results.relevanceDistribution.medium++;\n                } else {\n                    analytics.results.relevanceDistribution.low++;\n                }\n            });\n        }\n        return analytics;\n    } catch (error) {\n        console.error(\"Error generating search analytics:\", error);\n        return {\n            error: \"Analytics generation failed\"\n        };\n    }\n}\n// Get applied filters summary\nfunction getAppliedFilters(filters) {\n    const applied = [];\n    Object.entries(filters).forEach(([key, value])=>{\n        if (value !== null && value !== undefined && value !== \"\") {\n            applied.push({\n                type: key,\n                value,\n                display: formatFilterDisplay(key, value)\n            });\n        }\n    });\n    return applied;\n}\n// Get available filters based on current results\nasync function getAvailableFilters(results) {\n    const available = {\n        status: {},\n        sector: {},\n        registrar: {},\n        priceRange: {\n            min: null,\n            max: null\n        },\n        issueSizeRange: {\n            min: null,\n            max: null\n        }\n    };\n    results.forEach((result)=>{\n        // Status options\n        available.status[result.status] = (available.status[result.status] || 0) + 1;\n        // Sector options\n        if (result.sector) {\n            available.sector[result.sector] = (available.sector[result.sector] || 0) + 1;\n        }\n        // Registrar options\n        if (result.registrar) {\n            available.registrar[result.registrar] = (available.registrar[result.registrar] || 0) + 1;\n        }\n        // Price range\n        if (result.minPrice) {\n            available.priceRange.min = available.priceRange.min ? Math.min(available.priceRange.min, result.minPrice) : result.minPrice;\n        }\n        if (result.maxPrice) {\n            available.priceRange.max = available.priceRange.max ? Math.max(available.priceRange.max, result.maxPrice) : result.maxPrice;\n        }\n        // Issue size range\n        if (result.issueSize) {\n            const sizeInCrores = parseInt(result.issueSize) / 10000000;\n            available.issueSizeRange.min = available.issueSizeRange.min ? Math.min(available.issueSizeRange.min, sizeInCrores) : sizeInCrores;\n            available.issueSizeRange.max = available.issueSizeRange.max ? Math.max(available.issueSizeRange.max, sizeInCrores) : sizeInCrores;\n        }\n    });\n    return available;\n}\n// Get sorting options\nfunction getSortingOptions() {\n    return [\n        {\n            value: \"relevance\",\n            label: \"Relevance\",\n            description: \"Best match first\"\n        },\n        {\n            value: \"openDate\",\n            label: \"Open Date\",\n            description: \"Sort by IPO opening date\"\n        },\n        {\n            value: \"closeDate\",\n            label: \"Close Date\",\n            description: \"Sort by IPO closing date\"\n        },\n        {\n            value: \"issueSize\",\n            label: \"Issue Size\",\n            description: \"Sort by IPO issue size\"\n        },\n        {\n            value: \"maxPrice\",\n            label: \"Price\",\n            description: \"Sort by maximum price\"\n        },\n        {\n            value: \"name\",\n            label: \"Company Name\",\n            description: \"Alphabetical by company name\"\n        },\n        {\n            value: \"symbol\",\n            label: \"Symbol\",\n            description: \"Alphabetical by symbol\"\n        },\n        {\n            value: \"status\",\n            label: \"Status\",\n            description: \"Group by IPO status\"\n        },\n        {\n            value: \"sector\",\n            label: \"Sector\",\n            description: \"Group by sector\"\n        }\n    ];\n}\n// Format filter display text\nfunction formatFilterDisplay(key, value) {\n    switch(key){\n        case \"minPrice\":\n            return `Min Price: ₹${value}`;\n        case \"maxPrice\":\n            return `Max Price: ₹${value}`;\n        case \"minIssueSize\":\n            return `Min Issue Size: ₹${value} Cr`;\n        case \"maxIssueSize\":\n            return `Max Issue Size: ₹${value} Cr`;\n        case \"minGMP\":\n            return `Min GMP: ₹${value}`;\n        case \"maxGMP\":\n            return `Max GMP: ₹${value}`;\n        case \"subscriptionMin\":\n            return `Min Subscription: ${value}x`;\n        case \"subscriptionMax\":\n            return `Max Subscription: ${value}x`;\n        case \"dateFrom\":\n            return `From: ${new Date(value).toLocaleDateString()}`;\n        case \"dateTo\":\n            return `To: ${new Date(value).toLocaleDateString()}`;\n        default:\n            return `${key}: ${value}`;\n    }\n}\n// Advanced search functions (ML-powered)\nasync function buildAdvancedSearchConditions(queries, searchType) {\n    // Implementation would depend on the search type\n    const conditions = [];\n    queries.forEach((query)=>{\n        const terms = extractSearchTerms(query);\n        if (searchType === \"semantic\") {\n            // Add semantic search conditions\n            conditions.push(...buildSemanticSearch(terms));\n        } else {\n            // Add traditional search conditions\n            conditions.push(...buildUniversalSearch(terms, true));\n        }\n    });\n    return conditions;\n}\nfunction buildSemanticSearch(terms) {\n    // Mock semantic search - in production, this would use NLP models\n    const semanticConditions = [];\n    terms.forEach((term)=>{\n        // Add related terms based on semantic similarity\n        const relatedTerms = getSemanticallySimilarTerms(term);\n        relatedTerms.forEach((relatedTerm)=>{\n            semanticConditions.push({\n                name: {\n                    contains: relatedTerm,\n                    mode: \"insensitive\"\n                }\n            }, {\n                sector: {\n                    contains: relatedTerm,\n                    mode: \"insensitive\"\n                }\n            });\n        });\n    });\n    return semanticConditions;\n}\nfunction getSemanticallySimilarTerms(term) {\n    // Mock semantic similarity - in production, use word embeddings\n    const synonyms = {\n        tech: [\n            \"technology\",\n            \"software\",\n            \"digital\",\n            \"IT\"\n        ],\n        bank: [\n            \"banking\",\n            \"financial\",\n            \"finance\"\n        ],\n        pharma: [\n            \"pharmaceutical\",\n            \"drug\",\n            \"medicine\"\n        ],\n        auto: [\n            \"automobile\",\n            \"automotive\",\n            \"vehicle\"\n        ]\n    };\n    return synonyms[term.toLowerCase()] || [\n        term\n    ];\n}\nasync function applyMLRanking(results, params) {\n    // Mock ML ranking - in production, use trained models\n    return results.map((ipo, index)=>{\n        const mlScore = calculateMLScore(ipo, params);\n        return {\n            ...ipo,\n            mlScore,\n            rankingFactors: {\n                textRelevance: 0.7,\n                popularity: 0.2,\n                recency: 0.1\n            }\n        };\n    }).sort((a, b)=>b.mlScore - a.mlScore);\n}\nfunction calculateMLScore(ipo, params) {\n    // Mock ML scoring\n    let score = Math.random() * 100;\n    // Boost for exact matches\n    if (params.queries.some((q)=>ipo.symbol.toLowerCase().includes(q.toLowerCase()) || ipo.name.toLowerCase().includes(q.toLowerCase()))) {\n        score *= 1.5;\n    }\n    // Status boost\n    const statusBoosts = {\n        open: 1.3,\n        upcoming: 1.1,\n        closed: 1.0,\n        listed: 0.9\n    };\n    score *= statusBoosts[ipo.status] || 1.0;\n    return Math.round(score * 100) / 100;\n}\nfunction buildAdvancedFilters(filters) {\n    const conditions = [];\n    Object.entries(filters).forEach(([key, value])=>{\n        if (value !== null && value !== undefined) {\n            switch(key){\n                case \"status\":\n                    conditions.push({\n                        status: Array.isArray(value) ? {\n                            in: value\n                        } : value\n                    });\n                    break;\n                case \"sector\":\n                    conditions.push({\n                        sector: {\n                            in: Array.isArray(value) ? value : [\n                                value\n                            ]\n                        }\n                    });\n                    break;\n                case \"priceRange\":\n                    if (value.min) conditions.push({\n                        maxPrice: {\n                            gte: value.min\n                        }\n                    });\n                    if (value.max) conditions.push({\n                        minPrice: {\n                            lte: value.max\n                        }\n                    });\n                    break;\n            }\n        }\n    });\n    return conditions;\n}\nasync function performSemanticAnalysis(queries) {\n    // Mock semantic analysis\n    return {\n        entities: extractEntitiesFromQueries(queries),\n        intent: detectSearchIntent(queries),\n        sentiment: \"neutral\",\n        complexity: queries.reduce((sum, q)=>sum + q.split(\" \").length, 0) / queries.length\n    };\n}\nasync function extractEntities(queries) {\n    // Mock entity extraction\n    const entities = {\n        companies: [],\n        sectors: [],\n        dates: [],\n        amounts: []\n    };\n    queries.forEach((query)=>{\n        // Extract company names (mock)\n        if (query.includes(\"ltd\") || query.includes(\"limited\")) {\n            entities.companies.push(query);\n        }\n        // Extract sectors (mock)\n        const sectorKeywords = [\n            \"tech\",\n            \"bank\",\n            \"pharma\",\n            \"auto\"\n        ];\n        sectorKeywords.forEach((keyword)=>{\n            if (query.toLowerCase().includes(keyword)) {\n                entities.sectors.push(keyword);\n            }\n        });\n        // Extract dates (mock)\n        const datePattern = /\\d{4}-\\d{2}-\\d{2}/g;\n        const dates = query.match(datePattern);\n        if (dates) entities.dates.push(...dates);\n        // Extract amounts (mock)\n        const amountPattern = /₹?\\d+(?:,\\d+)*(?:\\.\\d+)?(?:\\s*(?:cr|crore|l|lakh))?/gi;\n        const amounts = query.match(amountPattern);\n        if (amounts) entities.amounts.push(...amounts);\n    });\n    return entities;\n}\nfunction extractEntitiesFromQueries(queries) {\n    return queries.flatMap((query)=>extractSearchTerms(query));\n}\nfunction detectSearchIntent(queries) {\n    // Mock intent detection\n    const query = queries.join(\" \").toLowerCase();\n    if (query.includes(\"when\") || query.includes(\"date\")) return \"temporal\";\n    if (query.includes(\"best\") || query.includes(\"good\")) return \"recommendation\";\n    if (query.includes(\"price\") || query.includes(\"₹\")) return \"financial\";\n    if (query.includes(\"compare\")) return \"comparison\";\n    return \"search\";\n}\nasync function generateAdvancedSearchAnalytics(queries, results) {\n    return {\n        queryComplexity: queries.reduce((sum, q)=>sum + q.split(\" \").length, 0) / queries.length,\n        resultDiversity: calculateResultDiversity(results.data),\n        confidence: 0.85,\n        processingTime: 150\n    };\n}\nfunction calculateResultDiversity(results) {\n    const sectors = new Set(results.map((r)=>r.sector).filter(Boolean));\n    const statuses = new Set(results.map((r)=>r.status));\n    return {\n        sectorDiversity: sectors.size / Math.max(results.length, 1),\n        statusDiversity: statuses.size / Math.max(results.length, 1),\n        overallDiversity: (sectors.size + statuses.size) / (2 * Math.max(results.length, 1))\n    };\n}\nasync function generateSearchRecommendations(results, queries) {\n    const recommendations = [];\n    if (results.length === 0) {\n        recommendations.push({\n            type: \"broaden_search\",\n            message: \"Try removing some filters or using broader search terms\",\n            action: \"modify_query\"\n        });\n    } else if (results.length > 50) {\n        recommendations.push({\n            type: \"narrow_search\",\n            message: \"Too many results. Try adding filters or being more specific\",\n            action: \"add_filters\"\n        });\n    }\n    // Sector-based recommendations\n    const sectors = [\n        ...new Set(results.map((r)=>r.sector).filter(Boolean))\n    ];\n    if (sectors.length === 1) {\n        recommendations.push({\n            type: \"explore_sectors\",\n            message: `All results are from ${sectors[0]}. Explore other sectors?`,\n            action: \"suggest_sectors\",\n            data: {\n                excludeSector: sectors[0]\n            }\n        });\n    }\n    return recommendations;\n}\nasync function processAdvancedSearchResult(ipo, options) {\n    const { queries, searchType, highlight, includeAnalytics, includePredictions } = options;\n    const result = await processSearchResult(ipo, {\n        includeAnalytics,\n        includePredictions,\n        highlight,\n        searchTerms: queries.flatMap((q)=>extractSearchTerms(q)),\n        relevanceScore: ipo.mlScore || 1.0\n    });\n    // Add advanced search specific data\n    result.mlScore = ipo.mlScore;\n    result.rankingFactors = ipo.rankingFactors;\n    result.searchType = searchType;\n    return result;\n}\n// Logging function\nfunction logSearchQuery(request, data) {\n    try {\n        // Log search analytics - non-blocking\n        setImmediate(()=>{\n            console.log(\"Search Query:\", {\n                timestamp: new Date().toISOString(),\n                ip: request.ip,\n                userAgent: request.headers.get(\"user-agent\"),\n                ...data\n            });\n        });\n    } catch (error) {\n    // Silent fail for logging\n    }\n}\n// Export configuration\nconst dynamic = \"force-dynamic\";\nconst runtime = \"nodejs\";\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q1hqUixRQUFRa1IsR0FBRyxDQUFDLGlCQUFpQjtnQkFDM0J0UixXQUFXLElBQUlwQyxPQUFPQyxXQUFXO2dCQUNqQzBULElBQUl4VyxRQUFRd1csRUFBRTtnQkFDZEMsV0FBV3pXLFFBQVEwVyxPQUFPLENBQUNyVyxHQUFHLENBQUM7Z0JBQy9CLEdBQUdrRCxJQUFJO1lBQ1Q7UUFDRjtJQUNGLEVBQUUsT0FBT2xCLE9BQU87SUFDZCwwQkFBMEI7SUFDNUI7QUFDRjtBQUVBLHVCQUF1QjtBQUNoQixNQUFNc1UsVUFBVSxnQkFBZ0I7QUFDaEMsTUFBTUMsVUFBVSxTQUFTIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaXBvLXRyYWNrZXIvLi9zcmMvYXBwL2FwaS9pcG9zL3JvdXRlLmpzPzRiMjkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTmV4dFJlcXVlc3QsIE5leHRSZXNwb25zZSB9IGZyb20gJ25leHQvc2VydmVyJztcclxuaW1wb3J0IHsgcHJpc21hIH0gZnJvbSAnLi4vLi4vLi4vbGliL2RiLmpzJztcclxuaW1wb3J0IHsgY2FjaGUgfSBmcm9tICcuLi8uLi8uLi9saWIvY2FjaGUuanMnO1xyXG5pbXBvcnQgeyBhbmFseXRpY3NTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vLi4vbGliL2FuYWx5dGljcy5qcyc7XHJcbmltcG9ydCB7IHByZWRpY3Rpb25TZXJ2aWNlIH0gZnJvbSAnLi4vLi4vLi4vc2VydmljZXMvcHJlZGljdGlvbi1zZXJ2aWNlLmpzJztcclxuXHJcbi8vIEFkdmFuY2VkIElQTyBzZWFyY2ggZW5kcG9pbnQgd2l0aCBmdWxsLXRleHQgc2VhcmNoLCBmaWx0ZXJzLCBhbmQgQUktcG93ZXJlZCBzdWdnZXN0aW9uc1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gR0VUKHJlcXVlc3QpIHtcclxuICB0cnkge1xyXG4gICAgY29uc3QgeyBzZWFyY2hQYXJhbXMgfSA9IG5ldyBVUkwocmVxdWVzdC51cmwpO1xyXG5cclxuICAgIC8vIEV4dHJhY3Qgc2VhcmNoIHBhcmFtZXRlcnNcclxuICAgIGNvbnN0IHF1ZXJ5ID0gc2VhcmNoUGFyYW1zLmdldCgncScpIHx8IHNlYXJjaFBhcmFtcy5nZXQoJ3F1ZXJ5JykgfHwgJyc7XHJcbiAgICBjb25zdCB0eXBlID0gc2VhcmNoUGFyYW1zLmdldCgndHlwZScpIHx8ICdhbGwnOyAvLyBhbGwsIHN5bWJvbCwgbmFtZSwgc2VjdG9yLCByZWdpc3RyYXJcclxuICAgIGNvbnN0IHN0YXR1cyA9IHNlYXJjaFBhcmFtcy5nZXQoJ3N0YXR1cycpO1xyXG4gICAgY29uc3Qgc2VjdG9yID0gc2VhcmNoUGFyYW1zLmdldCgnc2VjdG9yJyk7XHJcbiAgICBjb25zdCByZWdpc3RyYXIgPSBzZWFyY2hQYXJhbXMuZ2V0KCdyZWdpc3RyYXInKTtcclxuICAgIGNvbnN0IG1pblByaWNlID0gcGFyc2VGbG9hdChzZWFyY2hQYXJhbXMuZ2V0KCdtaW5QcmljZScpKTtcclxuICAgIGNvbnN0IG1heFByaWNlID0gcGFyc2VGbG9hdChzZWFyY2hQYXJhbXMuZ2V0KCdtYXhQcmljZScpKTtcclxuICAgIGNvbnN0IG1pbklzc3VlU2l6ZSA9IHBhcnNlRmxvYXQoc2VhcmNoUGFyYW1zLmdldCgnbWluSXNzdWVTaXplJykpO1xyXG4gICAgY29uc3QgbWF4SXNzdWVTaXplID0gcGFyc2VGbG9hdChzZWFyY2hQYXJhbXMuZ2V0KCdtYXhJc3N1ZVNpemUnKSk7XHJcbiAgICBjb25zdCBtaW5HTVAgPSBwYXJzZUZsb2F0KHNlYXJjaFBhcmFtcy5nZXQoJ21pbkdNUCcpKTtcclxuICAgIGNvbnN0IG1heEdNUCA9IHBhcnNlRmxvYXQoc2VhcmNoUGFyYW1zLmdldCgnbWF4R01QJykpO1xyXG4gICAgY29uc3Qgc3Vic2NyaXB0aW9uTWluID0gcGFyc2VGbG9hdChzZWFyY2hQYXJhbXMuZ2V0KCdzdWJzY3JpcHRpb25NaW4nKSk7XHJcbiAgICBjb25zdCBzdWJzY3JpcHRpb25NYXggPSBwYXJzZUZsb2F0KHNlYXJjaFBhcmFtcy5nZXQoJ3N1YnNjcmlwdGlvbk1heCcpKTtcclxuICAgIGNvbnN0IGRhdGVGcm9tID0gc2VhcmNoUGFyYW1zLmdldCgnZGF0ZUZyb20nKTtcclxuICAgIGNvbnN0IGRhdGVUbyA9IHNlYXJjaFBhcmFtcy5nZXQoJ2RhdGVUbycpO1xyXG4gICAgY29uc3Qgc29ydEJ5ID0gc2VhcmNoUGFyYW1zLmdldCgnc29ydEJ5JykgfHwgJ3JlbGV2YW5jZSc7XHJcbiAgICBjb25zdCBzb3J0T3JkZXIgPSBzZWFyY2hQYXJhbXMuZ2V0KCdzb3J0T3JkZXInKSB8fCAnZGVzYyc7XHJcbiAgICBjb25zdCBwYWdlID0gcGFyc2VJbnQoc2VhcmNoUGFyYW1zLmdldCgncGFnZScpKSB8fCAxO1xyXG4gICAgY29uc3QgbGltaXQgPSBNYXRoLm1pbihwYXJzZUludChzZWFyY2hQYXJhbXMuZ2V0KCdsaW1pdCcpKSB8fCAyMCwgMTAwKTtcclxuICAgIGNvbnN0IGZ1enp5ID0gc2VhcmNoUGFyYW1zLmdldCgnZnV6enknKSAhPT0gJ2ZhbHNlJzsgLy8gRGVmYXVsdCB0cnVlXHJcbiAgICBjb25zdCBzdWdnZXN0aW9ucyA9IHNlYXJjaFBhcmFtcy5nZXQoJ3N1Z2dlc3Rpb25zJykgPT09ICd0cnVlJztcclxuICAgIGNvbnN0IGhpZ2hsaWdodCA9IHNlYXJjaFBhcmFtcy5nZXQoJ2hpZ2hsaWdodCcpICE9PSAnZmFsc2UnOyAvLyBEZWZhdWx0IHRydWVcclxuICAgIGNvbnN0IGluY2x1ZGVBbmFseXRpY3MgPSBzZWFyY2hQYXJhbXMuZ2V0KCdpbmNsdWRlQW5hbHl0aWNzJykgPT09ICd0cnVlJztcclxuICAgIGNvbnN0IGluY2x1ZGVQcmVkaWN0aW9ucyA9IHNlYXJjaFBhcmFtcy5nZXQoJ2luY2x1ZGVQcmVkaWN0aW9ucycpID09PSAndHJ1ZSc7XHJcbiAgICBjb25zdCBhZHZhbmNlZCA9IHNlYXJjaFBhcmFtcy5nZXQoJ2FkdmFuY2VkJykgPT09ICd0cnVlJztcclxuXHJcbiAgICAvLyBWYWxpZGF0ZSBxdWVyeSBsZW5ndGhcclxuICAgIGlmIChxdWVyeS5sZW5ndGggPiAwICYmIHF1ZXJ5Lmxlbmd0aCA8IDIpIHtcclxuICAgICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxyXG4gICAgICAgICAgZXJyb3I6ICdTZWFyY2ggcXVlcnkgbXVzdCBiZSBhdCBsZWFzdCAyIGNoYXJhY3RlcnMgbG9uZycsXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7IHN0YXR1czogNDAwIH1cclxuICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBCdWlsZCBjYWNoZSBrZXlcclxuICAgIGNvbnN0IGNhY2hlS2V5ID0gY2FjaGUua2V5KFxyXG4gICAgICAnU0VBUkNIJyxcclxuICAgICAgYGlwb3M6JHtKU09OLnN0cmluZ2lmeSh7XHJcbiAgICAgICAgcXVlcnk6IHF1ZXJ5LnRvTG93ZXJDYXNlKCksXHJcbiAgICAgICAgdHlwZSxcclxuICAgICAgICBzdGF0dXMsXHJcbiAgICAgICAgc2VjdG9yLFxyXG4gICAgICAgIHJlZ2lzdHJhcixcclxuICAgICAgICBtaW5QcmljZSxcclxuICAgICAgICBtYXhQcmljZSxcclxuICAgICAgICBtaW5Jc3N1ZVNpemUsXHJcbiAgICAgICAgbWF4SXNzdWVTaXplLFxyXG4gICAgICAgIG1pbkdNUCxcclxuICAgICAgICBtYXhHTVAsXHJcbiAgICAgICAgc3Vic2NyaXB0aW9uTWluLFxyXG4gICAgICAgIHN1YnNjcmlwdGlvbk1heCxcclxuICAgICAgICBkYXRlRnJvbSxcclxuICAgICAgICBkYXRlVG8sXHJcbiAgICAgICAgc29ydEJ5LFxyXG4gICAgICAgIHNvcnRPcmRlcixcclxuICAgICAgICBwYWdlLFxyXG4gICAgICAgIGxpbWl0LFxyXG4gICAgICAgIGZ1enp5LFxyXG4gICAgICAgIGluY2x1ZGVBbmFseXRpY3MsXHJcbiAgICAgICAgaW5jbHVkZVByZWRpY3Rpb25zLFxyXG4gICAgICAgIGFkdmFuY2VkLFxyXG4gICAgICB9KX1gXHJcbiAgICApO1xyXG5cclxuICAgIC8vIFRyeSBjYWNoZSBmaXJzdFxyXG4gICAgY29uc3QgY2FjaGVkID0gYXdhaXQgY2FjaGUuZ2V0KGNhY2hlS2V5KTtcclxuICAgIGlmIChjYWNoZWQpIHtcclxuICAgICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKHtcclxuICAgICAgICAuLi5jYWNoZWQsXHJcbiAgICAgICAgY2FjaGVkOiB0cnVlLFxyXG4gICAgICAgIGNhY2hlVGltZTogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBCdWlsZCBzZWFyY2ggcmVzdWx0c1xyXG4gICAgbGV0IHNlYXJjaFJlc3VsdHM7XHJcblxyXG4gICAgaWYgKHF1ZXJ5LnRyaW0oKSA9PT0gJycpIHtcclxuICAgICAgLy8gSWYgbm8gcXVlcnksIHJldHVybiBmaWx0ZXJlZCByZXN1bHRzXHJcbiAgICAgIHNlYXJjaFJlc3VsdHMgPSBhd2FpdCBwZXJmb3JtRmlsdGVyZWRTZWFyY2goe1xyXG4gICAgICAgIHN0YXR1cyxcclxuICAgICAgICBzZWN0b3IsXHJcbiAgICAgICAgcmVnaXN0cmFyLFxyXG4gICAgICAgIG1pblByaWNlLFxyXG4gICAgICAgIG1heFByaWNlLFxyXG4gICAgICAgIG1pbklzc3VlU2l6ZSxcclxuICAgICAgICBtYXhJc3N1ZVNpemUsXHJcbiAgICAgICAgbWluR01QLFxyXG4gICAgICAgIG1heEdNUCxcclxuICAgICAgICBzdWJzY3JpcHRpb25NaW4sXHJcbiAgICAgICAgc3Vic2NyaXB0aW9uTWF4LFxyXG4gICAgICAgIGRhdGVGcm9tLFxyXG4gICAgICAgIGRhdGVUbyxcclxuICAgICAgICBzb3J0QnksXHJcbiAgICAgICAgc29ydE9yZGVyLFxyXG4gICAgICAgIHBhZ2UsXHJcbiAgICAgICAgbGltaXQsXHJcbiAgICAgICAgaW5jbHVkZUFuYWx5dGljcyxcclxuICAgICAgICBpbmNsdWRlUHJlZGljdGlvbnMsXHJcbiAgICAgIH0pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy8gUGVyZm9ybSB0ZXh0IHNlYXJjaFxyXG4gICAgICBzZWFyY2hSZXN1bHRzID0gYXdhaXQgcGVyZm9ybVRleHRTZWFyY2goe1xyXG4gICAgICAgIHF1ZXJ5LFxyXG4gICAgICAgIHR5cGUsXHJcbiAgICAgICAgc3RhdHVzLFxyXG4gICAgICAgIHNlY3RvcixcclxuICAgICAgICByZWdpc3RyYXIsXHJcbiAgICAgICAgbWluUHJpY2UsXHJcbiAgICAgICAgbWF4UHJpY2UsXHJcbiAgICAgICAgbWluSXNzdWVTaXplLFxyXG4gICAgICAgIG1heElzc3VlU2l6ZSxcclxuICAgICAgICBtaW5HTVAsXHJcbiAgICAgICAgbWF4R01QLFxyXG4gICAgICAgIHN1YnNjcmlwdGlvbk1pbixcclxuICAgICAgICBzdWJzY3JpcHRpb25NYXgsXHJcbiAgICAgICAgZGF0ZUZyb20sXHJcbiAgICAgICAgZGF0ZVRvLFxyXG4gICAgICAgIHNvcnRCeSxcclxuICAgICAgICBzb3J0T3JkZXIsXHJcbiAgICAgICAgcGFnZSxcclxuICAgICAgICBsaW1pdCxcclxuICAgICAgICBmdXp6eSxcclxuICAgICAgICBoaWdobGlnaHQsXHJcbiAgICAgICAgaW5jbHVkZUFuYWx5dGljcyxcclxuICAgICAgICBpbmNsdWRlUHJlZGljdGlvbnMsXHJcbiAgICAgICAgYWR2YW5jZWQsXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEdlbmVyYXRlIHNlYXJjaCBzdWdnZXN0aW9ucyBpZiByZXF1ZXN0ZWRcclxuICAgIGxldCBzZWFyY2hTdWdnZXN0aW9ucyA9IFtdO1xyXG4gICAgaWYgKHN1Z2dlc3Rpb25zICYmIHF1ZXJ5Lmxlbmd0aCA+PSAyKSB7XHJcbiAgICAgIHNlYXJjaFN1Z2dlc3Rpb25zID0gYXdhaXQgZ2VuZXJhdGVTZWFyY2hTdWdnZXN0aW9ucyhxdWVyeSwge1xyXG4gICAgICAgIHR5cGUsXHJcbiAgICAgICAgc3RhdHVzLFxyXG4gICAgICAgIHNlY3RvcixcclxuICAgICAgICBsaW1pdDogMTAsXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEdlbmVyYXRlIHNlYXJjaCBhbmFseXRpY3NcclxuICAgIGNvbnN0IHNlYXJjaEFuYWx5dGljcyA9IGF3YWl0IGdlbmVyYXRlU2VhcmNoQW5hbHl0aWNzKHF1ZXJ5LCBzZWFyY2hSZXN1bHRzLmRhdGEpO1xyXG5cclxuICAgIC8vIEJ1aWxkIGNvbXByZWhlbnNpdmUgcmVzcG9uc2VcclxuICAgIGNvbnN0IHJlc3BvbnNlID0ge1xyXG4gICAgICBzdWNjZXNzOiB0cnVlLFxyXG4gICAgICBxdWVyeToge1xyXG4gICAgICAgIG9yaWdpbmFsOiBxdWVyeSxcclxuICAgICAgICBwcm9jZXNzZWQ6IHByb2Nlc3NTZWFyY2hRdWVyeShxdWVyeSksXHJcbiAgICAgICAgdHlwZSxcclxuICAgICAgICBmdXp6eSxcclxuICAgICAgICBhZHZhbmNlZCxcclxuICAgICAgfSxcclxuICAgICAgcmVzdWx0czogc2VhcmNoUmVzdWx0cy5kYXRhLFxyXG4gICAgICBwYWdpbmF0aW9uOiBzZWFyY2hSZXN1bHRzLnBhZ2luYXRpb24sXHJcbiAgICAgIHN1Z2dlc3Rpb25zOiBzZWFyY2hTdWdnZXN0aW9ucyxcclxuICAgICAgYW5hbHl0aWNzOiBzZWFyY2hBbmFseXRpY3MsXHJcbiAgICAgIGZpbHRlcnM6IHtcclxuICAgICAgICBhcHBsaWVkOiBnZXRBcHBsaWVkRmlsdGVycyh7XHJcbiAgICAgICAgICBzdGF0dXMsXHJcbiAgICAgICAgICBzZWN0b3IsXHJcbiAgICAgICAgICByZWdpc3RyYXIsXHJcbiAgICAgICAgICBtaW5QcmljZSxcclxuICAgICAgICAgIG1heFByaWNlLFxyXG4gICAgICAgICAgbWluSXNzdWVTaXplLFxyXG4gICAgICAgICAgbWF4SXNzdWVTaXplLFxyXG4gICAgICAgICAgbWluR01QLFxyXG4gICAgICAgICAgbWF4R01QLFxyXG4gICAgICAgICAgc3Vic2NyaXB0aW9uTWluLFxyXG4gICAgICAgICAgc3Vic2NyaXB0aW9uTWF4LFxyXG4gICAgICAgICAgZGF0ZUZyb20sXHJcbiAgICAgICAgICBkYXRlVG8sXHJcbiAgICAgICAgfSksXHJcbiAgICAgICAgYXZhaWxhYmxlOiBhd2FpdCBnZXRBdmFpbGFibGVGaWx0ZXJzKHNlYXJjaFJlc3VsdHMuZGF0YSksXHJcbiAgICAgIH0sXHJcbiAgICAgIHNvcnRpbmc6IHtcclxuICAgICAgICBzb3J0QnksXHJcbiAgICAgICAgc29ydE9yZGVyLFxyXG4gICAgICAgIG9wdGlvbnM6IGdldFNvcnRpbmdPcHRpb25zKCksXHJcbiAgICAgIH0sXHJcbiAgICAgIG1ldGFkYXRhOiB7XHJcbiAgICAgICAgc2VhcmNoVGltZTogRGF0ZS5ub3coKSAtIChzZWFyY2hSZXN1bHRzLnN0YXJ0VGltZSB8fCBEYXRlLm5vdygpKSxcclxuICAgICAgICB0b3RhbFJlc3VsdHM6IHNlYXJjaFJlc3VsdHMucGFnaW5hdGlvbi50b3RhbENvdW50LFxyXG4gICAgICAgIGhhc01vcmU6IHNlYXJjaFJlc3VsdHMucGFnaW5hdGlvbi5oYXNOZXh0UGFnZSxcclxuICAgICAgICByZWxldmFuY2VTY29yaW5nOiBxdWVyeS5sZW5ndGggPiAwLFxyXG4gICAgICAgIGhpZ2hsaWdodGluZzogaGlnaGxpZ2h0ICYmIHF1ZXJ5Lmxlbmd0aCA+IDAsXHJcbiAgICAgIH0sXHJcbiAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxyXG4gICAgfTtcclxuXHJcbiAgICAvLyBDYWNoZSByZXNwb25zZSBmb3IgNSBtaW51dGVzXHJcbiAgICBhd2FpdCBjYWNoZS5zZXQoY2FjaGVLZXksIHJlc3BvbnNlLCAzMDApO1xyXG5cclxuICAgIC8vIExvZyBzZWFyY2ggZm9yIGFuYWx5dGljc1xyXG4gICAgbG9nU2VhcmNoUXVlcnkocmVxdWVzdCwge1xyXG4gICAgICBxdWVyeSxcclxuICAgICAgdHlwZSxcclxuICAgICAgcmVzdWx0Q291bnQ6IHNlYXJjaFJlc3VsdHMuZGF0YS5sZW5ndGgsXHJcbiAgICAgIGZpbHRlcnM6IHJlc3BvbnNlLmZpbHRlcnMuYXBwbGllZCxcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbihyZXNwb25zZSk7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0dFVCAvYXBpL2lwb3Mvc2VhcmNoIGVycm9yOicsIGVycm9yKTtcclxuXHJcbiAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oXHJcbiAgICAgIHtcclxuICAgICAgICBzdWNjZXNzOiBmYWxzZSxcclxuICAgICAgICBlcnJvcjogJ1NlYXJjaCBmYWlsZWQnLFxyXG4gICAgICAgIG1lc3NhZ2U6IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnID8gZXJyb3IubWVzc2FnZSA6ICdJbnRlcm5hbCBzZXJ2ZXIgZXJyb3InLFxyXG4gICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxyXG4gICAgICB9LFxyXG4gICAgICB7IHN0YXR1czogNTAwIH1cclxuICAgICk7XHJcbiAgfVxyXG59XHJcblxyXG4vLyBBZHZhbmNlZCBzZWFyY2ggd2l0aCBxdWVyeSBwcm9jZXNzaW5nIGFuZCBNTC1wb3dlcmVkIHJhbmtpbmdcclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIFBPU1QocmVxdWVzdCkge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCBib2R5ID0gYXdhaXQgcmVxdWVzdC5qc29uKCk7XHJcbiAgICBjb25zdCB7XHJcbiAgICAgIHF1ZXJpZXMsXHJcbiAgICAgIHNlYXJjaFR5cGUgPSAnc2VtYW50aWMnLFxyXG4gICAgICByYW5raW5nTW9kZWwgPSAncmVsZXZhbmNlJyxcclxuICAgICAgYm9vc3QgPSB7fSxcclxuICAgICAgZmlsdGVycyA9IHt9LFxyXG4gICAgICBvcHRpb25zID0ge30sXHJcbiAgICB9ID0gYm9keTtcclxuXHJcbiAgICAvLyBWYWxpZGF0ZSBjb21wbGV4IHNlYXJjaCByZXF1ZXN0XHJcbiAgICBpZiAoIXF1ZXJpZXMgfHwgKCFBcnJheS5pc0FycmF5KHF1ZXJpZXMpICYmIHR5cGVvZiBxdWVyaWVzICE9PSAnc3RyaW5nJykpIHtcclxuICAgICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxyXG4gICAgICAgICAgZXJyb3I6ICdRdWVyaWVzIHBhcmFtZXRlciBpcyByZXF1aXJlZCcsXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7IHN0YXR1czogNDAwIH1cclxuICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBQcm9jZXNzIG11bHRpcGxlIHF1ZXJpZXMgb3IgY29tcGxleCBxdWVyeVxyXG4gICAgY29uc3Qgc2VhcmNoUXVlcmllcyA9IEFycmF5LmlzQXJyYXkocXVlcmllcykgPyBxdWVyaWVzIDogW3F1ZXJpZXNdO1xyXG5cclxuICAgIGNvbnN0IHNlYXJjaFJlc3VsdHMgPSBhd2FpdCBwZXJmb3JtQWR2YW5jZWRTZWFyY2goe1xyXG4gICAgICBxdWVyaWVzOiBzZWFyY2hRdWVyaWVzLFxyXG4gICAgICBzZWFyY2hUeXBlLFxyXG4gICAgICByYW5raW5nTW9kZWwsXHJcbiAgICAgIGJvb3N0LFxyXG4gICAgICBmaWx0ZXJzLFxyXG4gICAgICBvcHRpb25zLFxyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gR2VuZXJhdGUgYWR2YW5jZWQgYW5hbHl0aWNzXHJcbiAgICBjb25zdCBhZHZhbmNlZEFuYWx5dGljcyA9IGF3YWl0IGdlbmVyYXRlQWR2YW5jZWRTZWFyY2hBbmFseXRpY3Moc2VhcmNoUXVlcmllcywgc2VhcmNoUmVzdWx0cyk7XHJcblxyXG4gICAgY29uc3QgcmVzcG9uc2UgPSB7XHJcbiAgICAgIHN1Y2Nlc3M6IHRydWUsXHJcbiAgICAgIHNlYXJjaFR5cGUsXHJcbiAgICAgIHJhbmtpbmdNb2RlbCxcclxuICAgICAgcXVlcmllczogc2VhcmNoUXVlcmllcyxcclxuICAgICAgcmVzdWx0czogc2VhcmNoUmVzdWx0cy5kYXRhLFxyXG4gICAgICBwYWdpbmF0aW9uOiBzZWFyY2hSZXN1bHRzLnBhZ2luYXRpb24sXHJcbiAgICAgIGFuYWx5dGljczogYWR2YW5jZWRBbmFseXRpY3MsXHJcbiAgICAgIHJlbGV2YW5jZVNjb3Jlczogc2VhcmNoUmVzdWx0cy5yZWxldmFuY2VTY29yZXMsXHJcbiAgICAgIHF1ZXJ5UHJvY2Vzc2luZzoge1xyXG4gICAgICAgIG5vcm1hbGl6ZWRRdWVyaWVzOiBzZWFyY2hRdWVyaWVzLm1hcCgocSkgPT4gcHJvY2Vzc1NlYXJjaFF1ZXJ5KHEpKSxcclxuICAgICAgICBzZW1hbnRpY0FuYWx5c2lzOlxyXG4gICAgICAgICAgc2VhcmNoVHlwZSA9PT0gJ3NlbWFudGljJyA/IGF3YWl0IHBlcmZvcm1TZW1hbnRpY0FuYWx5c2lzKHNlYXJjaFF1ZXJpZXMpIDogbnVsbCxcclxuICAgICAgICBlbnRpdHlFeHRyYWN0aW9uOiBhd2FpdCBleHRyYWN0RW50aXRpZXMoc2VhcmNoUXVlcmllcyksXHJcbiAgICAgIH0sXHJcbiAgICAgIHJlY29tbWVuZGF0aW9uczogYXdhaXQgZ2VuZXJhdGVTZWFyY2hSZWNvbW1lbmRhdGlvbnMoc2VhcmNoUmVzdWx0cy5kYXRhLCBzZWFyY2hRdWVyaWVzKSxcclxuICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbihyZXNwb25zZSk7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ1BPU1QgL2FwaS9pcG9zL3NlYXJjaCBlcnJvcjonLCBlcnJvcik7XHJcblxyXG4gICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKFxyXG4gICAgICB7XHJcbiAgICAgICAgc3VjY2VzczogZmFsc2UsXHJcbiAgICAgICAgZXJyb3I6ICdBZHZhbmNlZCBzZWFyY2ggZmFpbGVkJyxcclxuICAgICAgICBtZXNzYWdlOiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyA/IGVycm9yLm1lc3NhZ2UgOiAnSW50ZXJuYWwgc2VydmVyIGVycm9yJyxcclxuICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcclxuICAgICAgfSxcclxuICAgICAgeyBzdGF0dXM6IDUwMCB9XHJcbiAgICApO1xyXG4gIH1cclxufVxyXG5cclxuLy8gUGVyZm9ybSBmaWx0ZXJlZCBzZWFyY2ggd2l0aG91dCB0ZXh0IHF1ZXJ5XHJcbmFzeW5jIGZ1bmN0aW9uIHBlcmZvcm1GaWx0ZXJlZFNlYXJjaChwYXJhbXMpIHtcclxuICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xyXG5cclxuICB0cnkge1xyXG4gICAgY29uc3Qge1xyXG4gICAgICBzdGF0dXMsXHJcbiAgICAgIHNlY3RvcixcclxuICAgICAgcmVnaXN0cmFyLFxyXG4gICAgICBtaW5QcmljZSxcclxuICAgICAgbWF4UHJpY2UsXHJcbiAgICAgIG1pbklzc3VlU2l6ZSxcclxuICAgICAgbWF4SXNzdWVTaXplLFxyXG4gICAgICBtaW5HTVAsXHJcbiAgICAgIG1heEdNUCxcclxuICAgICAgc3Vic2NyaXB0aW9uTWluLFxyXG4gICAgICBzdWJzY3JpcHRpb25NYXgsXHJcbiAgICAgIGRhdGVGcm9tLFxyXG4gICAgICBkYXRlVG8sXHJcbiAgICAgIHNvcnRCeSxcclxuICAgICAgc29ydE9yZGVyLFxyXG4gICAgICBwYWdlLFxyXG4gICAgICBsaW1pdCxcclxuICAgICAgaW5jbHVkZUFuYWx5dGljcyxcclxuICAgICAgaW5jbHVkZVByZWRpY3Rpb25zLFxyXG4gICAgfSA9IHBhcmFtcztcclxuXHJcbiAgICAvLyBCdWlsZCB3aGVyZSBjbGF1c2VcclxuICAgIGNvbnN0IHdoZXJlQ2xhdXNlID0ge1xyXG4gICAgICBpc0FjdGl2ZTogdHJ1ZSxcclxuICAgIH07XHJcblxyXG4gICAgLy8gQXBwbHkgYmFzaWMgZmlsdGVyc1xyXG4gICAgaWYgKHN0YXR1cyAmJiBzdGF0dXMgIT09ICdhbGwnKSB7XHJcbiAgICAgIHdoZXJlQ2xhdXNlLnN0YXR1cyA9IHN0YXR1cy5pbmNsdWRlcygnLCcpID8geyBpbjogc3RhdHVzLnNwbGl0KCcsJykgfSA6IHN0YXR1cztcclxuICAgIH1cclxuXHJcbiAgICBpZiAoc2VjdG9yKSB7XHJcbiAgICAgIHdoZXJlQ2xhdXNlLnNlY3RvciA9IHNlY3Rvci5pbmNsdWRlcygnLCcpXHJcbiAgICAgICAgPyB7IGluOiBzZWN0b3Iuc3BsaXQoJywnKSB9XHJcbiAgICAgICAgOiB7IGNvbnRhaW5zOiBzZWN0b3IsIG1vZGU6ICdpbnNlbnNpdGl2ZScgfTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAocmVnaXN0cmFyKSB7XHJcbiAgICAgIHdoZXJlQ2xhdXNlLnJlZ2lzdHJhciA9IHsgY29udGFpbnM6IHJlZ2lzdHJhciwgbW9kZTogJ2luc2Vuc2l0aXZlJyB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFByaWNlIHJhbmdlIGZpbHRlcnNcclxuICAgIGlmIChtaW5QcmljZSAmJiAhaXNOYU4obWluUHJpY2UpKSB7XHJcbiAgICAgIHdoZXJlQ2xhdXNlLm1heFByaWNlID0geyBndGU6IG1pblByaWNlIH07XHJcbiAgICB9XHJcbiAgICBpZiAobWF4UHJpY2UgJiYgIWlzTmFOKG1heFByaWNlKSkge1xyXG4gICAgICB3aGVyZUNsYXVzZS5taW5QcmljZSA9IHsgbHRlOiBtYXhQcmljZSB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8vIElzc3VlIHNpemUgZmlsdGVyc1xyXG4gICAgaWYgKG1pbklzc3VlU2l6ZSAmJiAhaXNOYU4obWluSXNzdWVTaXplKSkge1xyXG4gICAgICB3aGVyZUNsYXVzZS5pc3N1ZVNpemUgPSB7XHJcbiAgICAgICAgLi4uKHdoZXJlQ2xhdXNlLmlzc3VlU2l6ZSB8fCB7fSksXHJcbiAgICAgICAgZ3RlOiBtaW5Jc3N1ZVNpemUgKiAxMDAwMDAwMCxcclxuICAgICAgfTtcclxuICAgIH1cclxuICAgIGlmIChtYXhJc3N1ZVNpemUgJiYgIWlzTmFOKG1heElzc3VlU2l6ZSkpIHtcclxuICAgICAgd2hlcmVDbGF1c2UuaXNzdWVTaXplID0ge1xyXG4gICAgICAgIC4uLih3aGVyZUNsYXVzZS5pc3N1ZVNpemUgfHwge30pLFxyXG4gICAgICAgIGx0ZTogbWF4SXNzdWVTaXplICogMTAwMDAwMDAsXHJcbiAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRGF0ZSBmaWx0ZXJzXHJcbiAgICBpZiAoZGF0ZUZyb20gfHwgZGF0ZVRvKSB7XHJcbiAgICAgIGNvbnN0IGRhdGVGaWx0ZXIgPSB7fTtcclxuICAgICAgaWYgKGRhdGVGcm9tKSBkYXRlRmlsdGVyLmd0ZSA9IG5ldyBEYXRlKGRhdGVGcm9tKTtcclxuICAgICAgaWYgKGRhdGVUbykgZGF0ZUZpbHRlci5sdGUgPSBuZXcgRGF0ZShkYXRlVG8pO1xyXG4gICAgICB3aGVyZUNsYXVzZS5vcGVuRGF0ZSA9IGRhdGVGaWx0ZXI7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gSW5jbHVkZSBjbGF1c2UgZm9yIHJlbGF0ZWQgZGF0YVxyXG4gICAgLy8gQWRkIHRoaXMgYXQgdGhlIGJlZ2lubmluZyBvZiB5b3VyIHBlcmZvcm1GaWx0ZXJlZFNlYXJjaCBmdW5jdGlvblxyXG4gICAgY29uc3QgaW5jbHVkZUNsYXVzZSA9IHtcclxuICAgICAgZ21wRGF0YToge1xyXG4gICAgICAgIG9yZGVyQnk6IHsgdGltZXN0YW1wOiAnZGVzYycgfSxcclxuICAgICAgICB0YWtlOiA1LFxyXG4gICAgICB9LFxyXG4gICAgICBzdWJzY3JpcHRpb25EYXRhOiB7XHJcbiAgICAgICAgb3JkZXJCeTogeyB0aW1lc3RhbXA6ICdkZXNjJyB9LFxyXG4gICAgICAgIHRha2U6IDUsXHJcbiAgICAgIH0sXHJcbiAgICAgIGFsbG90bWVudERhdGE6IHRydWUsXHJcbiAgICAgIGFuYWx5dGljczogdHJ1ZSxcclxuICAgICAgd2F0Y2hsaXN0czogdHJ1ZSxcclxuICAgICAgYWxlcnRzOiB0cnVlLFxyXG4gICAgfTtcclxuXHJcbiAgICAvLyBBZGQgR01QIGRhdGEgZm9yIEdNUC1iYXNlZCBmaWx0ZXJpbmdcclxuICAgIGlmIChtaW5HTVAgfHwgbWF4R01QIHx8IHN1YnNjcmlwdGlvbk1pbiB8fCBzdWJzY3JpcHRpb25NYXgpIHtcclxuICAgICAgaW5jbHVkZUNsYXVzZS5nbXAgPSB7XHJcbiAgICAgICAgb3JkZXJCeTogeyB0aW1lc3RhbXA6ICdkZXNjJyB9LFxyXG4gICAgICAgIHRha2U6IDEsXHJcbiAgICAgIH07XHJcbiAgICAgIGluY2x1ZGVDbGF1c2Uuc3Vic2NyaXB0aW9uID0ge1xyXG4gICAgICAgIG9yZGVyQnk6IHsgdGltZXN0YW1wOiAnZGVzYycgfSxcclxuICAgICAgICB0YWtlOiA1LFxyXG4gICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChpbmNsdWRlQW5hbHl0aWNzKSB7XHJcbiAgICAgIGluY2x1ZGVDbGF1c2UuYW5hbHl0aWNzID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBCdWlsZCBvcmRlciBjbGF1c2VcclxuICAgIGNvbnN0IG9yZGVyQnkgPSBidWlsZE9yZGVyQ2xhdXNlKHNvcnRCeSwgc29ydE9yZGVyKTtcclxuXHJcbiAgICAvLyBDYWxjdWxhdGUgcGFnaW5hdGlvblxyXG4gICAgY29uc3Qgb2Zmc2V0ID0gKHBhZ2UgLSAxKSAqIGxpbWl0O1xyXG5cclxuICAgIC8vIEV4ZWN1dGUgcXVlcnlcclxuICAgIGNvbnN0IFtpcG9zLCB0b3RhbENvdW50XSA9IGF3YWl0IFByb21pc2UuYWxsKFtcclxuICAgICAgcHJpc21hLmlQTy5maW5kTWFueSh7XHJcbiAgICAgICAgd2hlcmU6IHdoZXJlQ2xhdXNlLFxyXG4gICAgICAgIGluY2x1ZGU6IGluY2x1ZGVDbGF1c2UsXHJcbiAgICAgICAgb3JkZXJCeSxcclxuICAgICAgICBza2lwOiBvZmZzZXQsXHJcbiAgICAgICAgdGFrZTogbGltaXQsXHJcbiAgICAgIH0pLFxyXG4gICAgICBwcmlzbWEuaVBPLmNvdW50KHsgd2hlcmU6IHdoZXJlQ2xhdXNlIH0pLFxyXG4gICAgXSk7XHJcblxyXG4gICAgLy8gUG9zdC1wcm9jZXNzIHJlc3VsdHMgZm9yIEdNUCBhbmQgc3Vic2NyaXB0aW9uIGZpbHRlcnNcclxuICAgIGxldCBmaWx0ZXJlZFJlc3VsdHMgPSBpcG9zO1xyXG5cclxuICAgIGlmIChtaW5HTVAgfHwgbWF4R01QIHx8IHN1YnNjcmlwdGlvbk1pbiB8fCBzdWJzY3JpcHRpb25NYXgpIHtcclxuICAgICAgZmlsdGVyZWRSZXN1bHRzID0gYXdhaXQgYXBwbHlBZHZhbmNlZEZpbHRlcnMoaXBvcywge1xyXG4gICAgICAgIG1pbkdNUCxcclxuICAgICAgICBtYXhHTVAsXHJcbiAgICAgICAgc3Vic2NyaXB0aW9uTWluLFxyXG4gICAgICAgIHN1YnNjcmlwdGlvbk1heCxcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUHJvY2VzcyByZXN1bHRzXHJcbiAgICBjb25zdCBwcm9jZXNzZWRSZXN1bHRzID0gYXdhaXQgUHJvbWlzZS5hbGwoXHJcbiAgICAgIGZpbHRlcmVkUmVzdWx0cy5tYXAoKGlwbykgPT5cclxuICAgICAgICBwcm9jZXNzU2VhcmNoUmVzdWx0KGlwbywge1xyXG4gICAgICAgICAgaW5jbHVkZUFuYWx5dGljcyxcclxuICAgICAgICAgIGluY2x1ZGVQcmVkaWN0aW9ucyxcclxuICAgICAgICAgIGhpZ2hsaWdodDogZmFsc2UsXHJcbiAgICAgICAgICByZWxldmFuY2VTY29yZTogMS4wLFxyXG4gICAgICAgIH0pXHJcbiAgICAgIClcclxuICAgICk7XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgZGF0YTogcHJvY2Vzc2VkUmVzdWx0cyxcclxuICAgICAgcGFnaW5hdGlvbjoge1xyXG4gICAgICAgIGN1cnJlbnRQYWdlOiBwYWdlLFxyXG4gICAgICAgIHRvdGFsUGFnZXM6IE1hdGguY2VpbCh0b3RhbENvdW50IC8gbGltaXQpLFxyXG4gICAgICAgIHRvdGFsQ291bnQsXHJcbiAgICAgICAgbGltaXQsXHJcbiAgICAgICAgaGFzTmV4dFBhZ2U6IHBhZ2UgPCBNYXRoLmNlaWwodG90YWxDb3VudCAvIGxpbWl0KSxcclxuICAgICAgICBoYXNQcmV2UGFnZTogcGFnZSA+IDEsXHJcbiAgICAgIH0sXHJcbiAgICAgIHN0YXJ0VGltZSxcclxuICAgIH07XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIHBlcmZvcm1GaWx0ZXJlZFNlYXJjaDonLCBlcnJvcik7XHJcbiAgICB0aHJvdyBlcnJvcjtcclxuICB9XHJcbn1cclxuXHJcbi8vIFBlcmZvcm0gdGV4dC1iYXNlZCBzZWFyY2ggd2l0aCByZWxldmFuY2Ugc2NvcmluZ1xyXG5hc3luYyBmdW5jdGlvbiBwZXJmb3JtVGV4dFNlYXJjaChwYXJhbXMpIHtcclxuICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xyXG5cclxuICB0cnkge1xyXG4gICAgY29uc3Qge1xyXG4gICAgICBxdWVyeSxcclxuICAgICAgdHlwZSxcclxuICAgICAgc3RhdHVzLFxyXG4gICAgICBzZWN0b3IsXHJcbiAgICAgIHJlZ2lzdHJhcixcclxuICAgICAgbWluUHJpY2UsXHJcbiAgICAgIG1heFByaWNlLFxyXG4gICAgICBtaW5Jc3N1ZVNpemUsXHJcbiAgICAgIG1heElzc3VlU2l6ZSxcclxuICAgICAgbWluR01QLFxyXG4gICAgICBtYXhHTVAsXHJcbiAgICAgIHN1YnNjcmlwdGlvbk1pbixcclxuICAgICAgc3Vic2NyaXB0aW9uTWF4LFxyXG4gICAgICBkYXRlRnJvbSxcclxuICAgICAgZGF0ZVRvLFxyXG4gICAgICBzb3J0QnksXHJcbiAgICAgIHNvcnRPcmRlcixcclxuICAgICAgcGFnZSxcclxuICAgICAgbGltaXQsXHJcbiAgICAgIGZ1enp5LFxyXG4gICAgICBoaWdobGlnaHQsXHJcbiAgICAgIGluY2x1ZGVBbmFseXRpY3MsXHJcbiAgICAgIGluY2x1ZGVQcmVkaWN0aW9ucyxcclxuICAgICAgYWR2YW5jZWQsXHJcbiAgICB9ID0gcGFyYW1zO1xyXG5cclxuICAgIC8vIFByb2Nlc3MgYW5kIG5vcm1hbGl6ZSBxdWVyeVxyXG4gICAgY29uc3QgcHJvY2Vzc2VkUXVlcnkgPSBwcm9jZXNzU2VhcmNoUXVlcnkocXVlcnkpO1xyXG4gICAgY29uc3Qgc2VhcmNoVGVybXMgPSBleHRyYWN0U2VhcmNoVGVybXMocHJvY2Vzc2VkUXVlcnkpO1xyXG5cclxuICAgIC8vIEJ1aWxkIGJhc2Ugd2hlcmUgY2xhdXNlXHJcbiAgICBjb25zdCBiYXNlV2hlcmVDbGF1c2UgPSB7XHJcbiAgICAgIGlzQWN0aXZlOiB0cnVlLFxyXG4gICAgfTtcclxuXHJcbiAgICAvLyBBcHBseSBhZGRpdGlvbmFsIGZpbHRlcnNcclxuICAgIGFwcGx5QWRkaXRpb25hbEZpbHRlcnMoYmFzZVdoZXJlQ2xhdXNlLCB7XHJcbiAgICAgIHN0YXR1cyxcclxuICAgICAgc2VjdG9yLFxyXG4gICAgICByZWdpc3RyYXIsXHJcbiAgICAgIG1pblByaWNlLFxyXG4gICAgICBtYXhQcmljZSxcclxuICAgICAgbWluSXNzdWVTaXplLFxyXG4gICAgICBtYXhJc3N1ZVNpemUsXHJcbiAgICAgIGRhdGVGcm9tLFxyXG4gICAgICBkYXRlVG8sXHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBCdWlsZCBzZWFyY2ggY29uZGl0aW9ucyBiYXNlZCBvbiBzZWFyY2ggdHlwZVxyXG4gICAgbGV0IHNlYXJjaENvbmRpdGlvbnMgPSBbXTtcclxuXHJcbiAgICBzd2l0Y2ggKHR5cGUpIHtcclxuICAgICAgY2FzZSAnc3ltYm9sJzpcclxuICAgICAgICBzZWFyY2hDb25kaXRpb25zID0gYnVpbGRTeW1ib2xTZWFyY2goc2VhcmNoVGVybXMsIGZ1enp5KTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSAnbmFtZSc6XHJcbiAgICAgICAgc2VhcmNoQ29uZGl0aW9ucyA9IGJ1aWxkTmFtZVNlYXJjaChzZWFyY2hUZXJtcywgZnV6enkpO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlICdzZWN0b3InOlxyXG4gICAgICAgIHNlYXJjaENvbmRpdGlvbnMgPSBidWlsZFNlY3RvclNlYXJjaChzZWFyY2hUZXJtcywgZnV6enkpO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlICdyZWdpc3RyYXInOlxyXG4gICAgICAgIHNlYXJjaENvbmRpdGlvbnMgPSBidWlsZFJlZ2lzdHJhclNlYXJjaChzZWFyY2hUZXJtcywgZnV6enkpO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBkZWZhdWx0OlxyXG4gICAgICAgIHNlYXJjaENvbmRpdGlvbnMgPSBidWlsZFVuaXZlcnNhbFNlYXJjaChzZWFyY2hUZXJtcywgZnV6enkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIENvbWJpbmUgYmFzZSBmaWx0ZXJzIHdpdGggc2VhcmNoIGNvbmRpdGlvbnNcclxuICAgIGNvbnN0IHdoZXJlQ2xhdXNlID0ge1xyXG4gICAgICAuLi5iYXNlV2hlcmVDbGF1c2UsXHJcbiAgICAgIEFORDogW3sgT1I6IHNlYXJjaENvbmRpdGlvbnMgfV0sXHJcbiAgICB9O1xyXG5cclxuICAgIC8vIEluY2x1ZGUgcmVsYXRlZCBkYXRhXHJcbiAgICBjb25zdCBpbmNsdWRlQ2xhdXNlID0ge1xyXG4gICAgICBjYXRlZ29yaWVzOiB0cnVlLFxyXG4gICAgICBnbXA6IHtcclxuICAgICAgICBvcmRlckJ5OiB7IHRpbWVzdGFtcDogJ2Rlc2MnIH0sXHJcbiAgICAgICAgdGFrZTogNSxcclxuICAgICAgfSxcclxuICAgICAgc3Vic2NyaXB0aW9uOiB7XHJcbiAgICAgICAgb3JkZXJCeTogeyB0aW1lc3RhbXA6ICdkZXNjJyB9LFxyXG4gICAgICAgIHRha2U6IDUsXHJcbiAgICAgIH0sXHJcbiAgICB9O1xyXG5cclxuICAgIGlmIChpbmNsdWRlQW5hbHl0aWNzKSB7XHJcbiAgICAgIGluY2x1ZGVDbGF1c2UuYW5hbHl0aWNzID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBFeGVjdXRlIHNlYXJjaFxyXG4gICAgY29uc3QgW3NlYXJjaFJlc3VsdHMsIHRvdGFsQ291bnRdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xyXG4gICAgICBwcmlzbWEuaVBPLmZpbmRNYW55KHtcclxuICAgICAgICB3aGVyZTogd2hlcmVDbGF1c2UsXHJcbiAgICAgICAgaW5jbHVkZTogaW5jbHVkZUNsYXVzZSxcclxuICAgICAgfSksXHJcbiAgICAgIHByaXNtYS5pUE8uY291bnQoeyB3aGVyZTogd2hlcmVDbGF1c2UgfSksXHJcbiAgICBdKTtcclxuXHJcbiAgICAvLyBBcHBseSBhZHZhbmNlZCBmaWx0ZXJzIGlmIG5lZWRlZFxyXG4gICAgbGV0IGZpbHRlcmVkUmVzdWx0cyA9IHNlYXJjaFJlc3VsdHM7XHJcbiAgICBpZiAobWluR01QIHx8IG1heEdNUCB8fCBzdWJzY3JpcHRpb25NaW4gfHwgc3Vic2NyaXB0aW9uTWF4KSB7XHJcbiAgICAgIGZpbHRlcmVkUmVzdWx0cyA9IGF3YWl0IGFwcGx5QWR2YW5jZWRGaWx0ZXJzKHNlYXJjaFJlc3VsdHMsIHtcclxuICAgICAgICBtaW5HTVAsXHJcbiAgICAgICAgbWF4R01QLFxyXG4gICAgICAgIHN1YnNjcmlwdGlvbk1pbixcclxuICAgICAgICBzdWJzY3JpcHRpb25NYXgsXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIENhbGN1bGF0ZSByZWxldmFuY2Ugc2NvcmVzXHJcbiAgICBjb25zdCBzY29yZWRSZXN1bHRzID0gZmlsdGVyZWRSZXN1bHRzLm1hcCgoaXBvKSA9PiB7XHJcbiAgICAgIGNvbnN0IHJlbGV2YW5jZVNjb3JlID0gY2FsY3VsYXRlUmVsZXZhbmNlU2NvcmUoaXBvLCBzZWFyY2hUZXJtcywgdHlwZSk7XHJcbiAgICAgIHJldHVybiB7IC4uLmlwbywgcmVsZXZhbmNlU2NvcmUgfTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIFNvcnQgcmVzdWx0c1xyXG4gICAgbGV0IHNvcnRlZFJlc3VsdHM7XHJcbiAgICBpZiAoc29ydEJ5ID09PSAncmVsZXZhbmNlJykge1xyXG4gICAgICBzb3J0ZWRSZXN1bHRzID0gc2NvcmVkUmVzdWx0cy5zb3J0KChhLCBiKSA9PlxyXG4gICAgICAgIHNvcnRPcmRlciA9PT0gJ2Rlc2MnXHJcbiAgICAgICAgICA/IGIucmVsZXZhbmNlU2NvcmUgLSBhLnJlbGV2YW5jZVNjb3JlXHJcbiAgICAgICAgICA6IGEucmVsZXZhbmNlU2NvcmUgLSBiLnJlbGV2YW5jZVNjb3JlXHJcbiAgICAgICk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjb25zdCBvcmRlckJ5ID0gYnVpbGRPcmRlckNsYXVzZShzb3J0QnksIHNvcnRPcmRlcik7XHJcbiAgICAgIHNvcnRlZFJlc3VsdHMgPSBzb3J0UmVzdWx0cyhzY29yZWRSZXN1bHRzLCBvcmRlckJ5KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBBcHBseSBwYWdpbmF0aW9uXHJcbiAgICBjb25zdCBvZmZzZXQgPSAocGFnZSAtIDEpICogbGltaXQ7XHJcbiAgICBjb25zdCBwYWdpbmF0ZWRSZXN1bHRzID0gc29ydGVkUmVzdWx0cy5zbGljZShvZmZzZXQsIG9mZnNldCArIGxpbWl0KTtcclxuXHJcbiAgICAvLyBQcm9jZXNzIGZpbmFsIHJlc3VsdHNcclxuICAgIGNvbnN0IHByb2Nlc3NlZFJlc3VsdHMgPSBhd2FpdCBQcm9taXNlLmFsbChcclxuICAgICAgcGFnaW5hdGVkUmVzdWx0cy5tYXAoKGlwbykgPT5cclxuICAgICAgICBwcm9jZXNzU2VhcmNoUmVzdWx0KGlwbywge1xyXG4gICAgICAgICAgaW5jbHVkZUFuYWx5dGljcyxcclxuICAgICAgICAgIGluY2x1ZGVQcmVkaWN0aW9ucyxcclxuICAgICAgICAgIGhpZ2hsaWdodCxcclxuICAgICAgICAgIHNlYXJjaFRlcm1zLFxyXG4gICAgICAgICAgcmVsZXZhbmNlU2NvcmU6IGlwby5yZWxldmFuY2VTY29yZSxcclxuICAgICAgICB9KVxyXG4gICAgICApXHJcbiAgICApO1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgIGRhdGE6IHByb2Nlc3NlZFJlc3VsdHMsXHJcbiAgICAgIHBhZ2luYXRpb246IHtcclxuICAgICAgICBjdXJyZW50UGFnZTogcGFnZSxcclxuICAgICAgICB0b3RhbFBhZ2VzOiBNYXRoLmNlaWwoZmlsdGVyZWRSZXN1bHRzLmxlbmd0aCAvIGxpbWl0KSxcclxuICAgICAgICB0b3RhbENvdW50OiBmaWx0ZXJlZFJlc3VsdHMubGVuZ3RoLFxyXG4gICAgICAgIG9yaWdpbmFsQ291bnQ6IHRvdGFsQ291bnQsXHJcbiAgICAgICAgbGltaXQsXHJcbiAgICAgICAgaGFzTmV4dFBhZ2U6IHBhZ2UgPCBNYXRoLmNlaWwoZmlsdGVyZWRSZXN1bHRzLmxlbmd0aCAvIGxpbWl0KSxcclxuICAgICAgICBoYXNQcmV2UGFnZTogcGFnZSA+IDEsXHJcbiAgICAgIH0sXHJcbiAgICAgIHN0YXJ0VGltZSxcclxuICAgIH07XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIHBlcmZvcm1UZXh0U2VhcmNoOicsIGVycm9yKTtcclxuICAgIHRocm93IGVycm9yO1xyXG4gIH1cclxufVxyXG5cclxuLy8gUGVyZm9ybSBhZHZhbmNlZCBzZWFyY2ggd2l0aCBNTCByYW5raW5nXHJcbmFzeW5jIGZ1bmN0aW9uIHBlcmZvcm1BZHZhbmNlZFNlYXJjaChwYXJhbXMpIHtcclxuICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xyXG5cclxuICB0cnkge1xyXG4gICAgY29uc3QgeyBxdWVyaWVzLCBzZWFyY2hUeXBlLCByYW5raW5nTW9kZWwsIGJvb3N0LCBmaWx0ZXJzLCBvcHRpb25zIH0gPSBwYXJhbXM7XHJcblxyXG4gICAgLy8gUHJvY2VzcyBhbGwgcXVlcmllc1xyXG4gICAgY29uc3QgcHJvY2Vzc2VkUXVlcmllcyA9IHF1ZXJpZXMubWFwKChxKSA9PiBwcm9jZXNzU2VhcmNoUXVlcnkocSkpO1xyXG4gICAgY29uc3QgYWxsU2VhcmNoVGVybXMgPSBwcm9jZXNzZWRRdWVyaWVzLmZsYXRNYXAoKHEpID0+IGV4dHJhY3RTZWFyY2hUZXJtcyhxKSk7XHJcbiAgICBjb25zdCB1bmlxdWVUZXJtcyA9IFsuLi5uZXcgU2V0KGFsbFNlYXJjaFRlcm1zKV07XHJcblxyXG4gICAgLy8gQnVpbGQgYWR2YW5jZWQgc2VhcmNoIGNvbmRpdGlvbnNcclxuICAgIGNvbnN0IHNlYXJjaENvbmRpdGlvbnMgPSBidWlsZEFkdmFuY2VkU2VhcmNoQ29uZGl0aW9ucyhwcm9jZXNzZWRRdWVyaWVzLCBzZWFyY2hUeXBlKTtcclxuXHJcbiAgICAvLyBBcHBseSBmaWx0ZXJzXHJcbiAgICBjb25zdCB3aGVyZUNsYXVzZSA9IHtcclxuICAgICAgaXNBY3RpdmU6IHRydWUsXHJcbiAgICAgIEFORDogW3sgT1I6IHNlYXJjaENvbmRpdGlvbnMgfSwgLi4uYnVpbGRBZHZhbmNlZEZpbHRlcnMoZmlsdGVycyldLFxyXG4gICAgfTtcclxuXHJcbiAgICAvLyBFeGVjdXRlIHNlYXJjaCB3aXRoIGNvbXByZWhlbnNpdmUgaW5jbHVkZXNcclxuICAgIGNvbnN0IHNlYXJjaFJlc3VsdHMgPSBhd2FpdCBwcmlzbWEuaVBPLmZpbmRNYW55KHtcclxuICAgICAgd2hlcmU6IHdoZXJlQ2xhdXNlLFxyXG4gICAgICBpbmNsdWRlOiB7XHJcbiAgICAgICAgY2F0ZWdvcmllczogdHJ1ZSxcclxuICAgICAgICBnbXA6IHtcclxuICAgICAgICAgIG9yZGVyQnk6IHsgdGltZXN0YW1wOiAnZGVzYycgfSxcclxuICAgICAgICAgIHRha2U6IDEwLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc3Vic2NyaXB0aW9uOiB7XHJcbiAgICAgICAgICBvcmRlckJ5OiB7IHRpbWVzdGFtcDogJ2Rlc2MnIH0sXHJcbiAgICAgICAgICB0YWtlOiAxMCxcclxuICAgICAgICB9LFxyXG4gICAgICAgIGFuYWx5dGljczogdHJ1ZSxcclxuICAgICAgICBhbGxvdG1lbnRSZXN1bHRzOiB7XHJcbiAgICAgICAgICB0YWtlOiA1LFxyXG4gICAgICAgICAgc2VsZWN0OiB7XHJcbiAgICAgICAgICAgIGNhdGVnb3J5OiB0cnVlLFxyXG4gICAgICAgICAgICBhbGxvdG1lbnRTdGF0dXM6IHRydWUsXHJcbiAgICAgICAgICAgIGFsbG90dGVkUXVhbnRpdHk6IHRydWUsXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgIH0sXHJcbiAgICAgIH0sXHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBBcHBseSBNTC1wb3dlcmVkIHJhbmtpbmdcclxuICAgIGNvbnN0IHJhbmtlZFJlc3VsdHMgPSBhd2FpdCBhcHBseU1MUmFua2luZyhzZWFyY2hSZXN1bHRzLCB7XHJcbiAgICAgIHF1ZXJpZXM6IHByb2Nlc3NlZFF1ZXJpZXMsXHJcbiAgICAgIHJhbmtpbmdNb2RlbCxcclxuICAgICAgYm9vc3QsXHJcbiAgICAgIHNlYXJjaFR5cGUsXHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBHZW5lcmF0ZSByZWxldmFuY2Ugc2NvcmVzXHJcbiAgICBjb25zdCByZWxldmFuY2VTY29yZXMgPSByYW5rZWRSZXN1bHRzLm1hcCgoaXBvLCBpbmRleCkgPT4gKHtcclxuICAgICAgaXBvSWQ6IGlwby5pZCxcclxuICAgICAgc3ltYm9sOiBpcG8uc3ltYm9sLFxyXG4gICAgICBzY29yZTogaXBvLm1sU2NvcmUgfHwgMS4wLFxyXG4gICAgICByYW5rOiBpbmRleCArIDEsXHJcbiAgICAgIGZhY3RvcnM6IGlwby5yYW5raW5nRmFjdG9ycyB8fCB7fSxcclxuICAgIH0pKTtcclxuXHJcbiAgICAvLyBBcHBseSBwYWdpbmF0aW9uXHJcbiAgICBjb25zdCBwYWdlID0gb3B0aW9ucy5wYWdlIHx8IDE7XHJcbiAgICBjb25zdCBsaW1pdCA9IE1hdGgubWluKG9wdGlvbnMubGltaXQgfHwgMjAsIDEwMCk7XHJcbiAgICBjb25zdCBvZmZzZXQgPSAocGFnZSAtIDEpICogbGltaXQ7XHJcbiAgICBjb25zdCBwYWdpbmF0ZWRSZXN1bHRzID0gcmFua2VkUmVzdWx0cy5zbGljZShvZmZzZXQsIG9mZnNldCArIGxpbWl0KTtcclxuXHJcbiAgICAvLyBQcm9jZXNzIGZpbmFsIHJlc3VsdHNcclxuICAgIGNvbnN0IHByb2Nlc3NlZFJlc3VsdHMgPSBhd2FpdCBQcm9taXNlLmFsbChcclxuICAgICAgcGFnaW5hdGVkUmVzdWx0cy5tYXAoKGlwbykgPT5cclxuICAgICAgICBwcm9jZXNzQWR2YW5jZWRTZWFyY2hSZXN1bHQoaXBvLCB7XHJcbiAgICAgICAgICBxdWVyaWVzOiBwcm9jZXNzZWRRdWVyaWVzLFxyXG4gICAgICAgICAgc2VhcmNoVHlwZSxcclxuICAgICAgICAgIGhpZ2hsaWdodDogb3B0aW9ucy5oaWdobGlnaHQgIT09IGZhbHNlLFxyXG4gICAgICAgICAgaW5jbHVkZUFuYWx5dGljczogb3B0aW9ucy5pbmNsdWRlQW5hbHl0aWNzID09PSB0cnVlLFxyXG4gICAgICAgICAgaW5jbHVkZVByZWRpY3Rpb25zOiBvcHRpb25zLmluY2x1ZGVQcmVkaWN0aW9ucyA9PT0gdHJ1ZSxcclxuICAgICAgICB9KVxyXG4gICAgICApXHJcbiAgICApO1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgIGRhdGE6IHByb2Nlc3NlZFJlc3VsdHMsXHJcbiAgICAgIHBhZ2luYXRpb246IHtcclxuICAgICAgICBjdXJyZW50UGFnZTogcGFnZSxcclxuICAgICAgICB0b3RhbFBhZ2VzOiBNYXRoLmNlaWwocmFua2VkUmVzdWx0cy5sZW5ndGggLyBsaW1pdCksXHJcbiAgICAgICAgdG90YWxDb3VudDogcmFua2VkUmVzdWx0cy5sZW5ndGgsXHJcbiAgICAgICAgbGltaXQsXHJcbiAgICAgICAgaGFzTmV4dFBhZ2U6IHBhZ2UgPCBNYXRoLmNlaWwocmFua2VkUmVzdWx0cy5sZW5ndGggLyBsaW1pdCksXHJcbiAgICAgICAgaGFzUHJldlBhZ2U6IHBhZ2UgPiAxLFxyXG4gICAgICB9LFxyXG4gICAgICByZWxldmFuY2VTY29yZXMsXHJcbiAgICAgIHN0YXJ0VGltZSxcclxuICAgIH07XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIHBlcmZvcm1BZHZhbmNlZFNlYXJjaDonLCBlcnJvcik7XHJcbiAgICB0aHJvdyBlcnJvcjtcclxuICB9XHJcbn1cclxuXHJcbi8vIFByb2Nlc3Mgc2VhcmNoIHF1ZXJ5IGFuZCBub3JtYWxpemVcclxuZnVuY3Rpb24gcHJvY2Vzc1NlYXJjaFF1ZXJ5KHF1ZXJ5KSB7XHJcbiAgaWYgKCFxdWVyeSB8fCB0eXBlb2YgcXVlcnkgIT09ICdzdHJpbmcnKSByZXR1cm4gJyc7XHJcblxyXG4gIHJldHVybiBxdWVyeVxyXG4gICAgLnRvTG93ZXJDYXNlKClcclxuICAgIC50cmltKClcclxuICAgIC5yZXBsYWNlKC9bXlxcd1xcc10vZywgJyAnKSAvLyBSZW1vdmUgc3BlY2lhbCBjaGFyYWN0ZXJzXHJcbiAgICAucmVwbGFjZSgvXFxzKy9nLCAnICcpIC8vIE5vcm1hbGl6ZSB3aGl0ZXNwYWNlXHJcbiAgICAudHJpbSgpO1xyXG59XHJcblxyXG4vLyBFeHRyYWN0IHNlYXJjaCB0ZXJtcyBmcm9tIHByb2Nlc3NlZCBxdWVyeVxyXG5mdW5jdGlvbiBleHRyYWN0U2VhcmNoVGVybXMocHJvY2Vzc2VkUXVlcnkpIHtcclxuICBpZiAoIXByb2Nlc3NlZFF1ZXJ5KSByZXR1cm4gW107XHJcblxyXG4gIGNvbnN0IHRlcm1zID0gcHJvY2Vzc2VkUXVlcnkuc3BsaXQoJyAnKS5maWx0ZXIoKHRlcm0pID0+IHRlcm0ubGVuZ3RoID49IDIpO1xyXG5cclxuICAvLyBBZGQgcGFydGlhbCB0ZXJtcyBmb3IgZnV6enkgbWF0Y2hpbmdcclxuICBjb25zdCBleHBhbmRlZFRlcm1zID0gWy4uLnRlcm1zXTtcclxuICB0ZXJtcy5mb3JFYWNoKCh0ZXJtKSA9PiB7XHJcbiAgICBpZiAodGVybS5sZW5ndGggPj0gNCkge1xyXG4gICAgICBleHBhbmRlZFRlcm1zLnB1c2godGVybS5zdWJzdHJpbmcoMCwgdGVybS5sZW5ndGggLSAxKSk7IC8vIFBhcnRpYWwgbWF0Y2hcclxuICAgIH1cclxuICB9KTtcclxuXHJcbiAgcmV0dXJuIFsuLi5uZXcgU2V0KGV4cGFuZGVkVGVybXMpXTtcclxufVxyXG5cclxuLy8gQnVpbGQgc2VhcmNoIGNvbmRpdGlvbnMgZm9yIGRpZmZlcmVudCB0eXBlc1xyXG5mdW5jdGlvbiBidWlsZFN5bWJvbFNlYXJjaChzZWFyY2hUZXJtcywgZnV6enkpIHtcclxuICBjb25zdCBjb25kaXRpb25zID0gW107XHJcblxyXG4gIHNlYXJjaFRlcm1zLmZvckVhY2goKHRlcm0pID0+IHtcclxuICAgIGlmIChmdXp6eSkge1xyXG4gICAgICBjb25kaXRpb25zLnB1c2goe1xyXG4gICAgICAgIHN5bWJvbDogeyBjb250YWluczogdGVybSwgbW9kZTogJ2luc2Vuc2l0aXZlJyB9LFxyXG4gICAgICB9KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGNvbmRpdGlvbnMucHVzaCh7XHJcbiAgICAgICAgc3ltYm9sOiB7IHN0YXJ0c1dpdGg6IHRlcm0udG9VcHBlckNhc2UoKSB9LFxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9KTtcclxuXHJcbiAgcmV0dXJuIGNvbmRpdGlvbnM7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGJ1aWxkTmFtZVNlYXJjaChzZWFyY2hUZXJtcywgZnV6enkpIHtcclxuICBjb25zdCBjb25kaXRpb25zID0gW107XHJcblxyXG4gIHNlYXJjaFRlcm1zLmZvckVhY2goKHRlcm0pID0+IHtcclxuICAgIGNvbmRpdGlvbnMucHVzaCh7XHJcbiAgICAgIG5hbWU6IHsgY29udGFpbnM6IHRlcm0sIG1vZGU6ICdpbnNlbnNpdGl2ZScgfSxcclxuICAgIH0pO1xyXG4gIH0pO1xyXG5cclxuICByZXR1cm4gY29uZGl0aW9ucztcclxufVxyXG5cclxuZnVuY3Rpb24gYnVpbGRTZWN0b3JTZWFyY2goc2VhcmNoVGVybXMsIGZ1enp5KSB7XHJcbiAgY29uc3QgY29uZGl0aW9ucyA9IFtdO1xyXG5cclxuICBzZWFyY2hUZXJtcy5mb3JFYWNoKCh0ZXJtKSA9PiB7XHJcbiAgICBjb25kaXRpb25zLnB1c2goe1xyXG4gICAgICBzZWN0b3I6IHsgY29udGFpbnM6IHRlcm0sIG1vZGU6ICdpbnNlbnNpdGl2ZScgfSxcclxuICAgIH0pO1xyXG4gIH0pO1xyXG5cclxuICByZXR1cm4gY29uZGl0aW9ucztcclxufVxyXG5cclxuZnVuY3Rpb24gYnVpbGRSZWdpc3RyYXJTZWFyY2goc2VhcmNoVGVybXMsIGZ1enp5KSB7XHJcbiAgY29uc3QgY29uZGl0aW9ucyA9IFtdO1xyXG5cclxuICBzZWFyY2hUZXJtcy5mb3JFYWNoKCh0ZXJtKSA9PiB7XHJcbiAgICBjb25kaXRpb25zLnB1c2goe1xyXG4gICAgICByZWdpc3RyYXI6IHsgY29udGFpbnM6IHRlcm0sIG1vZGU6ICdpbnNlbnNpdGl2ZScgfSxcclxuICAgIH0pO1xyXG4gIH0pO1xyXG5cclxuICByZXR1cm4gY29uZGl0aW9ucztcclxufVxyXG5cclxuZnVuY3Rpb24gYnVpbGRVbml2ZXJzYWxTZWFyY2goc2VhcmNoVGVybXMsIGZ1enp5KSB7XHJcbiAgY29uc3QgY29uZGl0aW9ucyA9IFtdO1xyXG5cclxuICBzZWFyY2hUZXJtcy5mb3JFYWNoKCh0ZXJtKSA9PiB7XHJcbiAgICBjb25kaXRpb25zLnB1c2goXHJcbiAgICAgIHsgc3ltYm9sOiB7IGNvbnRhaW5zOiB0ZXJtLCBtb2RlOiAnaW5zZW5zaXRpdmUnIH0gfSxcclxuICAgICAgeyBuYW1lOiB7IGNvbnRhaW5zOiB0ZXJtLCBtb2RlOiAnaW5zZW5zaXRpdmUnIH0gfSxcclxuICAgICAgeyBzZWN0b3I6IHsgY29udGFpbnM6IHRlcm0sIG1vZGU6ICdpbnNlbnNpdGl2ZScgfSB9LFxyXG4gICAgICB7IHJlZ2lzdHJhcjogeyBjb250YWluczogdGVybSwgbW9kZTogJ2luc2Vuc2l0aXZlJyB9IH1cclxuICAgICk7XHJcblxyXG4gICAgLy8gQWRkIGxlYWQgbWFuYWdlcnMgc2VhcmNoXHJcbiAgICBpZiAodGVybS5sZW5ndGggPj0gMykge1xyXG4gICAgICBjb25kaXRpb25zLnB1c2goe1xyXG4gICAgICAgIGxlYWRNYW5hZ2Vyczoge1xyXG4gICAgICAgICAgYXJyYXlfY29udGFpbnM6IFt0ZXJtXSxcclxuICAgICAgICB9LFxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9KTtcclxuXHJcbiAgcmV0dXJuIGNvbmRpdGlvbnM7XHJcbn1cclxuXHJcbi8vIENhbGN1bGF0ZSByZWxldmFuY2Ugc2NvcmUgZm9yIHNlYXJjaCByZXN1bHRzXHJcbmZ1bmN0aW9uIGNhbGN1bGF0ZVJlbGV2YW5jZVNjb3JlKGlwbywgc2VhcmNoVGVybXMsIHNlYXJjaFR5cGUpIHtcclxuICBsZXQgc2NvcmUgPSAwO1xyXG4gIGNvbnN0IHdlaWdodHMgPSB7XHJcbiAgICBzeW1ib2w6IDEwLFxyXG4gICAgbmFtZTogOCxcclxuICAgIHNlY3RvcjogNSxcclxuICAgIHJlZ2lzdHJhcjogMyxcclxuICAgIGxlYWRNYW5hZ2VyczogMixcclxuICB9O1xyXG5cclxuICBzZWFyY2hUZXJtcy5mb3JFYWNoKCh0ZXJtKSA9PiB7XHJcbiAgICBjb25zdCB0ZXJtUmVnZXggPSBuZXcgUmVnRXhwKHRlcm0sICdpJyk7XHJcblxyXG4gICAgLy8gU3ltYm9sIG1hdGNoaW5nIChoaWdoZXN0IHdlaWdodClcclxuICAgIGlmIChpcG8uc3ltYm9sICYmIHRlcm1SZWdleC50ZXN0KGlwby5zeW1ib2wpKSB7XHJcbiAgICAgIHNjb3JlICs9IHdlaWdodHMuc3ltYm9sO1xyXG4gICAgICBpZiAoaXBvLnN5bWJvbC50b0xvd2VyQ2FzZSgpLnN0YXJ0c1dpdGgodGVybS50b0xvd2VyQ2FzZSgpKSkge1xyXG4gICAgICAgIHNjb3JlICs9IHdlaWdodHMuc3ltYm9sICogMC41OyAvLyBCb251cyBmb3IgcHJlZml4IG1hdGNoXHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBOYW1lIG1hdGNoaW5nXHJcbiAgICBpZiAoaXBvLm5hbWUgJiYgdGVybVJlZ2V4LnRlc3QoaXBvLm5hbWUpKSB7XHJcbiAgICAgIHNjb3JlICs9IHdlaWdodHMubmFtZTtcclxuICAgICAgY29uc3QgbmFtZVdvcmRzID0gaXBvLm5hbWUudG9Mb3dlckNhc2UoKS5zcGxpdCgnICcpO1xyXG4gICAgICBpZiAobmFtZVdvcmRzLnNvbWUoKHdvcmQpID0+IHdvcmQuc3RhcnRzV2l0aCh0ZXJtLnRvTG93ZXJDYXNlKCkpKSkge1xyXG4gICAgICAgIHNjb3JlICs9IHdlaWdodHMubmFtZSAqIDAuMzsgLy8gQm9udXMgZm9yIHdvcmQgc3RhcnQgbWF0Y2hcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIFNlY3RvciBtYXRjaGluZ1xyXG4gICAgaWYgKGlwby5zZWN0b3IgJiYgdGVybVJlZ2V4LnRlc3QoaXBvLnNlY3RvcikpIHtcclxuICAgICAgc2NvcmUgKz0gd2VpZ2h0cy5zZWN0b3I7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUmVnaXN0cmFyIG1hdGNoaW5nXHJcbiAgICBpZiAoaXBvLnJlZ2lzdHJhciAmJiB0ZXJtUmVnZXgudGVzdChpcG8ucmVnaXN0cmFyKSkge1xyXG4gICAgICBzY29yZSArPSB3ZWlnaHRzLnJlZ2lzdHJhcjtcclxuICAgIH1cclxuXHJcbiAgICAvLyBMZWFkIG1hbmFnZXJzIG1hdGNoaW5nXHJcbiAgICBpZiAoaXBvLmxlYWRNYW5hZ2VycyAmJiBBcnJheS5pc0FycmF5KGlwby5sZWFkTWFuYWdlcnMpKSB7XHJcbiAgICAgIGlwby5sZWFkTWFuYWdlcnMuZm9yRWFjaCgobWFuYWdlcikgPT4ge1xyXG4gICAgICAgIGlmICh0ZXJtUmVnZXgudGVzdChtYW5hZ2VyKSkge1xyXG4gICAgICAgICAgc2NvcmUgKz0gd2VpZ2h0cy5sZWFkTWFuYWdlcnM7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9KTtcclxuXHJcbiAgLy8gQXBwbHkgc2VhcmNoIHR5cGUgYm9vc3RcclxuICBpZiAoc2VhcmNoVHlwZSAhPT0gJ2FsbCcpIHtcclxuICAgIGNvbnN0IHR5cGVCb29zdHMgPSB7XHJcbiAgICAgIHN5bWJvbDogaXBvLnN5bWJvbCA/IDEuNSA6IDAuNSxcclxuICAgICAgbmFtZTogaXBvLm5hbWUgPyAxLjMgOiAwLjcsXHJcbiAgICAgIHNlY3RvcjogaXBvLnNlY3RvciA/IDEuMiA6IDAuOCxcclxuICAgICAgcmVnaXN0cmFyOiBpcG8ucmVnaXN0cmFyID8gMS4xIDogMC45LFxyXG4gICAgfTtcclxuICAgIHNjb3JlICo9IHR5cGVCb29zdHNbc2VhcmNoVHlwZV0gfHwgMS4wO1xyXG4gIH1cclxuXHJcbiAgLy8gQXBwbHkgc3RhdHVzIGJvb3N0IChvcGVuIElQT3MgZ2V0IGhpZ2hlciByZWxldmFuY2UpXHJcbiAgY29uc3Qgc3RhdHVzQm9vc3RzID0ge1xyXG4gICAgb3BlbjogMS41LFxyXG4gICAgdXBjb21pbmc6IDEuMixcclxuICAgIGNsb3NlZDogMS4wLFxyXG4gICAgbGlzdGVkOiAwLjgsXHJcbiAgfTtcclxuICBzY29yZSAqPSBzdGF0dXNCb29zdHNbaXBvLnN0YXR1c10gfHwgMS4wO1xyXG5cclxuICByZXR1cm4gTWF0aC5yb3VuZChzY29yZSAqIDEwMCkgLyAxMDA7XHJcbn1cclxuXHJcbi8vIEFwcGx5IGFkZGl0aW9uYWwgZmlsdGVycyB0byB3aGVyZSBjbGF1c2VcclxuZnVuY3Rpb24gYXBwbHlBZGRpdGlvbmFsRmlsdGVycyh3aGVyZUNsYXVzZSwgZmlsdGVycykge1xyXG4gIGNvbnN0IHtcclxuICAgIHN0YXR1cyxcclxuICAgIHNlY3RvcixcclxuICAgIHJlZ2lzdHJhcixcclxuICAgIG1pblByaWNlLFxyXG4gICAgbWF4UHJpY2UsXHJcbiAgICBtaW5Jc3N1ZVNpemUsXHJcbiAgICBtYXhJc3N1ZVNpemUsXHJcbiAgICBkYXRlRnJvbSxcclxuICAgIGRhdGVUbyxcclxuICB9ID0gZmlsdGVycztcclxuXHJcbiAgaWYgKHN0YXR1cyAmJiBzdGF0dXMgIT09ICdhbGwnKSB7XHJcbiAgICB3aGVyZUNsYXVzZS5zdGF0dXMgPSBzdGF0dXMuaW5jbHVkZXMoJywnKSA/IHsgaW46IHN0YXR1cy5zcGxpdCgnLCcpIH0gOiBzdGF0dXM7XHJcbiAgfVxyXG5cclxuICBpZiAoc2VjdG9yKSB7XHJcbiAgICB3aGVyZUNsYXVzZS5zZWN0b3IgPSBzZWN0b3IuaW5jbHVkZXMoJywnKVxyXG4gICAgICA/IHsgaW46IHNlY3Rvci5zcGxpdCgnLCcpIH1cclxuICAgICAgOiB7IGNvbnRhaW5zOiBzZWN0b3IsIG1vZGU6ICdpbnNlbnNpdGl2ZScgfTtcclxuICB9XHJcblxyXG4gIGlmIChyZWdpc3RyYXIpIHtcclxuICAgIHdoZXJlQ2xhdXNlLnJlZ2lzdHJhciA9IHsgY29udGFpbnM6IHJlZ2lzdHJhciwgbW9kZTogJ2luc2Vuc2l0aXZlJyB9O1xyXG4gIH1cclxuXHJcbiAgaWYgKG1pblByaWNlICYmICFpc05hTihtaW5QcmljZSkpIHtcclxuICAgIHdoZXJlQ2xhdXNlLm1heFByaWNlID0geyBndGU6IG1pblByaWNlIH07XHJcbiAgfVxyXG4gIGlmIChtYXhQcmljZSAmJiAhaXNOYU4obWF4UHJpY2UpKSB7XHJcbiAgICB3aGVyZUNsYXVzZS5taW5QcmljZSA9IHsgbHRlOiBtYXhQcmljZSB9O1xyXG4gIH1cclxuXHJcbiAgaWYgKG1pbklzc3VlU2l6ZSAmJiAhaXNOYU4obWluSXNzdWVTaXplKSkge1xyXG4gICAgd2hlcmVDbGF1c2UuaXNzdWVTaXplID0ge1xyXG4gICAgICAuLi4od2hlcmVDbGF1c2UuaXNzdWVTaXplIHx8IHt9KSxcclxuICAgICAgZ3RlOiBtaW5Jc3N1ZVNpemUgKiAxMDAwMDAwMCxcclxuICAgIH07XHJcbiAgfVxyXG4gIGlmIChtYXhJc3N1ZVNpemUgJiYgIWlzTmFOKG1heElzc3VlU2l6ZSkpIHtcclxuICAgIHdoZXJlQ2xhdXNlLmlzc3VlU2l6ZSA9IHtcclxuICAgICAgLi4uKHdoZXJlQ2xhdXNlLmlzc3VlU2l6ZSB8fCB7fSksXHJcbiAgICAgIGx0ZTogbWF4SXNzdWVTaXplICogMTAwMDAwMDAsXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgaWYgKGRhdGVGcm9tIHx8IGRhdGVUbykge1xyXG4gICAgY29uc3QgZGF0ZUZpbHRlciA9IHt9O1xyXG4gICAgaWYgKGRhdGVGcm9tKSBkYXRlRmlsdGVyLmd0ZSA9IG5ldyBEYXRlKGRhdGVGcm9tKTtcclxuICAgIGlmIChkYXRlVG8pIGRhdGVGaWx0ZXIubHRlID0gbmV3IERhdGUoZGF0ZVRvKTtcclxuICAgIHdoZXJlQ2xhdXNlLm9wZW5EYXRlID0gZGF0ZUZpbHRlcjtcclxuICB9XHJcbn1cclxuXHJcbi8vIEFwcGx5IGFkdmFuY2VkIGZpbHRlcnMgKEdNUCwgc3Vic2NyaXB0aW9uKVxyXG5hc3luYyBmdW5jdGlvbiBhcHBseUFkdmFuY2VkRmlsdGVycyhpcG9zLCBmaWx0ZXJzKSB7XHJcbiAgY29uc3QgeyBtaW5HTVAsIG1heEdNUCwgc3Vic2NyaXB0aW9uTWluLCBzdWJzY3JpcHRpb25NYXggfSA9IGZpbHRlcnM7XHJcblxyXG4gIHJldHVybiBpcG9zLmZpbHRlcigoaXBvKSA9PiB7XHJcbiAgICAvLyBHTVAgZmlsdGVyaW5nXHJcbiAgICBpZiAobWluR01QIHx8IG1heEdNUCkge1xyXG4gICAgICBjb25zdCBsYXRlc3RHTVAgPSBpcG8uZ21wPy5bMF07XHJcbiAgICAgIGlmICghbGF0ZXN0R01QKSByZXR1cm4gZmFsc2U7XHJcblxyXG4gICAgICBpZiAobWluR01QICYmIGxhdGVzdEdNUC52YWx1ZSA8IG1pbkdNUCkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICBpZiAobWF4R01QICYmIGxhdGVzdEdNUC52YWx1ZSA+IG1heEdNUCkgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFN1YnNjcmlwdGlvbiBmaWx0ZXJpbmdcclxuICAgIGlmIChzdWJzY3JpcHRpb25NaW4gfHwgc3Vic2NyaXB0aW9uTWF4KSB7XHJcbiAgICAgIGlmICghaXBvLnN1YnNjcmlwdGlvbiB8fCBpcG8uc3Vic2NyaXB0aW9uLmxlbmd0aCA9PT0gMCkgcmV0dXJuIGZhbHNlO1xyXG5cclxuICAgICAgY29uc3QgbWF4U3Vic2NyaXB0aW9uID0gTWF0aC5tYXgoLi4uaXBvLnN1YnNjcmlwdGlvbi5tYXAoKHMpID0+IHMuc3Vic2NyaXB0aW9uUmF0aW8pKTtcclxuXHJcbiAgICAgIGlmIChzdWJzY3JpcHRpb25NaW4gJiYgbWF4U3Vic2NyaXB0aW9uIDwgc3Vic2NyaXB0aW9uTWluKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgIGlmIChzdWJzY3JpcHRpb25NYXggJiYgbWF4U3Vic2NyaXB0aW9uID4gc3Vic2NyaXB0aW9uTWF4KSByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfSk7XHJcbn1cclxuXHJcbi8vIEJ1aWxkIG9yZGVyIGNsYXVzZSBmb3Igc29ydGluZ1xyXG5mdW5jdGlvbiBidWlsZE9yZGVyQ2xhdXNlKHNvcnRCeSwgc29ydE9yZGVyKSB7XHJcbiAgY29uc3Qgb3JkZXJEaXJlY3Rpb24gPSBzb3J0T3JkZXIgPT09ICdhc2MnID8gJ2FzYycgOiAnZGVzYyc7XHJcblxyXG4gIHN3aXRjaCAoc29ydEJ5KSB7XHJcbiAgICBjYXNlICdvcGVuRGF0ZSc6XHJcbiAgICAgIHJldHVybiB7IG9wZW5EYXRlOiBvcmRlckRpcmVjdGlvbiB9O1xyXG4gICAgY2FzZSAnY2xvc2VEYXRlJzpcclxuICAgICAgcmV0dXJuIHsgY2xvc2VEYXRlOiBvcmRlckRpcmVjdGlvbiB9O1xyXG4gICAgY2FzZSAnbGlzdGluZ0RhdGUnOlxyXG4gICAgICByZXR1cm4geyBsaXN0aW5nRGF0ZTogb3JkZXJEaXJlY3Rpb24gfTtcclxuICAgIGNhc2UgJ2lzc3VlU2l6ZSc6XHJcbiAgICAgIHJldHVybiB7IGlzc3VlU2l6ZTogb3JkZXJEaXJlY3Rpb24gfTtcclxuICAgIGNhc2UgJ21heFByaWNlJzpcclxuICAgICAgcmV0dXJuIHsgbWF4UHJpY2U6IG9yZGVyRGlyZWN0aW9uIH07XHJcbiAgICBjYXNlICduYW1lJzpcclxuICAgICAgcmV0dXJuIHsgbmFtZTogb3JkZXJEaXJlY3Rpb24gfTtcclxuICAgIGNhc2UgJ3N5bWJvbCc6XHJcbiAgICAgIHJldHVybiB7IHN5bWJvbDogb3JkZXJEaXJlY3Rpb24gfTtcclxuICAgIGNhc2UgJ3N0YXR1cyc6XHJcbiAgICAgIHJldHVybiB7IHN0YXR1czogb3JkZXJEaXJlY3Rpb24gfTtcclxuICAgIGNhc2UgJ3NlY3Rvcic6XHJcbiAgICAgIHJldHVybiB7IHNlY3Rvcjogb3JkZXJEaXJlY3Rpb24gfTtcclxuICAgIGNhc2UgJ2NyZWF0ZWRBdCc6XHJcbiAgICAgIHJldHVybiB7IGNyZWF0ZWRBdDogb3JkZXJEaXJlY3Rpb24gfTtcclxuICAgIGRlZmF1bHQ6XHJcbiAgICAgIHJldHVybiB7IHVwZGF0ZWRBdDogJ2Rlc2MnIH07XHJcbiAgfVxyXG59XHJcblxyXG4vLyBTb3J0IHJlc3VsdHMgbWFudWFsbHkgKGZvciByZWxldmFuY2UtYmFzZWQgc29ydGluZylcclxuZnVuY3Rpb24gc29ydFJlc3VsdHMocmVzdWx0cywgb3JkZXJCeSkge1xyXG4gIGlmICghb3JkZXJCeSB8fCB0eXBlb2Ygb3JkZXJCeSAhPT0gJ29iamVjdCcpIHJldHVybiByZXN1bHRzO1xyXG5cclxuICBjb25zdCBbZmllbGQsIGRpcmVjdGlvbl0gPSBPYmplY3QuZW50cmllcyhvcmRlckJ5KVswXTtcclxuXHJcbiAgcmV0dXJuIHJlc3VsdHMuc29ydCgoYSwgYikgPT4ge1xyXG4gICAgbGV0IGFWYWwgPSBhW2ZpZWxkXTtcclxuICAgIGxldCBiVmFsID0gYltmaWVsZF07XHJcblxyXG4gICAgLy8gSGFuZGxlIGRpZmZlcmVudCBkYXRhIHR5cGVzXHJcbiAgICBpZiAoYVZhbCBpbnN0YW5jZW9mIERhdGUpIGFWYWwgPSBhVmFsLmdldFRpbWUoKTtcclxuICAgIGlmIChiVmFsIGluc3RhbmNlb2YgRGF0ZSkgYlZhbCA9IGJWYWwuZ2V0VGltZSgpO1xyXG4gICAgaWYgKHR5cGVvZiBhVmFsID09PSAnc3RyaW5nJykgYVZhbCA9IGFWYWwudG9Mb3dlckNhc2UoKTtcclxuICAgIGlmICh0eXBlb2YgYlZhbCA9PT0gJ3N0cmluZycpIGJWYWwgPSBiVmFsLnRvTG93ZXJDYXNlKCk7XHJcblxyXG4gICAgLy8gSGFuZGxlIG51bGwvdW5kZWZpbmVkIHZhbHVlc1xyXG4gICAgaWYgKGFWYWwgPT0gbnVsbCAmJiBiVmFsID09IG51bGwpIHJldHVybiAwO1xyXG4gICAgaWYgKGFWYWwgPT0gbnVsbCkgcmV0dXJuIGRpcmVjdGlvbiA9PT0gJ2FzYycgPyAtMSA6IDE7XHJcbiAgICBpZiAoYlZhbCA9PSBudWxsKSByZXR1cm4gZGlyZWN0aW9uID09PSAnYXNjJyA/IDEgOiAtMTtcclxuXHJcbiAgICAvLyBDb21wYXJlIHZhbHVlc1xyXG4gICAgaWYgKGFWYWwgPCBiVmFsKSByZXR1cm4gZGlyZWN0aW9uID09PSAnYXNjJyA/IC0xIDogMTtcclxuICAgIGlmIChhVmFsID4gYlZhbCkgcmV0dXJuIGRpcmVjdGlvbiA9PT0gJ2FzYycgPyAxIDogLTE7XHJcbiAgICByZXR1cm4gMDtcclxuICB9KTtcclxufVxyXG5cclxuLy8gUHJvY2VzcyBzZWFyY2ggcmVzdWx0IHdpdGggaGlnaGxpZ2h0aW5nIGFuZCBlbmhhbmNlbWVudHNcclxuYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc1NlYXJjaFJlc3VsdChpcG8sIG9wdGlvbnMpIHtcclxuICBjb25zdCB7IGluY2x1ZGVBbmFseXRpY3MsIGluY2x1ZGVQcmVkaWN0aW9ucywgaGlnaGxpZ2h0LCBzZWFyY2hUZXJtcywgcmVsZXZhbmNlU2NvcmUgfSA9IG9wdGlvbnM7XHJcblxyXG4gIC8vIEJhc2UgcmVzdWx0XHJcbiAgY29uc3QgcmVzdWx0ID0ge1xyXG4gICAgaWQ6IGlwby5pZCxcclxuICAgIHN5bWJvbDogaXBvLnN5bWJvbCxcclxuICAgIG5hbWU6IGlwby5uYW1lLFxyXG4gICAgc2VjdG9yOiBpcG8uc2VjdG9yLFxyXG4gICAgc3RhdHVzOiBpcG8uc3RhdHVzLFxyXG4gICAgb3BlbkRhdGU6IGlwby5vcGVuRGF0ZSxcclxuICAgIGNsb3NlRGF0ZTogaXBvLmNsb3NlRGF0ZSxcclxuICAgIGxpc3RpbmdEYXRlOiBpcG8ubGlzdGluZ0RhdGUsXHJcbiAgICBtaW5QcmljZTogaXBvLm1pblByaWNlLFxyXG4gICAgbWF4UHJpY2U6IGlwby5tYXhQcmljZSxcclxuICAgIGxvdFNpemU6IGlwby5sb3RTaXplLFxyXG4gICAgaXNzdWVTaXplOiBpcG8uaXNzdWVTaXplPy50b1N0cmluZygpLFxyXG4gICAgcmVnaXN0cmFyOiBpcG8ucmVnaXN0cmFyLFxyXG4gICAgbGVhZE1hbmFnZXJzOiBpcG8ubGVhZE1hbmFnZXJzLFxyXG4gICAgY2F0ZWdvcmllczogaXBvLmNhdGVnb3JpZXMsXHJcbiAgICByZWxldmFuY2VTY29yZSxcclxuXHJcbiAgICAvLyBDdXJyZW50IG1ldHJpY3NcclxuICAgIGN1cnJlbnRNZXRyaWNzOiB7XHJcbiAgICAgIGdtcDogaXBvLmdtcD8uWzBdXHJcbiAgICAgICAgPyB7XHJcbiAgICAgICAgICAgIHZhbHVlOiBpcG8uZ21wWzBdLnZhbHVlLFxyXG4gICAgICAgICAgICBwZXJjZW50YWdlOiBpcG8uZ21wWzBdLnBlcmNlbnRhZ2UsXHJcbiAgICAgICAgICAgIHRpbWVzdGFtcDogaXBvLmdtcFswXS50aW1lc3RhbXAsXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgOiBudWxsLFxyXG4gICAgICBzdWJzY3JpcHRpb246IGdldExhdGVzdFN1YnNjcmlwdGlvbihpcG8uc3Vic2NyaXB0aW9uKSxcclxuICAgIH0sXHJcbiAgfTtcclxuXHJcbiAgLy8gQWRkIGhpZ2hsaWdodGluZyBpZiByZXF1ZXN0ZWRcclxuICBpZiAoaGlnaGxpZ2h0ICYmIHNlYXJjaFRlcm1zICYmIHNlYXJjaFRlcm1zLmxlbmd0aCA+IDApIHtcclxuICAgIHJlc3VsdC5oaWdobGlnaHRzID0gZ2VuZXJhdGVIaWdobGlnaHRzKGlwbywgc2VhcmNoVGVybXMpO1xyXG4gIH1cclxuXHJcbiAgLy8gQWRkIGFuYWx5dGljcyBpZiByZXF1ZXN0ZWRcclxuICBpZiAoaW5jbHVkZUFuYWx5dGljcyAmJiBpcG8uYW5hbHl0aWNzKSB7XHJcbiAgICByZXN1bHQuYW5hbHl0aWNzID0ge1xyXG4gICAgICByaXNrU2NvcmU6IGlwby5hbmFseXRpY3Mucmlza1Njb3JlLFxyXG4gICAgICBwcmVkaWN0ZWRMaXN0aW5nR2FpbjogaXBvLmFuYWx5dGljcy5wcmVkaWN0ZWRMaXN0aW5nR2FpbixcclxuICAgICAgYXZnR01QOiBpcG8uYW5hbHl0aWNzLmF2Z0dNUCxcclxuICAgICAgZmluYWxTdWJzY3JpcHRpb246IGlwby5hbmFseXRpY3MuZmluYWxTdWJzY3JpcHRpb24sXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgLy8gQWRkIHByZWRpY3Rpb25zIGlmIHJlcXVlc3RlZFxyXG4gIGlmIChpbmNsdWRlUHJlZGljdGlvbnMpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IFtsaXN0aW5nR2FpbiwgbWFya2V0U2VudGltZW50XSA9IGF3YWl0IFByb21pc2UuYWxsU2V0dGxlZChbXHJcbiAgICAgICAgcHJlZGljdGlvblNlcnZpY2UucHJlZGljdExpc3RpbmdHYWluKGlwby5pZCksXHJcbiAgICAgICAgcHJlZGljdGlvblNlcnZpY2UucHJlZGljdE1hcmtldFNlbnRpbWVudChpcG8uaWQpLFxyXG4gICAgICBdKTtcclxuXHJcbiAgICAgIHJlc3VsdC5wcmVkaWN0aW9ucyA9IHtcclxuICAgICAgICBsaXN0aW5nR2FpbjogbGlzdGluZ0dhaW4uc3RhdHVzID09PSAnZnVsZmlsbGVkJyA/IGxpc3RpbmdHYWluLnZhbHVlIDogbnVsbCxcclxuICAgICAgICBtYXJrZXRTZW50aW1lbnQ6IG1hcmtldFNlbnRpbWVudC5zdGF0dXMgPT09ICdmdWxmaWxsZWQnID8gbWFya2V0U2VudGltZW50LnZhbHVlIDogbnVsbCxcclxuICAgICAgfTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIHJlc3VsdC5wcmVkaWN0aW9ucyA9IG51bGw7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gcmVzdWx0O1xyXG59XHJcblxyXG4vLyBHZW5lcmF0ZSB0ZXh0IGhpZ2hsaWdodHMgZm9yIHNlYXJjaCB0ZXJtc1xyXG5mdW5jdGlvbiBnZW5lcmF0ZUhpZ2hsaWdodHMoaXBvLCBzZWFyY2hUZXJtcykge1xyXG4gIGNvbnN0IGhpZ2hsaWdodHMgPSB7fTtcclxuXHJcbiAgY29uc3QgaGlnaGxpZ2h0VGV4dCA9ICh0ZXh0LCB0ZXJtcykgPT4ge1xyXG4gICAgaWYgKCF0ZXh0IHx8ICF0ZXJtcy5sZW5ndGgpIHJldHVybiB0ZXh0O1xyXG5cclxuICAgIGxldCBoaWdobGlnaHRlZFRleHQgPSB0ZXh0O1xyXG4gICAgdGVybXMuZm9yRWFjaCgodGVybSkgPT4ge1xyXG4gICAgICBjb25zdCByZWdleCA9IG5ldyBSZWdFeHAoYCgke3Rlcm19KWAsICdnaScpO1xyXG4gICAgICBoaWdobGlnaHRlZFRleHQgPSBoaWdobGlnaHRlZFRleHQucmVwbGFjZShyZWdleCwgJzxtYXJrPiQxPC9tYXJrPicpO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gaGlnaGxpZ2h0ZWRUZXh0O1xyXG4gIH07XHJcblxyXG4gIC8vIEhpZ2hsaWdodCBkaWZmZXJlbnQgZmllbGRzXHJcbiAgaWYgKGlwby5zeW1ib2wpIHtcclxuICAgIGNvbnN0IGhpZ2hsaWdodGVkID0gaGlnaGxpZ2h0VGV4dChpcG8uc3ltYm9sLCBzZWFyY2hUZXJtcyk7XHJcbiAgICBpZiAoaGlnaGxpZ2h0ZWQgIT09IGlwby5zeW1ib2wpIHtcclxuICAgICAgaGlnaGxpZ2h0cy5zeW1ib2wgPSBoaWdobGlnaHRlZDtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGlmIChpcG8ubmFtZSkge1xyXG4gICAgY29uc3QgaGlnaGxpZ2h0ZWQgPSBoaWdobGlnaHRUZXh0KGlwby5uYW1lLCBzZWFyY2hUZXJtcyk7XHJcbiAgICBpZiAoaGlnaGxpZ2h0ZWQgIT09IGlwby5uYW1lKSB7XHJcbiAgICAgIGhpZ2hsaWdodHMubmFtZSA9IGhpZ2hsaWdodGVkO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgaWYgKGlwby5zZWN0b3IpIHtcclxuICAgIGNvbnN0IGhpZ2hsaWdodGVkID0gaGlnaGxpZ2h0VGV4dChpcG8uc2VjdG9yLCBzZWFyY2hUZXJtcyk7XHJcbiAgICBpZiAoaGlnaGxpZ2h0ZWQgIT09IGlwby5zZWN0b3IpIHtcclxuICAgICAgaGlnaGxpZ2h0cy5zZWN0b3IgPSBoaWdobGlnaHRlZDtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGlmIChpcG8ucmVnaXN0cmFyKSB7XHJcbiAgICBjb25zdCBoaWdobGlnaHRlZCA9IGhpZ2hsaWdodFRleHQoaXBvLnJlZ2lzdHJhciwgc2VhcmNoVGVybXMpO1xyXG4gICAgaWYgKGhpZ2hsaWdodGVkICE9PSBpcG8ucmVnaXN0cmFyKSB7XHJcbiAgICAgIGhpZ2hsaWdodHMucmVnaXN0cmFyID0gaGlnaGxpZ2h0ZWQ7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gaGlnaGxpZ2h0cztcclxufVxyXG5cclxuLy8gR2V0IGxhdGVzdCBzdWJzY3JpcHRpb24gZGF0YVxyXG5mdW5jdGlvbiBnZXRMYXRlc3RTdWJzY3JpcHRpb24oc3Vic2NyaXB0aW9uRGF0YSkge1xyXG4gIGlmICghc3Vic2NyaXB0aW9uRGF0YSB8fCBzdWJzY3JpcHRpb25EYXRhLmxlbmd0aCA9PT0gMCkgcmV0dXJuIG51bGw7XHJcblxyXG4gIGNvbnN0IGxhdGVzdCA9IHN1YnNjcmlwdGlvbkRhdGEucmVkdWNlKChsYXRlc3QsIGN1cnJlbnQpID0+IHtcclxuICAgIHJldHVybiBjdXJyZW50LnRpbWVzdGFtcCA+IGxhdGVzdC50aW1lc3RhbXAgPyBjdXJyZW50IDogbGF0ZXN0O1xyXG4gIH0pO1xyXG5cclxuICByZXR1cm4ge1xyXG4gICAgY2F0ZWdvcnk6IGxhdGVzdC5jYXRlZ29yeSxcclxuICAgIHN1YnNjcmlwdGlvblJhdGlvOiBsYXRlc3Quc3Vic2NyaXB0aW9uUmF0aW8sXHJcbiAgICBxdWFudGl0eTogbGF0ZXN0LnF1YW50aXR5Py50b1N0cmluZygpLFxyXG4gICAgYmlkQ291bnQ6IGxhdGVzdC5iaWRDb3VudCxcclxuICAgIHRpbWVzdGFtcDogbGF0ZXN0LnRpbWVzdGFtcCxcclxuICB9O1xyXG59XHJcblxyXG4vLyBHZW5lcmF0ZSBzZWFyY2ggc3VnZ2VzdGlvbnNcclxuYXN5bmMgZnVuY3Rpb24gZ2VuZXJhdGVTZWFyY2hTdWdnZXN0aW9ucyhxdWVyeSwgb3B0aW9ucykge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCB7IHR5cGUsIHN0YXR1cywgc2VjdG9yLCBsaW1pdCB9ID0gb3B0aW9ucztcclxuICAgIGNvbnN0IHByb2Nlc3NlZFF1ZXJ5ID0gcHJvY2Vzc1NlYXJjaFF1ZXJ5KHF1ZXJ5KTtcclxuXHJcbiAgICBpZiAocHJvY2Vzc2VkUXVlcnkubGVuZ3RoIDwgMikgcmV0dXJuIFtdO1xyXG5cclxuICAgIC8vIEdldCBzdWdnZXN0aW9ucyBmcm9tIGRpZmZlcmVudCBzb3VyY2VzXHJcbiAgICBjb25zdCBzdWdnZXN0aW9ucyA9IFtdO1xyXG5cclxuICAgIC8vIFN5bWJvbCBzdWdnZXN0aW9uc1xyXG4gICAgY29uc3Qgc3ltYm9sU3VnZ2VzdGlvbnMgPSBhd2FpdCBwcmlzbWEuaVBPLmZpbmRNYW55KHtcclxuICAgICAgd2hlcmU6IHtcclxuICAgICAgICBpc0FjdGl2ZTogdHJ1ZSxcclxuICAgICAgICBzeW1ib2w6IHsgY29udGFpbnM6IHByb2Nlc3NlZFF1ZXJ5LnRvVXBwZXJDYXNlKCkgfSxcclxuICAgICAgICAuLi4oc3RhdHVzICYmIHN0YXR1cyAhPT0gJ2FsbCcgPyB7IHN0YXR1cyB9IDoge30pLFxyXG4gICAgICB9LFxyXG4gICAgICBzZWxlY3Q6IHsgc3ltYm9sOiB0cnVlLCBuYW1lOiB0cnVlIH0sXHJcbiAgICAgIHRha2U6IDUsXHJcbiAgICB9KTtcclxuXHJcbiAgICBzeW1ib2xTdWdnZXN0aW9ucy5mb3JFYWNoKChpcG8pID0+IHtcclxuICAgICAgc3VnZ2VzdGlvbnMucHVzaCh7XHJcbiAgICAgICAgdHlwZTogJ3N5bWJvbCcsXHJcbiAgICAgICAgdmFsdWU6IGlwby5zeW1ib2wsXHJcbiAgICAgICAgZGlzcGxheTogYCR7aXBvLnN5bWJvbH0gLSAke2lwby5uYW1lfWAsXHJcbiAgICAgICAgY2F0ZWdvcnk6ICdTeW1ib2wnLFxyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIE5hbWUgc3VnZ2VzdGlvbnNcclxuICAgIGNvbnN0IG5hbWVTdWdnZXN0aW9ucyA9IGF3YWl0IHByaXNtYS5pUE8uZmluZE1hbnkoe1xyXG4gICAgICB3aGVyZToge1xyXG4gICAgICAgIGlzQWN0aXZlOiB0cnVlLFxyXG4gICAgICAgIG5hbWU6IHsgY29udGFpbnM6IHByb2Nlc3NlZFF1ZXJ5LCBtb2RlOiAnaW5zZW5zaXRpdmUnIH0sXHJcbiAgICAgICAgLi4uKHN0YXR1cyAmJiBzdGF0dXMgIT09ICdhbGwnID8geyBzdGF0dXMgfSA6IHt9KSxcclxuICAgICAgfSxcclxuICAgICAgc2VsZWN0OiB7IHN5bWJvbDogdHJ1ZSwgbmFtZTogdHJ1ZSB9LFxyXG4gICAgICB0YWtlOiA1LFxyXG4gICAgfSk7XHJcblxyXG4gICAgbmFtZVN1Z2dlc3Rpb25zLmZvckVhY2goKGlwbykgPT4ge1xyXG4gICAgICBpZiAoIXN1Z2dlc3Rpb25zLnNvbWUoKHMpID0+IHMudmFsdWUgPT09IGlwby5zeW1ib2wpKSB7XHJcbiAgICAgICAgc3VnZ2VzdGlvbnMucHVzaCh7XHJcbiAgICAgICAgICB0eXBlOiAnbmFtZScsXHJcbiAgICAgICAgICB2YWx1ZTogaXBvLm5hbWUsXHJcbiAgICAgICAgICBkaXNwbGF5OiBgJHtpcG8ubmFtZX0gKCR7aXBvLnN5bWJvbH0pYCxcclxuICAgICAgICAgIGNhdGVnb3J5OiAnQ29tcGFueScsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIC8vIFNlY3RvciBzdWdnZXN0aW9uc1xyXG4gICAgY29uc3Qgc2VjdG9yU3VnZ2VzdGlvbnMgPSBhd2FpdCBwcmlzbWEuaVBPLmdyb3VwQnkoe1xyXG4gICAgICBieTogWydzZWN0b3InXSxcclxuICAgICAgd2hlcmU6IHtcclxuICAgICAgICBpc0FjdGl2ZTogdHJ1ZSxcclxuICAgICAgICBzZWN0b3I6IHsgY29udGFpbnM6IHByb2Nlc3NlZFF1ZXJ5LCBtb2RlOiAnaW5zZW5zaXRpdmUnIH0sXHJcbiAgICAgICAgLi4uKHN0YXR1cyAmJiBzdGF0dXMgIT09ICdhbGwnID8geyBzdGF0dXMgfSA6IHt9KSxcclxuICAgICAgfSxcclxuICAgICAgX2NvdW50OiB7IHNlY3RvcjogdHJ1ZSB9LFxyXG4gICAgICB0YWtlOiAzLFxyXG4gICAgfSk7XHJcblxyXG4gICAgc2VjdG9yU3VnZ2VzdGlvbnMuZm9yRWFjaCgoaXRlbSkgPT4ge1xyXG4gICAgICBpZiAoaXRlbS5zZWN0b3IpIHtcclxuICAgICAgICBzdWdnZXN0aW9ucy5wdXNoKHtcclxuICAgICAgICAgIHR5cGU6ICdzZWN0b3InLFxyXG4gICAgICAgICAgdmFsdWU6IGl0ZW0uc2VjdG9yLFxyXG4gICAgICAgICAgZGlzcGxheTogYCR7aXRlbS5zZWN0b3J9ICgke2l0ZW0uX2NvdW50LnNlY3Rvcn0gSVBPcylgLFxyXG4gICAgICAgICAgY2F0ZWdvcnk6ICdTZWN0b3InLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBSZWdpc3RyYXIgc3VnZ2VzdGlvbnNcclxuICAgIGNvbnN0IHJlZ2lzdHJhclN1Z2dlc3Rpb25zID0gYXdhaXQgcHJpc21hLmlQTy5ncm91cEJ5KHtcclxuICAgICAgYnk6IFsncmVnaXN0cmFyJ10sXHJcbiAgICAgIHdoZXJlOiB7XHJcbiAgICAgICAgaXNBY3RpdmU6IHRydWUsXHJcbiAgICAgICAgcmVnaXN0cmFyOiB7IGNvbnRhaW5zOiBwcm9jZXNzZWRRdWVyeSwgbW9kZTogJ2luc2Vuc2l0aXZlJyB9LFxyXG4gICAgICAgIC4uLihzdGF0dXMgJiYgc3RhdHVzICE9PSAnYWxsJyA/IHsgc3RhdHVzIH0gOiB7fSksXHJcbiAgICAgIH0sXHJcbiAgICAgIF9jb3VudDogeyByZWdpc3RyYXI6IHRydWUgfSxcclxuICAgICAgdGFrZTogMyxcclxuICAgIH0pO1xyXG5cclxuICAgIHJlZ2lzdHJhclN1Z2dlc3Rpb25zLmZvckVhY2goKGl0ZW0pID0+IHtcclxuICAgICAgaWYgKGl0ZW0ucmVnaXN0cmFyKSB7XHJcbiAgICAgICAgc3VnZ2VzdGlvbnMucHVzaCh7XHJcbiAgICAgICAgICB0eXBlOiAncmVnaXN0cmFyJyxcclxuICAgICAgICAgIHZhbHVlOiBpdGVtLnJlZ2lzdHJhcixcclxuICAgICAgICAgIGRpc3BsYXk6IGAke2l0ZW0ucmVnaXN0cmFyfSAoJHtpdGVtLl9jb3VudC5yZWdpc3RyYXJ9IElQT3MpYCxcclxuICAgICAgICAgIGNhdGVnb3J5OiAnUmVnaXN0cmFyJyxcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gU29ydCBieSByZWxldmFuY2UgYW5kIGxpbWl0XHJcbiAgICByZXR1cm4gc3VnZ2VzdGlvbnNcclxuICAgICAgLnNvcnQoKGEsIGIpID0+IHtcclxuICAgICAgICBjb25zdCB0eXBlT3JkZXIgPSB7IHN5bWJvbDogMCwgbmFtZTogMSwgc2VjdG9yOiAyLCByZWdpc3RyYXI6IDMgfTtcclxuICAgICAgICByZXR1cm4gdHlwZU9yZGVyW2EudHlwZV0gLSB0eXBlT3JkZXJbYi50eXBlXTtcclxuICAgICAgfSlcclxuICAgICAgLnNsaWNlKDAsIGxpbWl0KTtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZ2VuZXJhdGluZyBzZWFyY2ggc3VnZ2VzdGlvbnM6JywgZXJyb3IpO1xyXG4gICAgcmV0dXJuIFtdO1xyXG4gIH1cclxufVxyXG5cclxuLy8gR2VuZXJhdGUgc2VhcmNoIGFuYWx5dGljc1xyXG5hc3luYyBmdW5jdGlvbiBnZW5lcmF0ZVNlYXJjaEFuYWx5dGljcyhxdWVyeSwgcmVzdWx0cykge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCBhbmFseXRpY3MgPSB7XHJcbiAgICAgIHF1ZXJ5OiB7XHJcbiAgICAgICAgbGVuZ3RoOiBxdWVyeS5sZW5ndGgsXHJcbiAgICAgICAgd29yZENvdW50OiBxdWVyeS5zcGxpdCgnICcpLmZpbHRlcigodykgPT4gdy5sZW5ndGggPiAwKS5sZW5ndGgsXHJcbiAgICAgICAgaGFzTnVtYmVyczogL1xcZC8udGVzdChxdWVyeSksXHJcbiAgICAgICAgaGFzU3BlY2lhbENoYXJzOiAvW15hLXpBLVowLTlcXHNdLy50ZXN0KHF1ZXJ5KSxcclxuICAgICAgfSxcclxuICAgICAgcmVzdWx0czoge1xyXG4gICAgICAgIHRvdGFsOiByZXN1bHRzLmxlbmd0aCxcclxuICAgICAgICBieVN0YXR1czoge30sXHJcbiAgICAgICAgYnlTZWN0b3I6IHt9LFxyXG4gICAgICAgIHJlbGV2YW5jZURpc3RyaWJ1dGlvbjoge1xyXG4gICAgICAgICAgaGlnaDogMCwgLy8gPiA3NSUgb2YgbWF4IHJlbGV2YW5jZVxyXG4gICAgICAgICAgbWVkaXVtOiAwLCAvLyAyNS03NSUgb2YgbWF4IHJlbGV2YW5jZVxyXG4gICAgICAgICAgbG93OiAwLCAvLyA8IDI1JSBvZiBtYXggcmVsZXZhbmNlXHJcbiAgICAgICAgfSxcclxuICAgICAgfSxcclxuICAgICAgcGVyZm9ybWFuY2U6IHtcclxuICAgICAgICBzZWFyY2hUaW1lOiBEYXRlLm5vdygpICUgMTAwMCwgLy8gTW9jayBzZWFyY2ggdGltZVxyXG4gICAgICAgIGNhY2hlSGl0OiBmYWxzZSxcclxuICAgICAgfSxcclxuICAgIH07XHJcblxyXG4gICAgLy8gQW5hbHl6ZSByZXN1bHRzXHJcbiAgICBpZiAocmVzdWx0cy5sZW5ndGggPiAwKSB7XHJcbiAgICAgIGNvbnN0IG1heFJlbGV2YW5jZSA9IE1hdGgubWF4KC4uLnJlc3VsdHMubWFwKChyKSA9PiByLnJlbGV2YW5jZVNjb3JlIHx8IDApKTtcclxuXHJcbiAgICAgIHJlc3VsdHMuZm9yRWFjaCgocmVzdWx0KSA9PiB7XHJcbiAgICAgICAgLy8gU3RhdHVzIGRpc3RyaWJ1dGlvblxyXG4gICAgICAgIGFuYWx5dGljcy5yZXN1bHRzLmJ5U3RhdHVzW3Jlc3VsdC5zdGF0dXNdID1cclxuICAgICAgICAgIChhbmFseXRpY3MucmVzdWx0cy5ieVN0YXR1c1tyZXN1bHQuc3RhdHVzXSB8fCAwKSArIDE7XHJcblxyXG4gICAgICAgIC8vIFNlY3RvciBkaXN0cmlidXRpb25cclxuICAgICAgICBpZiAocmVzdWx0LnNlY3Rvcikge1xyXG4gICAgICAgICAgYW5hbHl0aWNzLnJlc3VsdHMuYnlTZWN0b3JbcmVzdWx0LnNlY3Rvcl0gPVxyXG4gICAgICAgICAgICAoYW5hbHl0aWNzLnJlc3VsdHMuYnlTZWN0b3JbcmVzdWx0LnNlY3Rvcl0gfHwgMCkgKyAxO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gUmVsZXZhbmNlIGRpc3RyaWJ1dGlvblxyXG4gICAgICAgIGNvbnN0IHJlbGV2YW5jZVBlcmNlbnQgPSBtYXhSZWxldmFuY2UgPiAwID8gKHJlc3VsdC5yZWxldmFuY2VTY29yZSB8fCAwKSAvIG1heFJlbGV2YW5jZSA6IDA7XHJcbiAgICAgICAgaWYgKHJlbGV2YW5jZVBlcmNlbnQgPiAwLjc1KSB7XHJcbiAgICAgICAgICBhbmFseXRpY3MucmVzdWx0cy5yZWxldmFuY2VEaXN0cmlidXRpb24uaGlnaCsrO1xyXG4gICAgICAgIH0gZWxzZSBpZiAocmVsZXZhbmNlUGVyY2VudCA+IDAuMjUpIHtcclxuICAgICAgICAgIGFuYWx5dGljcy5yZXN1bHRzLnJlbGV2YW5jZURpc3RyaWJ1dGlvbi5tZWRpdW0rKztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgYW5hbHl0aWNzLnJlc3VsdHMucmVsZXZhbmNlRGlzdHJpYnV0aW9uLmxvdysrO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGFuYWx5dGljcztcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZ2VuZXJhdGluZyBzZWFyY2ggYW5hbHl0aWNzOicsIGVycm9yKTtcclxuICAgIHJldHVybiB7IGVycm9yOiAnQW5hbHl0aWNzIGdlbmVyYXRpb24gZmFpbGVkJyB9O1xyXG4gIH1cclxufVxyXG5cclxuLy8gR2V0IGFwcGxpZWQgZmlsdGVycyBzdW1tYXJ5XHJcbmZ1bmN0aW9uIGdldEFwcGxpZWRGaWx0ZXJzKGZpbHRlcnMpIHtcclxuICBjb25zdCBhcHBsaWVkID0gW107XHJcblxyXG4gIE9iamVjdC5lbnRyaWVzKGZpbHRlcnMpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xyXG4gICAgaWYgKHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09ICcnKSB7XHJcbiAgICAgIGFwcGxpZWQucHVzaCh7XHJcbiAgICAgICAgdHlwZToga2V5LFxyXG4gICAgICAgIHZhbHVlLFxyXG4gICAgICAgIGRpc3BsYXk6IGZvcm1hdEZpbHRlckRpc3BsYXkoa2V5LCB2YWx1ZSksXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH0pO1xyXG5cclxuICByZXR1cm4gYXBwbGllZDtcclxufVxyXG5cclxuLy8gR2V0IGF2YWlsYWJsZSBmaWx0ZXJzIGJhc2VkIG9uIGN1cnJlbnQgcmVzdWx0c1xyXG5hc3luYyBmdW5jdGlvbiBnZXRBdmFpbGFibGVGaWx0ZXJzKHJlc3VsdHMpIHtcclxuICBjb25zdCBhdmFpbGFibGUgPSB7XHJcbiAgICBzdGF0dXM6IHt9LFxyXG4gICAgc2VjdG9yOiB7fSxcclxuICAgIHJlZ2lzdHJhcjoge30sXHJcbiAgICBwcmljZVJhbmdlOiB7IG1pbjogbnVsbCwgbWF4OiBudWxsIH0sXHJcbiAgICBpc3N1ZVNpemVSYW5nZTogeyBtaW46IG51bGwsIG1heDogbnVsbCB9LFxyXG4gIH07XHJcblxyXG4gIHJlc3VsdHMuZm9yRWFjaCgocmVzdWx0KSA9PiB7XHJcbiAgICAvLyBTdGF0dXMgb3B0aW9uc1xyXG4gICAgYXZhaWxhYmxlLnN0YXR1c1tyZXN1bHQuc3RhdHVzXSA9IChhdmFpbGFibGUuc3RhdHVzW3Jlc3VsdC5zdGF0dXNdIHx8IDApICsgMTtcclxuXHJcbiAgICAvLyBTZWN0b3Igb3B0aW9uc1xyXG4gICAgaWYgKHJlc3VsdC5zZWN0b3IpIHtcclxuICAgICAgYXZhaWxhYmxlLnNlY3RvcltyZXN1bHQuc2VjdG9yXSA9IChhdmFpbGFibGUuc2VjdG9yW3Jlc3VsdC5zZWN0b3JdIHx8IDApICsgMTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBSZWdpc3RyYXIgb3B0aW9uc1xyXG4gICAgaWYgKHJlc3VsdC5yZWdpc3RyYXIpIHtcclxuICAgICAgYXZhaWxhYmxlLnJlZ2lzdHJhcltyZXN1bHQucmVnaXN0cmFyXSA9IChhdmFpbGFibGUucmVnaXN0cmFyW3Jlc3VsdC5yZWdpc3RyYXJdIHx8IDApICsgMTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBQcmljZSByYW5nZVxyXG4gICAgaWYgKHJlc3VsdC5taW5QcmljZSkge1xyXG4gICAgICBhdmFpbGFibGUucHJpY2VSYW5nZS5taW4gPSBhdmFpbGFibGUucHJpY2VSYW5nZS5taW5cclxuICAgICAgICA/IE1hdGgubWluKGF2YWlsYWJsZS5wcmljZVJhbmdlLm1pbiwgcmVzdWx0Lm1pblByaWNlKVxyXG4gICAgICAgIDogcmVzdWx0Lm1pblByaWNlO1xyXG4gICAgfVxyXG4gICAgaWYgKHJlc3VsdC5tYXhQcmljZSkge1xyXG4gICAgICBhdmFpbGFibGUucHJpY2VSYW5nZS5tYXggPSBhdmFpbGFibGUucHJpY2VSYW5nZS5tYXhcclxuICAgICAgICA/IE1hdGgubWF4KGF2YWlsYWJsZS5wcmljZVJhbmdlLm1heCwgcmVzdWx0Lm1heFByaWNlKVxyXG4gICAgICAgIDogcmVzdWx0Lm1heFByaWNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIElzc3VlIHNpemUgcmFuZ2VcclxuICAgIGlmIChyZXN1bHQuaXNzdWVTaXplKSB7XHJcbiAgICAgIGNvbnN0IHNpemVJbkNyb3JlcyA9IHBhcnNlSW50KHJlc3VsdC5pc3N1ZVNpemUpIC8gMTAwMDAwMDA7XHJcbiAgICAgIGF2YWlsYWJsZS5pc3N1ZVNpemVSYW5nZS5taW4gPSBhdmFpbGFibGUuaXNzdWVTaXplUmFuZ2UubWluXHJcbiAgICAgICAgPyBNYXRoLm1pbihhdmFpbGFibGUuaXNzdWVTaXplUmFuZ2UubWluLCBzaXplSW5Dcm9yZXMpXHJcbiAgICAgICAgOiBzaXplSW5Dcm9yZXM7XHJcbiAgICAgIGF2YWlsYWJsZS5pc3N1ZVNpemVSYW5nZS5tYXggPSBhdmFpbGFibGUuaXNzdWVTaXplUmFuZ2UubWF4XHJcbiAgICAgICAgPyBNYXRoLm1heChhdmFpbGFibGUuaXNzdWVTaXplUmFuZ2UubWF4LCBzaXplSW5Dcm9yZXMpXHJcbiAgICAgICAgOiBzaXplSW5Dcm9yZXM7XHJcbiAgICB9XHJcbiAgfSk7XHJcblxyXG4gIHJldHVybiBhdmFpbGFibGU7XHJcbn1cclxuXHJcbi8vIEdldCBzb3J0aW5nIG9wdGlvbnNcclxuZnVuY3Rpb24gZ2V0U29ydGluZ09wdGlvbnMoKSB7XHJcbiAgcmV0dXJuIFtcclxuICAgIHsgdmFsdWU6ICdyZWxldmFuY2UnLCBsYWJlbDogJ1JlbGV2YW5jZScsIGRlc2NyaXB0aW9uOiAnQmVzdCBtYXRjaCBmaXJzdCcgfSxcclxuICAgIHtcclxuICAgICAgdmFsdWU6ICdvcGVuRGF0ZScsXHJcbiAgICAgIGxhYmVsOiAnT3BlbiBEYXRlJyxcclxuICAgICAgZGVzY3JpcHRpb246ICdTb3J0IGJ5IElQTyBvcGVuaW5nIGRhdGUnLFxyXG4gICAgfSxcclxuICAgIHtcclxuICAgICAgdmFsdWU6ICdjbG9zZURhdGUnLFxyXG4gICAgICBsYWJlbDogJ0Nsb3NlIERhdGUnLFxyXG4gICAgICBkZXNjcmlwdGlvbjogJ1NvcnQgYnkgSVBPIGNsb3NpbmcgZGF0ZScsXHJcbiAgICB9LFxyXG4gICAge1xyXG4gICAgICB2YWx1ZTogJ2lzc3VlU2l6ZScsXHJcbiAgICAgIGxhYmVsOiAnSXNzdWUgU2l6ZScsXHJcbiAgICAgIGRlc2NyaXB0aW9uOiAnU29ydCBieSBJUE8gaXNzdWUgc2l6ZScsXHJcbiAgICB9LFxyXG4gICAgeyB2YWx1ZTogJ21heFByaWNlJywgbGFiZWw6ICdQcmljZScsIGRlc2NyaXB0aW9uOiAnU29ydCBieSBtYXhpbXVtIHByaWNlJyB9LFxyXG4gICAge1xyXG4gICAgICB2YWx1ZTogJ25hbWUnLFxyXG4gICAgICBsYWJlbDogJ0NvbXBhbnkgTmFtZScsXHJcbiAgICAgIGRlc2NyaXB0aW9uOiAnQWxwaGFiZXRpY2FsIGJ5IGNvbXBhbnkgbmFtZScsXHJcbiAgICB9LFxyXG4gICAgeyB2YWx1ZTogJ3N5bWJvbCcsIGxhYmVsOiAnU3ltYm9sJywgZGVzY3JpcHRpb246ICdBbHBoYWJldGljYWwgYnkgc3ltYm9sJyB9LFxyXG4gICAgeyB2YWx1ZTogJ3N0YXR1cycsIGxhYmVsOiAnU3RhdHVzJywgZGVzY3JpcHRpb246ICdHcm91cCBieSBJUE8gc3RhdHVzJyB9LFxyXG4gICAgeyB2YWx1ZTogJ3NlY3RvcicsIGxhYmVsOiAnU2VjdG9yJywgZGVzY3JpcHRpb246ICdHcm91cCBieSBzZWN0b3InIH0sXHJcbiAgXTtcclxufVxyXG5cclxuLy8gRm9ybWF0IGZpbHRlciBkaXNwbGF5IHRleHRcclxuZnVuY3Rpb24gZm9ybWF0RmlsdGVyRGlzcGxheShrZXksIHZhbHVlKSB7XHJcbiAgc3dpdGNoIChrZXkpIHtcclxuICAgIGNhc2UgJ21pblByaWNlJzpcclxuICAgICAgcmV0dXJuIGBNaW4gUHJpY2U6IOKCuSR7dmFsdWV9YDtcclxuICAgIGNhc2UgJ21heFByaWNlJzpcclxuICAgICAgcmV0dXJuIGBNYXggUHJpY2U6IOKCuSR7dmFsdWV9YDtcclxuICAgIGNhc2UgJ21pbklzc3VlU2l6ZSc6XHJcbiAgICAgIHJldHVybiBgTWluIElzc3VlIFNpemU6IOKCuSR7dmFsdWV9IENyYDtcclxuICAgIGNhc2UgJ21heElzc3VlU2l6ZSc6XHJcbiAgICAgIHJldHVybiBgTWF4IElzc3VlIFNpemU6IOKCuSR7dmFsdWV9IENyYDtcclxuICAgIGNhc2UgJ21pbkdNUCc6XHJcbiAgICAgIHJldHVybiBgTWluIEdNUDog4oK5JHt2YWx1ZX1gO1xyXG4gICAgY2FzZSAnbWF4R01QJzpcclxuICAgICAgcmV0dXJuIGBNYXggR01QOiDigrkke3ZhbHVlfWA7XHJcbiAgICBjYXNlICdzdWJzY3JpcHRpb25NaW4nOlxyXG4gICAgICByZXR1cm4gYE1pbiBTdWJzY3JpcHRpb246ICR7dmFsdWV9eGA7XHJcbiAgICBjYXNlICdzdWJzY3JpcHRpb25NYXgnOlxyXG4gICAgICByZXR1cm4gYE1heCBTdWJzY3JpcHRpb246ICR7dmFsdWV9eGA7XHJcbiAgICBjYXNlICdkYXRlRnJvbSc6XHJcbiAgICAgIHJldHVybiBgRnJvbTogJHtuZXcgRGF0ZSh2YWx1ZSkudG9Mb2NhbGVEYXRlU3RyaW5nKCl9YDtcclxuICAgIGNhc2UgJ2RhdGVUbyc6XHJcbiAgICAgIHJldHVybiBgVG86ICR7bmV3IERhdGUodmFsdWUpLnRvTG9jYWxlRGF0ZVN0cmluZygpfWA7XHJcbiAgICBkZWZhdWx0OlxyXG4gICAgICByZXR1cm4gYCR7a2V5fTogJHt2YWx1ZX1gO1xyXG4gIH1cclxufVxyXG5cclxuLy8gQWR2YW5jZWQgc2VhcmNoIGZ1bmN0aW9ucyAoTUwtcG93ZXJlZClcclxuYXN5bmMgZnVuY3Rpb24gYnVpbGRBZHZhbmNlZFNlYXJjaENvbmRpdGlvbnMocXVlcmllcywgc2VhcmNoVHlwZSkge1xyXG4gIC8vIEltcGxlbWVudGF0aW9uIHdvdWxkIGRlcGVuZCBvbiB0aGUgc2VhcmNoIHR5cGVcclxuICBjb25zdCBjb25kaXRpb25zID0gW107XHJcblxyXG4gIHF1ZXJpZXMuZm9yRWFjaCgocXVlcnkpID0+IHtcclxuICAgIGNvbnN0IHRlcm1zID0gZXh0cmFjdFNlYXJjaFRlcm1zKHF1ZXJ5KTtcclxuXHJcbiAgICBpZiAoc2VhcmNoVHlwZSA9PT0gJ3NlbWFudGljJykge1xyXG4gICAgICAvLyBBZGQgc2VtYW50aWMgc2VhcmNoIGNvbmRpdGlvbnNcclxuICAgICAgY29uZGl0aW9ucy5wdXNoKC4uLmJ1aWxkU2VtYW50aWNTZWFyY2godGVybXMpKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIEFkZCB0cmFkaXRpb25hbCBzZWFyY2ggY29uZGl0aW9uc1xyXG4gICAgICBjb25kaXRpb25zLnB1c2goLi4uYnVpbGRVbml2ZXJzYWxTZWFyY2godGVybXMsIHRydWUpKTtcclxuICAgIH1cclxuICB9KTtcclxuXHJcbiAgcmV0dXJuIGNvbmRpdGlvbnM7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGJ1aWxkU2VtYW50aWNTZWFyY2godGVybXMpIHtcclxuICAvLyBNb2NrIHNlbWFudGljIHNlYXJjaCAtIGluIHByb2R1Y3Rpb24sIHRoaXMgd291bGQgdXNlIE5MUCBtb2RlbHNcclxuICBjb25zdCBzZW1hbnRpY0NvbmRpdGlvbnMgPSBbXTtcclxuXHJcbiAgdGVybXMuZm9yRWFjaCgodGVybSkgPT4ge1xyXG4gICAgLy8gQWRkIHJlbGF0ZWQgdGVybXMgYmFzZWQgb24gc2VtYW50aWMgc2ltaWxhcml0eVxyXG4gICAgY29uc3QgcmVsYXRlZFRlcm1zID0gZ2V0U2VtYW50aWNhbGx5U2ltaWxhclRlcm1zKHRlcm0pO1xyXG5cclxuICAgIHJlbGF0ZWRUZXJtcy5mb3JFYWNoKChyZWxhdGVkVGVybSkgPT4ge1xyXG4gICAgICBzZW1hbnRpY0NvbmRpdGlvbnMucHVzaChcclxuICAgICAgICB7IG5hbWU6IHsgY29udGFpbnM6IHJlbGF0ZWRUZXJtLCBtb2RlOiAnaW5zZW5zaXRpdmUnIH0gfSxcclxuICAgICAgICB7IHNlY3RvcjogeyBjb250YWluczogcmVsYXRlZFRlcm0sIG1vZGU6ICdpbnNlbnNpdGl2ZScgfSB9XHJcbiAgICAgICk7XHJcbiAgICB9KTtcclxuICB9KTtcclxuXHJcbiAgcmV0dXJuIHNlbWFudGljQ29uZGl0aW9ucztcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0U2VtYW50aWNhbGx5U2ltaWxhclRlcm1zKHRlcm0pIHtcclxuICAvLyBNb2NrIHNlbWFudGljIHNpbWlsYXJpdHkgLSBpbiBwcm9kdWN0aW9uLCB1c2Ugd29yZCBlbWJlZGRpbmdzXHJcbiAgY29uc3Qgc3lub255bXMgPSB7XHJcbiAgICB0ZWNoOiBbJ3RlY2hub2xvZ3knLCAnc29mdHdhcmUnLCAnZGlnaXRhbCcsICdJVCddLFxyXG4gICAgYmFuazogWydiYW5raW5nJywgJ2ZpbmFuY2lhbCcsICdmaW5hbmNlJ10sXHJcbiAgICBwaGFybWE6IFsncGhhcm1hY2V1dGljYWwnLCAnZHJ1ZycsICdtZWRpY2luZSddLFxyXG4gICAgYXV0bzogWydhdXRvbW9iaWxlJywgJ2F1dG9tb3RpdmUnLCAndmVoaWNsZSddLFxyXG4gIH07XHJcblxyXG4gIHJldHVybiBzeW5vbnltc1t0ZXJtLnRvTG93ZXJDYXNlKCldIHx8IFt0ZXJtXTtcclxufVxyXG5cclxuYXN5bmMgZnVuY3Rpb24gYXBwbHlNTFJhbmtpbmcocmVzdWx0cywgcGFyYW1zKSB7XHJcbiAgLy8gTW9jayBNTCByYW5raW5nIC0gaW4gcHJvZHVjdGlvbiwgdXNlIHRyYWluZWQgbW9kZWxzXHJcbiAgcmV0dXJuIHJlc3VsdHNcclxuICAgIC5tYXAoKGlwbywgaW5kZXgpID0+IHtcclxuICAgICAgY29uc3QgbWxTY29yZSA9IGNhbGN1bGF0ZU1MU2NvcmUoaXBvLCBwYXJhbXMpO1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIC4uLmlwbyxcclxuICAgICAgICBtbFNjb3JlLFxyXG4gICAgICAgIHJhbmtpbmdGYWN0b3JzOiB7XHJcbiAgICAgICAgICB0ZXh0UmVsZXZhbmNlOiAwLjcsXHJcbiAgICAgICAgICBwb3B1bGFyaXR5OiAwLjIsXHJcbiAgICAgICAgICByZWNlbmN5OiAwLjEsXHJcbiAgICAgICAgfSxcclxuICAgICAgfTtcclxuICAgIH0pXHJcbiAgICAuc29ydCgoYSwgYikgPT4gYi5tbFNjb3JlIC0gYS5tbFNjb3JlKTtcclxufVxyXG5cclxuZnVuY3Rpb24gY2FsY3VsYXRlTUxTY29yZShpcG8sIHBhcmFtcykge1xyXG4gIC8vIE1vY2sgTUwgc2NvcmluZ1xyXG4gIGxldCBzY29yZSA9IE1hdGgucmFuZG9tKCkgKiAxMDA7XHJcblxyXG4gIC8vIEJvb3N0IGZvciBleGFjdCBtYXRjaGVzXHJcbiAgaWYgKFxyXG4gICAgcGFyYW1zLnF1ZXJpZXMuc29tZShcclxuICAgICAgKHEpID0+XHJcbiAgICAgICAgaXBvLnN5bWJvbC50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKHEudG9Mb3dlckNhc2UoKSkgfHxcclxuICAgICAgICBpcG8ubmFtZS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKHEudG9Mb3dlckNhc2UoKSlcclxuICAgIClcclxuICApIHtcclxuICAgIHNjb3JlICo9IDEuNTtcclxuICB9XHJcblxyXG4gIC8vIFN0YXR1cyBib29zdFxyXG4gIGNvbnN0IHN0YXR1c0Jvb3N0cyA9IHsgb3BlbjogMS4zLCB1cGNvbWluZzogMS4xLCBjbG9zZWQ6IDEuMCwgbGlzdGVkOiAwLjkgfTtcclxuICBzY29yZSAqPSBzdGF0dXNCb29zdHNbaXBvLnN0YXR1c10gfHwgMS4wO1xyXG5cclxuICByZXR1cm4gTWF0aC5yb3VuZChzY29yZSAqIDEwMCkgLyAxMDA7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGJ1aWxkQWR2YW5jZWRGaWx0ZXJzKGZpbHRlcnMpIHtcclxuICBjb25zdCBjb25kaXRpb25zID0gW107XHJcblxyXG4gIE9iamVjdC5lbnRyaWVzKGZpbHRlcnMpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xyXG4gICAgaWYgKHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgc3dpdGNoIChrZXkpIHtcclxuICAgICAgICBjYXNlICdzdGF0dXMnOlxyXG4gICAgICAgICAgY29uZGl0aW9ucy5wdXNoKHtcclxuICAgICAgICAgICAgc3RhdHVzOiBBcnJheS5pc0FycmF5KHZhbHVlKSA/IHsgaW46IHZhbHVlIH0gOiB2YWx1ZSxcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAnc2VjdG9yJzpcclxuICAgICAgICAgIGNvbmRpdGlvbnMucHVzaCh7XHJcbiAgICAgICAgICAgIHNlY3RvcjogeyBpbjogQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IFt2YWx1ZV0gfSxcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAncHJpY2VSYW5nZSc6XHJcbiAgICAgICAgICBpZiAodmFsdWUubWluKSBjb25kaXRpb25zLnB1c2goeyBtYXhQcmljZTogeyBndGU6IHZhbHVlLm1pbiB9IH0pO1xyXG4gICAgICAgICAgaWYgKHZhbHVlLm1heCkgY29uZGl0aW9ucy5wdXNoKHsgbWluUHJpY2U6IHsgbHRlOiB2YWx1ZS5tYXggfSB9KTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIC8vIEFkZCBtb3JlIGZpbHRlciB0eXBlcyBhcyBuZWVkZWRcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0pO1xyXG5cclxuICByZXR1cm4gY29uZGl0aW9ucztcclxufVxyXG5cclxuYXN5bmMgZnVuY3Rpb24gcGVyZm9ybVNlbWFudGljQW5hbHlzaXMocXVlcmllcykge1xyXG4gIC8vIE1vY2sgc2VtYW50aWMgYW5hbHlzaXNcclxuICByZXR1cm4ge1xyXG4gICAgZW50aXRpZXM6IGV4dHJhY3RFbnRpdGllc0Zyb21RdWVyaWVzKHF1ZXJpZXMpLFxyXG4gICAgaW50ZW50OiBkZXRlY3RTZWFyY2hJbnRlbnQocXVlcmllcyksXHJcbiAgICBzZW50aW1lbnQ6ICduZXV0cmFsJyxcclxuICAgIGNvbXBsZXhpdHk6IHF1ZXJpZXMucmVkdWNlKChzdW0sIHEpID0+IHN1bSArIHEuc3BsaXQoJyAnKS5sZW5ndGgsIDApIC8gcXVlcmllcy5sZW5ndGgsXHJcbiAgfTtcclxufVxyXG5cclxuYXN5bmMgZnVuY3Rpb24gZXh0cmFjdEVudGl0aWVzKHF1ZXJpZXMpIHtcclxuICAvLyBNb2NrIGVudGl0eSBleHRyYWN0aW9uXHJcbiAgY29uc3QgZW50aXRpZXMgPSB7XHJcbiAgICBjb21wYW5pZXM6IFtdLFxyXG4gICAgc2VjdG9yczogW10sXHJcbiAgICBkYXRlczogW10sXHJcbiAgICBhbW91bnRzOiBbXSxcclxuICB9O1xyXG5cclxuICBxdWVyaWVzLmZvckVhY2goKHF1ZXJ5KSA9PiB7XHJcbiAgICAvLyBFeHRyYWN0IGNvbXBhbnkgbmFtZXMgKG1vY2spXHJcbiAgICBpZiAocXVlcnkuaW5jbHVkZXMoJ2x0ZCcpIHx8IHF1ZXJ5LmluY2x1ZGVzKCdsaW1pdGVkJykpIHtcclxuICAgICAgZW50aXRpZXMuY29tcGFuaWVzLnB1c2gocXVlcnkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEV4dHJhY3Qgc2VjdG9ycyAobW9jaylcclxuICAgIGNvbnN0IHNlY3RvcktleXdvcmRzID0gWyd0ZWNoJywgJ2JhbmsnLCAncGhhcm1hJywgJ2F1dG8nXTtcclxuICAgIHNlY3RvcktleXdvcmRzLmZvckVhY2goKGtleXdvcmQpID0+IHtcclxuICAgICAgaWYgKHF1ZXJ5LnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoa2V5d29yZCkpIHtcclxuICAgICAgICBlbnRpdGllcy5zZWN0b3JzLnB1c2goa2V5d29yZCk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIC8vIEV4dHJhY3QgZGF0ZXMgKG1vY2spXHJcbiAgICBjb25zdCBkYXRlUGF0dGVybiA9IC9cXGR7NH0tXFxkezJ9LVxcZHsyfS9nO1xyXG4gICAgY29uc3QgZGF0ZXMgPSBxdWVyeS5tYXRjaChkYXRlUGF0dGVybik7XHJcbiAgICBpZiAoZGF0ZXMpIGVudGl0aWVzLmRhdGVzLnB1c2goLi4uZGF0ZXMpO1xyXG5cclxuICAgIC8vIEV4dHJhY3QgYW1vdW50cyAobW9jaylcclxuICAgIGNvbnN0IGFtb3VudFBhdHRlcm4gPSAv4oK5P1xcZCsoPzosXFxkKykqKD86XFwuXFxkKyk/KD86XFxzKig/OmNyfGNyb3JlfGx8bGFraCkpPy9naTtcclxuICAgIGNvbnN0IGFtb3VudHMgPSBxdWVyeS5tYXRjaChhbW91bnRQYXR0ZXJuKTtcclxuICAgIGlmIChhbW91bnRzKSBlbnRpdGllcy5hbW91bnRzLnB1c2goLi4uYW1vdW50cyk7XHJcbiAgfSk7XHJcblxyXG4gIHJldHVybiBlbnRpdGllcztcclxufVxyXG5cclxuZnVuY3Rpb24gZXh0cmFjdEVudGl0aWVzRnJvbVF1ZXJpZXMocXVlcmllcykge1xyXG4gIHJldHVybiBxdWVyaWVzLmZsYXRNYXAoKHF1ZXJ5KSA9PiBleHRyYWN0U2VhcmNoVGVybXMocXVlcnkpKTtcclxufVxyXG5cclxuZnVuY3Rpb24gZGV0ZWN0U2VhcmNoSW50ZW50KHF1ZXJpZXMpIHtcclxuICAvLyBNb2NrIGludGVudCBkZXRlY3Rpb25cclxuICBjb25zdCBxdWVyeSA9IHF1ZXJpZXMuam9pbignICcpLnRvTG93ZXJDYXNlKCk7XHJcblxyXG4gIGlmIChxdWVyeS5pbmNsdWRlcygnd2hlbicpIHx8IHF1ZXJ5LmluY2x1ZGVzKCdkYXRlJykpIHJldHVybiAndGVtcG9yYWwnO1xyXG4gIGlmIChxdWVyeS5pbmNsdWRlcygnYmVzdCcpIHx8IHF1ZXJ5LmluY2x1ZGVzKCdnb29kJykpIHJldHVybiAncmVjb21tZW5kYXRpb24nO1xyXG4gIGlmIChxdWVyeS5pbmNsdWRlcygncHJpY2UnKSB8fCBxdWVyeS5pbmNsdWRlcygn4oK5JykpIHJldHVybiAnZmluYW5jaWFsJztcclxuICBpZiAocXVlcnkuaW5jbHVkZXMoJ2NvbXBhcmUnKSkgcmV0dXJuICdjb21wYXJpc29uJztcclxuXHJcbiAgcmV0dXJuICdzZWFyY2gnO1xyXG59XHJcblxyXG5hc3luYyBmdW5jdGlvbiBnZW5lcmF0ZUFkdmFuY2VkU2VhcmNoQW5hbHl0aWNzKHF1ZXJpZXMsIHJlc3VsdHMpIHtcclxuICByZXR1cm4ge1xyXG4gICAgcXVlcnlDb21wbGV4aXR5OiBxdWVyaWVzLnJlZHVjZSgoc3VtLCBxKSA9PiBzdW0gKyBxLnNwbGl0KCcgJykubGVuZ3RoLCAwKSAvIHF1ZXJpZXMubGVuZ3RoLFxyXG4gICAgcmVzdWx0RGl2ZXJzaXR5OiBjYWxjdWxhdGVSZXN1bHREaXZlcnNpdHkocmVzdWx0cy5kYXRhKSxcclxuICAgIGNvbmZpZGVuY2U6IDAuODUsIC8vIE1vY2sgY29uZmlkZW5jZSBzY29yZVxyXG4gICAgcHJvY2Vzc2luZ1RpbWU6IDE1MCwgLy8gTW9jayBwcm9jZXNzaW5nIHRpbWUgaW4gbXNcclxuICB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBjYWxjdWxhdGVSZXN1bHREaXZlcnNpdHkocmVzdWx0cykge1xyXG4gIGNvbnN0IHNlY3RvcnMgPSBuZXcgU2V0KHJlc3VsdHMubWFwKChyKSA9PiByLnNlY3RvcikuZmlsdGVyKEJvb2xlYW4pKTtcclxuICBjb25zdCBzdGF0dXNlcyA9IG5ldyBTZXQocmVzdWx0cy5tYXAoKHIpID0+IHIuc3RhdHVzKSk7XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICBzZWN0b3JEaXZlcnNpdHk6IHNlY3RvcnMuc2l6ZSAvIE1hdGgubWF4KHJlc3VsdHMubGVuZ3RoLCAxKSxcclxuICAgIHN0YXR1c0RpdmVyc2l0eTogc3RhdHVzZXMuc2l6ZSAvIE1hdGgubWF4KHJlc3VsdHMubGVuZ3RoLCAxKSxcclxuICAgIG92ZXJhbGxEaXZlcnNpdHk6IChzZWN0b3JzLnNpemUgKyBzdGF0dXNlcy5zaXplKSAvICgyICogTWF0aC5tYXgocmVzdWx0cy5sZW5ndGgsIDEpKSxcclxuICB9O1xyXG59XHJcblxyXG5hc3luYyBmdW5jdGlvbiBnZW5lcmF0ZVNlYXJjaFJlY29tbWVuZGF0aW9ucyhyZXN1bHRzLCBxdWVyaWVzKSB7XHJcbiAgY29uc3QgcmVjb21tZW5kYXRpb25zID0gW107XHJcblxyXG4gIGlmIChyZXN1bHRzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgcmVjb21tZW5kYXRpb25zLnB1c2goe1xyXG4gICAgICB0eXBlOiAnYnJvYWRlbl9zZWFyY2gnLFxyXG4gICAgICBtZXNzYWdlOiAnVHJ5IHJlbW92aW5nIHNvbWUgZmlsdGVycyBvciB1c2luZyBicm9hZGVyIHNlYXJjaCB0ZXJtcycsXHJcbiAgICAgIGFjdGlvbjogJ21vZGlmeV9xdWVyeScsXHJcbiAgICB9KTtcclxuICB9IGVsc2UgaWYgKHJlc3VsdHMubGVuZ3RoID4gNTApIHtcclxuICAgIHJlY29tbWVuZGF0aW9ucy5wdXNoKHtcclxuICAgICAgdHlwZTogJ25hcnJvd19zZWFyY2gnLFxyXG4gICAgICBtZXNzYWdlOiAnVG9vIG1hbnkgcmVzdWx0cy4gVHJ5IGFkZGluZyBmaWx0ZXJzIG9yIGJlaW5nIG1vcmUgc3BlY2lmaWMnLFxyXG4gICAgICBhY3Rpb246ICdhZGRfZmlsdGVycycsXHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8vIFNlY3Rvci1iYXNlZCByZWNvbW1lbmRhdGlvbnNcclxuICBjb25zdCBzZWN0b3JzID0gWy4uLm5ldyBTZXQocmVzdWx0cy5tYXAoKHIpID0+IHIuc2VjdG9yKS5maWx0ZXIoQm9vbGVhbikpXTtcclxuICBpZiAoc2VjdG9ycy5sZW5ndGggPT09IDEpIHtcclxuICAgIHJlY29tbWVuZGF0aW9ucy5wdXNoKHtcclxuICAgICAgdHlwZTogJ2V4cGxvcmVfc2VjdG9ycycsXHJcbiAgICAgIG1lc3NhZ2U6IGBBbGwgcmVzdWx0cyBhcmUgZnJvbSAke3NlY3RvcnNbMF19LiBFeHBsb3JlIG90aGVyIHNlY3RvcnM/YCxcclxuICAgICAgYWN0aW9uOiAnc3VnZ2VzdF9zZWN0b3JzJyxcclxuICAgICAgZGF0YTogeyBleGNsdWRlU2VjdG9yOiBzZWN0b3JzWzBdIH0sXHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIHJldHVybiByZWNvbW1lbmRhdGlvbnM7XHJcbn1cclxuXHJcbmFzeW5jIGZ1bmN0aW9uIHByb2Nlc3NBZHZhbmNlZFNlYXJjaFJlc3VsdChpcG8sIG9wdGlvbnMpIHtcclxuICBjb25zdCB7IHF1ZXJpZXMsIHNlYXJjaFR5cGUsIGhpZ2hsaWdodCwgaW5jbHVkZUFuYWx5dGljcywgaW5jbHVkZVByZWRpY3Rpb25zIH0gPSBvcHRpb25zO1xyXG5cclxuICBjb25zdCByZXN1bHQgPSBhd2FpdCBwcm9jZXNzU2VhcmNoUmVzdWx0KGlwbywge1xyXG4gICAgaW5jbHVkZUFuYWx5dGljcyxcclxuICAgIGluY2x1ZGVQcmVkaWN0aW9ucyxcclxuICAgIGhpZ2hsaWdodCxcclxuICAgIHNlYXJjaFRlcm1zOiBxdWVyaWVzLmZsYXRNYXAoKHEpID0+IGV4dHJhY3RTZWFyY2hUZXJtcyhxKSksXHJcbiAgICByZWxldmFuY2VTY29yZTogaXBvLm1sU2NvcmUgfHwgMS4wLFxyXG4gIH0pO1xyXG5cclxuICAvLyBBZGQgYWR2YW5jZWQgc2VhcmNoIHNwZWNpZmljIGRhdGFcclxuICByZXN1bHQubWxTY29yZSA9IGlwby5tbFNjb3JlO1xyXG4gIHJlc3VsdC5yYW5raW5nRmFjdG9ycyA9IGlwby5yYW5raW5nRmFjdG9ycztcclxuICByZXN1bHQuc2VhcmNoVHlwZSA9IHNlYXJjaFR5cGU7XHJcblxyXG4gIHJldHVybiByZXN1bHQ7XHJcbn1cclxuXHJcbi8vIExvZ2dpbmcgZnVuY3Rpb25cclxuZnVuY3Rpb24gbG9nU2VhcmNoUXVlcnkocmVxdWVzdCwgZGF0YSkge1xyXG4gIHRyeSB7XHJcbiAgICAvLyBMb2cgc2VhcmNoIGFuYWx5dGljcyAtIG5vbi1ibG9ja2luZ1xyXG4gICAgc2V0SW1tZWRpYXRlKCgpID0+IHtcclxuICAgICAgY29uc29sZS5sb2coJ1NlYXJjaCBRdWVyeTonLCB7XHJcbiAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXHJcbiAgICAgICAgaXA6IHJlcXVlc3QuaXAsXHJcbiAgICAgICAgdXNlckFnZW50OiByZXF1ZXN0LmhlYWRlcnMuZ2V0KCd1c2VyLWFnZW50JyksXHJcbiAgICAgICAgLi4uZGF0YSxcclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgLy8gU2lsZW50IGZhaWwgZm9yIGxvZ2dpbmdcclxuICB9XHJcbn1cclxuXHJcbi8vIEV4cG9ydCBjb25maWd1cmF0aW9uXHJcbmV4cG9ydCBjb25zdCBkeW5hbWljID0gJ2ZvcmNlLWR5bmFtaWMnO1xyXG5leHBvcnQgY29uc3QgcnVudGltZSA9ICdub2RlanMnO1xyXG4iXSwibmFtZXMiOlsiTmV4dFJlcXVlc3QiLCJOZXh0UmVzcG9uc2UiLCJwcmlzbWEiLCJjYWNoZSIsImFuYWx5dGljc1NlcnZpY2UiLCJwcmVkaWN0aW9uU2VydmljZSIsIkdFVCIsInJlcXVlc3QiLCJzZWFyY2hQYXJhbXMiLCJVUkwiLCJ1cmwiLCJxdWVyeSIsImdldCIsInR5cGUiLCJzdGF0dXMiLCJzZWN0b3IiLCJyZWdpc3RyYXIiLCJtaW5QcmljZSIsInBhcnNlRmxvYXQiLCJtYXhQcmljZSIsIm1pbklzc3VlU2l6ZSIsIm1heElzc3VlU2l6ZSIsIm1pbkdNUCIsIm1heEdNUCIsInN1YnNjcmlwdGlvbk1pbiIsInN1YnNjcmlwdGlvbk1heCIsImRhdGVGcm9tIiwiZGF0ZVRvIiwic29ydEJ5Iiwic29ydE9yZGVyIiwicGFnZSIsInBhcnNlSW50IiwibGltaXQiLCJNYXRoIiwibWluIiwiZnV6enkiLCJzdWdnZXN0aW9ucyIsImhpZ2hsaWdodCIsImluY2x1ZGVBbmFseXRpY3MiLCJpbmNsdWRlUHJlZGljdGlvbnMiLCJhZHZhbmNlZCIsImxlbmd0aCIsImpzb24iLCJzdWNjZXNzIiwiZXJyb3IiLCJjYWNoZUtleSIsImtleSIsIkpTT04iLCJzdHJpbmdpZnkiLCJ0b0xvd2VyQ2FzZSIsImNhY2hlZCIsImNhY2hlVGltZSIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsInNlYXJjaFJlc3VsdHMiLCJ0cmltIiwicGVyZm9ybUZpbHRlcmVkU2VhcmNoIiwicGVyZm9ybVRleHRTZWFyY2giLCJzZWFyY2hTdWdnZXN0aW9ucyIsImdlbmVyYXRlU2VhcmNoU3VnZ2VzdGlvbnMiLCJzZWFyY2hBbmFseXRpY3MiLCJnZW5lcmF0ZVNlYXJjaEFuYWx5dGljcyIsImRhdGEiLCJyZXNwb25zZSIsIm9yaWdpbmFsIiwicHJvY2Vzc2VkIiwicHJvY2Vzc1NlYXJjaFF1ZXJ5IiwicmVzdWx0cyIsInBhZ2luYXRpb24iLCJhbmFseXRpY3MiLCJmaWx0ZXJzIiwiYXBwbGllZCIsImdldEFwcGxpZWRGaWx0ZXJzIiwiYXZhaWxhYmxlIiwiZ2V0QXZhaWxhYmxlRmlsdGVycyIsInNvcnRpbmciLCJvcHRpb25zIiwiZ2V0U29ydGluZ09wdGlvbnMiLCJtZXRhZGF0YSIsInNlYXJjaFRpbWUiLCJub3ciLCJzdGFydFRpbWUiLCJ0b3RhbFJlc3VsdHMiLCJ0b3RhbENvdW50IiwiaGFzTW9yZSIsImhhc05leHRQYWdlIiwicmVsZXZhbmNlU2NvcmluZyIsImhpZ2hsaWdodGluZyIsInRpbWVzdGFtcCIsInNldCIsImxvZ1NlYXJjaFF1ZXJ5IiwicmVzdWx0Q291bnQiLCJjb25zb2xlIiwibWVzc2FnZSIsInByb2Nlc3MiLCJQT1NUIiwiYm9keSIsInF1ZXJpZXMiLCJzZWFyY2hUeXBlIiwicmFua2luZ01vZGVsIiwiYm9vc3QiLCJBcnJheSIsImlzQXJyYXkiLCJzZWFyY2hRdWVyaWVzIiwicGVyZm9ybUFkdmFuY2VkU2VhcmNoIiwiYWR2YW5jZWRBbmFseXRpY3MiLCJnZW5lcmF0ZUFkdmFuY2VkU2VhcmNoQW5hbHl0aWNzIiwicmVsZXZhbmNlU2NvcmVzIiwicXVlcnlQcm9jZXNzaW5nIiwibm9ybWFsaXplZFF1ZXJpZXMiLCJtYXAiLCJxIiwic2VtYW50aWNBbmFseXNpcyIsInBlcmZvcm1TZW1hbnRpY0FuYWx5c2lzIiwiZW50aXR5RXh0cmFjdGlvbiIsImV4dHJhY3RFbnRpdGllcyIsInJlY29tbWVuZGF0aW9ucyIsImdlbmVyYXRlU2VhcmNoUmVjb21tZW5kYXRpb25zIiwicGFyYW1zIiwid2hlcmVDbGF1c2UiLCJpc0FjdGl2ZSIsImluY2x1ZGVzIiwiaW4iLCJzcGxpdCIsImNvbnRhaW5zIiwibW9kZSIsImlzTmFOIiwiZ3RlIiwibHRlIiwiaXNzdWVTaXplIiwiZGF0ZUZpbHRlciIsIm9wZW5EYXRlIiwiaW5jbHVkZUNsYXVzZSIsImdtcERhdGEiLCJvcmRlckJ5IiwidGFrZSIsInN1YnNjcmlwdGlvbkRhdGEiLCJhbGxvdG1lbnREYXRhIiwid2F0Y2hsaXN0cyIsImFsZXJ0cyIsImdtcCIsInN1YnNjcmlwdGlvbiIsImJ1aWxkT3JkZXJDbGF1c2UiLCJvZmZzZXQiLCJpcG9zIiwiUHJvbWlzZSIsImFsbCIsImlQTyIsImZpbmRNYW55Iiwid2hlcmUiLCJpbmNsdWRlIiwic2tpcCIsImNvdW50IiwiZmlsdGVyZWRSZXN1bHRzIiwiYXBwbHlBZHZhbmNlZEZpbHRlcnMiLCJwcm9jZXNzZWRSZXN1bHRzIiwiaXBvIiwicHJvY2Vzc1NlYXJjaFJlc3VsdCIsInJlbGV2YW5jZVNjb3JlIiwiY3VycmVudFBhZ2UiLCJ0b3RhbFBhZ2VzIiwiY2VpbCIsImhhc1ByZXZQYWdlIiwicHJvY2Vzc2VkUXVlcnkiLCJzZWFyY2hUZXJtcyIsImV4dHJhY3RTZWFyY2hUZXJtcyIsImJhc2VXaGVyZUNsYXVzZSIsImFwcGx5QWRkaXRpb25hbEZpbHRlcnMiLCJzZWFyY2hDb25kaXRpb25zIiwiYnVpbGRTeW1ib2xTZWFyY2giLCJidWlsZE5hbWVTZWFyY2giLCJidWlsZFNlY3RvclNlYXJjaCIsImJ1aWxkUmVnaXN0cmFyU2VhcmNoIiwiYnVpbGRVbml2ZXJzYWxTZWFyY2giLCJBTkQiLCJPUiIsImNhdGVnb3JpZXMiLCJzY29yZWRSZXN1bHRzIiwiY2FsY3VsYXRlUmVsZXZhbmNlU2NvcmUiLCJzb3J0ZWRSZXN1bHRzIiwic29ydCIsImEiLCJiIiwic29ydFJlc3VsdHMiLCJwYWdpbmF0ZWRSZXN1bHRzIiwic2xpY2UiLCJvcmlnaW5hbENvdW50IiwicHJvY2Vzc2VkUXVlcmllcyIsImFsbFNlYXJjaFRlcm1zIiwiZmxhdE1hcCIsInVuaXF1ZVRlcm1zIiwiU2V0IiwiYnVpbGRBZHZhbmNlZFNlYXJjaENvbmRpdGlvbnMiLCJidWlsZEFkdmFuY2VkRmlsdGVycyIsImFsbG90bWVudFJlc3VsdHMiLCJzZWxlY3QiLCJjYXRlZ29yeSIsImFsbG90bWVudFN0YXR1cyIsImFsbG90dGVkUXVhbnRpdHkiLCJyYW5rZWRSZXN1bHRzIiwiYXBwbHlNTFJhbmtpbmciLCJpbmRleCIsImlwb0lkIiwiaWQiLCJzeW1ib2wiLCJzY29yZSIsIm1sU2NvcmUiLCJyYW5rIiwiZmFjdG9ycyIsInJhbmtpbmdGYWN0b3JzIiwicHJvY2Vzc0FkdmFuY2VkU2VhcmNoUmVzdWx0IiwicmVwbGFjZSIsInRlcm1zIiwiZmlsdGVyIiwidGVybSIsImV4cGFuZGVkVGVybXMiLCJmb3JFYWNoIiwicHVzaCIsInN1YnN0cmluZyIsImNvbmRpdGlvbnMiLCJzdGFydHNXaXRoIiwidG9VcHBlckNhc2UiLCJuYW1lIiwibGVhZE1hbmFnZXJzIiwiYXJyYXlfY29udGFpbnMiLCJ3ZWlnaHRzIiwidGVybVJlZ2V4IiwiUmVnRXhwIiwidGVzdCIsIm5hbWVXb3JkcyIsInNvbWUiLCJ3b3JkIiwibWFuYWdlciIsInR5cGVCb29zdHMiLCJzdGF0dXNCb29zdHMiLCJvcGVuIiwidXBjb21pbmciLCJjbG9zZWQiLCJsaXN0ZWQiLCJyb3VuZCIsImxhdGVzdEdNUCIsInZhbHVlIiwibWF4U3Vic2NyaXB0aW9uIiwibWF4IiwicyIsInN1YnNjcmlwdGlvblJhdGlvIiwib3JkZXJEaXJlY3Rpb24iLCJjbG9zZURhdGUiLCJsaXN0aW5nRGF0ZSIsImNyZWF0ZWRBdCIsInVwZGF0ZWRBdCIsImZpZWxkIiwiZGlyZWN0aW9uIiwiT2JqZWN0IiwiZW50cmllcyIsImFWYWwiLCJiVmFsIiwiZ2V0VGltZSIsInJlc3VsdCIsImxvdFNpemUiLCJ0b1N0cmluZyIsImN1cnJlbnRNZXRyaWNzIiwicGVyY2VudGFnZSIsImdldExhdGVzdFN1YnNjcmlwdGlvbiIsImhpZ2hsaWdodHMiLCJnZW5lcmF0ZUhpZ2hsaWdodHMiLCJyaXNrU2NvcmUiLCJwcmVkaWN0ZWRMaXN0aW5nR2FpbiIsImF2Z0dNUCIsImZpbmFsU3Vic2NyaXB0aW9uIiwibGlzdGluZ0dhaW4iLCJtYXJrZXRTZW50aW1lbnQiLCJhbGxTZXR0bGVkIiwicHJlZGljdExpc3RpbmdHYWluIiwicHJlZGljdE1hcmtldFNlbnRpbWVudCIsInByZWRpY3Rpb25zIiwiaGlnaGxpZ2h0VGV4dCIsInRleHQiLCJoaWdobGlnaHRlZFRleHQiLCJyZWdleCIsImhpZ2hsaWdodGVkIiwibGF0ZXN0IiwicmVkdWNlIiwiY3VycmVudCIsInF1YW50aXR5IiwiYmlkQ291bnQiLCJzeW1ib2xTdWdnZXN0aW9ucyIsImRpc3BsYXkiLCJuYW1lU3VnZ2VzdGlvbnMiLCJzZWN0b3JTdWdnZXN0aW9ucyIsImdyb3VwQnkiLCJieSIsIl9jb3VudCIsIml0ZW0iLCJyZWdpc3RyYXJTdWdnZXN0aW9ucyIsInR5cGVPcmRlciIsIndvcmRDb3VudCIsInciLCJoYXNOdW1iZXJzIiwiaGFzU3BlY2lhbENoYXJzIiwidG90YWwiLCJieVN0YXR1cyIsImJ5U2VjdG9yIiwicmVsZXZhbmNlRGlzdHJpYnV0aW9uIiwiaGlnaCIsIm1lZGl1bSIsImxvdyIsInBlcmZvcm1hbmNlIiwiY2FjaGVIaXQiLCJtYXhSZWxldmFuY2UiLCJyIiwicmVsZXZhbmNlUGVyY2VudCIsInVuZGVmaW5lZCIsImZvcm1hdEZpbHRlckRpc3BsYXkiLCJwcmljZVJhbmdlIiwiaXNzdWVTaXplUmFuZ2UiLCJzaXplSW5Dcm9yZXMiLCJsYWJlbCIsImRlc2NyaXB0aW9uIiwidG9Mb2NhbGVEYXRlU3RyaW5nIiwiYnVpbGRTZW1hbnRpY1NlYXJjaCIsInNlbWFudGljQ29uZGl0aW9ucyIsInJlbGF0ZWRUZXJtcyIsImdldFNlbWFudGljYWxseVNpbWlsYXJUZXJtcyIsInJlbGF0ZWRUZXJtIiwic3lub255bXMiLCJ0ZWNoIiwiYmFuayIsInBoYXJtYSIsImF1dG8iLCJjYWxjdWxhdGVNTFNjb3JlIiwidGV4dFJlbGV2YW5jZSIsInBvcHVsYXJpdHkiLCJyZWNlbmN5IiwicmFuZG9tIiwiZW50aXRpZXMiLCJleHRyYWN0RW50aXRpZXNGcm9tUXVlcmllcyIsImludGVudCIsImRldGVjdFNlYXJjaEludGVudCIsInNlbnRpbWVudCIsImNvbXBsZXhpdHkiLCJzdW0iLCJjb21wYW5pZXMiLCJzZWN0b3JzIiwiZGF0ZXMiLCJhbW91bnRzIiwic2VjdG9yS2V5d29yZHMiLCJrZXl3b3JkIiwiZGF0ZVBhdHRlcm4iLCJtYXRjaCIsImFtb3VudFBhdHRlcm4iLCJqb2luIiwicXVlcnlDb21wbGV4aXR5IiwicmVzdWx0RGl2ZXJzaXR5IiwiY2FsY3VsYXRlUmVzdWx0RGl2ZXJzaXR5IiwiY29uZmlkZW5jZSIsInByb2Nlc3NpbmdUaW1lIiwiQm9vbGVhbiIsInN0YXR1c2VzIiwic2VjdG9yRGl2ZXJzaXR5Iiwic2l6ZSIsInN0YXR1c0RpdmVyc2l0eSIsIm92ZXJhbGxEaXZlcnNpdHkiLCJhY3Rpb24iLCJleGNsdWRlU2VjdG9yIiwic2V0SW1tZWRpYXRlIiwibG9nIiwiaXAiLCJ1c2VyQWdlbnQiLCJoZWFkZXJzIiwiZHluYW1pYyIsInJ1bnRpbWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./src/app/api/ipos/route.js\n");

/***/ }),

/***/ "(rsc)/./src/lib/analytics.js":
/*!******************************!*\
  !*** ./src/lib/analytics.js ***!
  \******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   analyticsService: () => (/* binding */ analyticsService),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _db_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./db.js */ \"(rsc)/./src/lib/db.js\");\n/* harmony import */ var _cache_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cache.js */ \"(rsc)/./src/lib/cache.js\");\n\n\nclass AnalyticsService {\n    constructor(){\n        // Performance metrics\n        this.metrics = {\n            computationsPerformed: 0,\n            cacheHits: 0,\n            cacheMisses: 0,\n            averageComputationTime: 0,\n            errors: 0\n        };\n        // Analytics cache with TTL\n        this.analyticsCache = new Map();\n        this.cacheTTL = {\n            BASIC: 5 * 60 * 1000,\n            DETAILED: 10 * 60 * 1000,\n            HISTORICAL: 30 * 60 * 1000,\n            PREDICTIONS: 15 * 60 * 1000\n        };\n        // Risk assessment weights\n        this.riskWeights = {\n            GMP_VOLATILITY: 0.3,\n            SUBSCRIPTION_RATIO: 0.25,\n            ISSUE_SIZE: 0.2,\n            MARKET_CONDITIONS: 0.15,\n            SECTOR_PERFORMANCE: 0.1\n        };\n        // Prediction models configuration\n        this.predictionModels = {\n            LISTING_GAIN: {\n                factors: [\n                    \"avgGMP\",\n                    \"subscriptionRatio\",\n                    \"issueSize\",\n                    \"marketSentiment\"\n                ],\n                weights: [\n                    0.4,\n                    0.3,\n                    0.2,\n                    0.1\n                ]\n            },\n            ALLOTMENT_PROBABILITY: {\n                factors: [\n                    \"subscriptionRatio\",\n                    \"applicationAmount\",\n                    \"category\"\n                ],\n                weights: [\n                    0.6,\n                    0.3,\n                    0.1\n                ]\n            }\n        };\n    }\n    // Comprehensive IPO analytics computation\n    async computeIPOAnalytics(ipoId, options = {}) {\n        const startTime = Date.now();\n        try {\n            const { includeHistorical = true, includePredictions = true, timeRange = 30, refreshCache = false } = options;\n            // Check cache first\n            const cacheKey = `analytics:${ipoId}:${timeRange}:${includeHistorical}:${includePredictions}`;\n            if (!refreshCache) {\n                const cached = await this.getCachedAnalytics(cacheKey);\n                if (cached) {\n                    this.metrics.cacheHits++;\n                    return cached;\n                }\n            }\n            this.metrics.cacheMisses++;\n            // Fetch comprehensive data\n            const [ipoData, gmpData, subscriptionData, demandData, categoryData] = await Promise.all([\n                this.getIPOBasicData(ipoId),\n                this.getGMPData(ipoId, timeRange),\n                this.getSubscriptionData(ipoId, timeRange),\n                this.getDemandData(ipoId, timeRange),\n                this.getIPOCategories(ipoId)\n            ]);\n            if (!ipoData) {\n                throw new Error(`IPO with ID ${ipoId} not found`);\n            }\n            // Compute analytics\n            const analytics = {\n                ipoId,\n                symbol: ipoData.symbol,\n                name: ipoData.name,\n                status: ipoData.status,\n                computedAt: new Date().toISOString(),\n                // Basic metrics\n                basicMetrics: this.computeBasicMetrics(ipoData),\n                // GMP analytics\n                gmpAnalytics: this.computeGMPAnalytics(gmpData),\n                // Subscription analytics\n                subscriptionAnalytics: this.computeSubscriptionAnalytics(subscriptionData, categoryData),\n                // Market demand analytics\n                demandAnalytics: this.computeDemandAnalytics(demandData),\n                // Risk assessment\n                riskAssessment: this.computeRiskAssessment(ipoData, gmpData, subscriptionData),\n                // Performance indicators\n                performanceIndicators: this.computePerformanceIndicators(ipoData, gmpData, subscriptionData)\n            };\n            // Add historical analysis\n            if (includeHistorical) {\n                analytics.historicalAnalysis = await this.computeHistoricalAnalysis(ipoId, timeRange);\n            }\n            // Add predictions\n            if (includePredictions) {\n                analytics.predictions = await this.computePredictions(analytics);\n            }\n            // Add comparative analysis\n            analytics.comparativeAnalysis = await this.computeComparativeAnalysis(ipoData);\n            // Add insights and recommendations\n            analytics.insights = this.generateInsights(analytics);\n            analytics.recommendations = this.generateRecommendations(analytics);\n            // Cache the results\n            await this.setCachedAnalytics(cacheKey, analytics, this.cacheTTL.DETAILED);\n            // Update metrics\n            const computationTime = Date.now() - startTime;\n            this.updateMetrics(computationTime);\n            return analytics;\n        } catch (error) {\n            this.metrics.errors++;\n            console.error(`Analytics computation failed for IPO ${ipoId}:`, error);\n            throw error;\n        }\n    }\n    // Basic IPO metrics computation\n    computeBasicMetrics(ipoData) {\n        const priceRange = ipoData.maxPrice - ipoData.minPrice;\n        const issueSize = Number(ipoData.issueSize || 0);\n        const lotValue = ipoData.lotSize * (ipoData.maxPrice || 0);\n        return {\n            priceRange: {\n                min: ipoData.minPrice,\n                max: ipoData.maxPrice,\n                spread: priceRange,\n                spreadPercentage: ipoData.minPrice > 0 ? parseFloat((priceRange / ipoData.minPrice * 100).toFixed(2)) : 0\n            },\n            issue: {\n                size: issueSize,\n                sizeCategory: this.categorizeIssueSize(issueSize),\n                lotSize: ipoData.lotSize,\n                lotValue,\n                faceValue: ipoData.faceValue\n            },\n            timeline: {\n                openDate: ipoData.openDate,\n                closeDate: ipoData.closeDate,\n                listingDate: ipoData.listingDate,\n                durationDays: this.calculateDuration(ipoData.openDate, ipoData.closeDate),\n                daysToListing: ipoData.listingDate ? this.calculateDuration(ipoData.closeDate, ipoData.listingDate) : null\n            },\n            type: {\n                issueType: ipoData.issueType,\n                subType: ipoData.subType,\n                registrar: ipoData.registrar\n            }\n        };\n    }\n    // GMP analytics computation\n    computeGMPAnalytics(gmpData) {\n        if (!gmpData || gmpData.length === 0) {\n            return {\n                status: \"no_data\",\n                message: \"No GMP data available\"\n            };\n        }\n        const values = gmpData.map((g)=>g.value);\n        const percentages = gmpData.map((g)=>g.percentage);\n        const volumes = gmpData.map((g)=>g.volume || 0);\n        // Statistical measures\n        const stats = {\n            current: values[0] || 0,\n            average: this.calculateAverage(values),\n            median: this.calculateMedian(values),\n            mode: this.calculateMode(values),\n            min: Math.min(...values),\n            max: Math.max(...values),\n            range: Math.max(...values) - Math.min(...values),\n            standardDeviation: this.calculateStandardDeviation(values),\n            variance: this.calculateVariance(values),\n            coefficient: this.calculateCoefficientOfVariation(values)\n        };\n        // Trend analysis\n        const trend = this.analyzeTrend(values);\n        // Volatility analysis\n        const volatility = this.analyzeVolatility(values, gmpData.map((g)=>g.timestamp));\n        // Volume analysis\n        const volumeAnalysis = this.analyzeVolume(volumes, values);\n        // Price momentum\n        const momentum = this.calculateMomentum(values);\n        return {\n            status: \"available\",\n            recordCount: gmpData.length,\n            timespan: this.calculateTimespan(gmpData),\n            statistics: stats,\n            trend,\n            volatility,\n            volumeAnalysis,\n            momentum,\n            priceTargets: this.calculatePriceTargets(stats),\n            riskMetrics: this.calculateGMPRiskMetrics(values)\n        };\n    }\n    // Subscription analytics computation\n    computeSubscriptionAnalytics(subscriptionData, categoryData) {\n        if (!subscriptionData || subscriptionData.length === 0) {\n            return {\n                status: \"no_data\",\n                message: \"No subscription data available\"\n            };\n        }\n        // Get latest subscription by category\n        const latestByCategory = this.getLatestSubscriptionByCategory(subscriptionData);\n        // Overall subscription metrics\n        const overallMetrics = {\n            totalSubscription: this.calculateOverallSubscription(latestByCategory),\n            isOversubscribed: false,\n            oversubscriptionRatio: 0,\n            totalApplications: 0,\n            totalQuantity: BigInt(0)\n        };\n        overallMetrics.isOversubscribed = overallMetrics.totalSubscription > 1;\n        overallMetrics.oversubscriptionRatio = Math.max(0, overallMetrics.totalSubscription - 1);\n        // Category-wise analysis\n        const categoryAnalysis = {};\n        for (const [category, data] of Object.entries(latestByCategory)){\n            categoryAnalysis[category] = {\n                subscriptionRatio: data.subscriptionRatio,\n                quantity: data.quantity.toString(),\n                bidCount: data.bidCount,\n                averageBidSize: data.bidCount > 0 ? Number(data.quantity) / data.bidCount : 0,\n                timestamp: data.timestamp\n            };\n            overallMetrics.totalApplications += data.bidCount;\n            overallMetrics.totalQuantity += data.quantity;\n        }\n        // Subscription pattern analysis\n        const patterns = this.analyzeSubscriptionPatterns(subscriptionData);\n        // Allotment probability calculation\n        const allotmentProbability = this.calculateAllotmentProbabilities(latestByCategory);\n        return {\n            status: \"available\",\n            recordCount: subscriptionData.length,\n            overall: overallMetrics,\n            categories: categoryAnalysis,\n            patterns,\n            allotmentProbability,\n            insights: this.generateSubscriptionInsights(overallMetrics, categoryAnalysis)\n        };\n    }\n    // Market demand analytics computation\n    computeDemandAnalytics(demandData) {\n        if (!demandData || demandData.length === 0) {\n            return {\n                status: \"no_data\",\n                message: \"No demand data available\"\n            };\n        }\n        // Price-wise demand analysis\n        const priceWiseDemand = this.analyzePriceWiseDemand(demandData);\n        // Cut-off analysis\n        const cutOffAnalysis = this.analyzeCutOffDemand(demandData);\n        // Demand distribution\n        const distribution = this.analyzeDemandDistribution(demandData);\n        // Bid concentration\n        const concentration = this.analyzeBidConcentration(demandData);\n        return {\n            status: \"available\",\n            recordCount: demandData.length,\n            priceWiseDemand,\n            cutOffAnalysis,\n            distribution,\n            concentration,\n            summary: {\n                totalQuantity: demandData.reduce((sum, d)=>sum + Number(d.absoluteQuantity), 0),\n                totalBids: demandData.reduce((sum, d)=>sum + d.absoluteBidCount, 0),\n                priceRange: {\n                    min: Math.min(...demandData.map((d)=>d.price).filter((p)=>p !== null)),\n                    max: Math.max(...demandData.map((d)=>d.price).filter((p)=>p !== null))\n                }\n            }\n        };\n    }\n    // Risk assessment computation\n    computeRiskAssessment(ipoData, gmpData, subscriptionData) {\n        let riskScore = 50; // Base risk score\n        const riskFactors = [];\n        // GMP volatility risk\n        if (gmpData && gmpData.length > 1) {\n            const gmpValues = gmpData.map((g)=>g.value);\n            const volatility = this.calculateStandardDeviation(gmpValues);\n            const avgGMP = this.calculateAverage(gmpValues);\n            const volatilityRatio = avgGMP > 0 ? volatility / avgGMP : 0;\n            if (volatilityRatio > 0.3) {\n                riskScore += 20;\n                riskFactors.push({\n                    type: \"HIGH_GMP_VOLATILITY\",\n                    impact: \"high\",\n                    description: `High GMP volatility (${(volatilityRatio * 100).toFixed(1)}%)`,\n                    mitigation: \"Consider waiting for price stabilization\"\n                });\n            } else if (volatilityRatio > 0.15) {\n                riskScore += 10;\n                riskFactors.push({\n                    type: \"MODERATE_GMP_VOLATILITY\",\n                    impact: \"medium\",\n                    description: `Moderate GMP volatility (${(volatilityRatio * 100).toFixed(1)}%)`,\n                    mitigation: \"Monitor GMP trends closely\"\n                });\n            }\n        }\n        // Subscription risk\n        if (subscriptionData && subscriptionData.length > 0) {\n            const latestSubscription = this.getLatestSubscriptionByCategory(subscriptionData);\n            const overallSubscription = this.calculateOverallSubscription(latestSubscription);\n            if (overallSubscription < 0.5) {\n                riskScore += 25;\n                riskFactors.push({\n                    type: \"LOW_SUBSCRIPTION\",\n                    impact: \"high\",\n                    description: `Low subscription ratio (${overallSubscription.toFixed(2)}x)`,\n                    mitigation: \"Reconsider investment due to weak demand\"\n                });\n            } else if (overallSubscription > 10) {\n                riskScore += 15;\n                riskFactors.push({\n                    type: \"OVER_SUBSCRIPTION\",\n                    impact: \"medium\",\n                    description: `Very high subscription (${overallSubscription.toFixed(2)}x)`,\n                    mitigation: \"Low allotment probability, consider alternatives\"\n                });\n            }\n        }\n        // Issue size risk\n        const issueSize = Number(ipoData.issueSize || 0);\n        if (issueSize > 5000 * 10000000) {\n            // 5000 Cr\n            riskScore += 10;\n            riskFactors.push({\n                type: \"LARGE_ISSUE_SIZE\",\n                impact: \"medium\",\n                description: \"Large issue size may impact liquidity\",\n                mitigation: \"Ensure adequate market support post-listing\"\n            });\n        }\n        // Price band risk\n        const priceRange = ipoData.maxPrice - ipoData.minPrice;\n        const spreadPercentage = ipoData.minPrice > 0 ? priceRange / ipoData.minPrice * 100 : 0;\n        if (spreadPercentage > 20) {\n            riskScore += 5;\n            riskFactors.push({\n                type: \"WIDE_PRICE_BAND\",\n                impact: \"low\",\n                description: `Wide price band (${spreadPercentage.toFixed(1)}%)`,\n                mitigation: \"Price discovery may be challenging\"\n            });\n        }\n        // Normalize risk score\n        riskScore = Math.max(0, Math.min(100, riskScore));\n        return {\n            overallRiskScore: riskScore,\n            riskLevel: this.categorizeRiskLevel(riskScore),\n            riskFactors,\n            recommendation: this.generateRiskRecommendation(riskScore, riskFactors),\n            lastUpdated: new Date().toISOString()\n        };\n    }\n    // Performance indicators computation\n    computePerformanceIndicators(ipoData, gmpData, subscriptionData) {\n        const indicators = {};\n        // Market sentiment indicator\n        indicators.marketSentiment = this.calculateMarketSentiment(gmpData, subscriptionData);\n        // Demand strength indicator\n        indicators.demandStrength = this.calculateDemandStrength(subscriptionData);\n        // Price momentum indicator\n        if (gmpData && gmpData.length > 0) {\n            indicators.priceMomentum = this.calculateMomentum(gmpData.map((g)=>g.value));\n        }\n        // Listing readiness indicator\n        indicators.listingReadiness = this.calculateListingReadiness(ipoData, subscriptionData);\n        // Investment attractiveness score\n        indicators.attractivenessScore = this.calculateAttractivenessScore(indicators);\n        return indicators;\n    }\n    // Historical analysis computation\n    async computeHistoricalAnalysis(ipoId, timeRange) {\n        try {\n            // Get comparable IPOs for benchmarking\n            const comparableIPOs = await this.getComparableIPOs(ipoId, timeRange);\n            // Historical performance metrics\n            const historicalMetrics = await this.calculateHistoricalMetrics(ipoId, timeRange);\n            // Trend analysis over time\n            const trends = await this.calculateHistoricalTrends(ipoId, timeRange);\n            return {\n                timeRange,\n                comparableIPOs: comparableIPOs.length,\n                metrics: historicalMetrics,\n                trends,\n                benchmarks: await this.calculateBenchmarks(comparableIPOs)\n            };\n        } catch (error) {\n            console.error(\"Historical analysis failed:\", error);\n            return {\n                status: \"error\",\n                message: \"Historical analysis unavailable\"\n            };\n        }\n    }\n    // Predictions computation\n    async computePredictions(analytics) {\n        const predictions = {};\n        try {\n            // Listing gain prediction\n            predictions.listingGain = this.predictListingGain(analytics);\n            // Allotment probability prediction\n            predictions.allotmentProbability = this.predictAllotmentProbability(analytics);\n            // Price target prediction\n            predictions.priceTargets = this.predictPriceTargets(analytics);\n            // Risk-adjusted returns\n            predictions.riskAdjustedReturns = this.calculateRiskAdjustedReturns(predictions.listingGain, analytics.riskAssessment.overallRiskScore);\n            // Confidence intervals\n            predictions.confidenceIntervals = this.calculateConfidenceIntervals(predictions);\n            predictions.lastUpdated = new Date().toISOString();\n            predictions.model = \"IPO_ANALYTICS_V1.0\";\n        } catch (error) {\n            console.error(\"Predictions computation failed:\", error);\n            predictions.status = \"error\";\n            predictions.message = \"Predictions unavailable\";\n        }\n        return predictions;\n    }\n    // Comparative analysis\n    async computeComparativeAnalysis(ipoData) {\n        try {\n            // Find similar IPOs by sector, size, and time period\n            const similarIPOs = await this.findSimilarIPOs(ipoData);\n            // Calculate relative performance\n            const relativePerformance = await this.calculateRelativePerformance(ipoData, similarIPOs);\n            // Market positioning\n            const marketPositioning = this.calculateMarketPositioning(ipoData, similarIPOs);\n            return {\n                similarIPOsCount: similarIPOs.length,\n                relativePerformance,\n                marketPositioning,\n                benchmarks: await this.calculateIndustryBenchmarks(ipoData.issueType)\n            };\n        } catch (error) {\n            console.error(\"Comparative analysis failed:\", error);\n            return {\n                status: \"error\",\n                message: \"Comparative analysis unavailable\"\n            };\n        }\n    }\n    // Insights generation\n    generateInsights(analytics) {\n        const insights = [];\n        // GMP insights\n        if (analytics.gmpAnalytics.status === \"available\") {\n            const gmp = analytics.gmpAnalytics;\n            if (gmp.statistics.current > gmp.statistics.average * 1.2) {\n                insights.push({\n                    type: \"positive\",\n                    category: \"GMP\",\n                    title: \"Strong GMP Performance\",\n                    description: `Current GMP (₹${gmp.statistics.current}) is ${((gmp.statistics.current / gmp.statistics.average - 1) * 100).toFixed(1)}% above average`,\n                    impact: \"Indicates strong market demand\"\n                });\n            }\n            if (gmp.volatility.level === \"high\") {\n                insights.push({\n                    type: \"warning\",\n                    category: \"GMP\",\n                    title: \"High Price Volatility\",\n                    description: `GMP showing high volatility (${gmp.volatility.coefficient}%)`,\n                    impact: \"Increased uncertainty in price expectations\"\n                });\n            }\n        }\n        // Subscription insights\n        if (analytics.subscriptionAnalytics.status === \"available\") {\n            const sub = analytics.subscriptionAnalytics;\n            if (sub.overall.totalSubscription > 5) {\n                insights.push({\n                    type: \"positive\",\n                    category: \"Subscription\",\n                    title: \"Strong Oversubscription\",\n                    description: `IPO oversubscribed by ${sub.overall.totalSubscription.toFixed(2)}x`,\n                    impact: \"High investor interest but lower allotment probability\"\n                });\n            }\n            if (sub.overall.totalSubscription < 1) {\n                insights.push({\n                    type: \"negative\",\n                    category: \"Subscription\",\n                    title: \"Undersubscribed IPO\",\n                    description: `IPO subscribed only ${(sub.overall.totalSubscription * 100).toFixed(1)}%`,\n                    impact: \"Weak investor demand, potential listing concerns\"\n                });\n            }\n        }\n        // Risk insights\n        const risk = analytics.riskAssessment;\n        if (risk.riskLevel === \"high\") {\n            insights.push({\n                type: \"warning\",\n                category: \"Risk\",\n                title: \"High Risk Investment\",\n                description: `Risk score of ${risk.overallRiskScore} indicates elevated risk`,\n                impact: \"Careful consideration required before investment\"\n            });\n        }\n        return insights;\n    }\n    // Recommendations generation\n    generateRecommendations(analytics) {\n        const recommendations = [];\n        const risk = analytics.riskAssessment.overallRiskScore;\n        const subscription = analytics.subscriptionAnalytics.overall?.totalSubscription || 0;\n        const gmp = analytics.gmpAnalytics.statistics?.current || 0;\n        // Investment recommendation\n        if (risk < 30 && subscription > 2 && gmp > 0) {\n            recommendations.push({\n                type: \"BUY\",\n                confidence: \"high\",\n                reasoning: \"Low risk, strong demand, positive GMP\",\n                action: \"Consider applying for maximum allocation\"\n            });\n        } else if (risk < 50 && subscription > 1) {\n            recommendations.push({\n                type: \"HOLD\",\n                confidence: \"medium\",\n                reasoning: \"Moderate risk with adequate demand\",\n                action: \"Apply with caution, consider smaller allocation\"\n            });\n        } else if (risk > 70 || subscription < 0.5) {\n            recommendations.push({\n                type: \"AVOID\",\n                confidence: \"high\",\n                reasoning: \"High risk or weak demand indicators\",\n                action: \"Consider alternative investment opportunities\"\n            });\n        }\n        // Timing recommendations\n        if (analytics.performanceIndicators?.listingReadiness > 0.8) {\n            recommendations.push({\n                type: \"TIMING\",\n                confidence: \"medium\",\n                reasoning: \"IPO appears ready for successful listing\",\n                action: \"Good timing for application\"\n            });\n        }\n        // Allocation recommendations\n        if (subscription > 10) {\n            recommendations.push({\n                type: \"ALLOCATION\",\n                confidence: \"high\",\n                reasoning: \"Very high oversubscription\",\n                action: \"Apply for maximum retail quota to improve allotment chances\"\n            });\n        }\n        return recommendations;\n    }\n    // Utility methods for calculations\n    calculateAverage(values) {\n        if (!values || values.length === 0) return 0;\n        return values.reduce((sum, val)=>sum + val, 0) / values.length;\n    }\n    calculateMedian(values) {\n        if (!values || values.length === 0) return 0;\n        const sorted = [\n            ...values\n        ].sort((a, b)=>a - b);\n        const mid = Math.floor(sorted.length / 2);\n        return sorted.length % 2 === 0 ? (sorted[mid - 1] + sorted[mid]) / 2 : sorted[mid];\n    }\n    calculateMode(values) {\n        if (!values || values.length === 0) return 0;\n        const frequency = {};\n        values.forEach((val)=>frequency[val] = (frequency[val] || 0) + 1);\n        return Object.keys(frequency).reduce((a, b)=>frequency[a] > frequency[b] ? a : b);\n    }\n    calculateStandardDeviation(values) {\n        if (!values || values.length < 2) return 0;\n        const avg = this.calculateAverage(values);\n        const variance = values.reduce((sum, val)=>sum + Math.pow(val - avg, 2), 0) / values.length;\n        return Math.sqrt(variance);\n    }\n    calculateVariance(values) {\n        if (!values || values.length < 2) return 0;\n        const avg = this.calculateAverage(values);\n        return values.reduce((sum, val)=>sum + Math.pow(val - avg, 2), 0) / values.length;\n    }\n    calculateCoefficientOfVariation(values) {\n        const avg = this.calculateAverage(values);\n        const stdDev = this.calculateStandardDeviation(values);\n        return avg > 0 ? stdDev / avg * 100 : 0;\n    }\n    analyzeTrend(values) {\n        if (!values || values.length < 2) return {\n            direction: \"stable\",\n            strength: 0\n        };\n        const recent = values.slice(0, Math.min(5, Math.floor(values.length / 2)));\n        const older = values.slice(-Math.min(5, Math.floor(values.length / 2)));\n        const recentAvg = this.calculateAverage(recent);\n        const olderAvg = this.calculateAverage(older);\n        const change = recentAvg - olderAvg;\n        const changePercent = olderAvg > 0 ? change / olderAvg * 100 : 0;\n        let direction = \"stable\";\n        let strength = Math.abs(changePercent);\n        if (changePercent > 5) direction = \"bullish\";\n        else if (changePercent < -5) direction = \"bearish\";\n        return {\n            direction,\n            strength,\n            change,\n            changePercent\n        };\n    }\n    analyzeVolatility(values, timestamps) {\n        if (!values || values.length < 2) return {\n            level: \"unknown\",\n            coefficient: 0\n        };\n        const coefficient = this.calculateCoefficientOfVariation(values);\n        let level = \"low\";\n        if (coefficient > 30) level = \"high\";\n        else if (coefficient > 15) level = \"medium\";\n        return {\n            level,\n            coefficient,\n            standardDeviation: this.calculateStandardDeviation(values)\n        };\n    }\n    calculateMomentum(values) {\n        if (!values || values.length < 3) return {\n            score: 0,\n            direction: \"neutral\"\n        };\n        const recent = values.slice(0, 3);\n        const momentum = recent[0] - recent[2];\n        const momentumPercent = recent[2] > 0 ? momentum / recent[2] * 100 : 0;\n        let direction = \"neutral\";\n        if (momentumPercent > 2) direction = \"positive\";\n        else if (momentumPercent < -2) direction = \"negative\";\n        return {\n            score: momentumPercent,\n            direction,\n            absolute: momentum\n        };\n    }\n    // Data fetching methods\n    async getIPOBasicData(ipoId) {\n        return await _db_js__WEBPACK_IMPORTED_MODULE_0__.prisma.iPO.findUnique({\n            where: {\n                id: ipoId\n            },\n            include: {\n                categories: true\n            }\n        });\n    }\n    async getGMPData(ipoId, days = 30) {\n        const startDate = new Date();\n        startDate.setDate(startDate.getDate() - days);\n        return await _db_js__WEBPACK_IMPORTED_MODULE_0__.prisma.gMP.findMany({\n            where: {\n                ipoId,\n                timestamp: {\n                    gte: startDate\n                }\n            },\n            orderBy: {\n                timestamp: \"desc\"\n            }\n        });\n    }\n    async getSubscriptionData(ipoId, days = 30) {\n        const startDate = new Date();\n        startDate.setDate(startDate.getDate() - days);\n        return await _db_js__WEBPACK_IMPORTED_MODULE_0__.prisma.subscriptionData.findMany({\n            where: {\n                ipoId,\n                timestamp: {\n                    gte: startDate\n                }\n            },\n            orderBy: {\n                timestamp: \"desc\"\n            }\n        });\n    }\n    async getDemandData(ipoId, days = 30) {\n        const startDate = new Date();\n        startDate.setDate(startDate.getDate() - days);\n        return await _db_js__WEBPACK_IMPORTED_MODULE_0__.prisma.marketDemand.findMany({\n            where: {\n                ipoId,\n                timestamp: {\n                    gte: startDate\n                }\n            },\n            orderBy: {\n                timestamp: \"desc\"\n            }\n        });\n    }\n    async getIPOCategories(ipoId) {\n        return await _db_js__WEBPACK_IMPORTED_MODULE_0__.prisma.iPOCategory.findMany({\n            where: {\n                ipoId\n            }\n        });\n    }\n    // Cache management\n    async getCachedAnalytics(key) {\n        // Check in-memory cache first\n        if (this.analyticsCache.has(key)) {\n            const cached = this.analyticsCache.get(key);\n            if (Date.now() - cached.timestamp < this.cacheTTL.DETAILED) {\n                return cached.data;\n            }\n            this.analyticsCache.delete(key);\n        }\n        // Check Redis cache\n        return await _cache_js__WEBPACK_IMPORTED_MODULE_1__.cache.get(key);\n    }\n    async setCachedAnalytics(key, data, ttl) {\n        // Set in-memory cache\n        this.analyticsCache.set(key, {\n            data,\n            timestamp: Date.now()\n        });\n        // Set in Redis\n        return await _cache_js__WEBPACK_IMPORTED_MODULE_1__.cache.set(key, data, ttl / 1000);\n    }\n    // Helper methods\n    categorizeIssueSize(size) {\n        if (size < 500 * 10000000) return \"small\"; // < 500 Cr\n        if (size < 2000 * 10000000) return \"medium\"; // < 2000 Cr\n        return \"large\"; // >= 2000 Cr\n    }\n    calculateDuration(startDate, endDate) {\n        const start = new Date(startDate);\n        const end = new Date(endDate);\n        return Math.ceil((end - start) / (1000 * 60 * 60 * 24));\n    }\n    categorizeRiskLevel(score) {\n        if (score < 30) return \"low\";\n        if (score < 60) return \"medium\";\n        return \"high\";\n    }\n    getLatestSubscriptionByCategory(subscriptionData) {\n        const latest = {};\n        subscriptionData.forEach((item)=>{\n            const key = item.category + (item.subCategory || \"\");\n            if (!latest[key] || item.timestamp > latest[key].timestamp) {\n                latest[key] = item;\n            }\n        });\n        return latest;\n    }\n    calculateOverallSubscription(latestByCategory) {\n        const ratios = Object.values(latestByCategory).map((item)=>item.subscriptionRatio || 0);\n        return ratios.length > 0 ? Math.max(...ratios) : 0;\n    }\n    // Performance tracking\n    updateMetrics(computationTime) {\n        this.metrics.computationsPerformed++;\n        this.metrics.averageComputationTime = (this.metrics.averageComputationTime * (this.metrics.computationsPerformed - 1) + computationTime) / this.metrics.computationsPerformed;\n    }\n    getPerformanceMetrics() {\n        const hitRate = this.metrics.cacheHits + this.metrics.cacheMisses > 0 ? (this.metrics.cacheHits / (this.metrics.cacheHits + this.metrics.cacheMisses) * 100).toFixed(2) : \"0.00\";\n        return {\n            ...this.metrics,\n            cacheHitRate: `${hitRate}%`,\n            averageComputationTime: Math.round(this.metrics.averageComputationTime),\n            successRate: this.metrics.computationsPerformed > 0 ? ((this.metrics.computationsPerformed - this.metrics.errors) / this.metrics.computationsPerformed * 100).toFixed(2) : \"100.00\"\n        };\n    }\n    // Placeholder methods for advanced features (to be implemented)\n    async getComparableIPOs(ipoId, timeRange) {\n        return [];\n    }\n    async calculateHistoricalMetrics(ipoId, timeRange) {\n        return {};\n    }\n    async calculateHistoricalTrends(ipoId, timeRange) {\n        return {};\n    }\n    async calculateBenchmarks(comparableIPOs) {\n        return {};\n    }\n    async findSimilarIPOs(ipoData) {\n        return [];\n    }\n    async calculateRelativePerformance(ipoData, similarIPOs) {\n        return {};\n    }\n    calculateMarketPositioning(ipoData, similarIPOs) {\n        return {};\n    }\n    async calculateIndustryBenchmarks(issueType) {\n        return {};\n    }\n    predictListingGain(analytics) {\n        const gmp = analytics.gmpAnalytics.statistics?.current || 0;\n        const risk = analytics.riskAssessment.overallRiskScore || 50;\n        const subscription = analytics.subscriptionAnalytics.overall?.totalSubscription || 1;\n        // Simple prediction model (enhance with ML)\n        let prediction = gmp * 0.8; // Conservative estimate\n        // Adjust for risk\n        prediction *= 1 - risk / 200; // Reduce by half the risk percentage\n        // Adjust for subscription\n        if (subscription > 5) prediction *= 0.9; // High subscription may limit gains\n        else if (subscription < 1) prediction *= 0.7; // Low subscription is bearish\n        return {\n            value: Math.round(prediction),\n            confidence: 0.6,\n            range: {\n                min: Math.round(prediction * 0.7),\n                max: Math.round(prediction * 1.3)\n            }\n        };\n    }\n    predictAllotmentProbability(analytics) {\n        const subscription = analytics.subscriptionAnalytics.overall?.totalSubscription || 1;\n        let probability = 100;\n        if (subscription > 1) {\n            probability = Math.min(95, 100 / subscription);\n        }\n        return {\n            retail: Math.round(probability),\n            confidence: 0.8\n        };\n    }\n    predictPriceTargets(analytics) {\n        const gmp = analytics.gmpAnalytics.statistics?.current || 0;\n        const basePrice = analytics.basicMetrics?.priceRange?.max || 0;\n        return {\n            conservative: basePrice + gmp * 0.5,\n            moderate: basePrice + gmp * 0.8,\n            aggressive: basePrice + gmp * 1.2\n        };\n    }\n    calculateRiskAdjustedReturns(listingGain, riskScore) {\n        const gain = listingGain.value || 0;\n        const risk = riskScore || 50;\n        return {\n            riskAdjustedReturn: gain * (1 - risk / 100),\n            sharpeRatio: risk > 0 ? gain / risk : 0\n        };\n    }\n    calculateConfidenceIntervals(predictions) {\n        return {\n            listingGain: {\n                confidence90: {\n                    min: predictions.listingGain?.range?.min || 0,\n                    max: predictions.listingGain?.range?.max || 0\n                }\n            }\n        };\n    }\n    // Additional helper methods\n    analyzeVolume(volumes, values) {\n        return {\n            correlation: 0,\n            trend: \"stable\"\n        };\n    }\n    calculatePriceTargets(stats) {\n        return {\n            support: stats.min,\n            resistance: stats.max,\n            pivot: stats.average\n        };\n    }\n    calculateGMPRiskMetrics(values) {\n        return {\n            valueAtRisk: this.calculateStandardDeviation(values) * 1.645,\n            maxDrawdown: this.calculateMaxDrawdown(values)\n        };\n    }\n    calculateMaxDrawdown(values) {\n        let maxDrawdown = 0;\n        let peak = values[0];\n        for(let i = 1; i < values.length; i++){\n            if (values[i] > peak) {\n                peak = values[i];\n            } else {\n                const drawdown = (peak - values[i]) / peak;\n                maxDrawdown = Math.max(maxDrawdown, drawdown);\n            }\n        }\n        return maxDrawdown * 100; // Return as percentage\n    }\n    analyzeSubscriptionPatterns(subscriptionData) {\n        return {\n            trend: \"increasing\"\n        };\n    }\n    calculateAllotmentProbabilities(latestByCategory) {\n        const result = {};\n        for (const [category, data] of Object.entries(latestByCategory)){\n            const ratio = data.subscriptionRatio || 1;\n            result[category] = ratio > 1 ? Math.min(95, 100 / ratio) : 95;\n        }\n        return result;\n    }\n    generateSubscriptionInsights(overall, categories) {\n        return [];\n    }\n    analyzePriceWiseDemand(demandData) {\n        return {\n            distribution: \"normal\"\n        };\n    }\n    analyzeCutOffDemand(demandData) {\n        return {\n            percentage: 0\n        };\n    }\n    analyzeDemandDistribution(demandData) {\n        return {\n            concentration: \"distributed\"\n        };\n    }\n    analyzeBidConcentration(demandData) {\n        return {\n            herfindahlIndex: 0\n        };\n    }\n    calculateMarketSentiment(gmpData, subscriptionData) {\n        return 0.5;\n    }\n    calculateDemandStrength(subscriptionData) {\n        return 0.5;\n    }\n    calculateListingReadiness(ipoData, subscriptionData) {\n        return 0.8;\n    }\n    calculateAttractivenessScore(indicators) {\n        return 0.7;\n    }\n    calculateTimespan(data) {\n        if (!data || data.length < 2) return 0;\n        const first = new Date(data[data.length - 1].timestamp);\n        const last = new Date(data[0].timestamp);\n        return Math.ceil((last - first) / (1000 * 60 * 60 * 24));\n    }\n    generateRiskRecommendation(score, factors) {\n        if (score < 30) return \"Low risk investment, suitable for conservative investors\";\n        if (score < 60) return \"Moderate risk, suitable for balanced portfolios\";\n        return \"High risk investment, suitable only for aggressive investors\";\n    }\n}\n// Export singleton instance\nconst analyticsService = new AnalyticsService();\n// Cleanup old cache entries periodically\nsetInterval(()=>{\n    const now = Date.now();\n    for (const [key, value] of analyticsService.analyticsCache.entries()){\n        if (now - value.timestamp > analyticsService.cacheTTL.DETAILED) {\n            analyticsService.analyticsCache.delete(key);\n        }\n    }\n}, 10 * 60 * 1000); // Every 10 minutes\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (analyticsService);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFFdkQseUNBQXlDO0FBQ3pDZ1csWUFDRTtJQUNFLE1BQU1qVSxNQUFNRCxLQUFLQyxHQUFHO0lBQ3BCLEtBQUssTUFBTSxDQUFDbVIsS0FBSzNMLE1BQU0sSUFBSXdPLGlCQUFpQnZWLGNBQWMsQ0FBQ21LLE9BQU8sR0FBSTtRQUNwRSxJQUFJNUksTUFBTXdGLE1BQU15QixTQUFTLEdBQUcrTSxpQkFBaUJyVixRQUFRLENBQUNFLFFBQVEsRUFBRTtZQUM5RG1WLGlCQUFpQnZWLGNBQWMsQ0FBQzZTLE1BQU0sQ0FBQ0g7UUFDekM7SUFDRjtBQUNGLEdBQ0EsS0FBSyxLQUFLLE9BQ1QsbUJBQW1CO0FBRXRCLGlFQUFlNkMsZ0JBQWdCQSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaXBvLXRyYWNrZXIvLi9zcmMvbGliL2FuYWx5dGljcy5qcz83MWFkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHByaXNtYSB9IGZyb20gXCIuL2RiLmpzXCI7XHJcbmltcG9ydCB7IGNhY2hlIH0gZnJvbSBcIi4vY2FjaGUuanNcIjtcclxuXHJcbmNsYXNzIEFuYWx5dGljc1NlcnZpY2Uge1xyXG4gIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgLy8gUGVyZm9ybWFuY2UgbWV0cmljc1xyXG4gICAgdGhpcy5tZXRyaWNzID0ge1xyXG4gICAgICBjb21wdXRhdGlvbnNQZXJmb3JtZWQ6IDAsXHJcbiAgICAgIGNhY2hlSGl0czogMCxcclxuICAgICAgY2FjaGVNaXNzZXM6IDAsXHJcbiAgICAgIGF2ZXJhZ2VDb21wdXRhdGlvblRpbWU6IDAsXHJcbiAgICAgIGVycm9yczogMCxcclxuICAgIH07XHJcblxyXG4gICAgLy8gQW5hbHl0aWNzIGNhY2hlIHdpdGggVFRMXHJcbiAgICB0aGlzLmFuYWx5dGljc0NhY2hlID0gbmV3IE1hcCgpO1xyXG4gICAgdGhpcy5jYWNoZVRUTCA9IHtcclxuICAgICAgQkFTSUM6IDUgKiA2MCAqIDEwMDAsIC8vIDUgbWludXRlc1xyXG4gICAgICBERVRBSUxFRDogMTAgKiA2MCAqIDEwMDAsIC8vIDEwIG1pbnV0ZXNcclxuICAgICAgSElTVE9SSUNBTDogMzAgKiA2MCAqIDEwMDAsIC8vIDMwIG1pbnV0ZXNcclxuICAgICAgUFJFRElDVElPTlM6IDE1ICogNjAgKiAxMDAwLCAvLyAxNSBtaW51dGVzXHJcbiAgICB9O1xyXG5cclxuICAgIC8vIFJpc2sgYXNzZXNzbWVudCB3ZWlnaHRzXHJcbiAgICB0aGlzLnJpc2tXZWlnaHRzID0ge1xyXG4gICAgICBHTVBfVk9MQVRJTElUWTogMC4zLFxyXG4gICAgICBTVUJTQ1JJUFRJT05fUkFUSU86IDAuMjUsXHJcbiAgICAgIElTU1VFX1NJWkU6IDAuMixcclxuICAgICAgTUFSS0VUX0NPTkRJVElPTlM6IDAuMTUsXHJcbiAgICAgIFNFQ1RPUl9QRVJGT1JNQU5DRTogMC4xLFxyXG4gICAgfTtcclxuXHJcbiAgICAvLyBQcmVkaWN0aW9uIG1vZGVscyBjb25maWd1cmF0aW9uXHJcbiAgICB0aGlzLnByZWRpY3Rpb25Nb2RlbHMgPSB7XHJcbiAgICAgIExJU1RJTkdfR0FJTjoge1xyXG4gICAgICAgIGZhY3RvcnM6IFtcclxuICAgICAgICAgIFwiYXZnR01QXCIsXHJcbiAgICAgICAgICBcInN1YnNjcmlwdGlvblJhdGlvXCIsXHJcbiAgICAgICAgICBcImlzc3VlU2l6ZVwiLFxyXG4gICAgICAgICAgXCJtYXJrZXRTZW50aW1lbnRcIixcclxuICAgICAgICBdLFxyXG4gICAgICAgIHdlaWdodHM6IFswLjQsIDAuMywgMC4yLCAwLjFdLFxyXG4gICAgICB9LFxyXG4gICAgICBBTExPVE1FTlRfUFJPQkFCSUxJVFk6IHtcclxuICAgICAgICBmYWN0b3JzOiBbXCJzdWJzY3JpcHRpb25SYXRpb1wiLCBcImFwcGxpY2F0aW9uQW1vdW50XCIsIFwiY2F0ZWdvcnlcIl0sXHJcbiAgICAgICAgd2VpZ2h0czogWzAuNiwgMC4zLCAwLjFdLFxyXG4gICAgICB9LFxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIC8vIENvbXByZWhlbnNpdmUgSVBPIGFuYWx5dGljcyBjb21wdXRhdGlvblxyXG4gIGFzeW5jIGNvbXB1dGVJUE9BbmFseXRpY3MoaXBvSWQsIG9wdGlvbnMgPSB7fSkge1xyXG4gICAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcclxuXHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCB7XHJcbiAgICAgICAgaW5jbHVkZUhpc3RvcmljYWwgPSB0cnVlLFxyXG4gICAgICAgIGluY2x1ZGVQcmVkaWN0aW9ucyA9IHRydWUsXHJcbiAgICAgICAgdGltZVJhbmdlID0gMzAsIC8vIGRheXNcclxuICAgICAgICByZWZyZXNoQ2FjaGUgPSBmYWxzZSxcclxuICAgICAgfSA9IG9wdGlvbnM7XHJcblxyXG4gICAgICAvLyBDaGVjayBjYWNoZSBmaXJzdFxyXG4gICAgICBjb25zdCBjYWNoZUtleSA9IGBhbmFseXRpY3M6JHtpcG9JZH06JHt0aW1lUmFuZ2V9OiR7aW5jbHVkZUhpc3RvcmljYWx9OiR7aW5jbHVkZVByZWRpY3Rpb25zfWA7XHJcblxyXG4gICAgICBpZiAoIXJlZnJlc2hDYWNoZSkge1xyXG4gICAgICAgIGNvbnN0IGNhY2hlZCA9IGF3YWl0IHRoaXMuZ2V0Q2FjaGVkQW5hbHl0aWNzKGNhY2hlS2V5KTtcclxuICAgICAgICBpZiAoY2FjaGVkKSB7XHJcbiAgICAgICAgICB0aGlzLm1ldHJpY3MuY2FjaGVIaXRzKys7XHJcbiAgICAgICAgICByZXR1cm4gY2FjaGVkO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy5tZXRyaWNzLmNhY2hlTWlzc2VzKys7XHJcblxyXG4gICAgICAvLyBGZXRjaCBjb21wcmVoZW5zaXZlIGRhdGFcclxuICAgICAgY29uc3QgW2lwb0RhdGEsIGdtcERhdGEsIHN1YnNjcmlwdGlvbkRhdGEsIGRlbWFuZERhdGEsIGNhdGVnb3J5RGF0YV0gPVxyXG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKFtcclxuICAgICAgICAgIHRoaXMuZ2V0SVBPQmFzaWNEYXRhKGlwb0lkKSxcclxuICAgICAgICAgIHRoaXMuZ2V0R01QRGF0YShpcG9JZCwgdGltZVJhbmdlKSxcclxuICAgICAgICAgIHRoaXMuZ2V0U3Vic2NyaXB0aW9uRGF0YShpcG9JZCwgdGltZVJhbmdlKSxcclxuICAgICAgICAgIHRoaXMuZ2V0RGVtYW5kRGF0YShpcG9JZCwgdGltZVJhbmdlKSxcclxuICAgICAgICAgIHRoaXMuZ2V0SVBPQ2F0ZWdvcmllcyhpcG9JZCksXHJcbiAgICAgICAgXSk7XHJcblxyXG4gICAgICBpZiAoIWlwb0RhdGEpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYElQTyB3aXRoIElEICR7aXBvSWR9IG5vdCBmb3VuZGApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBDb21wdXRlIGFuYWx5dGljc1xyXG4gICAgICBjb25zdCBhbmFseXRpY3MgPSB7XHJcbiAgICAgICAgaXBvSWQsXHJcbiAgICAgICAgc3ltYm9sOiBpcG9EYXRhLnN5bWJvbCxcclxuICAgICAgICBuYW1lOiBpcG9EYXRhLm5hbWUsXHJcbiAgICAgICAgc3RhdHVzOiBpcG9EYXRhLnN0YXR1cyxcclxuICAgICAgICBjb21wdXRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXHJcblxyXG4gICAgICAgIC8vIEJhc2ljIG1ldHJpY3NcclxuICAgICAgICBiYXNpY01ldHJpY3M6IHRoaXMuY29tcHV0ZUJhc2ljTWV0cmljcyhpcG9EYXRhKSxcclxuXHJcbiAgICAgICAgLy8gR01QIGFuYWx5dGljc1xyXG4gICAgICAgIGdtcEFuYWx5dGljczogdGhpcy5jb21wdXRlR01QQW5hbHl0aWNzKGdtcERhdGEpLFxyXG5cclxuICAgICAgICAvLyBTdWJzY3JpcHRpb24gYW5hbHl0aWNzXHJcbiAgICAgICAgc3Vic2NyaXB0aW9uQW5hbHl0aWNzOiB0aGlzLmNvbXB1dGVTdWJzY3JpcHRpb25BbmFseXRpY3MoXHJcbiAgICAgICAgICBzdWJzY3JpcHRpb25EYXRhLFxyXG4gICAgICAgICAgY2F0ZWdvcnlEYXRhXHJcbiAgICAgICAgKSxcclxuXHJcbiAgICAgICAgLy8gTWFya2V0IGRlbWFuZCBhbmFseXRpY3NcclxuICAgICAgICBkZW1hbmRBbmFseXRpY3M6IHRoaXMuY29tcHV0ZURlbWFuZEFuYWx5dGljcyhkZW1hbmREYXRhKSxcclxuXHJcbiAgICAgICAgLy8gUmlzayBhc3Nlc3NtZW50XHJcbiAgICAgICAgcmlza0Fzc2Vzc21lbnQ6IHRoaXMuY29tcHV0ZVJpc2tBc3Nlc3NtZW50KFxyXG4gICAgICAgICAgaXBvRGF0YSxcclxuICAgICAgICAgIGdtcERhdGEsXHJcbiAgICAgICAgICBzdWJzY3JpcHRpb25EYXRhXHJcbiAgICAgICAgKSxcclxuXHJcbiAgICAgICAgLy8gUGVyZm9ybWFuY2UgaW5kaWNhdG9yc1xyXG4gICAgICAgIHBlcmZvcm1hbmNlSW5kaWNhdG9yczogdGhpcy5jb21wdXRlUGVyZm9ybWFuY2VJbmRpY2F0b3JzKFxyXG4gICAgICAgICAgaXBvRGF0YSxcclxuICAgICAgICAgIGdtcERhdGEsXHJcbiAgICAgICAgICBzdWJzY3JpcHRpb25EYXRhXHJcbiAgICAgICAgKSxcclxuICAgICAgfTtcclxuXHJcbiAgICAgIC8vIEFkZCBoaXN0b3JpY2FsIGFuYWx5c2lzXHJcbiAgICAgIGlmIChpbmNsdWRlSGlzdG9yaWNhbCkge1xyXG4gICAgICAgIGFuYWx5dGljcy5oaXN0b3JpY2FsQW5hbHlzaXMgPSBhd2FpdCB0aGlzLmNvbXB1dGVIaXN0b3JpY2FsQW5hbHlzaXMoXHJcbiAgICAgICAgICBpcG9JZCxcclxuICAgICAgICAgIHRpbWVSYW5nZVxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIEFkZCBwcmVkaWN0aW9uc1xyXG4gICAgICBpZiAoaW5jbHVkZVByZWRpY3Rpb25zKSB7XHJcbiAgICAgICAgYW5hbHl0aWNzLnByZWRpY3Rpb25zID0gYXdhaXQgdGhpcy5jb21wdXRlUHJlZGljdGlvbnMoYW5hbHl0aWNzKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQWRkIGNvbXBhcmF0aXZlIGFuYWx5c2lzXHJcbiAgICAgIGFuYWx5dGljcy5jb21wYXJhdGl2ZUFuYWx5c2lzID1cclxuICAgICAgICBhd2FpdCB0aGlzLmNvbXB1dGVDb21wYXJhdGl2ZUFuYWx5c2lzKGlwb0RhdGEpO1xyXG5cclxuICAgICAgLy8gQWRkIGluc2lnaHRzIGFuZCByZWNvbW1lbmRhdGlvbnNcclxuICAgICAgYW5hbHl0aWNzLmluc2lnaHRzID0gdGhpcy5nZW5lcmF0ZUluc2lnaHRzKGFuYWx5dGljcyk7XHJcbiAgICAgIGFuYWx5dGljcy5yZWNvbW1lbmRhdGlvbnMgPSB0aGlzLmdlbmVyYXRlUmVjb21tZW5kYXRpb25zKGFuYWx5dGljcyk7XHJcblxyXG4gICAgICAvLyBDYWNoZSB0aGUgcmVzdWx0c1xyXG4gICAgICBhd2FpdCB0aGlzLnNldENhY2hlZEFuYWx5dGljcyhcclxuICAgICAgICBjYWNoZUtleSxcclxuICAgICAgICBhbmFseXRpY3MsXHJcbiAgICAgICAgdGhpcy5jYWNoZVRUTC5ERVRBSUxFRFxyXG4gICAgICApO1xyXG5cclxuICAgICAgLy8gVXBkYXRlIG1ldHJpY3NcclxuICAgICAgY29uc3QgY29tcHV0YXRpb25UaW1lID0gRGF0ZS5ub3coKSAtIHN0YXJ0VGltZTtcclxuICAgICAgdGhpcy51cGRhdGVNZXRyaWNzKGNvbXB1dGF0aW9uVGltZSk7XHJcblxyXG4gICAgICByZXR1cm4gYW5hbHl0aWNzO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgdGhpcy5tZXRyaWNzLmVycm9ycysrO1xyXG4gICAgICBjb25zb2xlLmVycm9yKGBBbmFseXRpY3MgY29tcHV0YXRpb24gZmFpbGVkIGZvciBJUE8gJHtpcG9JZH06YCwgZXJyb3IpO1xyXG4gICAgICB0aHJvdyBlcnJvcjtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIEJhc2ljIElQTyBtZXRyaWNzIGNvbXB1dGF0aW9uXHJcbiAgY29tcHV0ZUJhc2ljTWV0cmljcyhpcG9EYXRhKSB7XHJcbiAgICBjb25zdCBwcmljZVJhbmdlID0gaXBvRGF0YS5tYXhQcmljZSAtIGlwb0RhdGEubWluUHJpY2U7XHJcbiAgICBjb25zdCBpc3N1ZVNpemUgPSBOdW1iZXIoaXBvRGF0YS5pc3N1ZVNpemUgfHwgMCk7XHJcbiAgICBjb25zdCBsb3RWYWx1ZSA9IGlwb0RhdGEubG90U2l6ZSAqIChpcG9EYXRhLm1heFByaWNlIHx8IDApO1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgIHByaWNlUmFuZ2U6IHtcclxuICAgICAgICBtaW46IGlwb0RhdGEubWluUHJpY2UsXHJcbiAgICAgICAgbWF4OiBpcG9EYXRhLm1heFByaWNlLFxyXG4gICAgICAgIHNwcmVhZDogcHJpY2VSYW5nZSxcclxuICAgICAgICBzcHJlYWRQZXJjZW50YWdlOlxyXG4gICAgICAgICAgaXBvRGF0YS5taW5QcmljZSA+IDBcclxuICAgICAgICAgICAgPyBwYXJzZUZsb2F0KCgocHJpY2VSYW5nZSAvIGlwb0RhdGEubWluUHJpY2UpICogMTAwKS50b0ZpeGVkKDIpKVxyXG4gICAgICAgICAgICA6IDAsXHJcbiAgICAgIH0sXHJcbiAgICAgIGlzc3VlOiB7XHJcbiAgICAgICAgc2l6ZTogaXNzdWVTaXplLFxyXG4gICAgICAgIHNpemVDYXRlZ29yeTogdGhpcy5jYXRlZ29yaXplSXNzdWVTaXplKGlzc3VlU2l6ZSksXHJcbiAgICAgICAgbG90U2l6ZTogaXBvRGF0YS5sb3RTaXplLFxyXG4gICAgICAgIGxvdFZhbHVlLFxyXG4gICAgICAgIGZhY2VWYWx1ZTogaXBvRGF0YS5mYWNlVmFsdWUsXHJcbiAgICAgIH0sXHJcbiAgICAgIHRpbWVsaW5lOiB7XHJcbiAgICAgICAgb3BlbkRhdGU6IGlwb0RhdGEub3BlbkRhdGUsXHJcbiAgICAgICAgY2xvc2VEYXRlOiBpcG9EYXRhLmNsb3NlRGF0ZSxcclxuICAgICAgICBsaXN0aW5nRGF0ZTogaXBvRGF0YS5saXN0aW5nRGF0ZSxcclxuICAgICAgICBkdXJhdGlvbkRheXM6IHRoaXMuY2FsY3VsYXRlRHVyYXRpb24oXHJcbiAgICAgICAgICBpcG9EYXRhLm9wZW5EYXRlLFxyXG4gICAgICAgICAgaXBvRGF0YS5jbG9zZURhdGVcclxuICAgICAgICApLFxyXG4gICAgICAgIGRheXNUb0xpc3Rpbmc6IGlwb0RhdGEubGlzdGluZ0RhdGVcclxuICAgICAgICAgID8gdGhpcy5jYWxjdWxhdGVEdXJhdGlvbihpcG9EYXRhLmNsb3NlRGF0ZSwgaXBvRGF0YS5saXN0aW5nRGF0ZSlcclxuICAgICAgICAgIDogbnVsbCxcclxuICAgICAgfSxcclxuICAgICAgdHlwZToge1xyXG4gICAgICAgIGlzc3VlVHlwZTogaXBvRGF0YS5pc3N1ZVR5cGUsXHJcbiAgICAgICAgc3ViVHlwZTogaXBvRGF0YS5zdWJUeXBlLFxyXG4gICAgICAgIHJlZ2lzdHJhcjogaXBvRGF0YS5yZWdpc3RyYXIsXHJcbiAgICAgIH0sXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgLy8gR01QIGFuYWx5dGljcyBjb21wdXRhdGlvblxyXG4gIGNvbXB1dGVHTVBBbmFseXRpY3MoZ21wRGF0YSkge1xyXG4gICAgaWYgKCFnbXBEYXRhIHx8IGdtcERhdGEubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgc3RhdHVzOiBcIm5vX2RhdGFcIixcclxuICAgICAgICBtZXNzYWdlOiBcIk5vIEdNUCBkYXRhIGF2YWlsYWJsZVwiLFxyXG4gICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHZhbHVlcyA9IGdtcERhdGEubWFwKChnKSA9PiBnLnZhbHVlKTtcclxuICAgIGNvbnN0IHBlcmNlbnRhZ2VzID0gZ21wRGF0YS5tYXAoKGcpID0+IGcucGVyY2VudGFnZSk7XHJcbiAgICBjb25zdCB2b2x1bWVzID0gZ21wRGF0YS5tYXAoKGcpID0+IGcudm9sdW1lIHx8IDApO1xyXG5cclxuICAgIC8vIFN0YXRpc3RpY2FsIG1lYXN1cmVzXHJcbiAgICBjb25zdCBzdGF0cyA9IHtcclxuICAgICAgY3VycmVudDogdmFsdWVzWzBdIHx8IDAsXHJcbiAgICAgIGF2ZXJhZ2U6IHRoaXMuY2FsY3VsYXRlQXZlcmFnZSh2YWx1ZXMpLFxyXG4gICAgICBtZWRpYW46IHRoaXMuY2FsY3VsYXRlTWVkaWFuKHZhbHVlcyksXHJcbiAgICAgIG1vZGU6IHRoaXMuY2FsY3VsYXRlTW9kZSh2YWx1ZXMpLFxyXG4gICAgICBtaW46IE1hdGgubWluKC4uLnZhbHVlcyksXHJcbiAgICAgIG1heDogTWF0aC5tYXgoLi4udmFsdWVzKSxcclxuICAgICAgcmFuZ2U6IE1hdGgubWF4KC4uLnZhbHVlcykgLSBNYXRoLm1pbiguLi52YWx1ZXMpLFxyXG4gICAgICBzdGFuZGFyZERldmlhdGlvbjogdGhpcy5jYWxjdWxhdGVTdGFuZGFyZERldmlhdGlvbih2YWx1ZXMpLFxyXG4gICAgICB2YXJpYW5jZTogdGhpcy5jYWxjdWxhdGVWYXJpYW5jZSh2YWx1ZXMpLFxyXG4gICAgICBjb2VmZmljaWVudDogdGhpcy5jYWxjdWxhdGVDb2VmZmljaWVudE9mVmFyaWF0aW9uKHZhbHVlcyksXHJcbiAgICB9O1xyXG5cclxuICAgIC8vIFRyZW5kIGFuYWx5c2lzXHJcbiAgICBjb25zdCB0cmVuZCA9IHRoaXMuYW5hbHl6ZVRyZW5kKHZhbHVlcyk7XHJcblxyXG4gICAgLy8gVm9sYXRpbGl0eSBhbmFseXNpc1xyXG4gICAgY29uc3Qgdm9sYXRpbGl0eSA9IHRoaXMuYW5hbHl6ZVZvbGF0aWxpdHkoXHJcbiAgICAgIHZhbHVlcyxcclxuICAgICAgZ21wRGF0YS5tYXAoKGcpID0+IGcudGltZXN0YW1wKVxyXG4gICAgKTtcclxuXHJcbiAgICAvLyBWb2x1bWUgYW5hbHlzaXNcclxuICAgIGNvbnN0IHZvbHVtZUFuYWx5c2lzID0gdGhpcy5hbmFseXplVm9sdW1lKHZvbHVtZXMsIHZhbHVlcyk7XHJcblxyXG4gICAgLy8gUHJpY2UgbW9tZW50dW1cclxuICAgIGNvbnN0IG1vbWVudHVtID0gdGhpcy5jYWxjdWxhdGVNb21lbnR1bSh2YWx1ZXMpO1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgIHN0YXR1czogXCJhdmFpbGFibGVcIixcclxuICAgICAgcmVjb3JkQ291bnQ6IGdtcERhdGEubGVuZ3RoLFxyXG4gICAgICB0aW1lc3BhbjogdGhpcy5jYWxjdWxhdGVUaW1lc3BhbihnbXBEYXRhKSxcclxuICAgICAgc3RhdGlzdGljczogc3RhdHMsXHJcbiAgICAgIHRyZW5kLFxyXG4gICAgICB2b2xhdGlsaXR5LFxyXG4gICAgICB2b2x1bWVBbmFseXNpcyxcclxuICAgICAgbW9tZW50dW0sXHJcbiAgICAgIHByaWNlVGFyZ2V0czogdGhpcy5jYWxjdWxhdGVQcmljZVRhcmdldHMoc3RhdHMpLFxyXG4gICAgICByaXNrTWV0cmljczogdGhpcy5jYWxjdWxhdGVHTVBSaXNrTWV0cmljcyh2YWx1ZXMpLFxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIC8vIFN1YnNjcmlwdGlvbiBhbmFseXRpY3MgY29tcHV0YXRpb25cclxuICBjb21wdXRlU3Vic2NyaXB0aW9uQW5hbHl0aWNzKHN1YnNjcmlwdGlvbkRhdGEsIGNhdGVnb3J5RGF0YSkge1xyXG4gICAgaWYgKCFzdWJzY3JpcHRpb25EYXRhIHx8IHN1YnNjcmlwdGlvbkRhdGEubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgc3RhdHVzOiBcIm5vX2RhdGFcIixcclxuICAgICAgICBtZXNzYWdlOiBcIk5vIHN1YnNjcmlwdGlvbiBkYXRhIGF2YWlsYWJsZVwiLFxyXG4gICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEdldCBsYXRlc3Qgc3Vic2NyaXB0aW9uIGJ5IGNhdGVnb3J5XHJcbiAgICBjb25zdCBsYXRlc3RCeUNhdGVnb3J5ID1cclxuICAgICAgdGhpcy5nZXRMYXRlc3RTdWJzY3JpcHRpb25CeUNhdGVnb3J5KHN1YnNjcmlwdGlvbkRhdGEpO1xyXG5cclxuICAgIC8vIE92ZXJhbGwgc3Vic2NyaXB0aW9uIG1ldHJpY3NcclxuICAgIGNvbnN0IG92ZXJhbGxNZXRyaWNzID0ge1xyXG4gICAgICB0b3RhbFN1YnNjcmlwdGlvbjogdGhpcy5jYWxjdWxhdGVPdmVyYWxsU3Vic2NyaXB0aW9uKGxhdGVzdEJ5Q2F0ZWdvcnkpLFxyXG4gICAgICBpc092ZXJzdWJzY3JpYmVkOiBmYWxzZSxcclxuICAgICAgb3ZlcnN1YnNjcmlwdGlvblJhdGlvOiAwLFxyXG4gICAgICB0b3RhbEFwcGxpY2F0aW9uczogMCxcclxuICAgICAgdG90YWxRdWFudGl0eTogQmlnSW50KDApLFxyXG4gICAgfTtcclxuXHJcbiAgICBvdmVyYWxsTWV0cmljcy5pc092ZXJzdWJzY3JpYmVkID0gb3ZlcmFsbE1ldHJpY3MudG90YWxTdWJzY3JpcHRpb24gPiAxO1xyXG4gICAgb3ZlcmFsbE1ldHJpY3Mub3ZlcnN1YnNjcmlwdGlvblJhdGlvID0gTWF0aC5tYXgoXHJcbiAgICAgIDAsXHJcbiAgICAgIG92ZXJhbGxNZXRyaWNzLnRvdGFsU3Vic2NyaXB0aW9uIC0gMVxyXG4gICAgKTtcclxuXHJcbiAgICAvLyBDYXRlZ29yeS13aXNlIGFuYWx5c2lzXHJcbiAgICBjb25zdCBjYXRlZ29yeUFuYWx5c2lzID0ge307XHJcbiAgICBmb3IgKGNvbnN0IFtjYXRlZ29yeSwgZGF0YV0gb2YgT2JqZWN0LmVudHJpZXMobGF0ZXN0QnlDYXRlZ29yeSkpIHtcclxuICAgICAgY2F0ZWdvcnlBbmFseXNpc1tjYXRlZ29yeV0gPSB7XHJcbiAgICAgICAgc3Vic2NyaXB0aW9uUmF0aW86IGRhdGEuc3Vic2NyaXB0aW9uUmF0aW8sXHJcbiAgICAgICAgcXVhbnRpdHk6IGRhdGEucXVhbnRpdHkudG9TdHJpbmcoKSxcclxuICAgICAgICBiaWRDb3VudDogZGF0YS5iaWRDb3VudCxcclxuICAgICAgICBhdmVyYWdlQmlkU2l6ZTpcclxuICAgICAgICAgIGRhdGEuYmlkQ291bnQgPiAwID8gTnVtYmVyKGRhdGEucXVhbnRpdHkpIC8gZGF0YS5iaWRDb3VudCA6IDAsXHJcbiAgICAgICAgdGltZXN0YW1wOiBkYXRhLnRpbWVzdGFtcCxcclxuICAgICAgfTtcclxuXHJcbiAgICAgIG92ZXJhbGxNZXRyaWNzLnRvdGFsQXBwbGljYXRpb25zICs9IGRhdGEuYmlkQ291bnQ7XHJcbiAgICAgIG92ZXJhbGxNZXRyaWNzLnRvdGFsUXVhbnRpdHkgKz0gZGF0YS5xdWFudGl0eTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBTdWJzY3JpcHRpb24gcGF0dGVybiBhbmFseXNpc1xyXG4gICAgY29uc3QgcGF0dGVybnMgPSB0aGlzLmFuYWx5emVTdWJzY3JpcHRpb25QYXR0ZXJucyhzdWJzY3JpcHRpb25EYXRhKTtcclxuXHJcbiAgICAvLyBBbGxvdG1lbnQgcHJvYmFiaWxpdHkgY2FsY3VsYXRpb25cclxuICAgIGNvbnN0IGFsbG90bWVudFByb2JhYmlsaXR5ID1cclxuICAgICAgdGhpcy5jYWxjdWxhdGVBbGxvdG1lbnRQcm9iYWJpbGl0aWVzKGxhdGVzdEJ5Q2F0ZWdvcnkpO1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgIHN0YXR1czogXCJhdmFpbGFibGVcIixcclxuICAgICAgcmVjb3JkQ291bnQ6IHN1YnNjcmlwdGlvbkRhdGEubGVuZ3RoLFxyXG4gICAgICBvdmVyYWxsOiBvdmVyYWxsTWV0cmljcyxcclxuICAgICAgY2F0ZWdvcmllczogY2F0ZWdvcnlBbmFseXNpcyxcclxuICAgICAgcGF0dGVybnMsXHJcbiAgICAgIGFsbG90bWVudFByb2JhYmlsaXR5LFxyXG4gICAgICBpbnNpZ2h0czogdGhpcy5nZW5lcmF0ZVN1YnNjcmlwdGlvbkluc2lnaHRzKFxyXG4gICAgICAgIG92ZXJhbGxNZXRyaWNzLFxyXG4gICAgICAgIGNhdGVnb3J5QW5hbHlzaXNcclxuICAgICAgKSxcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICAvLyBNYXJrZXQgZGVtYW5kIGFuYWx5dGljcyBjb21wdXRhdGlvblxyXG4gIGNvbXB1dGVEZW1hbmRBbmFseXRpY3MoZGVtYW5kRGF0YSkge1xyXG4gICAgaWYgKCFkZW1hbmREYXRhIHx8IGRlbWFuZERhdGEubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgc3RhdHVzOiBcIm5vX2RhdGFcIixcclxuICAgICAgICBtZXNzYWdlOiBcIk5vIGRlbWFuZCBkYXRhIGF2YWlsYWJsZVwiLFxyXG4gICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFByaWNlLXdpc2UgZGVtYW5kIGFuYWx5c2lzXHJcbiAgICBjb25zdCBwcmljZVdpc2VEZW1hbmQgPSB0aGlzLmFuYWx5emVQcmljZVdpc2VEZW1hbmQoZGVtYW5kRGF0YSk7XHJcblxyXG4gICAgLy8gQ3V0LW9mZiBhbmFseXNpc1xyXG4gICAgY29uc3QgY3V0T2ZmQW5hbHlzaXMgPSB0aGlzLmFuYWx5emVDdXRPZmZEZW1hbmQoZGVtYW5kRGF0YSk7XHJcblxyXG4gICAgLy8gRGVtYW5kIGRpc3RyaWJ1dGlvblxyXG4gICAgY29uc3QgZGlzdHJpYnV0aW9uID0gdGhpcy5hbmFseXplRGVtYW5kRGlzdHJpYnV0aW9uKGRlbWFuZERhdGEpO1xyXG5cclxuICAgIC8vIEJpZCBjb25jZW50cmF0aW9uXHJcbiAgICBjb25zdCBjb25jZW50cmF0aW9uID0gdGhpcy5hbmFseXplQmlkQ29uY2VudHJhdGlvbihkZW1hbmREYXRhKTtcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBzdGF0dXM6IFwiYXZhaWxhYmxlXCIsXHJcbiAgICAgIHJlY29yZENvdW50OiBkZW1hbmREYXRhLmxlbmd0aCxcclxuICAgICAgcHJpY2VXaXNlRGVtYW5kLFxyXG4gICAgICBjdXRPZmZBbmFseXNpcyxcclxuICAgICAgZGlzdHJpYnV0aW9uLFxyXG4gICAgICBjb25jZW50cmF0aW9uLFxyXG4gICAgICBzdW1tYXJ5OiB7XHJcbiAgICAgICAgdG90YWxRdWFudGl0eTogZGVtYW5kRGF0YS5yZWR1Y2UoXHJcbiAgICAgICAgICAoc3VtLCBkKSA9PiBzdW0gKyBOdW1iZXIoZC5hYnNvbHV0ZVF1YW50aXR5KSxcclxuICAgICAgICAgIDBcclxuICAgICAgICApLFxyXG4gICAgICAgIHRvdGFsQmlkczogZGVtYW5kRGF0YS5yZWR1Y2UoKHN1bSwgZCkgPT4gc3VtICsgZC5hYnNvbHV0ZUJpZENvdW50LCAwKSxcclxuICAgICAgICBwcmljZVJhbmdlOiB7XHJcbiAgICAgICAgICBtaW46IE1hdGgubWluKFxyXG4gICAgICAgICAgICAuLi5kZW1hbmREYXRhLm1hcCgoZCkgPT4gZC5wcmljZSkuZmlsdGVyKChwKSA9PiBwICE9PSBudWxsKVxyXG4gICAgICAgICAgKSxcclxuICAgICAgICAgIG1heDogTWF0aC5tYXgoXHJcbiAgICAgICAgICAgIC4uLmRlbWFuZERhdGEubWFwKChkKSA9PiBkLnByaWNlKS5maWx0ZXIoKHApID0+IHAgIT09IG51bGwpXHJcbiAgICAgICAgICApLFxyXG4gICAgICAgIH0sXHJcbiAgICAgIH0sXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgLy8gUmlzayBhc3Nlc3NtZW50IGNvbXB1dGF0aW9uXHJcbiAgY29tcHV0ZVJpc2tBc3Nlc3NtZW50KGlwb0RhdGEsIGdtcERhdGEsIHN1YnNjcmlwdGlvbkRhdGEpIHtcclxuICAgIGxldCByaXNrU2NvcmUgPSA1MDsgLy8gQmFzZSByaXNrIHNjb3JlXHJcbiAgICBjb25zdCByaXNrRmFjdG9ycyA9IFtdO1xyXG5cclxuICAgIC8vIEdNUCB2b2xhdGlsaXR5IHJpc2tcclxuICAgIGlmIChnbXBEYXRhICYmIGdtcERhdGEubGVuZ3RoID4gMSkge1xyXG4gICAgICBjb25zdCBnbXBWYWx1ZXMgPSBnbXBEYXRhLm1hcCgoZykgPT4gZy52YWx1ZSk7XHJcbiAgICAgIGNvbnN0IHZvbGF0aWxpdHkgPSB0aGlzLmNhbGN1bGF0ZVN0YW5kYXJkRGV2aWF0aW9uKGdtcFZhbHVlcyk7XHJcbiAgICAgIGNvbnN0IGF2Z0dNUCA9IHRoaXMuY2FsY3VsYXRlQXZlcmFnZShnbXBWYWx1ZXMpO1xyXG4gICAgICBjb25zdCB2b2xhdGlsaXR5UmF0aW8gPSBhdmdHTVAgPiAwID8gdm9sYXRpbGl0eSAvIGF2Z0dNUCA6IDA7XHJcblxyXG4gICAgICBpZiAodm9sYXRpbGl0eVJhdGlvID4gMC4zKSB7XHJcbiAgICAgICAgcmlza1Njb3JlICs9IDIwO1xyXG4gICAgICAgIHJpc2tGYWN0b3JzLnB1c2goe1xyXG4gICAgICAgICAgdHlwZTogXCJISUdIX0dNUF9WT0xBVElMSVRZXCIsXHJcbiAgICAgICAgICBpbXBhY3Q6IFwiaGlnaFwiLFxyXG4gICAgICAgICAgZGVzY3JpcHRpb246IGBIaWdoIEdNUCB2b2xhdGlsaXR5ICgkeyh2b2xhdGlsaXR5UmF0aW8gKiAxMDApLnRvRml4ZWQoMSl9JSlgLFxyXG4gICAgICAgICAgbWl0aWdhdGlvbjogXCJDb25zaWRlciB3YWl0aW5nIGZvciBwcmljZSBzdGFiaWxpemF0aW9uXCIsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0gZWxzZSBpZiAodm9sYXRpbGl0eVJhdGlvID4gMC4xNSkge1xyXG4gICAgICAgIHJpc2tTY29yZSArPSAxMDtcclxuICAgICAgICByaXNrRmFjdG9ycy5wdXNoKHtcclxuICAgICAgICAgIHR5cGU6IFwiTU9ERVJBVEVfR01QX1ZPTEFUSUxJVFlcIixcclxuICAgICAgICAgIGltcGFjdDogXCJtZWRpdW1cIixcclxuICAgICAgICAgIGRlc2NyaXB0aW9uOiBgTW9kZXJhdGUgR01QIHZvbGF0aWxpdHkgKCR7KHZvbGF0aWxpdHlSYXRpbyAqIDEwMCkudG9GaXhlZCgxKX0lKWAsXHJcbiAgICAgICAgICBtaXRpZ2F0aW9uOiBcIk1vbml0b3IgR01QIHRyZW5kcyBjbG9zZWx5XCIsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBTdWJzY3JpcHRpb24gcmlza1xyXG4gICAgaWYgKHN1YnNjcmlwdGlvbkRhdGEgJiYgc3Vic2NyaXB0aW9uRGF0YS5sZW5ndGggPiAwKSB7XHJcbiAgICAgIGNvbnN0IGxhdGVzdFN1YnNjcmlwdGlvbiA9XHJcbiAgICAgICAgdGhpcy5nZXRMYXRlc3RTdWJzY3JpcHRpb25CeUNhdGVnb3J5KHN1YnNjcmlwdGlvbkRhdGEpO1xyXG4gICAgICBjb25zdCBvdmVyYWxsU3Vic2NyaXB0aW9uID1cclxuICAgICAgICB0aGlzLmNhbGN1bGF0ZU92ZXJhbGxTdWJzY3JpcHRpb24obGF0ZXN0U3Vic2NyaXB0aW9uKTtcclxuXHJcbiAgICAgIGlmIChvdmVyYWxsU3Vic2NyaXB0aW9uIDwgMC41KSB7XHJcbiAgICAgICAgcmlza1Njb3JlICs9IDI1O1xyXG4gICAgICAgIHJpc2tGYWN0b3JzLnB1c2goe1xyXG4gICAgICAgICAgdHlwZTogXCJMT1dfU1VCU0NSSVBUSU9OXCIsXHJcbiAgICAgICAgICBpbXBhY3Q6IFwiaGlnaFwiLFxyXG4gICAgICAgICAgZGVzY3JpcHRpb246IGBMb3cgc3Vic2NyaXB0aW9uIHJhdGlvICgke292ZXJhbGxTdWJzY3JpcHRpb24udG9GaXhlZCgyKX14KWAsXHJcbiAgICAgICAgICBtaXRpZ2F0aW9uOiBcIlJlY29uc2lkZXIgaW52ZXN0bWVudCBkdWUgdG8gd2VhayBkZW1hbmRcIixcclxuICAgICAgICB9KTtcclxuICAgICAgfSBlbHNlIGlmIChvdmVyYWxsU3Vic2NyaXB0aW9uID4gMTApIHtcclxuICAgICAgICByaXNrU2NvcmUgKz0gMTU7XHJcbiAgICAgICAgcmlza0ZhY3RvcnMucHVzaCh7XHJcbiAgICAgICAgICB0eXBlOiBcIk9WRVJfU1VCU0NSSVBUSU9OXCIsXHJcbiAgICAgICAgICBpbXBhY3Q6IFwibWVkaXVtXCIsXHJcbiAgICAgICAgICBkZXNjcmlwdGlvbjogYFZlcnkgaGlnaCBzdWJzY3JpcHRpb24gKCR7b3ZlcmFsbFN1YnNjcmlwdGlvbi50b0ZpeGVkKDIpfXgpYCxcclxuICAgICAgICAgIG1pdGlnYXRpb246IFwiTG93IGFsbG90bWVudCBwcm9iYWJpbGl0eSwgY29uc2lkZXIgYWx0ZXJuYXRpdmVzXCIsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBJc3N1ZSBzaXplIHJpc2tcclxuICAgIGNvbnN0IGlzc3VlU2l6ZSA9IE51bWJlcihpcG9EYXRhLmlzc3VlU2l6ZSB8fCAwKTtcclxuICAgIGlmIChpc3N1ZVNpemUgPiA1MDAwICogMTAwMDAwMDApIHtcclxuICAgICAgLy8gNTAwMCBDclxyXG4gICAgICByaXNrU2NvcmUgKz0gMTA7XHJcbiAgICAgIHJpc2tGYWN0b3JzLnB1c2goe1xyXG4gICAgICAgIHR5cGU6IFwiTEFSR0VfSVNTVUVfU0laRVwiLFxyXG4gICAgICAgIGltcGFjdDogXCJtZWRpdW1cIixcclxuICAgICAgICBkZXNjcmlwdGlvbjogXCJMYXJnZSBpc3N1ZSBzaXplIG1heSBpbXBhY3QgbGlxdWlkaXR5XCIsXHJcbiAgICAgICAgbWl0aWdhdGlvbjogXCJFbnN1cmUgYWRlcXVhdGUgbWFya2V0IHN1cHBvcnQgcG9zdC1saXN0aW5nXCIsXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFByaWNlIGJhbmQgcmlza1xyXG4gICAgY29uc3QgcHJpY2VSYW5nZSA9IGlwb0RhdGEubWF4UHJpY2UgLSBpcG9EYXRhLm1pblByaWNlO1xyXG4gICAgY29uc3Qgc3ByZWFkUGVyY2VudGFnZSA9XHJcbiAgICAgIGlwb0RhdGEubWluUHJpY2UgPiAwID8gKHByaWNlUmFuZ2UgLyBpcG9EYXRhLm1pblByaWNlKSAqIDEwMCA6IDA7XHJcblxyXG4gICAgaWYgKHNwcmVhZFBlcmNlbnRhZ2UgPiAyMCkge1xyXG4gICAgICByaXNrU2NvcmUgKz0gNTtcclxuICAgICAgcmlza0ZhY3RvcnMucHVzaCh7XHJcbiAgICAgICAgdHlwZTogXCJXSURFX1BSSUNFX0JBTkRcIixcclxuICAgICAgICBpbXBhY3Q6IFwibG93XCIsXHJcbiAgICAgICAgZGVzY3JpcHRpb246IGBXaWRlIHByaWNlIGJhbmQgKCR7c3ByZWFkUGVyY2VudGFnZS50b0ZpeGVkKDEpfSUpYCxcclxuICAgICAgICBtaXRpZ2F0aW9uOiBcIlByaWNlIGRpc2NvdmVyeSBtYXkgYmUgY2hhbGxlbmdpbmdcIixcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gTm9ybWFsaXplIHJpc2sgc2NvcmVcclxuICAgIHJpc2tTY29yZSA9IE1hdGgubWF4KDAsIE1hdGgubWluKDEwMCwgcmlza1Njb3JlKSk7XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgb3ZlcmFsbFJpc2tTY29yZTogcmlza1Njb3JlLFxyXG4gICAgICByaXNrTGV2ZWw6IHRoaXMuY2F0ZWdvcml6ZVJpc2tMZXZlbChyaXNrU2NvcmUpLFxyXG4gICAgICByaXNrRmFjdG9ycyxcclxuICAgICAgcmVjb21tZW5kYXRpb246IHRoaXMuZ2VuZXJhdGVSaXNrUmVjb21tZW5kYXRpb24ocmlza1Njb3JlLCByaXNrRmFjdG9ycyksXHJcbiAgICAgIGxhc3RVcGRhdGVkOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgLy8gUGVyZm9ybWFuY2UgaW5kaWNhdG9ycyBjb21wdXRhdGlvblxyXG4gIGNvbXB1dGVQZXJmb3JtYW5jZUluZGljYXRvcnMoaXBvRGF0YSwgZ21wRGF0YSwgc3Vic2NyaXB0aW9uRGF0YSkge1xyXG4gICAgY29uc3QgaW5kaWNhdG9ycyA9IHt9O1xyXG5cclxuICAgIC8vIE1hcmtldCBzZW50aW1lbnQgaW5kaWNhdG9yXHJcbiAgICBpbmRpY2F0b3JzLm1hcmtldFNlbnRpbWVudCA9IHRoaXMuY2FsY3VsYXRlTWFya2V0U2VudGltZW50KFxyXG4gICAgICBnbXBEYXRhLFxyXG4gICAgICBzdWJzY3JpcHRpb25EYXRhXHJcbiAgICApO1xyXG5cclxuICAgIC8vIERlbWFuZCBzdHJlbmd0aCBpbmRpY2F0b3JcclxuICAgIGluZGljYXRvcnMuZGVtYW5kU3RyZW5ndGggPSB0aGlzLmNhbGN1bGF0ZURlbWFuZFN0cmVuZ3RoKHN1YnNjcmlwdGlvbkRhdGEpO1xyXG5cclxuICAgIC8vIFByaWNlIG1vbWVudHVtIGluZGljYXRvclxyXG4gICAgaWYgKGdtcERhdGEgJiYgZ21wRGF0YS5sZW5ndGggPiAwKSB7XHJcbiAgICAgIGluZGljYXRvcnMucHJpY2VNb21lbnR1bSA9IHRoaXMuY2FsY3VsYXRlTW9tZW50dW0oXHJcbiAgICAgICAgZ21wRGF0YS5tYXAoKGcpID0+IGcudmFsdWUpXHJcbiAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gTGlzdGluZyByZWFkaW5lc3MgaW5kaWNhdG9yXHJcbiAgICBpbmRpY2F0b3JzLmxpc3RpbmdSZWFkaW5lc3MgPSB0aGlzLmNhbGN1bGF0ZUxpc3RpbmdSZWFkaW5lc3MoXHJcbiAgICAgIGlwb0RhdGEsXHJcbiAgICAgIHN1YnNjcmlwdGlvbkRhdGFcclxuICAgICk7XHJcblxyXG4gICAgLy8gSW52ZXN0bWVudCBhdHRyYWN0aXZlbmVzcyBzY29yZVxyXG4gICAgaW5kaWNhdG9ycy5hdHRyYWN0aXZlbmVzc1Njb3JlID1cclxuICAgICAgdGhpcy5jYWxjdWxhdGVBdHRyYWN0aXZlbmVzc1Njb3JlKGluZGljYXRvcnMpO1xyXG5cclxuICAgIHJldHVybiBpbmRpY2F0b3JzO1xyXG4gIH1cclxuXHJcbiAgLy8gSGlzdG9yaWNhbCBhbmFseXNpcyBjb21wdXRhdGlvblxyXG4gIGFzeW5jIGNvbXB1dGVIaXN0b3JpY2FsQW5hbHlzaXMoaXBvSWQsIHRpbWVSYW5nZSkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgLy8gR2V0IGNvbXBhcmFibGUgSVBPcyBmb3IgYmVuY2htYXJraW5nXHJcbiAgICAgIGNvbnN0IGNvbXBhcmFibGVJUE9zID0gYXdhaXQgdGhpcy5nZXRDb21wYXJhYmxlSVBPcyhpcG9JZCwgdGltZVJhbmdlKTtcclxuXHJcbiAgICAgIC8vIEhpc3RvcmljYWwgcGVyZm9ybWFuY2UgbWV0cmljc1xyXG4gICAgICBjb25zdCBoaXN0b3JpY2FsTWV0cmljcyA9IGF3YWl0IHRoaXMuY2FsY3VsYXRlSGlzdG9yaWNhbE1ldHJpY3MoXHJcbiAgICAgICAgaXBvSWQsXHJcbiAgICAgICAgdGltZVJhbmdlXHJcbiAgICAgICk7XHJcblxyXG4gICAgICAvLyBUcmVuZCBhbmFseXNpcyBvdmVyIHRpbWVcclxuICAgICAgY29uc3QgdHJlbmRzID0gYXdhaXQgdGhpcy5jYWxjdWxhdGVIaXN0b3JpY2FsVHJlbmRzKGlwb0lkLCB0aW1lUmFuZ2UpO1xyXG5cclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICB0aW1lUmFuZ2UsXHJcbiAgICAgICAgY29tcGFyYWJsZUlQT3M6IGNvbXBhcmFibGVJUE9zLmxlbmd0aCxcclxuICAgICAgICBtZXRyaWNzOiBoaXN0b3JpY2FsTWV0cmljcyxcclxuICAgICAgICB0cmVuZHMsXHJcbiAgICAgICAgYmVuY2htYXJrczogYXdhaXQgdGhpcy5jYWxjdWxhdGVCZW5jaG1hcmtzKGNvbXBhcmFibGVJUE9zKSxcclxuICAgICAgfTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJIaXN0b3JpY2FsIGFuYWx5c2lzIGZhaWxlZDpcIiwgZXJyb3IpO1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIHN0YXR1czogXCJlcnJvclwiLFxyXG4gICAgICAgIG1lc3NhZ2U6IFwiSGlzdG9yaWNhbCBhbmFseXNpcyB1bmF2YWlsYWJsZVwiLFxyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gUHJlZGljdGlvbnMgY29tcHV0YXRpb25cclxuICBhc3luYyBjb21wdXRlUHJlZGljdGlvbnMoYW5hbHl0aWNzKSB7XHJcbiAgICBjb25zdCBwcmVkaWN0aW9ucyA9IHt9O1xyXG5cclxuICAgIHRyeSB7XHJcbiAgICAgIC8vIExpc3RpbmcgZ2FpbiBwcmVkaWN0aW9uXHJcbiAgICAgIHByZWRpY3Rpb25zLmxpc3RpbmdHYWluID0gdGhpcy5wcmVkaWN0TGlzdGluZ0dhaW4oYW5hbHl0aWNzKTtcclxuXHJcbiAgICAgIC8vIEFsbG90bWVudCBwcm9iYWJpbGl0eSBwcmVkaWN0aW9uXHJcbiAgICAgIHByZWRpY3Rpb25zLmFsbG90bWVudFByb2JhYmlsaXR5ID1cclxuICAgICAgICB0aGlzLnByZWRpY3RBbGxvdG1lbnRQcm9iYWJpbGl0eShhbmFseXRpY3MpO1xyXG5cclxuICAgICAgLy8gUHJpY2UgdGFyZ2V0IHByZWRpY3Rpb25cclxuICAgICAgcHJlZGljdGlvbnMucHJpY2VUYXJnZXRzID0gdGhpcy5wcmVkaWN0UHJpY2VUYXJnZXRzKGFuYWx5dGljcyk7XHJcblxyXG4gICAgICAvLyBSaXNrLWFkanVzdGVkIHJldHVybnNcclxuICAgICAgcHJlZGljdGlvbnMucmlza0FkanVzdGVkUmV0dXJucyA9IHRoaXMuY2FsY3VsYXRlUmlza0FkanVzdGVkUmV0dXJucyhcclxuICAgICAgICBwcmVkaWN0aW9ucy5saXN0aW5nR2FpbixcclxuICAgICAgICBhbmFseXRpY3Mucmlza0Fzc2Vzc21lbnQub3ZlcmFsbFJpc2tTY29yZVxyXG4gICAgICApO1xyXG5cclxuICAgICAgLy8gQ29uZmlkZW5jZSBpbnRlcnZhbHNcclxuICAgICAgcHJlZGljdGlvbnMuY29uZmlkZW5jZUludGVydmFscyA9XHJcbiAgICAgICAgdGhpcy5jYWxjdWxhdGVDb25maWRlbmNlSW50ZXJ2YWxzKHByZWRpY3Rpb25zKTtcclxuXHJcbiAgICAgIHByZWRpY3Rpb25zLmxhc3RVcGRhdGVkID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpO1xyXG4gICAgICBwcmVkaWN0aW9ucy5tb2RlbCA9IFwiSVBPX0FOQUxZVElDU19WMS4wXCI7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKFwiUHJlZGljdGlvbnMgY29tcHV0YXRpb24gZmFpbGVkOlwiLCBlcnJvcik7XHJcbiAgICAgIHByZWRpY3Rpb25zLnN0YXR1cyA9IFwiZXJyb3JcIjtcclxuICAgICAgcHJlZGljdGlvbnMubWVzc2FnZSA9IFwiUHJlZGljdGlvbnMgdW5hdmFpbGFibGVcIjtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcHJlZGljdGlvbnM7XHJcbiAgfVxyXG5cclxuICAvLyBDb21wYXJhdGl2ZSBhbmFseXNpc1xyXG4gIGFzeW5jIGNvbXB1dGVDb21wYXJhdGl2ZUFuYWx5c2lzKGlwb0RhdGEpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgIC8vIEZpbmQgc2ltaWxhciBJUE9zIGJ5IHNlY3Rvciwgc2l6ZSwgYW5kIHRpbWUgcGVyaW9kXHJcbiAgICAgIGNvbnN0IHNpbWlsYXJJUE9zID0gYXdhaXQgdGhpcy5maW5kU2ltaWxhcklQT3MoaXBvRGF0YSk7XHJcblxyXG4gICAgICAvLyBDYWxjdWxhdGUgcmVsYXRpdmUgcGVyZm9ybWFuY2VcclxuICAgICAgY29uc3QgcmVsYXRpdmVQZXJmb3JtYW5jZSA9IGF3YWl0IHRoaXMuY2FsY3VsYXRlUmVsYXRpdmVQZXJmb3JtYW5jZShcclxuICAgICAgICBpcG9EYXRhLFxyXG4gICAgICAgIHNpbWlsYXJJUE9zXHJcbiAgICAgICk7XHJcblxyXG4gICAgICAvLyBNYXJrZXQgcG9zaXRpb25pbmdcclxuICAgICAgY29uc3QgbWFya2V0UG9zaXRpb25pbmcgPSB0aGlzLmNhbGN1bGF0ZU1hcmtldFBvc2l0aW9uaW5nKFxyXG4gICAgICAgIGlwb0RhdGEsXHJcbiAgICAgICAgc2ltaWxhcklQT3NcclxuICAgICAgKTtcclxuXHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgc2ltaWxhcklQT3NDb3VudDogc2ltaWxhcklQT3MubGVuZ3RoLFxyXG4gICAgICAgIHJlbGF0aXZlUGVyZm9ybWFuY2UsXHJcbiAgICAgICAgbWFya2V0UG9zaXRpb25pbmcsXHJcbiAgICAgICAgYmVuY2htYXJrczogYXdhaXQgdGhpcy5jYWxjdWxhdGVJbmR1c3RyeUJlbmNobWFya3MoaXBvRGF0YS5pc3N1ZVR5cGUpLFxyXG4gICAgICB9O1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcihcIkNvbXBhcmF0aXZlIGFuYWx5c2lzIGZhaWxlZDpcIiwgZXJyb3IpO1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIHN0YXR1czogXCJlcnJvclwiLFxyXG4gICAgICAgIG1lc3NhZ2U6IFwiQ29tcGFyYXRpdmUgYW5hbHlzaXMgdW5hdmFpbGFibGVcIixcclxuICAgICAgfTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIEluc2lnaHRzIGdlbmVyYXRpb25cclxuICBnZW5lcmF0ZUluc2lnaHRzKGFuYWx5dGljcykge1xyXG4gICAgY29uc3QgaW5zaWdodHMgPSBbXTtcclxuXHJcbiAgICAvLyBHTVAgaW5zaWdodHNcclxuICAgIGlmIChhbmFseXRpY3MuZ21wQW5hbHl0aWNzLnN0YXR1cyA9PT0gXCJhdmFpbGFibGVcIikge1xyXG4gICAgICBjb25zdCBnbXAgPSBhbmFseXRpY3MuZ21wQW5hbHl0aWNzO1xyXG5cclxuICAgICAgaWYgKGdtcC5zdGF0aXN0aWNzLmN1cnJlbnQgPiBnbXAuc3RhdGlzdGljcy5hdmVyYWdlICogMS4yKSB7XHJcbiAgICAgICAgaW5zaWdodHMucHVzaCh7XHJcbiAgICAgICAgICB0eXBlOiBcInBvc2l0aXZlXCIsXHJcbiAgICAgICAgICBjYXRlZ29yeTogXCJHTVBcIixcclxuICAgICAgICAgIHRpdGxlOiBcIlN0cm9uZyBHTVAgUGVyZm9ybWFuY2VcIixcclxuICAgICAgICAgIGRlc2NyaXB0aW9uOiBgQ3VycmVudCBHTVAgKOKCuSR7Z21wLnN0YXRpc3RpY3MuY3VycmVudH0pIGlzICR7KChnbXAuc3RhdGlzdGljcy5jdXJyZW50IC8gZ21wLnN0YXRpc3RpY3MuYXZlcmFnZSAtIDEpICogMTAwKS50b0ZpeGVkKDEpfSUgYWJvdmUgYXZlcmFnZWAsXHJcbiAgICAgICAgICBpbXBhY3Q6IFwiSW5kaWNhdGVzIHN0cm9uZyBtYXJrZXQgZGVtYW5kXCIsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChnbXAudm9sYXRpbGl0eS5sZXZlbCA9PT0gXCJoaWdoXCIpIHtcclxuICAgICAgICBpbnNpZ2h0cy5wdXNoKHtcclxuICAgICAgICAgIHR5cGU6IFwid2FybmluZ1wiLFxyXG4gICAgICAgICAgY2F0ZWdvcnk6IFwiR01QXCIsXHJcbiAgICAgICAgICB0aXRsZTogXCJIaWdoIFByaWNlIFZvbGF0aWxpdHlcIixcclxuICAgICAgICAgIGRlc2NyaXB0aW9uOiBgR01QIHNob3dpbmcgaGlnaCB2b2xhdGlsaXR5ICgke2dtcC52b2xhdGlsaXR5LmNvZWZmaWNpZW50fSUpYCxcclxuICAgICAgICAgIGltcGFjdDogXCJJbmNyZWFzZWQgdW5jZXJ0YWludHkgaW4gcHJpY2UgZXhwZWN0YXRpb25zXCIsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBTdWJzY3JpcHRpb24gaW5zaWdodHNcclxuICAgIGlmIChhbmFseXRpY3Muc3Vic2NyaXB0aW9uQW5hbHl0aWNzLnN0YXR1cyA9PT0gXCJhdmFpbGFibGVcIikge1xyXG4gICAgICBjb25zdCBzdWIgPSBhbmFseXRpY3Muc3Vic2NyaXB0aW9uQW5hbHl0aWNzO1xyXG5cclxuICAgICAgaWYgKHN1Yi5vdmVyYWxsLnRvdGFsU3Vic2NyaXB0aW9uID4gNSkge1xyXG4gICAgICAgIGluc2lnaHRzLnB1c2goe1xyXG4gICAgICAgICAgdHlwZTogXCJwb3NpdGl2ZVwiLFxyXG4gICAgICAgICAgY2F0ZWdvcnk6IFwiU3Vic2NyaXB0aW9uXCIsXHJcbiAgICAgICAgICB0aXRsZTogXCJTdHJvbmcgT3ZlcnN1YnNjcmlwdGlvblwiLFxyXG4gICAgICAgICAgZGVzY3JpcHRpb246IGBJUE8gb3ZlcnN1YnNjcmliZWQgYnkgJHtzdWIub3ZlcmFsbC50b3RhbFN1YnNjcmlwdGlvbi50b0ZpeGVkKDIpfXhgLFxyXG4gICAgICAgICAgaW1wYWN0OiBcIkhpZ2ggaW52ZXN0b3IgaW50ZXJlc3QgYnV0IGxvd2VyIGFsbG90bWVudCBwcm9iYWJpbGl0eVwiLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoc3ViLm92ZXJhbGwudG90YWxTdWJzY3JpcHRpb24gPCAxKSB7XHJcbiAgICAgICAgaW5zaWdodHMucHVzaCh7XHJcbiAgICAgICAgICB0eXBlOiBcIm5lZ2F0aXZlXCIsXHJcbiAgICAgICAgICBjYXRlZ29yeTogXCJTdWJzY3JpcHRpb25cIixcclxuICAgICAgICAgIHRpdGxlOiBcIlVuZGVyc3Vic2NyaWJlZCBJUE9cIixcclxuICAgICAgICAgIGRlc2NyaXB0aW9uOiBgSVBPIHN1YnNjcmliZWQgb25seSAkeyhzdWIub3ZlcmFsbC50b3RhbFN1YnNjcmlwdGlvbiAqIDEwMCkudG9GaXhlZCgxKX0lYCxcclxuICAgICAgICAgIGltcGFjdDogXCJXZWFrIGludmVzdG9yIGRlbWFuZCwgcG90ZW50aWFsIGxpc3RpbmcgY29uY2VybnNcIixcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIFJpc2sgaW5zaWdodHNcclxuICAgIGNvbnN0IHJpc2sgPSBhbmFseXRpY3Mucmlza0Fzc2Vzc21lbnQ7XHJcbiAgICBpZiAocmlzay5yaXNrTGV2ZWwgPT09IFwiaGlnaFwiKSB7XHJcbiAgICAgIGluc2lnaHRzLnB1c2goe1xyXG4gICAgICAgIHR5cGU6IFwid2FybmluZ1wiLFxyXG4gICAgICAgIGNhdGVnb3J5OiBcIlJpc2tcIixcclxuICAgICAgICB0aXRsZTogXCJIaWdoIFJpc2sgSW52ZXN0bWVudFwiLFxyXG4gICAgICAgIGRlc2NyaXB0aW9uOiBgUmlzayBzY29yZSBvZiAke3Jpc2sub3ZlcmFsbFJpc2tTY29yZX0gaW5kaWNhdGVzIGVsZXZhdGVkIHJpc2tgLFxyXG4gICAgICAgIGltcGFjdDogXCJDYXJlZnVsIGNvbnNpZGVyYXRpb24gcmVxdWlyZWQgYmVmb3JlIGludmVzdG1lbnRcIixcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGluc2lnaHRzO1xyXG4gIH1cclxuXHJcbiAgLy8gUmVjb21tZW5kYXRpb25zIGdlbmVyYXRpb25cclxuICBnZW5lcmF0ZVJlY29tbWVuZGF0aW9ucyhhbmFseXRpY3MpIHtcclxuICAgIGNvbnN0IHJlY29tbWVuZGF0aW9ucyA9IFtdO1xyXG4gICAgY29uc3QgcmlzayA9IGFuYWx5dGljcy5yaXNrQXNzZXNzbWVudC5vdmVyYWxsUmlza1Njb3JlO1xyXG4gICAgY29uc3Qgc3Vic2NyaXB0aW9uID1cclxuICAgICAgYW5hbHl0aWNzLnN1YnNjcmlwdGlvbkFuYWx5dGljcy5vdmVyYWxsPy50b3RhbFN1YnNjcmlwdGlvbiB8fCAwO1xyXG4gICAgY29uc3QgZ21wID0gYW5hbHl0aWNzLmdtcEFuYWx5dGljcy5zdGF0aXN0aWNzPy5jdXJyZW50IHx8IDA7XHJcblxyXG4gICAgLy8gSW52ZXN0bWVudCByZWNvbW1lbmRhdGlvblxyXG4gICAgaWYgKHJpc2sgPCAzMCAmJiBzdWJzY3JpcHRpb24gPiAyICYmIGdtcCA+IDApIHtcclxuICAgICAgcmVjb21tZW5kYXRpb25zLnB1c2goe1xyXG4gICAgICAgIHR5cGU6IFwiQlVZXCIsXHJcbiAgICAgICAgY29uZmlkZW5jZTogXCJoaWdoXCIsXHJcbiAgICAgICAgcmVhc29uaW5nOiBcIkxvdyByaXNrLCBzdHJvbmcgZGVtYW5kLCBwb3NpdGl2ZSBHTVBcIixcclxuICAgICAgICBhY3Rpb246IFwiQ29uc2lkZXIgYXBwbHlpbmcgZm9yIG1heGltdW0gYWxsb2NhdGlvblwiLFxyXG4gICAgICB9KTtcclxuICAgIH0gZWxzZSBpZiAocmlzayA8IDUwICYmIHN1YnNjcmlwdGlvbiA+IDEpIHtcclxuICAgICAgcmVjb21tZW5kYXRpb25zLnB1c2goe1xyXG4gICAgICAgIHR5cGU6IFwiSE9MRFwiLFxyXG4gICAgICAgIGNvbmZpZGVuY2U6IFwibWVkaXVtXCIsXHJcbiAgICAgICAgcmVhc29uaW5nOiBcIk1vZGVyYXRlIHJpc2sgd2l0aCBhZGVxdWF0ZSBkZW1hbmRcIixcclxuICAgICAgICBhY3Rpb246IFwiQXBwbHkgd2l0aCBjYXV0aW9uLCBjb25zaWRlciBzbWFsbGVyIGFsbG9jYXRpb25cIixcclxuICAgICAgfSk7XHJcbiAgICB9IGVsc2UgaWYgKHJpc2sgPiA3MCB8fCBzdWJzY3JpcHRpb24gPCAwLjUpIHtcclxuICAgICAgcmVjb21tZW5kYXRpb25zLnB1c2goe1xyXG4gICAgICAgIHR5cGU6IFwiQVZPSURcIixcclxuICAgICAgICBjb25maWRlbmNlOiBcImhpZ2hcIixcclxuICAgICAgICByZWFzb25pbmc6IFwiSGlnaCByaXNrIG9yIHdlYWsgZGVtYW5kIGluZGljYXRvcnNcIixcclxuICAgICAgICBhY3Rpb246IFwiQ29uc2lkZXIgYWx0ZXJuYXRpdmUgaW52ZXN0bWVudCBvcHBvcnR1bml0aWVzXCIsXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFRpbWluZyByZWNvbW1lbmRhdGlvbnNcclxuICAgIGlmIChhbmFseXRpY3MucGVyZm9ybWFuY2VJbmRpY2F0b3JzPy5saXN0aW5nUmVhZGluZXNzID4gMC44KSB7XHJcbiAgICAgIHJlY29tbWVuZGF0aW9ucy5wdXNoKHtcclxuICAgICAgICB0eXBlOiBcIlRJTUlOR1wiLFxyXG4gICAgICAgIGNvbmZpZGVuY2U6IFwibWVkaXVtXCIsXHJcbiAgICAgICAgcmVhc29uaW5nOiBcIklQTyBhcHBlYXJzIHJlYWR5IGZvciBzdWNjZXNzZnVsIGxpc3RpbmdcIixcclxuICAgICAgICBhY3Rpb246IFwiR29vZCB0aW1pbmcgZm9yIGFwcGxpY2F0aW9uXCIsXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEFsbG9jYXRpb24gcmVjb21tZW5kYXRpb25zXHJcbiAgICBpZiAoc3Vic2NyaXB0aW9uID4gMTApIHtcclxuICAgICAgcmVjb21tZW5kYXRpb25zLnB1c2goe1xyXG4gICAgICAgIHR5cGU6IFwiQUxMT0NBVElPTlwiLFxyXG4gICAgICAgIGNvbmZpZGVuY2U6IFwiaGlnaFwiLFxyXG4gICAgICAgIHJlYXNvbmluZzogXCJWZXJ5IGhpZ2ggb3ZlcnN1YnNjcmlwdGlvblwiLFxyXG4gICAgICAgIGFjdGlvbjogXCJBcHBseSBmb3IgbWF4aW11bSByZXRhaWwgcXVvdGEgdG8gaW1wcm92ZSBhbGxvdG1lbnQgY2hhbmNlc1wiLFxyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcmVjb21tZW5kYXRpb25zO1xyXG4gIH1cclxuXHJcbiAgLy8gVXRpbGl0eSBtZXRob2RzIGZvciBjYWxjdWxhdGlvbnNcclxuICBjYWxjdWxhdGVBdmVyYWdlKHZhbHVlcykge1xyXG4gICAgaWYgKCF2YWx1ZXMgfHwgdmFsdWVzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIDA7XHJcbiAgICByZXR1cm4gdmFsdWVzLnJlZHVjZSgoc3VtLCB2YWwpID0+IHN1bSArIHZhbCwgMCkgLyB2YWx1ZXMubGVuZ3RoO1xyXG4gIH1cclxuXHJcbiAgY2FsY3VsYXRlTWVkaWFuKHZhbHVlcykge1xyXG4gICAgaWYgKCF2YWx1ZXMgfHwgdmFsdWVzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIDA7XHJcbiAgICBjb25zdCBzb3J0ZWQgPSBbLi4udmFsdWVzXS5zb3J0KChhLCBiKSA9PiBhIC0gYik7XHJcbiAgICBjb25zdCBtaWQgPSBNYXRoLmZsb29yKHNvcnRlZC5sZW5ndGggLyAyKTtcclxuICAgIHJldHVybiBzb3J0ZWQubGVuZ3RoICUgMiA9PT0gMFxyXG4gICAgICA/IChzb3J0ZWRbbWlkIC0gMV0gKyBzb3J0ZWRbbWlkXSkgLyAyXHJcbiAgICAgIDogc29ydGVkW21pZF07XHJcbiAgfVxyXG5cclxuICBjYWxjdWxhdGVNb2RlKHZhbHVlcykge1xyXG4gICAgaWYgKCF2YWx1ZXMgfHwgdmFsdWVzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIDA7XHJcbiAgICBjb25zdCBmcmVxdWVuY3kgPSB7fTtcclxuICAgIHZhbHVlcy5mb3JFYWNoKCh2YWwpID0+IChmcmVxdWVuY3lbdmFsXSA9IChmcmVxdWVuY3lbdmFsXSB8fCAwKSArIDEpKTtcclxuICAgIHJldHVybiBPYmplY3Qua2V5cyhmcmVxdWVuY3kpLnJlZHVjZSgoYSwgYikgPT5cclxuICAgICAgZnJlcXVlbmN5W2FdID4gZnJlcXVlbmN5W2JdID8gYSA6IGJcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICBjYWxjdWxhdGVTdGFuZGFyZERldmlhdGlvbih2YWx1ZXMpIHtcclxuICAgIGlmICghdmFsdWVzIHx8IHZhbHVlcy5sZW5ndGggPCAyKSByZXR1cm4gMDtcclxuICAgIGNvbnN0IGF2ZyA9IHRoaXMuY2FsY3VsYXRlQXZlcmFnZSh2YWx1ZXMpO1xyXG4gICAgY29uc3QgdmFyaWFuY2UgPVxyXG4gICAgICB2YWx1ZXMucmVkdWNlKChzdW0sIHZhbCkgPT4gc3VtICsgTWF0aC5wb3codmFsIC0gYXZnLCAyKSwgMCkgL1xyXG4gICAgICB2YWx1ZXMubGVuZ3RoO1xyXG4gICAgcmV0dXJuIE1hdGguc3FydCh2YXJpYW5jZSk7XHJcbiAgfVxyXG5cclxuICBjYWxjdWxhdGVWYXJpYW5jZSh2YWx1ZXMpIHtcclxuICAgIGlmICghdmFsdWVzIHx8IHZhbHVlcy5sZW5ndGggPCAyKSByZXR1cm4gMDtcclxuICAgIGNvbnN0IGF2ZyA9IHRoaXMuY2FsY3VsYXRlQXZlcmFnZSh2YWx1ZXMpO1xyXG4gICAgcmV0dXJuIChcclxuICAgICAgdmFsdWVzLnJlZHVjZSgoc3VtLCB2YWwpID0+IHN1bSArIE1hdGgucG93KHZhbCAtIGF2ZywgMiksIDApIC9cclxuICAgICAgdmFsdWVzLmxlbmd0aFxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIGNhbGN1bGF0ZUNvZWZmaWNpZW50T2ZWYXJpYXRpb24odmFsdWVzKSB7XHJcbiAgICBjb25zdCBhdmcgPSB0aGlzLmNhbGN1bGF0ZUF2ZXJhZ2UodmFsdWVzKTtcclxuICAgIGNvbnN0IHN0ZERldiA9IHRoaXMuY2FsY3VsYXRlU3RhbmRhcmREZXZpYXRpb24odmFsdWVzKTtcclxuICAgIHJldHVybiBhdmcgPiAwID8gKHN0ZERldiAvIGF2ZykgKiAxMDAgOiAwO1xyXG4gIH1cclxuXHJcbiAgYW5hbHl6ZVRyZW5kKHZhbHVlcykge1xyXG4gICAgaWYgKCF2YWx1ZXMgfHwgdmFsdWVzLmxlbmd0aCA8IDIpXHJcbiAgICAgIHJldHVybiB7IGRpcmVjdGlvbjogXCJzdGFibGVcIiwgc3RyZW5ndGg6IDAgfTtcclxuXHJcbiAgICBjb25zdCByZWNlbnQgPSB2YWx1ZXMuc2xpY2UoMCwgTWF0aC5taW4oNSwgTWF0aC5mbG9vcih2YWx1ZXMubGVuZ3RoIC8gMikpKTtcclxuICAgIGNvbnN0IG9sZGVyID0gdmFsdWVzLnNsaWNlKC1NYXRoLm1pbig1LCBNYXRoLmZsb29yKHZhbHVlcy5sZW5ndGggLyAyKSkpO1xyXG5cclxuICAgIGNvbnN0IHJlY2VudEF2ZyA9IHRoaXMuY2FsY3VsYXRlQXZlcmFnZShyZWNlbnQpO1xyXG4gICAgY29uc3Qgb2xkZXJBdmcgPSB0aGlzLmNhbGN1bGF0ZUF2ZXJhZ2Uob2xkZXIpO1xyXG5cclxuICAgIGNvbnN0IGNoYW5nZSA9IHJlY2VudEF2ZyAtIG9sZGVyQXZnO1xyXG4gICAgY29uc3QgY2hhbmdlUGVyY2VudCA9IG9sZGVyQXZnID4gMCA/IChjaGFuZ2UgLyBvbGRlckF2ZykgKiAxMDAgOiAwO1xyXG5cclxuICAgIGxldCBkaXJlY3Rpb24gPSBcInN0YWJsZVwiO1xyXG4gICAgbGV0IHN0cmVuZ3RoID0gTWF0aC5hYnMoY2hhbmdlUGVyY2VudCk7XHJcblxyXG4gICAgaWYgKGNoYW5nZVBlcmNlbnQgPiA1KSBkaXJlY3Rpb24gPSBcImJ1bGxpc2hcIjtcclxuICAgIGVsc2UgaWYgKGNoYW5nZVBlcmNlbnQgPCAtNSkgZGlyZWN0aW9uID0gXCJiZWFyaXNoXCI7XHJcblxyXG4gICAgcmV0dXJuIHsgZGlyZWN0aW9uLCBzdHJlbmd0aCwgY2hhbmdlLCBjaGFuZ2VQZXJjZW50IH07XHJcbiAgfVxyXG5cclxuICBhbmFseXplVm9sYXRpbGl0eSh2YWx1ZXMsIHRpbWVzdGFtcHMpIHtcclxuICAgIGlmICghdmFsdWVzIHx8IHZhbHVlcy5sZW5ndGggPCAyKVxyXG4gICAgICByZXR1cm4geyBsZXZlbDogXCJ1bmtub3duXCIsIGNvZWZmaWNpZW50OiAwIH07XHJcblxyXG4gICAgY29uc3QgY29lZmZpY2llbnQgPSB0aGlzLmNhbGN1bGF0ZUNvZWZmaWNpZW50T2ZWYXJpYXRpb24odmFsdWVzKTtcclxuICAgIGxldCBsZXZlbCA9IFwibG93XCI7XHJcblxyXG4gICAgaWYgKGNvZWZmaWNpZW50ID4gMzApIGxldmVsID0gXCJoaWdoXCI7XHJcbiAgICBlbHNlIGlmIChjb2VmZmljaWVudCA+IDE1KSBsZXZlbCA9IFwibWVkaXVtXCI7XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgbGV2ZWwsXHJcbiAgICAgIGNvZWZmaWNpZW50LFxyXG4gICAgICBzdGFuZGFyZERldmlhdGlvbjogdGhpcy5jYWxjdWxhdGVTdGFuZGFyZERldmlhdGlvbih2YWx1ZXMpLFxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIGNhbGN1bGF0ZU1vbWVudHVtKHZhbHVlcykge1xyXG4gICAgaWYgKCF2YWx1ZXMgfHwgdmFsdWVzLmxlbmd0aCA8IDMpIHJldHVybiB7IHNjb3JlOiAwLCBkaXJlY3Rpb246IFwibmV1dHJhbFwiIH07XHJcblxyXG4gICAgY29uc3QgcmVjZW50ID0gdmFsdWVzLnNsaWNlKDAsIDMpO1xyXG4gICAgY29uc3QgbW9tZW50dW0gPSByZWNlbnRbMF0gLSByZWNlbnRbMl07XHJcbiAgICBjb25zdCBtb21lbnR1bVBlcmNlbnQgPSByZWNlbnRbMl0gPiAwID8gKG1vbWVudHVtIC8gcmVjZW50WzJdKSAqIDEwMCA6IDA7XHJcblxyXG4gICAgbGV0IGRpcmVjdGlvbiA9IFwibmV1dHJhbFwiO1xyXG4gICAgaWYgKG1vbWVudHVtUGVyY2VudCA+IDIpIGRpcmVjdGlvbiA9IFwicG9zaXRpdmVcIjtcclxuICAgIGVsc2UgaWYgKG1vbWVudHVtUGVyY2VudCA8IC0yKSBkaXJlY3Rpb24gPSBcIm5lZ2F0aXZlXCI7XHJcblxyXG4gICAgcmV0dXJuIHsgc2NvcmU6IG1vbWVudHVtUGVyY2VudCwgZGlyZWN0aW9uLCBhYnNvbHV0ZTogbW9tZW50dW0gfTtcclxuICB9XHJcblxyXG4gIC8vIERhdGEgZmV0Y2hpbmcgbWV0aG9kc1xyXG4gIGFzeW5jIGdldElQT0Jhc2ljRGF0YShpcG9JZCkge1xyXG4gICAgcmV0dXJuIGF3YWl0IHByaXNtYS5pUE8uZmluZFVuaXF1ZSh7XHJcbiAgICAgIHdoZXJlOiB7IGlkOiBpcG9JZCB9LFxyXG4gICAgICBpbmNsdWRlOiB7IGNhdGVnb3JpZXM6IHRydWUgfSxcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgZ2V0R01QRGF0YShpcG9JZCwgZGF5cyA9IDMwKSB7XHJcbiAgICBjb25zdCBzdGFydERhdGUgPSBuZXcgRGF0ZSgpO1xyXG4gICAgc3RhcnREYXRlLnNldERhdGUoc3RhcnREYXRlLmdldERhdGUoKSAtIGRheXMpO1xyXG5cclxuICAgIHJldHVybiBhd2FpdCBwcmlzbWEuZ01QLmZpbmRNYW55KHtcclxuICAgICAgd2hlcmU6IHtcclxuICAgICAgICBpcG9JZCxcclxuICAgICAgICB0aW1lc3RhbXA6IHsgZ3RlOiBzdGFydERhdGUgfSxcclxuICAgICAgfSxcclxuICAgICAgb3JkZXJCeTogeyB0aW1lc3RhbXA6IFwiZGVzY1wiIH0sXHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIGFzeW5jIGdldFN1YnNjcmlwdGlvbkRhdGEoaXBvSWQsIGRheXMgPSAzMCkge1xyXG4gICAgY29uc3Qgc3RhcnREYXRlID0gbmV3IERhdGUoKTtcclxuICAgIHN0YXJ0RGF0ZS5zZXREYXRlKHN0YXJ0RGF0ZS5nZXREYXRlKCkgLSBkYXlzKTtcclxuXHJcbiAgICByZXR1cm4gYXdhaXQgcHJpc21hLnN1YnNjcmlwdGlvbkRhdGEuZmluZE1hbnkoe1xyXG4gICAgICB3aGVyZToge1xyXG4gICAgICAgIGlwb0lkLFxyXG4gICAgICAgIHRpbWVzdGFtcDogeyBndGU6IHN0YXJ0RGF0ZSB9LFxyXG4gICAgICB9LFxyXG4gICAgICBvcmRlckJ5OiB7IHRpbWVzdGFtcDogXCJkZXNjXCIgfSxcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgZ2V0RGVtYW5kRGF0YShpcG9JZCwgZGF5cyA9IDMwKSB7XHJcbiAgICBjb25zdCBzdGFydERhdGUgPSBuZXcgRGF0ZSgpO1xyXG4gICAgc3RhcnREYXRlLnNldERhdGUoc3RhcnREYXRlLmdldERhdGUoKSAtIGRheXMpO1xyXG5cclxuICAgIHJldHVybiBhd2FpdCBwcmlzbWEubWFya2V0RGVtYW5kLmZpbmRNYW55KHtcclxuICAgICAgd2hlcmU6IHtcclxuICAgICAgICBpcG9JZCxcclxuICAgICAgICB0aW1lc3RhbXA6IHsgZ3RlOiBzdGFydERhdGUgfSxcclxuICAgICAgfSxcclxuICAgICAgb3JkZXJCeTogeyB0aW1lc3RhbXA6IFwiZGVzY1wiIH0sXHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIGFzeW5jIGdldElQT0NhdGVnb3JpZXMoaXBvSWQpIHtcclxuICAgIHJldHVybiBhd2FpdCBwcmlzbWEuaVBPQ2F0ZWdvcnkuZmluZE1hbnkoe1xyXG4gICAgICB3aGVyZTogeyBpcG9JZCB9LFxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvLyBDYWNoZSBtYW5hZ2VtZW50XHJcbiAgYXN5bmMgZ2V0Q2FjaGVkQW5hbHl0aWNzKGtleSkge1xyXG4gICAgLy8gQ2hlY2sgaW4tbWVtb3J5IGNhY2hlIGZpcnN0XHJcbiAgICBpZiAodGhpcy5hbmFseXRpY3NDYWNoZS5oYXMoa2V5KSkge1xyXG4gICAgICBjb25zdCBjYWNoZWQgPSB0aGlzLmFuYWx5dGljc0NhY2hlLmdldChrZXkpO1xyXG4gICAgICBpZiAoRGF0ZS5ub3coKSAtIGNhY2hlZC50aW1lc3RhbXAgPCB0aGlzLmNhY2hlVFRMLkRFVEFJTEVEKSB7XHJcbiAgICAgICAgcmV0dXJuIGNhY2hlZC5kYXRhO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuYW5hbHl0aWNzQ2FjaGUuZGVsZXRlKGtleSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ2hlY2sgUmVkaXMgY2FjaGVcclxuICAgIHJldHVybiBhd2FpdCBjYWNoZS5nZXQoa2V5KTtcclxuICB9XHJcblxyXG4gIGFzeW5jIHNldENhY2hlZEFuYWx5dGljcyhrZXksIGRhdGEsIHR0bCkge1xyXG4gICAgLy8gU2V0IGluLW1lbW9yeSBjYWNoZVxyXG4gICAgdGhpcy5hbmFseXRpY3NDYWNoZS5zZXQoa2V5LCB7XHJcbiAgICAgIGRhdGEsXHJcbiAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIFNldCBpbiBSZWRpc1xyXG4gICAgcmV0dXJuIGF3YWl0IGNhY2hlLnNldChrZXksIGRhdGEsIHR0bCAvIDEwMDApO1xyXG4gIH1cclxuXHJcbiAgLy8gSGVscGVyIG1ldGhvZHNcclxuICBjYXRlZ29yaXplSXNzdWVTaXplKHNpemUpIHtcclxuICAgIGlmIChzaXplIDwgNTAwICogMTAwMDAwMDApIHJldHVybiBcInNtYWxsXCI7IC8vIDwgNTAwIENyXHJcbiAgICBpZiAoc2l6ZSA8IDIwMDAgKiAxMDAwMDAwMCkgcmV0dXJuIFwibWVkaXVtXCI7IC8vIDwgMjAwMCBDclxyXG4gICAgcmV0dXJuIFwibGFyZ2VcIjsgLy8gPj0gMjAwMCBDclxyXG4gIH1cclxuXHJcbiAgY2FsY3VsYXRlRHVyYXRpb24oc3RhcnREYXRlLCBlbmREYXRlKSB7XHJcbiAgICBjb25zdCBzdGFydCA9IG5ldyBEYXRlKHN0YXJ0RGF0ZSk7XHJcbiAgICBjb25zdCBlbmQgPSBuZXcgRGF0ZShlbmREYXRlKTtcclxuICAgIHJldHVybiBNYXRoLmNlaWwoKGVuZCAtIHN0YXJ0KSAvICgxMDAwICogNjAgKiA2MCAqIDI0KSk7XHJcbiAgfVxyXG5cclxuICBjYXRlZ29yaXplUmlza0xldmVsKHNjb3JlKSB7XHJcbiAgICBpZiAoc2NvcmUgPCAzMCkgcmV0dXJuIFwibG93XCI7XHJcbiAgICBpZiAoc2NvcmUgPCA2MCkgcmV0dXJuIFwibWVkaXVtXCI7XHJcbiAgICByZXR1cm4gXCJoaWdoXCI7XHJcbiAgfVxyXG5cclxuICBnZXRMYXRlc3RTdWJzY3JpcHRpb25CeUNhdGVnb3J5KHN1YnNjcmlwdGlvbkRhdGEpIHtcclxuICAgIGNvbnN0IGxhdGVzdCA9IHt9O1xyXG5cclxuICAgIHN1YnNjcmlwdGlvbkRhdGEuZm9yRWFjaCgoaXRlbSkgPT4ge1xyXG4gICAgICBjb25zdCBrZXkgPSBpdGVtLmNhdGVnb3J5ICsgKGl0ZW0uc3ViQ2F0ZWdvcnkgfHwgXCJcIik7XHJcbiAgICAgIGlmICghbGF0ZXN0W2tleV0gfHwgaXRlbS50aW1lc3RhbXAgPiBsYXRlc3Rba2V5XS50aW1lc3RhbXApIHtcclxuICAgICAgICBsYXRlc3Rba2V5XSA9IGl0ZW07XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiBsYXRlc3Q7XHJcbiAgfVxyXG5cclxuICBjYWxjdWxhdGVPdmVyYWxsU3Vic2NyaXB0aW9uKGxhdGVzdEJ5Q2F0ZWdvcnkpIHtcclxuICAgIGNvbnN0IHJhdGlvcyA9IE9iamVjdC52YWx1ZXMobGF0ZXN0QnlDYXRlZ29yeSkubWFwKFxyXG4gICAgICAoaXRlbSkgPT4gaXRlbS5zdWJzY3JpcHRpb25SYXRpbyB8fCAwXHJcbiAgICApO1xyXG4gICAgcmV0dXJuIHJhdGlvcy5sZW5ndGggPiAwID8gTWF0aC5tYXgoLi4ucmF0aW9zKSA6IDA7XHJcbiAgfVxyXG5cclxuICAvLyBQZXJmb3JtYW5jZSB0cmFja2luZ1xyXG4gIHVwZGF0ZU1ldHJpY3MoY29tcHV0YXRpb25UaW1lKSB7XHJcbiAgICB0aGlzLm1ldHJpY3MuY29tcHV0YXRpb25zUGVyZm9ybWVkKys7XHJcbiAgICB0aGlzLm1ldHJpY3MuYXZlcmFnZUNvbXB1dGF0aW9uVGltZSA9XHJcbiAgICAgICh0aGlzLm1ldHJpY3MuYXZlcmFnZUNvbXB1dGF0aW9uVGltZSAqXHJcbiAgICAgICAgKHRoaXMubWV0cmljcy5jb21wdXRhdGlvbnNQZXJmb3JtZWQgLSAxKSArXHJcbiAgICAgICAgY29tcHV0YXRpb25UaW1lKSAvXHJcbiAgICAgIHRoaXMubWV0cmljcy5jb21wdXRhdGlvbnNQZXJmb3JtZWQ7XHJcbiAgfVxyXG5cclxuICBnZXRQZXJmb3JtYW5jZU1ldHJpY3MoKSB7XHJcbiAgICBjb25zdCBoaXRSYXRlID1cclxuICAgICAgdGhpcy5tZXRyaWNzLmNhY2hlSGl0cyArIHRoaXMubWV0cmljcy5jYWNoZU1pc3NlcyA+IDBcclxuICAgICAgICA/IChcclxuICAgICAgICAgICAgKHRoaXMubWV0cmljcy5jYWNoZUhpdHMgL1xyXG4gICAgICAgICAgICAgICh0aGlzLm1ldHJpY3MuY2FjaGVIaXRzICsgdGhpcy5tZXRyaWNzLmNhY2hlTWlzc2VzKSkgKlxyXG4gICAgICAgICAgICAxMDBcclxuICAgICAgICAgICkudG9GaXhlZCgyKVxyXG4gICAgICAgIDogXCIwLjAwXCI7XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgLi4udGhpcy5tZXRyaWNzLFxyXG4gICAgICBjYWNoZUhpdFJhdGU6IGAke2hpdFJhdGV9JWAsXHJcbiAgICAgIGF2ZXJhZ2VDb21wdXRhdGlvblRpbWU6IE1hdGgucm91bmQodGhpcy5tZXRyaWNzLmF2ZXJhZ2VDb21wdXRhdGlvblRpbWUpLFxyXG4gICAgICBzdWNjZXNzUmF0ZTpcclxuICAgICAgICB0aGlzLm1ldHJpY3MuY29tcHV0YXRpb25zUGVyZm9ybWVkID4gMFxyXG4gICAgICAgICAgPyAoXHJcbiAgICAgICAgICAgICAgKCh0aGlzLm1ldHJpY3MuY29tcHV0YXRpb25zUGVyZm9ybWVkIC0gdGhpcy5tZXRyaWNzLmVycm9ycykgL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tZXRyaWNzLmNvbXB1dGF0aW9uc1BlcmZvcm1lZCkgKlxyXG4gICAgICAgICAgICAgIDEwMFxyXG4gICAgICAgICAgICApLnRvRml4ZWQoMilcclxuICAgICAgICAgIDogXCIxMDAuMDBcIixcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICAvLyBQbGFjZWhvbGRlciBtZXRob2RzIGZvciBhZHZhbmNlZCBmZWF0dXJlcyAodG8gYmUgaW1wbGVtZW50ZWQpXHJcbiAgYXN5bmMgZ2V0Q29tcGFyYWJsZUlQT3MoaXBvSWQsIHRpbWVSYW5nZSkge1xyXG4gICAgcmV0dXJuIFtdO1xyXG4gIH1cclxuICBhc3luYyBjYWxjdWxhdGVIaXN0b3JpY2FsTWV0cmljcyhpcG9JZCwgdGltZVJhbmdlKSB7XHJcbiAgICByZXR1cm4ge307XHJcbiAgfVxyXG4gIGFzeW5jIGNhbGN1bGF0ZUhpc3RvcmljYWxUcmVuZHMoaXBvSWQsIHRpbWVSYW5nZSkge1xyXG4gICAgcmV0dXJuIHt9O1xyXG4gIH1cclxuICBhc3luYyBjYWxjdWxhdGVCZW5jaG1hcmtzKGNvbXBhcmFibGVJUE9zKSB7XHJcbiAgICByZXR1cm4ge307XHJcbiAgfVxyXG4gIGFzeW5jIGZpbmRTaW1pbGFySVBPcyhpcG9EYXRhKSB7XHJcbiAgICByZXR1cm4gW107XHJcbiAgfVxyXG4gIGFzeW5jIGNhbGN1bGF0ZVJlbGF0aXZlUGVyZm9ybWFuY2UoaXBvRGF0YSwgc2ltaWxhcklQT3MpIHtcclxuICAgIHJldHVybiB7fTtcclxuICB9XHJcbiAgY2FsY3VsYXRlTWFya2V0UG9zaXRpb25pbmcoaXBvRGF0YSwgc2ltaWxhcklQT3MpIHtcclxuICAgIHJldHVybiB7fTtcclxuICB9XHJcbiAgYXN5bmMgY2FsY3VsYXRlSW5kdXN0cnlCZW5jaG1hcmtzKGlzc3VlVHlwZSkge1xyXG4gICAgcmV0dXJuIHt9O1xyXG4gIH1cclxuXHJcbiAgcHJlZGljdExpc3RpbmdHYWluKGFuYWx5dGljcykge1xyXG4gICAgY29uc3QgZ21wID0gYW5hbHl0aWNzLmdtcEFuYWx5dGljcy5zdGF0aXN0aWNzPy5jdXJyZW50IHx8IDA7XHJcbiAgICBjb25zdCByaXNrID0gYW5hbHl0aWNzLnJpc2tBc3Nlc3NtZW50Lm92ZXJhbGxSaXNrU2NvcmUgfHwgNTA7XHJcbiAgICBjb25zdCBzdWJzY3JpcHRpb24gPVxyXG4gICAgICBhbmFseXRpY3Muc3Vic2NyaXB0aW9uQW5hbHl0aWNzLm92ZXJhbGw/LnRvdGFsU3Vic2NyaXB0aW9uIHx8IDE7XHJcblxyXG4gICAgLy8gU2ltcGxlIHByZWRpY3Rpb24gbW9kZWwgKGVuaGFuY2Ugd2l0aCBNTClcclxuICAgIGxldCBwcmVkaWN0aW9uID0gZ21wICogMC44OyAvLyBDb25zZXJ2YXRpdmUgZXN0aW1hdGVcclxuXHJcbiAgICAvLyBBZGp1c3QgZm9yIHJpc2tcclxuICAgIHByZWRpY3Rpb24gKj0gMSAtIHJpc2sgLyAyMDA7IC8vIFJlZHVjZSBieSBoYWxmIHRoZSByaXNrIHBlcmNlbnRhZ2VcclxuXHJcbiAgICAvLyBBZGp1c3QgZm9yIHN1YnNjcmlwdGlvblxyXG4gICAgaWYgKHN1YnNjcmlwdGlvbiA+IDUpXHJcbiAgICAgIHByZWRpY3Rpb24gKj0gMC45OyAvLyBIaWdoIHN1YnNjcmlwdGlvbiBtYXkgbGltaXQgZ2FpbnNcclxuICAgIGVsc2UgaWYgKHN1YnNjcmlwdGlvbiA8IDEpIHByZWRpY3Rpb24gKj0gMC43OyAvLyBMb3cgc3Vic2NyaXB0aW9uIGlzIGJlYXJpc2hcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB2YWx1ZTogTWF0aC5yb3VuZChwcmVkaWN0aW9uKSxcclxuICAgICAgY29uZmlkZW5jZTogMC42LCAvLyA2MCUgY29uZmlkZW5jZVxyXG4gICAgICByYW5nZToge1xyXG4gICAgICAgIG1pbjogTWF0aC5yb3VuZChwcmVkaWN0aW9uICogMC43KSxcclxuICAgICAgICBtYXg6IE1hdGgucm91bmQocHJlZGljdGlvbiAqIDEuMyksXHJcbiAgICAgIH0sXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgcHJlZGljdEFsbG90bWVudFByb2JhYmlsaXR5KGFuYWx5dGljcykge1xyXG4gICAgY29uc3Qgc3Vic2NyaXB0aW9uID1cclxuICAgICAgYW5hbHl0aWNzLnN1YnNjcmlwdGlvbkFuYWx5dGljcy5vdmVyYWxsPy50b3RhbFN1YnNjcmlwdGlvbiB8fCAxO1xyXG5cclxuICAgIGxldCBwcm9iYWJpbGl0eSA9IDEwMDtcclxuICAgIGlmIChzdWJzY3JpcHRpb24gPiAxKSB7XHJcbiAgICAgIHByb2JhYmlsaXR5ID0gTWF0aC5taW4oOTUsIDEwMCAvIHN1YnNjcmlwdGlvbik7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgcmV0YWlsOiBNYXRoLnJvdW5kKHByb2JhYmlsaXR5KSxcclxuICAgICAgY29uZmlkZW5jZTogMC44LFxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIHByZWRpY3RQcmljZVRhcmdldHMoYW5hbHl0aWNzKSB7XHJcbiAgICBjb25zdCBnbXAgPSBhbmFseXRpY3MuZ21wQW5hbHl0aWNzLnN0YXRpc3RpY3M/LmN1cnJlbnQgfHwgMDtcclxuICAgIGNvbnN0IGJhc2VQcmljZSA9IGFuYWx5dGljcy5iYXNpY01ldHJpY3M/LnByaWNlUmFuZ2U/Lm1heCB8fCAwO1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgIGNvbnNlcnZhdGl2ZTogYmFzZVByaWNlICsgZ21wICogMC41LFxyXG4gICAgICBtb2RlcmF0ZTogYmFzZVByaWNlICsgZ21wICogMC44LFxyXG4gICAgICBhZ2dyZXNzaXZlOiBiYXNlUHJpY2UgKyBnbXAgKiAxLjIsXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgY2FsY3VsYXRlUmlza0FkanVzdGVkUmV0dXJucyhsaXN0aW5nR2Fpbiwgcmlza1Njb3JlKSB7XHJcbiAgICBjb25zdCBnYWluID0gbGlzdGluZ0dhaW4udmFsdWUgfHwgMDtcclxuICAgIGNvbnN0IHJpc2sgPSByaXNrU2NvcmUgfHwgNTA7XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgcmlza0FkanVzdGVkUmV0dXJuOiBnYWluICogKDEgLSByaXNrIC8gMTAwKSxcclxuICAgICAgc2hhcnBlUmF0aW86IHJpc2sgPiAwID8gZ2FpbiAvIHJpc2sgOiAwLFxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIGNhbGN1bGF0ZUNvbmZpZGVuY2VJbnRlcnZhbHMocHJlZGljdGlvbnMpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGxpc3RpbmdHYWluOiB7XHJcbiAgICAgICAgY29uZmlkZW5jZTkwOiB7XHJcbiAgICAgICAgICBtaW46IHByZWRpY3Rpb25zLmxpc3RpbmdHYWluPy5yYW5nZT8ubWluIHx8IDAsXHJcbiAgICAgICAgICBtYXg6IHByZWRpY3Rpb25zLmxpc3RpbmdHYWluPy5yYW5nZT8ubWF4IHx8IDAsXHJcbiAgICAgICAgfSxcclxuICAgICAgfSxcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICAvLyBBZGRpdGlvbmFsIGhlbHBlciBtZXRob2RzXHJcbiAgYW5hbHl6ZVZvbHVtZSh2b2x1bWVzLCB2YWx1ZXMpIHtcclxuICAgIHJldHVybiB7IGNvcnJlbGF0aW9uOiAwLCB0cmVuZDogXCJzdGFibGVcIiB9O1xyXG4gIH1cclxuICBjYWxjdWxhdGVQcmljZVRhcmdldHMoc3RhdHMpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHN1cHBvcnQ6IHN0YXRzLm1pbixcclxuICAgICAgcmVzaXN0YW5jZTogc3RhdHMubWF4LFxyXG4gICAgICBwaXZvdDogc3RhdHMuYXZlcmFnZSxcclxuICAgIH07XHJcbiAgfVxyXG4gIGNhbGN1bGF0ZUdNUFJpc2tNZXRyaWNzKHZhbHVlcykge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgdmFsdWVBdFJpc2s6IHRoaXMuY2FsY3VsYXRlU3RhbmRhcmREZXZpYXRpb24odmFsdWVzKSAqIDEuNjQ1LCAvLyA5NSUgVmFSXHJcbiAgICAgIG1heERyYXdkb3duOiB0aGlzLmNhbGN1bGF0ZU1heERyYXdkb3duKHZhbHVlcyksXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgY2FsY3VsYXRlTWF4RHJhd2Rvd24odmFsdWVzKSB7XHJcbiAgICBsZXQgbWF4RHJhd2Rvd24gPSAwO1xyXG4gICAgbGV0IHBlYWsgPSB2YWx1ZXNbMF07XHJcblxyXG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgaWYgKHZhbHVlc1tpXSA+IHBlYWspIHtcclxuICAgICAgICBwZWFrID0gdmFsdWVzW2ldO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNvbnN0IGRyYXdkb3duID0gKHBlYWsgLSB2YWx1ZXNbaV0pIC8gcGVhaztcclxuICAgICAgICBtYXhEcmF3ZG93biA9IE1hdGgubWF4KG1heERyYXdkb3duLCBkcmF3ZG93bik7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbWF4RHJhd2Rvd24gKiAxMDA7IC8vIFJldHVybiBhcyBwZXJjZW50YWdlXHJcbiAgfVxyXG5cclxuICBhbmFseXplU3Vic2NyaXB0aW9uUGF0dGVybnMoc3Vic2NyaXB0aW9uRGF0YSkge1xyXG4gICAgcmV0dXJuIHsgdHJlbmQ6IFwiaW5jcmVhc2luZ1wiIH07XHJcbiAgfVxyXG4gIGNhbGN1bGF0ZUFsbG90bWVudFByb2JhYmlsaXRpZXMobGF0ZXN0QnlDYXRlZ29yeSkge1xyXG4gICAgY29uc3QgcmVzdWx0ID0ge307XHJcbiAgICBmb3IgKGNvbnN0IFtjYXRlZ29yeSwgZGF0YV0gb2YgT2JqZWN0LmVudHJpZXMobGF0ZXN0QnlDYXRlZ29yeSkpIHtcclxuICAgICAgY29uc3QgcmF0aW8gPSBkYXRhLnN1YnNjcmlwdGlvblJhdGlvIHx8IDE7XHJcbiAgICAgIHJlc3VsdFtjYXRlZ29yeV0gPSByYXRpbyA+IDEgPyBNYXRoLm1pbig5NSwgMTAwIC8gcmF0aW8pIDogOTU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG4gIH1cclxuXHJcbiAgZ2VuZXJhdGVTdWJzY3JpcHRpb25JbnNpZ2h0cyhvdmVyYWxsLCBjYXRlZ29yaWVzKSB7XHJcbiAgICByZXR1cm4gW107XHJcbiAgfVxyXG4gIGFuYWx5emVQcmljZVdpc2VEZW1hbmQoZGVtYW5kRGF0YSkge1xyXG4gICAgcmV0dXJuIHsgZGlzdHJpYnV0aW9uOiBcIm5vcm1hbFwiIH07XHJcbiAgfVxyXG4gIGFuYWx5emVDdXRPZmZEZW1hbmQoZGVtYW5kRGF0YSkge1xyXG4gICAgcmV0dXJuIHsgcGVyY2VudGFnZTogMCB9O1xyXG4gIH1cclxuICBhbmFseXplRGVtYW5kRGlzdHJpYnV0aW9uKGRlbWFuZERhdGEpIHtcclxuICAgIHJldHVybiB7IGNvbmNlbnRyYXRpb246IFwiZGlzdHJpYnV0ZWRcIiB9O1xyXG4gIH1cclxuICBhbmFseXplQmlkQ29uY2VudHJhdGlvbihkZW1hbmREYXRhKSB7XHJcbiAgICByZXR1cm4geyBoZXJmaW5kYWhsSW5kZXg6IDAgfTtcclxuICB9XHJcbiAgY2FsY3VsYXRlTWFya2V0U2VudGltZW50KGdtcERhdGEsIHN1YnNjcmlwdGlvbkRhdGEpIHtcclxuICAgIHJldHVybiAwLjU7XHJcbiAgfVxyXG4gIGNhbGN1bGF0ZURlbWFuZFN0cmVuZ3RoKHN1YnNjcmlwdGlvbkRhdGEpIHtcclxuICAgIHJldHVybiAwLjU7XHJcbiAgfVxyXG4gIGNhbGN1bGF0ZUxpc3RpbmdSZWFkaW5lc3MoaXBvRGF0YSwgc3Vic2NyaXB0aW9uRGF0YSkge1xyXG4gICAgcmV0dXJuIDAuODtcclxuICB9XHJcbiAgY2FsY3VsYXRlQXR0cmFjdGl2ZW5lc3NTY29yZShpbmRpY2F0b3JzKSB7XHJcbiAgICByZXR1cm4gMC43O1xyXG4gIH1cclxuICBjYWxjdWxhdGVUaW1lc3BhbihkYXRhKSB7XHJcbiAgICBpZiAoIWRhdGEgfHwgZGF0YS5sZW5ndGggPCAyKSByZXR1cm4gMDtcclxuICAgIGNvbnN0IGZpcnN0ID0gbmV3IERhdGUoZGF0YVtkYXRhLmxlbmd0aCAtIDFdLnRpbWVzdGFtcCk7XHJcbiAgICBjb25zdCBsYXN0ID0gbmV3IERhdGUoZGF0YVswXS50aW1lc3RhbXApO1xyXG4gICAgcmV0dXJuIE1hdGguY2VpbCgobGFzdCAtIGZpcnN0KSAvICgxMDAwICogNjAgKiA2MCAqIDI0KSk7XHJcbiAgfVxyXG4gIGdlbmVyYXRlUmlza1JlY29tbWVuZGF0aW9uKHNjb3JlLCBmYWN0b3JzKSB7XHJcbiAgICBpZiAoc2NvcmUgPCAzMClcclxuICAgICAgcmV0dXJuIFwiTG93IHJpc2sgaW52ZXN0bWVudCwgc3VpdGFibGUgZm9yIGNvbnNlcnZhdGl2ZSBpbnZlc3RvcnNcIjtcclxuICAgIGlmIChzY29yZSA8IDYwKSByZXR1cm4gXCJNb2RlcmF0ZSByaXNrLCBzdWl0YWJsZSBmb3IgYmFsYW5jZWQgcG9ydGZvbGlvc1wiO1xyXG4gICAgcmV0dXJuIFwiSGlnaCByaXNrIGludmVzdG1lbnQsIHN1aXRhYmxlIG9ubHkgZm9yIGFnZ3Jlc3NpdmUgaW52ZXN0b3JzXCI7XHJcbiAgfVxyXG59XHJcblxyXG4vLyBFeHBvcnQgc2luZ2xldG9uIGluc3RhbmNlXHJcbmV4cG9ydCBjb25zdCBhbmFseXRpY3NTZXJ2aWNlID0gbmV3IEFuYWx5dGljc1NlcnZpY2UoKTtcclxuXHJcbi8vIENsZWFudXAgb2xkIGNhY2hlIGVudHJpZXMgcGVyaW9kaWNhbGx5XHJcbnNldEludGVydmFsKFxyXG4gICgpID0+IHtcclxuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XHJcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBhbmFseXRpY3NTZXJ2aWNlLmFuYWx5dGljc0NhY2hlLmVudHJpZXMoKSkge1xyXG4gICAgICBpZiAobm93IC0gdmFsdWUudGltZXN0YW1wID4gYW5hbHl0aWNzU2VydmljZS5jYWNoZVRUTC5ERVRBSUxFRCkge1xyXG4gICAgICAgIGFuYWx5dGljc1NlcnZpY2UuYW5hbHl0aWNzQ2FjaGUuZGVsZXRlKGtleSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9LFxyXG4gIDEwICogNjAgKiAxMDAwXHJcbik7IC8vIEV2ZXJ5IDEwIG1pbnV0ZXNcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGFuYWx5dGljc1NlcnZpY2U7XHJcbiJdLCJuYW1lcyI6WyJwcmlzbWEiLCJjYWNoZSIsIkFuYWx5dGljc1NlcnZpY2UiLCJjb25zdHJ1Y3RvciIsIm1ldHJpY3MiLCJjb21wdXRhdGlvbnNQZXJmb3JtZWQiLCJjYWNoZUhpdHMiLCJjYWNoZU1pc3NlcyIsImF2ZXJhZ2VDb21wdXRhdGlvblRpbWUiLCJlcnJvcnMiLCJhbmFseXRpY3NDYWNoZSIsIk1hcCIsImNhY2hlVFRMIiwiQkFTSUMiLCJERVRBSUxFRCIsIkhJU1RPUklDQUwiLCJQUkVESUNUSU9OUyIsInJpc2tXZWlnaHRzIiwiR01QX1ZPTEFUSUxJVFkiLCJTVUJTQ1JJUFRJT05fUkFUSU8iLCJJU1NVRV9TSVpFIiwiTUFSS0VUX0NPTkRJVElPTlMiLCJTRUNUT1JfUEVSRk9STUFOQ0UiLCJwcmVkaWN0aW9uTW9kZWxzIiwiTElTVElOR19HQUlOIiwiZmFjdG9ycyIsIndlaWdodHMiLCJBTExPVE1FTlRfUFJPQkFCSUxJVFkiLCJjb21wdXRlSVBPQW5hbHl0aWNzIiwiaXBvSWQiLCJvcHRpb25zIiwic3RhcnRUaW1lIiwiRGF0ZSIsIm5vdyIsImluY2x1ZGVIaXN0b3JpY2FsIiwiaW5jbHVkZVByZWRpY3Rpb25zIiwidGltZVJhbmdlIiwicmVmcmVzaENhY2hlIiwiY2FjaGVLZXkiLCJjYWNoZWQiLCJnZXRDYWNoZWRBbmFseXRpY3MiLCJpcG9EYXRhIiwiZ21wRGF0YSIsInN1YnNjcmlwdGlvbkRhdGEiLCJkZW1hbmREYXRhIiwiY2F0ZWdvcnlEYXRhIiwiUHJvbWlzZSIsImFsbCIsImdldElQT0Jhc2ljRGF0YSIsImdldEdNUERhdGEiLCJnZXRTdWJzY3JpcHRpb25EYXRhIiwiZ2V0RGVtYW5kRGF0YSIsImdldElQT0NhdGVnb3JpZXMiLCJFcnJvciIsImFuYWx5dGljcyIsInN5bWJvbCIsIm5hbWUiLCJzdGF0dXMiLCJjb21wdXRlZEF0IiwidG9JU09TdHJpbmciLCJiYXNpY01ldHJpY3MiLCJjb21wdXRlQmFzaWNNZXRyaWNzIiwiZ21wQW5hbHl0aWNzIiwiY29tcHV0ZUdNUEFuYWx5dGljcyIsInN1YnNjcmlwdGlvbkFuYWx5dGljcyIsImNvbXB1dGVTdWJzY3JpcHRpb25BbmFseXRpY3MiLCJkZW1hbmRBbmFseXRpY3MiLCJjb21wdXRlRGVtYW5kQW5hbHl0aWNzIiwicmlza0Fzc2Vzc21lbnQiLCJjb21wdXRlUmlza0Fzc2Vzc21lbnQiLCJwZXJmb3JtYW5jZUluZGljYXRvcnMiLCJjb21wdXRlUGVyZm9ybWFuY2VJbmRpY2F0b3JzIiwiaGlzdG9yaWNhbEFuYWx5c2lzIiwiY29tcHV0ZUhpc3RvcmljYWxBbmFseXNpcyIsInByZWRpY3Rpb25zIiwiY29tcHV0ZVByZWRpY3Rpb25zIiwiY29tcGFyYXRpdmVBbmFseXNpcyIsImNvbXB1dGVDb21wYXJhdGl2ZUFuYWx5c2lzIiwiaW5zaWdodHMiLCJnZW5lcmF0ZUluc2lnaHRzIiwicmVjb21tZW5kYXRpb25zIiwiZ2VuZXJhdGVSZWNvbW1lbmRhdGlvbnMiLCJzZXRDYWNoZWRBbmFseXRpY3MiLCJjb21wdXRhdGlvblRpbWUiLCJ1cGRhdGVNZXRyaWNzIiwiZXJyb3IiLCJjb25zb2xlIiwicHJpY2VSYW5nZSIsIm1heFByaWNlIiwibWluUHJpY2UiLCJpc3N1ZVNpemUiLCJOdW1iZXIiLCJsb3RWYWx1ZSIsImxvdFNpemUiLCJtaW4iLCJtYXgiLCJzcHJlYWQiLCJzcHJlYWRQZXJjZW50YWdlIiwicGFyc2VGbG9hdCIsInRvRml4ZWQiLCJpc3N1ZSIsInNpemUiLCJzaXplQ2F0ZWdvcnkiLCJjYXRlZ29yaXplSXNzdWVTaXplIiwiZmFjZVZhbHVlIiwidGltZWxpbmUiLCJvcGVuRGF0ZSIsImNsb3NlRGF0ZSIsImxpc3RpbmdEYXRlIiwiZHVyYXRpb25EYXlzIiwiY2FsY3VsYXRlRHVyYXRpb24iLCJkYXlzVG9MaXN0aW5nIiwidHlwZSIsImlzc3VlVHlwZSIsInN1YlR5cGUiLCJyZWdpc3RyYXIiLCJsZW5ndGgiLCJtZXNzYWdlIiwidmFsdWVzIiwibWFwIiwiZyIsInZhbHVlIiwicGVyY2VudGFnZXMiLCJwZXJjZW50YWdlIiwidm9sdW1lcyIsInZvbHVtZSIsInN0YXRzIiwiY3VycmVudCIsImF2ZXJhZ2UiLCJjYWxjdWxhdGVBdmVyYWdlIiwibWVkaWFuIiwiY2FsY3VsYXRlTWVkaWFuIiwibW9kZSIsImNhbGN1bGF0ZU1vZGUiLCJNYXRoIiwicmFuZ2UiLCJzdGFuZGFyZERldmlhdGlvbiIsImNhbGN1bGF0ZVN0YW5kYXJkRGV2aWF0aW9uIiwidmFyaWFuY2UiLCJjYWxjdWxhdGVWYXJpYW5jZSIsImNvZWZmaWNpZW50IiwiY2FsY3VsYXRlQ29lZmZpY2llbnRPZlZhcmlhdGlvbiIsInRyZW5kIiwiYW5hbHl6ZVRyZW5kIiwidm9sYXRpbGl0eSIsImFuYWx5emVWb2xhdGlsaXR5IiwidGltZXN0YW1wIiwidm9sdW1lQW5hbHlzaXMiLCJhbmFseXplVm9sdW1lIiwibW9tZW50dW0iLCJjYWxjdWxhdGVNb21lbnR1bSIsInJlY29yZENvdW50IiwidGltZXNwYW4iLCJjYWxjdWxhdGVUaW1lc3BhbiIsInN0YXRpc3RpY3MiLCJwcmljZVRhcmdldHMiLCJjYWxjdWxhdGVQcmljZVRhcmdldHMiLCJyaXNrTWV0cmljcyIsImNhbGN1bGF0ZUdNUFJpc2tNZXRyaWNzIiwibGF0ZXN0QnlDYXRlZ29yeSIsImdldExhdGVzdFN1YnNjcmlwdGlvbkJ5Q2F0ZWdvcnkiLCJvdmVyYWxsTWV0cmljcyIsInRvdGFsU3Vic2NyaXB0aW9uIiwiY2FsY3VsYXRlT3ZlcmFsbFN1YnNjcmlwdGlvbiIsImlzT3ZlcnN1YnNjcmliZWQiLCJvdmVyc3Vic2NyaXB0aW9uUmF0aW8iLCJ0b3RhbEFwcGxpY2F0aW9ucyIsInRvdGFsUXVhbnRpdHkiLCJCaWdJbnQiLCJjYXRlZ29yeUFuYWx5c2lzIiwiY2F0ZWdvcnkiLCJkYXRhIiwiT2JqZWN0IiwiZW50cmllcyIsInN1YnNjcmlwdGlvblJhdGlvIiwicXVhbnRpdHkiLCJ0b1N0cmluZyIsImJpZENvdW50IiwiYXZlcmFnZUJpZFNpemUiLCJwYXR0ZXJucyIsImFuYWx5emVTdWJzY3JpcHRpb25QYXR0ZXJucyIsImFsbG90bWVudFByb2JhYmlsaXR5IiwiY2FsY3VsYXRlQWxsb3RtZW50UHJvYmFiaWxpdGllcyIsIm92ZXJhbGwiLCJjYXRlZ29yaWVzIiwiZ2VuZXJhdGVTdWJzY3JpcHRpb25JbnNpZ2h0cyIsInByaWNlV2lzZURlbWFuZCIsImFuYWx5emVQcmljZVdpc2VEZW1hbmQiLCJjdXRPZmZBbmFseXNpcyIsImFuYWx5emVDdXRPZmZEZW1hbmQiLCJkaXN0cmlidXRpb24iLCJhbmFseXplRGVtYW5kRGlzdHJpYnV0aW9uIiwiY29uY2VudHJhdGlvbiIsImFuYWx5emVCaWRDb25jZW50cmF0aW9uIiwic3VtbWFyeSIsInJlZHVjZSIsInN1bSIsImQiLCJhYnNvbHV0ZVF1YW50aXR5IiwidG90YWxCaWRzIiwiYWJzb2x1dGVCaWRDb3VudCIsInByaWNlIiwiZmlsdGVyIiwicCIsInJpc2tTY29yZSIsInJpc2tGYWN0b3JzIiwiZ21wVmFsdWVzIiwiYXZnR01QIiwidm9sYXRpbGl0eVJhdGlvIiwicHVzaCIsImltcGFjdCIsImRlc2NyaXB0aW9uIiwibWl0aWdhdGlvbiIsImxhdGVzdFN1YnNjcmlwdGlvbiIsIm92ZXJhbGxTdWJzY3JpcHRpb24iLCJvdmVyYWxsUmlza1Njb3JlIiwicmlza0xldmVsIiwiY2F0ZWdvcml6ZVJpc2tMZXZlbCIsInJlY29tbWVuZGF0aW9uIiwiZ2VuZXJhdGVSaXNrUmVjb21tZW5kYXRpb24iLCJsYXN0VXBkYXRlZCIsImluZGljYXRvcnMiLCJtYXJrZXRTZW50aW1lbnQiLCJjYWxjdWxhdGVNYXJrZXRTZW50aW1lbnQiLCJkZW1hbmRTdHJlbmd0aCIsImNhbGN1bGF0ZURlbWFuZFN0cmVuZ3RoIiwicHJpY2VNb21lbnR1bSIsImxpc3RpbmdSZWFkaW5lc3MiLCJjYWxjdWxhdGVMaXN0aW5nUmVhZGluZXNzIiwiYXR0cmFjdGl2ZW5lc3NTY29yZSIsImNhbGN1bGF0ZUF0dHJhY3RpdmVuZXNzU2NvcmUiLCJjb21wYXJhYmxlSVBPcyIsImdldENvbXBhcmFibGVJUE9zIiwiaGlzdG9yaWNhbE1ldHJpY3MiLCJjYWxjdWxhdGVIaXN0b3JpY2FsTWV0cmljcyIsInRyZW5kcyIsImNhbGN1bGF0ZUhpc3RvcmljYWxUcmVuZHMiLCJiZW5jaG1hcmtzIiwiY2FsY3VsYXRlQmVuY2htYXJrcyIsImxpc3RpbmdHYWluIiwicHJlZGljdExpc3RpbmdHYWluIiwicHJlZGljdEFsbG90bWVudFByb2JhYmlsaXR5IiwicHJlZGljdFByaWNlVGFyZ2V0cyIsInJpc2tBZGp1c3RlZFJldHVybnMiLCJjYWxjdWxhdGVSaXNrQWRqdXN0ZWRSZXR1cm5zIiwiY29uZmlkZW5jZUludGVydmFscyIsImNhbGN1bGF0ZUNvbmZpZGVuY2VJbnRlcnZhbHMiLCJtb2RlbCIsInNpbWlsYXJJUE9zIiwiZmluZFNpbWlsYXJJUE9zIiwicmVsYXRpdmVQZXJmb3JtYW5jZSIsImNhbGN1bGF0ZVJlbGF0aXZlUGVyZm9ybWFuY2UiLCJtYXJrZXRQb3NpdGlvbmluZyIsImNhbGN1bGF0ZU1hcmtldFBvc2l0aW9uaW5nIiwic2ltaWxhcklQT3NDb3VudCIsImNhbGN1bGF0ZUluZHVzdHJ5QmVuY2htYXJrcyIsImdtcCIsInRpdGxlIiwibGV2ZWwiLCJzdWIiLCJyaXNrIiwic3Vic2NyaXB0aW9uIiwiY29uZmlkZW5jZSIsInJlYXNvbmluZyIsImFjdGlvbiIsInZhbCIsInNvcnRlZCIsInNvcnQiLCJhIiwiYiIsIm1pZCIsImZsb29yIiwiZnJlcXVlbmN5IiwiZm9yRWFjaCIsImtleXMiLCJhdmciLCJwb3ciLCJzcXJ0Iiwic3RkRGV2IiwiZGlyZWN0aW9uIiwic3RyZW5ndGgiLCJyZWNlbnQiLCJzbGljZSIsIm9sZGVyIiwicmVjZW50QXZnIiwib2xkZXJBdmciLCJjaGFuZ2UiLCJjaGFuZ2VQZXJjZW50IiwiYWJzIiwidGltZXN0YW1wcyIsInNjb3JlIiwibW9tZW50dW1QZXJjZW50IiwiYWJzb2x1dGUiLCJpUE8iLCJmaW5kVW5pcXVlIiwid2hlcmUiLCJpZCIsImluY2x1ZGUiLCJkYXlzIiwic3RhcnREYXRlIiwic2V0RGF0ZSIsImdldERhdGUiLCJnTVAiLCJmaW5kTWFueSIsImd0ZSIsIm9yZGVyQnkiLCJtYXJrZXREZW1hbmQiLCJpUE9DYXRlZ29yeSIsImtleSIsImhhcyIsImdldCIsImRlbGV0ZSIsInR0bCIsInNldCIsImVuZERhdGUiLCJzdGFydCIsImVuZCIsImNlaWwiLCJsYXRlc3QiLCJpdGVtIiwic3ViQ2F0ZWdvcnkiLCJyYXRpb3MiLCJnZXRQZXJmb3JtYW5jZU1ldHJpY3MiLCJoaXRSYXRlIiwiY2FjaGVIaXRSYXRlIiwicm91bmQiLCJzdWNjZXNzUmF0ZSIsInByZWRpY3Rpb24iLCJwcm9iYWJpbGl0eSIsInJldGFpbCIsImJhc2VQcmljZSIsImNvbnNlcnZhdGl2ZSIsIm1vZGVyYXRlIiwiYWdncmVzc2l2ZSIsImdhaW4iLCJyaXNrQWRqdXN0ZWRSZXR1cm4iLCJzaGFycGVSYXRpbyIsImNvbmZpZGVuY2U5MCIsImNvcnJlbGF0aW9uIiwic3VwcG9ydCIsInJlc2lzdGFuY2UiLCJwaXZvdCIsInZhbHVlQXRSaXNrIiwibWF4RHJhd2Rvd24iLCJjYWxjdWxhdGVNYXhEcmF3ZG93biIsInBlYWsiLCJpIiwiZHJhd2Rvd24iLCJyZXN1bHQiLCJyYXRpbyIsImhlcmZpbmRhaGxJbmRleCIsImZpcnN0IiwibGFzdCIsImFuYWx5dGljc1NlcnZpY2UiLCJzZXRJbnRlcnZhbCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./src/lib/analytics.js\n");

/***/ }),

/***/ "(rsc)/./src/lib/cache.js":
/*!**************************!*\
  !*** ./src/lib/cache.js ***!
  \**************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   cache: () => (/* binding */ cache),\n/* harmony export */   cacheMiddleware: () => (/* binding */ cacheMiddleware),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   invalidateCacheOnUpdate: () => (/* binding */ invalidateCacheOnUpdate)\n/* harmony export */ });\n/* harmony import */ var _upstash_redis__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @upstash/redis */ \"(rsc)/./node_modules/@upstash/redis/nodejs.mjs\");\n/* harmony import */ var _db_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./db.js */ \"(rsc)/./src/lib/db.js\");\n\n\nclass CacheService {\n    constructor(){\n        this.redis = new _upstash_redis__WEBPACK_IMPORTED_MODULE_0__.Redis({\n            url: process.env.UPSTASH_REDIS_REST_URL,\n            token: process.env.UPSTASH_REDIS_REST_TOKEN\n        });\n        // Memory cache fallback for when Redis is unavailable\n        this.memoryCache = new Map();\n        this.memoryCacheSize = 0;\n        this.maxMemoryCache = 1000; // Maximum items in memory cache\n        // Cache key prefixes for organization\n        this.prefixes = {\n            IPO: \"ipo:\",\n            GMP: \"gmp:\",\n            SUBSCRIPTION: \"sub:\",\n            DEMAND: \"demand:\",\n            ALLOTMENT: \"allot:\",\n            USER: \"user:\",\n            SESSION: \"session:\",\n            API: \"api:\",\n            ANALYTICS: \"analytics:\",\n            REALTIME: \"rt:\",\n            SEARCH: \"search:\",\n            SYSTEM: \"sys:\"\n        };\n        // Default TTL values (in seconds)\n        this.defaultTTL = {\n            IPO_LIST: 300,\n            IPO_DETAIL: 180,\n            GMP_DATA: 60,\n            SUBSCRIPTION: 30,\n            DEMAND: 30,\n            ALLOTMENT: 3600,\n            USER_SESSION: 3600,\n            API_RESPONSE: 60,\n            ANALYTICS: 1800,\n            SEARCH: 600,\n            REALTIME: 15,\n            SYSTEM: 300\n        };\n        // Performance metrics\n        this.metrics = {\n            hits: 0,\n            misses: 0,\n            errors: 0,\n            operations: 0\n        };\n    }\n    // Generate cache key with prefix\n    key(prefix, identifier) {\n        return `${this.prefixes[prefix] || \"\"}${identifier}`;\n    }\n    // Enhanced get with fallback to memory cache\n    async get(key) {\n        this.metrics.operations++;\n        try {\n            // Try Redis first\n            const data = await this.redis.get(key);\n            if (data !== null) {\n                this.metrics.hits++;\n                return typeof data === \"string\" ? JSON.parse(data) : data;\n            }\n            // Fallback to memory cache\n            const memoryData = this.memoryCache.get(key);\n            if (memoryData && memoryData.expiresAt > Date.now()) {\n                this.metrics.hits++;\n                return memoryData.value;\n            }\n            this.metrics.misses++;\n            return null;\n        } catch (error) {\n            this.metrics.errors++;\n            console.error(\"Cache get error:\", error);\n            // Try memory cache as fallback\n            const memoryData = this.memoryCache.get(key);\n            if (memoryData && memoryData.expiresAt > Date.now()) {\n                return memoryData.value;\n            }\n            return null;\n        }\n    }\n    // Enhanced set with memory cache backup\n    async set(key, value, ttl = null) {\n        this.metrics.operations++;\n        try {\n            const serialized = typeof value === \"string\" ? value : JSON.stringify(value);\n            let result;\n            if (ttl) {\n                result = await this.redis.setex(key, ttl, serialized);\n            } else {\n                result = await this.redis.set(key, serialized);\n            }\n            // Also store in memory cache as backup\n            this.setMemoryCache(key, value, ttl);\n            return result;\n        } catch (error) {\n            this.metrics.errors++;\n            console.error(\"Cache set error:\", error);\n            // Fallback to memory cache only\n            this.setMemoryCache(key, value, ttl);\n            return false;\n        }\n    }\n    // Memory cache management\n    setMemoryCache(key, value, ttl = null) {\n        const expiresAt = ttl ? Date.now() + ttl * 1000 : Date.now() + 5 * 60 * 1000; // Default 5 min\n        // Remove old entry if exists\n        if (this.memoryCache.has(key)) {\n            this.memoryCacheSize--;\n        }\n        // Check if we need to evict items\n        if (this.memoryCacheSize >= this.maxMemoryCache) {\n            this.evictOldestMemoryCache();\n        }\n        this.memoryCache.set(key, {\n            value,\n            expiresAt\n        });\n        this.memoryCacheSize++;\n    }\n    // Evict oldest items from memory cache\n    evictOldestMemoryCache() {\n        const entries = Array.from(this.memoryCache.entries());\n        entries.sort((a, b)=>a[1].expiresAt - b[1].expiresAt);\n        // Remove oldest 10% of items\n        const toRemove = Math.max(1, Math.floor(entries.length * 0.1));\n        for(let i = 0; i < toRemove; i++){\n            this.memoryCache.delete(entries[i][0]);\n            this.memoryCacheSize--;\n        }\n    }\n    // Enhanced delete with memory cache cleanup\n    async del(key) {\n        this.metrics.operations++;\n        try {\n            const result = await this.redis.del(key);\n            // Also remove from memory cache\n            if (this.memoryCache.has(key)) {\n                this.memoryCache.delete(key);\n                this.memoryCacheSize--;\n            }\n            return result;\n        } catch (error) {\n            this.metrics.errors++;\n            console.error(\"Cache delete error:\", error);\n            // Still try to remove from memory cache\n            if (this.memoryCache.has(key)) {\n                this.memoryCache.delete(key);\n                this.memoryCacheSize--;\n            }\n            return false;\n        }\n    }\n    // Check if key exists\n    async exists(key) {\n        try {\n            const redisExists = await this.redis.exists(key);\n            if (redisExists) return true;\n            // Check memory cache\n            const memoryData = this.memoryCache.get(key);\n            return memoryData && memoryData.expiresAt > Date.now();\n        } catch (error) {\n            console.error(\"Cache exists error:\", error);\n            // Check memory cache only\n            const memoryData = this.memoryCache.get(key);\n            return memoryData && memoryData.expiresAt > Date.now();\n        }\n    }\n    // IPO-specific cache operations\n    async cacheIPOList(ipos, filters = {}) {\n        const filterKey = Object.keys(filters).sort().map((k)=>`${k}:${filters[k]}`).join(\"|\");\n        const cacheKey = this.key(\"IPO\", `list:${filterKey || \"all\"}`);\n        return this.set(cacheKey, ipos, this.defaultTTL.IPO_LIST);\n    }\n    async getCachedIPOList(filters = {}) {\n        const filterKey = Object.keys(filters).sort().map((k)=>`${k}:${filters[k]}`).join(\"|\");\n        const cacheKey = this.key(\"IPO\", `list:${filterKey || \"all\"}`);\n        return this.get(cacheKey);\n    }\n    async cacheIPODetail(ipoId, data) {\n        const cacheKey = this.key(\"IPO\", `detail:${ipoId}`);\n        return this.set(cacheKey, data, this.defaultTTL.IPO_DETAIL);\n    }\n    async getCachedIPODetail(ipoId) {\n        const cacheKey = this.key(\"IPO\", `detail:${ipoId}`);\n        return this.get(cacheKey);\n    }\n    // Real-time data cache with pub/sub support\n    async cacheRealTimeData(type, identifier, data) {\n        const cacheKey = this.key(\"REALTIME\", `${type}:${identifier}`);\n        const enrichedData = {\n            ...data,\n            timestamp: Date.now(),\n            cached_at: new Date().toISOString()\n        };\n        // Cache with short TTL for real-time data\n        await this.set(cacheKey, enrichedData, this.defaultTTL.REALTIME);\n        // Also publish to Redis pub/sub for WebSocket distribution (if available)\n        try {\n            await this.redis.publish(`realtime:${type}:${identifier}`, JSON.stringify(enrichedData));\n        } catch (error) {\n            console.warn(\"Redis publish failed, continuing without pub/sub:\", error.message);\n        }\n        return enrichedData;\n    }\n    async getRealTimeData(type, identifier) {\n        const cacheKey = this.key(\"REALTIME\", `${type}:${identifier}`);\n        const data = await this.get(cacheKey);\n        // Check if data is fresh (less than TTL)\n        if (data && Date.now() - data.timestamp < this.defaultTTL.REALTIME * 1000) {\n            return data;\n        }\n        return null;\n    }\n    // GMP cache operations\n    async cacheGMPData(ipoId, gmpData) {\n        const cacheKey = this.key(\"GMP\", `data:${ipoId}`);\n        return this.set(cacheKey, gmpData, this.defaultTTL.GMP_DATA);\n    }\n    async getCachedGMPData(ipoId) {\n        const cacheKey = this.key(\"GMP\", `data:${ipoId}`);\n        return this.get(cacheKey);\n    }\n    async cacheLiveGMP(ipoId, gmpValue) {\n        const cacheKey = this.key(\"GMP\", `live:${ipoId}`);\n        const gmpData = {\n            value: gmpValue,\n            timestamp: Date.now(),\n            cached_at: new Date().toISOString()\n        };\n        // Store with short TTL for real-time updates\n        return this.set(cacheKey, gmpData, 30);\n    }\n    async getCachedLiveGMP(ipoId) {\n        const cacheKey = this.key(\"GMP\", `live:${ipoId}`);\n        return this.get(cacheKey);\n    }\n    // Subscription data cache\n    async cacheSubscriptionData(symbol, data) {\n        const cacheKey = this.key(\"SUBSCRIPTION\", `data:${symbol}`);\n        return this.set(cacheKey, data, this.defaultTTL.SUBSCRIPTION);\n    }\n    async getCachedSubscriptionData(symbol) {\n        const cacheKey = this.key(\"SUBSCRIPTION\", `data:${symbol}`);\n        return this.get(cacheKey);\n    }\n    // Market demand cache\n    async cacheDemandData(symbol, data) {\n        const cacheKey = this.key(\"DEMAND\", `data:${symbol}`);\n        return this.set(cacheKey, data, this.defaultTTL.DEMAND);\n    }\n    async getCachedDemandData(symbol) {\n        const cacheKey = this.key(\"DEMAND\", `data:${symbol}`);\n        return this.get(cacheKey);\n    }\n    // Allotment cache\n    async cacheAllotmentStatus(panNumber, applicationNumber, data) {\n        const cacheKey = this.key(\"ALLOTMENT\", `status:${panNumber}:${applicationNumber}`);\n        return this.set(cacheKey, data, this.defaultTTL.ALLOTMENT);\n    }\n    async getCachedAllotmentStatus(panNumber, applicationNumber) {\n        const cacheKey = this.key(\"ALLOTMENT\", `status:${panNumber}:${applicationNumber}`);\n        return this.get(cacheKey);\n    }\n    // User session cache\n    async cacheUserSession(userId, sessionData) {\n        const cacheKey = this.key(\"USER\", `session:${userId}`);\n        return this.set(cacheKey, sessionData, this.defaultTTL.USER_SESSION);\n    }\n    async getCachedUserSession(userId) {\n        const cacheKey = this.key(\"USER\", `session:${userId}`);\n        return this.get(cacheKey);\n    }\n    // API response cache\n    async cacheAPIResponse(endpoint, params, data) {\n        const paramKey = Object.keys(params).sort().map((k)=>`${k}:${params[k]}`).join(\"|\");\n        const cacheKey = this.key(\"API\", `${endpoint}:${paramKey}`);\n        return this.set(cacheKey, data, this.defaultTTL.API_RESPONSE);\n    }\n    async getCachedAPIResponse(endpoint, params) {\n        const paramKey = Object.keys(params).sort().map((k)=>`${k}:${params[k]}`).join(\"|\");\n        const cacheKey = this.key(\"API\", `${endpoint}:${paramKey}`);\n        return this.get(cacheKey);\n    }\n    // Search results cache\n    async cacheSearchResults(query, results) {\n        const cacheKey = this.key(\"SEARCH\", `query:${query.toLowerCase()}`);\n        return this.set(cacheKey, results, this.defaultTTL.SEARCH);\n    }\n    async getCachedSearchResults(query) {\n        const cacheKey = this.key(\"SEARCH\", `query:${query.toLowerCase()}`);\n        return this.get(cacheKey);\n    }\n    // Analytics cache\n    async cacheAnalytics(type, identifier, data) {\n        const cacheKey = this.key(\"ANALYTICS\", `${type}:${identifier}`);\n        return this.set(cacheKey, data, this.defaultTTL.ANALYTICS);\n    }\n    async getCachedAnalytics(type, identifier) {\n        const cacheKey = this.key(\"ANALYTICS\", `${type}:${identifier}`);\n        return this.get(cacheKey);\n    }\n    // Batch operations\n    async mget(keys) {\n        try {\n            return await this.redis.mget(...keys);\n        } catch (error) {\n            console.error(\"Cache mget error:\", error);\n            // Fallback to individual gets from memory cache\n            const results = [];\n            for (const key of keys){\n                const memoryData = this.memoryCache.get(key);\n                if (memoryData && memoryData.expiresAt > Date.now()) {\n                    results.push(memoryData.value);\n                } else {\n                    results.push(null);\n                }\n            }\n            return results;\n        }\n    }\n    async mset(keyValuePairs) {\n        try {\n            const pairs = [];\n            for (const [key, value] of keyValuePairs){\n                pairs.push(key, typeof value === \"string\" ? value : JSON.stringify(value));\n                // Also set in memory cache\n                this.setMemoryCache(key, value);\n            }\n            return await this.redis.mset(...pairs);\n        } catch (error) {\n            console.error(\"Cache mset error:\", error);\n            // Fallback to memory cache only\n            for (const [key, value] of keyValuePairs){\n                this.setMemoryCache(key, value);\n            }\n            return false;\n        }\n    }\n    // Cache invalidation\n    async invalidatePattern(pattern) {\n        try {\n            const keys = await this.redis.keys(pattern);\n            if (keys.length > 0) {\n                // Delete from Redis\n                const redisResult = await this.redis.del(...keys);\n                // Delete from memory cache\n                for (const key of keys){\n                    if (this.memoryCache.has(key)) {\n                        this.memoryCache.delete(key);\n                        this.memoryCacheSize--;\n                    }\n                }\n                return redisResult;\n            }\n            return 0;\n        } catch (error) {\n            console.error(\"Cache invalidation error:\", error);\n            // Try to clear memory cache patterns (simple string matching)\n            let cleared = 0;\n            for (const [key] of this.memoryCache){\n                if (key.includes(pattern.replace(\"*\", \"\"))) {\n                    this.memoryCache.delete(key);\n                    this.memoryCacheSize--;\n                    cleared++;\n                }\n            }\n            return cleared;\n        }\n    }\n    async invalidateIPOCache(ipoId) {\n        const patterns = [\n            this.key(\"IPO\", `detail:${ipoId}`),\n            this.key(\"IPO\", \"list:*\"),\n            this.key(\"GMP\", `*:${ipoId}`),\n            this.key(\"SUBSCRIPTION\", `*:${ipoId}`),\n            this.key(\"DEMAND\", `*:${ipoId}`),\n            this.key(\"REALTIME\", `*:${ipoId}`)\n        ];\n        const results = await Promise.allSettled(patterns.map((pattern)=>this.invalidatePattern(pattern)));\n        return results.every((result)=>result.status === \"fulfilled\");\n    }\n    // Performance monitoring\n    async getCacheStats() {\n        try {\n            const redisInfo = await this.redis.info();\n            const hitRate = this.metrics.operations > 0 ? (this.metrics.hits / this.metrics.operations * 100).toFixed(2) : \"0.00\";\n            return {\n                connected: true,\n                redis: {\n                    memory: redisInfo.match(/used_memory_human:(.+)/)?.[1]?.trim(),\n                    keys: redisInfo.match(/db0:keys=(\\d+)/)?.[1],\n                    hits: redisInfo.match(/keyspace_hits:(\\d+)/)?.[1],\n                    misses: redisInfo.match(/keyspace_misses:(\\d+)/)?.[1]\n                },\n                local: {\n                    hitRate: `${hitRate}%`,\n                    totalOperations: this.metrics.operations,\n                    hits: this.metrics.hits,\n                    misses: this.metrics.misses,\n                    errors: this.metrics.errors,\n                    memoryCacheSize: this.memoryCacheSize,\n                    memoryCacheLimit: this.maxMemoryCache\n                },\n                timestamp: new Date().toISOString()\n            };\n        } catch (error) {\n            const hitRate = this.metrics.operations > 0 ? (this.metrics.hits / this.metrics.operations * 100).toFixed(2) : \"0.00\";\n            return {\n                connected: false,\n                error: error.message,\n                local: {\n                    hitRate: `${hitRate}%`,\n                    totalOperations: this.metrics.operations,\n                    hits: this.metrics.hits,\n                    misses: this.metrics.misses,\n                    errors: this.metrics.errors,\n                    memoryCacheSize: this.memoryCacheSize,\n                    memoryCacheLimit: this.maxMemoryCache\n                },\n                timestamp: new Date().toISOString()\n            };\n        }\n    }\n    // Cache warming for frequently accessed data\n    async warmCache() {\n        try {\n            console.log(\"\\uD83D\\uDD25 Starting cache warm-up...\");\n            // Cache active IPOs\n            const activeIPOs = await _db_js__WEBPACK_IMPORTED_MODULE_1__.prisma.iPO.findMany({\n                where: {\n                    status: {\n                        in: [\n                            \"open\",\n                            \"upcoming\"\n                        ]\n                    },\n                    isActive: true\n                },\n                include: {\n                    gmp: {\n                        take: 10,\n                        orderBy: {\n                            timestamp: \"desc\"\n                        }\n                    },\n                    subscription: {\n                        take: 5,\n                        orderBy: {\n                            timestamp: \"desc\"\n                        }\n                    },\n                    analytics: true\n                }\n            });\n            const cachePromises = activeIPOs.map((ipo)=>this.cacheIPODetail(ipo.id, ipo));\n            await Promise.all(cachePromises);\n            // Cache IPO list with common filters\n            await this.cacheIPOList(activeIPOs.filter((ipo)=>ipo.status === \"open\"), {\n                status: \"open\"\n            });\n            await this.cacheIPOList(activeIPOs.filter((ipo)=>ipo.status === \"upcoming\"), {\n                status: \"upcoming\"\n            });\n            console.log(`🔥 Cache warmed with ${activeIPOs.length} active IPOs`);\n            return true;\n        } catch (error) {\n            console.error(\"Cache warm-up failed:\", error);\n            return false;\n        }\n    }\n    // Health check\n    async healthCheck() {\n        try {\n            const testKey = \"health_check\";\n            const testValue = Date.now().toString();\n            await this.set(testKey, testValue, 10);\n            const retrieved = await this.get(testKey);\n            await this.del(testKey);\n            const isHealthy = retrieved === testValue;\n            return {\n                status: isHealthy ? \"healthy\" : \"degraded\",\n                redis: isHealthy,\n                memoryCache: this.memoryCacheSize < this.maxMemoryCache,\n                metrics: this.metrics,\n                timestamp: new Date().toISOString()\n            };\n        } catch (error) {\n            console.error(\"Cache health check failed:\", error);\n            return {\n                status: \"unhealthy\",\n                redis: false,\n                memoryCache: this.memoryCacheSize < this.maxMemoryCache,\n                error: error.message,\n                metrics: this.metrics,\n                timestamp: new Date().toISOString()\n            };\n        }\n    }\n    // Clean expired entries from memory cache\n    cleanExpiredMemoryCache() {\n        const now = Date.now();\n        const toDelete = [];\n        for (const [key, data] of this.memoryCache){\n            if (data.expiresAt <= now) {\n                toDelete.push(key);\n            }\n        }\n        for (const key of toDelete){\n            this.memoryCache.delete(key);\n            this.memoryCacheSize--;\n        }\n        return toDelete.length;\n    }\n    // Reset metrics\n    resetMetrics() {\n        this.metrics = {\n            hits: 0,\n            misses: 0,\n            errors: 0,\n            operations: 0\n        };\n    }\n    // Get cache size info\n    getCacheSize() {\n        return {\n            memoryCache: this.memoryCacheSize,\n            maxMemoryCache: this.maxMemoryCache,\n            utilizationPercent: (this.memoryCacheSize / this.maxMemoryCache * 100).toFixed(2)\n        };\n    }\n}\n// Export singleton instance\nconst cache = new CacheService();\n// Utility middleware for cache management\nconst cacheMiddleware = (ttl = 300)=>{\n    return async (req, res, next)=>{\n        const cacheKey = cache.key(\"API\", `${req.path}:${JSON.stringify(req.query)}`);\n        try {\n            const cached = await cache.get(cacheKey);\n            if (cached) {\n                return res.json({\n                    ...cached,\n                    cached: true,\n                    cacheTimestamp: new Date().toISOString()\n                });\n            }\n            // Store original res.json\n            const originalJson = res.json;\n            // Override res.json to cache the response\n            res.json = function(data) {\n                cache.set(cacheKey, data, ttl);\n                return originalJson.call(this, data);\n            };\n            next();\n        } catch (error) {\n            console.error(\"Cache middleware error:\", error);\n            next();\n        }\n    };\n};\n// Middleware to invalidate cache on updates\nconst invalidateCacheOnUpdate = (patterns)=>{\n    return async (req, res, next)=>{\n        // Store original response methods\n        const originalJson = res.json;\n        const originalSend = res.send;\n        const cleanup = async (data)=>{\n            if (res.statusCode >= 200 && res.statusCode < 300) {\n                // Success response, invalidate cache\n                await Promise.all(patterns.map((pattern)=>cache.invalidatePattern(pattern)));\n            }\n            return data;\n        };\n        res.json = function(data) {\n            cleanup(data);\n            return originalJson.call(this, data);\n        };\n        res.send = function(data) {\n            cleanup(data);\n            return originalSend.call(this, data);\n        };\n        next();\n    };\n};\n// Auto-cleanup expired memory cache entries every 5 minutes\nsetInterval(()=>{\n    const cleaned = cache.cleanExpiredMemoryCache();\n    if (cleaned > 0) {\n        console.log(`🧹 Cleaned up ${cleaned} expired memory cache entries`);\n    }\n}, 5 * 60 * 1000);\n// Periodic cache warming (every hour)\nsetInterval(async ()=>{\n    try {\n        await cache.warmCache();\n    } catch (error) {\n        console.error(\"Scheduled cache warming failed:\", error);\n    }\n}, 60 * 60 * 1000);\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (cache);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q2pELHFDQUFxQztnQkFDckMsTUFBTTdELFFBQVFpQyxHQUFHLENBQ2ZsQyxTQUFTN0QsR0FBRyxDQUFDLENBQUN1RCxVQUFZcUQsTUFBTXRELGlCQUFpQixDQUFDQztZQUV0RDtZQUNBLE9BQU9oRztRQUNUO1FBRUF3SixJQUFJSSxJQUFJLEdBQUcsU0FBVTVKLElBQUk7WUFDdkJtSyxRQUFRbks7WUFDUixPQUFPOEosYUFBYUMsSUFBSSxDQUFDLElBQUksRUFBRS9KO1FBQ2pDO1FBRUF3SixJQUFJVSxJQUFJLEdBQUcsU0FBVWxLLElBQUk7WUFDdkJtSyxRQUFRbks7WUFDUixPQUFPaUssYUFBYUYsSUFBSSxDQUFDLElBQUksRUFBRS9KO1FBQ2pDO1FBRUF5SjtJQUNGO0FBQ0YsRUFBRTtBQUVGLDREQUE0RDtBQUM1RFksWUFDRTtJQUNFLE1BQU1DLFVBQVVqQixNQUFNTCx1QkFBdUI7SUFDN0MsSUFBSXNCLFVBQVUsR0FBRztRQUNmN0osUUFBUStHLEdBQUcsQ0FBQyxDQUFDLGNBQWMsRUFBRThDLFFBQVEsNkJBQTZCLENBQUM7SUFDckU7QUFDRixHQUNBLElBQUksS0FBSztBQUdYLHNDQUFzQztBQUN0Q0QsWUFDRTtJQUNFLElBQUk7UUFDRixNQUFNaEIsTUFBTTlCLFNBQVM7SUFDdkIsRUFBRSxPQUFPL0csT0FBTztRQUNkQyxRQUFRRCxLQUFLLENBQUMsbUNBQW1DQTtJQUNuRDtBQUNGLEdBQ0EsS0FBSyxLQUFLO0FBR1osaUVBQWU2SSxLQUFLQSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaXBvLXRyYWNrZXIvLi9zcmMvbGliL2NhY2hlLmpzP2JlNTYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUmVkaXMgfSBmcm9tIFwiQHVwc3Rhc2gvcmVkaXNcIjtcclxuaW1wb3J0IHsgcHJpc21hIH0gZnJvbSBcIi4vZGIuanNcIjtcclxuXHJcbmNsYXNzIENhY2hlU2VydmljZSB7XHJcbiAgY29uc3RydWN0b3IoKSB7XHJcbiAgICB0aGlzLnJlZGlzID0gbmV3IFJlZGlzKHtcclxuICAgICAgdXJsOiBwcm9jZXNzLmVudi5VUFNUQVNIX1JFRElTX1JFU1RfVVJMLFxyXG4gICAgICB0b2tlbjogcHJvY2Vzcy5lbnYuVVBTVEFTSF9SRURJU19SRVNUX1RPS0VOLFxyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gTWVtb3J5IGNhY2hlIGZhbGxiYWNrIGZvciB3aGVuIFJlZGlzIGlzIHVuYXZhaWxhYmxlXHJcbiAgICB0aGlzLm1lbW9yeUNhY2hlID0gbmV3IE1hcCgpO1xyXG4gICAgdGhpcy5tZW1vcnlDYWNoZVNpemUgPSAwO1xyXG4gICAgdGhpcy5tYXhNZW1vcnlDYWNoZSA9IDEwMDA7IC8vIE1heGltdW0gaXRlbXMgaW4gbWVtb3J5IGNhY2hlXHJcblxyXG4gICAgLy8gQ2FjaGUga2V5IHByZWZpeGVzIGZvciBvcmdhbml6YXRpb25cclxuICAgIHRoaXMucHJlZml4ZXMgPSB7XHJcbiAgICAgIElQTzogXCJpcG86XCIsXHJcbiAgICAgIEdNUDogXCJnbXA6XCIsXHJcbiAgICAgIFNVQlNDUklQVElPTjogXCJzdWI6XCIsXHJcbiAgICAgIERFTUFORDogXCJkZW1hbmQ6XCIsXHJcbiAgICAgIEFMTE9UTUVOVDogXCJhbGxvdDpcIixcclxuICAgICAgVVNFUjogXCJ1c2VyOlwiLFxyXG4gICAgICBTRVNTSU9OOiBcInNlc3Npb246XCIsXHJcbiAgICAgIEFQSTogXCJhcGk6XCIsXHJcbiAgICAgIEFOQUxZVElDUzogXCJhbmFseXRpY3M6XCIsXHJcbiAgICAgIFJFQUxUSU1FOiBcInJ0OlwiLFxyXG4gICAgICBTRUFSQ0g6IFwic2VhcmNoOlwiLFxyXG4gICAgICBTWVNURU06IFwic3lzOlwiLFxyXG4gICAgfTtcclxuXHJcbiAgICAvLyBEZWZhdWx0IFRUTCB2YWx1ZXMgKGluIHNlY29uZHMpXHJcbiAgICB0aGlzLmRlZmF1bHRUVEwgPSB7XHJcbiAgICAgIElQT19MSVNUOiAzMDAsIC8vIDUgbWludXRlc1xyXG4gICAgICBJUE9fREVUQUlMOiAxODAsIC8vIDMgbWludXRlc1xyXG4gICAgICBHTVBfREFUQTogNjAsIC8vIDEgbWludXRlXHJcbiAgICAgIFNVQlNDUklQVElPTjogMzAsIC8vIDMwIHNlY29uZHNcclxuICAgICAgREVNQU5EOiAzMCwgLy8gMzAgc2Vjb25kc1xyXG4gICAgICBBTExPVE1FTlQ6IDM2MDAsIC8vIDEgaG91clxyXG4gICAgICBVU0VSX1NFU1NJT046IDM2MDAsIC8vIDEgaG91clxyXG4gICAgICBBUElfUkVTUE9OU0U6IDYwLCAvLyAxIG1pbnV0ZVxyXG4gICAgICBBTkFMWVRJQ1M6IDE4MDAsIC8vIDMwIG1pbnV0ZXNcclxuICAgICAgU0VBUkNIOiA2MDAsIC8vIDEwIG1pbnV0ZXNcclxuICAgICAgUkVBTFRJTUU6IDE1LCAvLyAxNSBzZWNvbmRzXHJcbiAgICAgIFNZU1RFTTogMzAwLCAvLyA1IG1pbnV0ZXNcclxuICAgIH07XHJcblxyXG4gICAgLy8gUGVyZm9ybWFuY2UgbWV0cmljc1xyXG4gICAgdGhpcy5tZXRyaWNzID0ge1xyXG4gICAgICBoaXRzOiAwLFxyXG4gICAgICBtaXNzZXM6IDAsXHJcbiAgICAgIGVycm9yczogMCxcclxuICAgICAgb3BlcmF0aW9uczogMCxcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICAvLyBHZW5lcmF0ZSBjYWNoZSBrZXkgd2l0aCBwcmVmaXhcclxuICBrZXkocHJlZml4LCBpZGVudGlmaWVyKSB7XHJcbiAgICByZXR1cm4gYCR7dGhpcy5wcmVmaXhlc1twcmVmaXhdIHx8IFwiXCJ9JHtpZGVudGlmaWVyfWA7XHJcbiAgfVxyXG5cclxuICAvLyBFbmhhbmNlZCBnZXQgd2l0aCBmYWxsYmFjayB0byBtZW1vcnkgY2FjaGVcclxuICBhc3luYyBnZXQoa2V5KSB7XHJcbiAgICB0aGlzLm1ldHJpY3Mub3BlcmF0aW9ucysrO1xyXG5cclxuICAgIHRyeSB7XHJcbiAgICAgIC8vIFRyeSBSZWRpcyBmaXJzdFxyXG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy5yZWRpcy5nZXQoa2V5KTtcclxuICAgICAgaWYgKGRhdGEgIT09IG51bGwpIHtcclxuICAgICAgICB0aGlzLm1ldHJpY3MuaGl0cysrO1xyXG4gICAgICAgIHJldHVybiB0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIiA/IEpTT04ucGFyc2UoZGF0YSkgOiBkYXRhO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBGYWxsYmFjayB0byBtZW1vcnkgY2FjaGVcclxuICAgICAgY29uc3QgbWVtb3J5RGF0YSA9IHRoaXMubWVtb3J5Q2FjaGUuZ2V0KGtleSk7XHJcbiAgICAgIGlmIChtZW1vcnlEYXRhICYmIG1lbW9yeURhdGEuZXhwaXJlc0F0ID4gRGF0ZS5ub3coKSkge1xyXG4gICAgICAgIHRoaXMubWV0cmljcy5oaXRzKys7XHJcbiAgICAgICAgcmV0dXJuIG1lbW9yeURhdGEudmFsdWU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMubWV0cmljcy5taXNzZXMrKztcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICB0aGlzLm1ldHJpY3MuZXJyb3JzKys7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJDYWNoZSBnZXQgZXJyb3I6XCIsIGVycm9yKTtcclxuXHJcbiAgICAgIC8vIFRyeSBtZW1vcnkgY2FjaGUgYXMgZmFsbGJhY2tcclxuICAgICAgY29uc3QgbWVtb3J5RGF0YSA9IHRoaXMubWVtb3J5Q2FjaGUuZ2V0KGtleSk7XHJcbiAgICAgIGlmIChtZW1vcnlEYXRhICYmIG1lbW9yeURhdGEuZXhwaXJlc0F0ID4gRGF0ZS5ub3coKSkge1xyXG4gICAgICAgIHJldHVybiBtZW1vcnlEYXRhLnZhbHVlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIEVuaGFuY2VkIHNldCB3aXRoIG1lbW9yeSBjYWNoZSBiYWNrdXBcclxuICBhc3luYyBzZXQoa2V5LCB2YWx1ZSwgdHRsID0gbnVsbCkge1xyXG4gICAgdGhpcy5tZXRyaWNzLm9wZXJhdGlvbnMrKztcclxuXHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBzZXJpYWxpemVkID1cclxuICAgICAgICB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgPyB2YWx1ZSA6IEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcclxuXHJcbiAgICAgIGxldCByZXN1bHQ7XHJcbiAgICAgIGlmICh0dGwpIHtcclxuICAgICAgICByZXN1bHQgPSBhd2FpdCB0aGlzLnJlZGlzLnNldGV4KGtleSwgdHRsLCBzZXJpYWxpemVkKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICByZXN1bHQgPSBhd2FpdCB0aGlzLnJlZGlzLnNldChrZXksIHNlcmlhbGl6ZWQpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBBbHNvIHN0b3JlIGluIG1lbW9yeSBjYWNoZSBhcyBiYWNrdXBcclxuICAgICAgdGhpcy5zZXRNZW1vcnlDYWNoZShrZXksIHZhbHVlLCB0dGwpO1xyXG5cclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIHRoaXMubWV0cmljcy5lcnJvcnMrKztcclxuICAgICAgY29uc29sZS5lcnJvcihcIkNhY2hlIHNldCBlcnJvcjpcIiwgZXJyb3IpO1xyXG5cclxuICAgICAgLy8gRmFsbGJhY2sgdG8gbWVtb3J5IGNhY2hlIG9ubHlcclxuICAgICAgdGhpcy5zZXRNZW1vcnlDYWNoZShrZXksIHZhbHVlLCB0dGwpO1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBNZW1vcnkgY2FjaGUgbWFuYWdlbWVudFxyXG4gIHNldE1lbW9yeUNhY2hlKGtleSwgdmFsdWUsIHR0bCA9IG51bGwpIHtcclxuICAgIGNvbnN0IGV4cGlyZXNBdCA9IHR0bFxyXG4gICAgICA/IERhdGUubm93KCkgKyB0dGwgKiAxMDAwXHJcbiAgICAgIDogRGF0ZS5ub3coKSArIDUgKiA2MCAqIDEwMDA7IC8vIERlZmF1bHQgNSBtaW5cclxuXHJcbiAgICAvLyBSZW1vdmUgb2xkIGVudHJ5IGlmIGV4aXN0c1xyXG4gICAgaWYgKHRoaXMubWVtb3J5Q2FjaGUuaGFzKGtleSkpIHtcclxuICAgICAgdGhpcy5tZW1vcnlDYWNoZVNpemUtLTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBDaGVjayBpZiB3ZSBuZWVkIHRvIGV2aWN0IGl0ZW1zXHJcbiAgICBpZiAodGhpcy5tZW1vcnlDYWNoZVNpemUgPj0gdGhpcy5tYXhNZW1vcnlDYWNoZSkge1xyXG4gICAgICB0aGlzLmV2aWN0T2xkZXN0TWVtb3J5Q2FjaGUoKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLm1lbW9yeUNhY2hlLnNldChrZXksIHsgdmFsdWUsIGV4cGlyZXNBdCB9KTtcclxuICAgIHRoaXMubWVtb3J5Q2FjaGVTaXplKys7XHJcbiAgfVxyXG5cclxuICAvLyBFdmljdCBvbGRlc3QgaXRlbXMgZnJvbSBtZW1vcnkgY2FjaGVcclxuICBldmljdE9sZGVzdE1lbW9yeUNhY2hlKCkge1xyXG4gICAgY29uc3QgZW50cmllcyA9IEFycmF5LmZyb20odGhpcy5tZW1vcnlDYWNoZS5lbnRyaWVzKCkpO1xyXG4gICAgZW50cmllcy5zb3J0KChhLCBiKSA9PiBhWzFdLmV4cGlyZXNBdCAtIGJbMV0uZXhwaXJlc0F0KTtcclxuXHJcbiAgICAvLyBSZW1vdmUgb2xkZXN0IDEwJSBvZiBpdGVtc1xyXG4gICAgY29uc3QgdG9SZW1vdmUgPSBNYXRoLm1heCgxLCBNYXRoLmZsb29yKGVudHJpZXMubGVuZ3RoICogMC4xKSk7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRvUmVtb3ZlOyBpKyspIHtcclxuICAgICAgdGhpcy5tZW1vcnlDYWNoZS5kZWxldGUoZW50cmllc1tpXVswXSk7XHJcbiAgICAgIHRoaXMubWVtb3J5Q2FjaGVTaXplLS07XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBFbmhhbmNlZCBkZWxldGUgd2l0aCBtZW1vcnkgY2FjaGUgY2xlYW51cFxyXG4gIGFzeW5jIGRlbChrZXkpIHtcclxuICAgIHRoaXMubWV0cmljcy5vcGVyYXRpb25zKys7XHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5yZWRpcy5kZWwoa2V5KTtcclxuXHJcbiAgICAgIC8vIEFsc28gcmVtb3ZlIGZyb20gbWVtb3J5IGNhY2hlXHJcbiAgICAgIGlmICh0aGlzLm1lbW9yeUNhY2hlLmhhcyhrZXkpKSB7XHJcbiAgICAgICAgdGhpcy5tZW1vcnlDYWNoZS5kZWxldGUoa2V5KTtcclxuICAgICAgICB0aGlzLm1lbW9yeUNhY2hlU2l6ZS0tO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgdGhpcy5tZXRyaWNzLmVycm9ycysrO1xyXG4gICAgICBjb25zb2xlLmVycm9yKFwiQ2FjaGUgZGVsZXRlIGVycm9yOlwiLCBlcnJvcik7XHJcblxyXG4gICAgICAvLyBTdGlsbCB0cnkgdG8gcmVtb3ZlIGZyb20gbWVtb3J5IGNhY2hlXHJcbiAgICAgIGlmICh0aGlzLm1lbW9yeUNhY2hlLmhhcyhrZXkpKSB7XHJcbiAgICAgICAgdGhpcy5tZW1vcnlDYWNoZS5kZWxldGUoa2V5KTtcclxuICAgICAgICB0aGlzLm1lbW9yeUNhY2hlU2l6ZS0tO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBDaGVjayBpZiBrZXkgZXhpc3RzXHJcbiAgYXN5bmMgZXhpc3RzKGtleSkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgcmVkaXNFeGlzdHMgPSBhd2FpdCB0aGlzLnJlZGlzLmV4aXN0cyhrZXkpO1xyXG4gICAgICBpZiAocmVkaXNFeGlzdHMpIHJldHVybiB0cnVlO1xyXG5cclxuICAgICAgLy8gQ2hlY2sgbWVtb3J5IGNhY2hlXHJcbiAgICAgIGNvbnN0IG1lbW9yeURhdGEgPSB0aGlzLm1lbW9yeUNhY2hlLmdldChrZXkpO1xyXG4gICAgICByZXR1cm4gbWVtb3J5RGF0YSAmJiBtZW1vcnlEYXRhLmV4cGlyZXNBdCA+IERhdGUubm93KCk7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKFwiQ2FjaGUgZXhpc3RzIGVycm9yOlwiLCBlcnJvcik7XHJcblxyXG4gICAgICAvLyBDaGVjayBtZW1vcnkgY2FjaGUgb25seVxyXG4gICAgICBjb25zdCBtZW1vcnlEYXRhID0gdGhpcy5tZW1vcnlDYWNoZS5nZXQoa2V5KTtcclxuICAgICAgcmV0dXJuIG1lbW9yeURhdGEgJiYgbWVtb3J5RGF0YS5leHBpcmVzQXQgPiBEYXRlLm5vdygpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gSVBPLXNwZWNpZmljIGNhY2hlIG9wZXJhdGlvbnNcclxuICBhc3luYyBjYWNoZUlQT0xpc3QoaXBvcywgZmlsdGVycyA9IHt9KSB7XHJcbiAgICBjb25zdCBmaWx0ZXJLZXkgPSBPYmplY3Qua2V5cyhmaWx0ZXJzKVxyXG4gICAgICAuc29ydCgpXHJcbiAgICAgIC5tYXAoKGspID0+IGAke2t9OiR7ZmlsdGVyc1trXX1gKVxyXG4gICAgICAuam9pbihcInxcIik7XHJcbiAgICBjb25zdCBjYWNoZUtleSA9IHRoaXMua2V5KFwiSVBPXCIsIGBsaXN0OiR7ZmlsdGVyS2V5IHx8IFwiYWxsXCJ9YCk7XHJcbiAgICByZXR1cm4gdGhpcy5zZXQoY2FjaGVLZXksIGlwb3MsIHRoaXMuZGVmYXVsdFRUTC5JUE9fTElTVCk7XHJcbiAgfVxyXG5cclxuICBhc3luYyBnZXRDYWNoZWRJUE9MaXN0KGZpbHRlcnMgPSB7fSkge1xyXG4gICAgY29uc3QgZmlsdGVyS2V5ID0gT2JqZWN0LmtleXMoZmlsdGVycylcclxuICAgICAgLnNvcnQoKVxyXG4gICAgICAubWFwKChrKSA9PiBgJHtrfToke2ZpbHRlcnNba119YClcclxuICAgICAgLmpvaW4oXCJ8XCIpO1xyXG4gICAgY29uc3QgY2FjaGVLZXkgPSB0aGlzLmtleShcIklQT1wiLCBgbGlzdDoke2ZpbHRlcktleSB8fCBcImFsbFwifWApO1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0KGNhY2hlS2V5KTtcclxuICB9XHJcblxyXG4gIGFzeW5jIGNhY2hlSVBPRGV0YWlsKGlwb0lkLCBkYXRhKSB7XHJcbiAgICBjb25zdCBjYWNoZUtleSA9IHRoaXMua2V5KFwiSVBPXCIsIGBkZXRhaWw6JHtpcG9JZH1gKTtcclxuICAgIHJldHVybiB0aGlzLnNldChjYWNoZUtleSwgZGF0YSwgdGhpcy5kZWZhdWx0VFRMLklQT19ERVRBSUwpO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgZ2V0Q2FjaGVkSVBPRGV0YWlsKGlwb0lkKSB7XHJcbiAgICBjb25zdCBjYWNoZUtleSA9IHRoaXMua2V5KFwiSVBPXCIsIGBkZXRhaWw6JHtpcG9JZH1gKTtcclxuICAgIHJldHVybiB0aGlzLmdldChjYWNoZUtleSk7XHJcbiAgfVxyXG5cclxuICAvLyBSZWFsLXRpbWUgZGF0YSBjYWNoZSB3aXRoIHB1Yi9zdWIgc3VwcG9ydFxyXG4gIGFzeW5jIGNhY2hlUmVhbFRpbWVEYXRhKHR5cGUsIGlkZW50aWZpZXIsIGRhdGEpIHtcclxuICAgIGNvbnN0IGNhY2hlS2V5ID0gdGhpcy5rZXkoXCJSRUFMVElNRVwiLCBgJHt0eXBlfToke2lkZW50aWZpZXJ9YCk7XHJcbiAgICBjb25zdCBlbnJpY2hlZERhdGEgPSB7XHJcbiAgICAgIC4uLmRhdGEsXHJcbiAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcclxuICAgICAgY2FjaGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXHJcbiAgICB9O1xyXG5cclxuICAgIC8vIENhY2hlIHdpdGggc2hvcnQgVFRMIGZvciByZWFsLXRpbWUgZGF0YVxyXG4gICAgYXdhaXQgdGhpcy5zZXQoY2FjaGVLZXksIGVucmljaGVkRGF0YSwgdGhpcy5kZWZhdWx0VFRMLlJFQUxUSU1FKTtcclxuXHJcbiAgICAvLyBBbHNvIHB1Ymxpc2ggdG8gUmVkaXMgcHViL3N1YiBmb3IgV2ViU29ja2V0IGRpc3RyaWJ1dGlvbiAoaWYgYXZhaWxhYmxlKVxyXG4gICAgdHJ5IHtcclxuICAgICAgYXdhaXQgdGhpcy5yZWRpcy5wdWJsaXNoKFxyXG4gICAgICAgIGByZWFsdGltZToke3R5cGV9OiR7aWRlbnRpZmllcn1gLFxyXG4gICAgICAgIEpTT04uc3RyaW5naWZ5KGVucmljaGVkRGF0YSlcclxuICAgICAgKTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUud2FybihcclxuICAgICAgICBcIlJlZGlzIHB1Ymxpc2ggZmFpbGVkLCBjb250aW51aW5nIHdpdGhvdXQgcHViL3N1YjpcIixcclxuICAgICAgICBlcnJvci5tZXNzYWdlXHJcbiAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGVucmljaGVkRGF0YTtcclxuICB9XHJcblxyXG4gIGFzeW5jIGdldFJlYWxUaW1lRGF0YSh0eXBlLCBpZGVudGlmaWVyKSB7XHJcbiAgICBjb25zdCBjYWNoZUtleSA9IHRoaXMua2V5KFwiUkVBTFRJTUVcIiwgYCR7dHlwZX06JHtpZGVudGlmaWVyfWApO1xyXG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IHRoaXMuZ2V0KGNhY2hlS2V5KTtcclxuXHJcbiAgICAvLyBDaGVjayBpZiBkYXRhIGlzIGZyZXNoIChsZXNzIHRoYW4gVFRMKVxyXG4gICAgaWYgKGRhdGEgJiYgRGF0ZS5ub3coKSAtIGRhdGEudGltZXN0YW1wIDwgdGhpcy5kZWZhdWx0VFRMLlJFQUxUSU1FICogMTAwMCkge1xyXG4gICAgICByZXR1cm4gZGF0YTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcblxyXG4gIC8vIEdNUCBjYWNoZSBvcGVyYXRpb25zXHJcbiAgYXN5bmMgY2FjaGVHTVBEYXRhKGlwb0lkLCBnbXBEYXRhKSB7XHJcbiAgICBjb25zdCBjYWNoZUtleSA9IHRoaXMua2V5KFwiR01QXCIsIGBkYXRhOiR7aXBvSWR9YCk7XHJcbiAgICByZXR1cm4gdGhpcy5zZXQoY2FjaGVLZXksIGdtcERhdGEsIHRoaXMuZGVmYXVsdFRUTC5HTVBfREFUQSk7XHJcbiAgfVxyXG5cclxuICBhc3luYyBnZXRDYWNoZWRHTVBEYXRhKGlwb0lkKSB7XHJcbiAgICBjb25zdCBjYWNoZUtleSA9IHRoaXMua2V5KFwiR01QXCIsIGBkYXRhOiR7aXBvSWR9YCk7XHJcbiAgICByZXR1cm4gdGhpcy5nZXQoY2FjaGVLZXkpO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgY2FjaGVMaXZlR01QKGlwb0lkLCBnbXBWYWx1ZSkge1xyXG4gICAgY29uc3QgY2FjaGVLZXkgPSB0aGlzLmtleShcIkdNUFwiLCBgbGl2ZToke2lwb0lkfWApO1xyXG4gICAgY29uc3QgZ21wRGF0YSA9IHtcclxuICAgICAgdmFsdWU6IGdtcFZhbHVlLFxyXG4gICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXHJcbiAgICAgIGNhY2hlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxyXG4gICAgfTtcclxuXHJcbiAgICAvLyBTdG9yZSB3aXRoIHNob3J0IFRUTCBmb3IgcmVhbC10aW1lIHVwZGF0ZXNcclxuICAgIHJldHVybiB0aGlzLnNldChjYWNoZUtleSwgZ21wRGF0YSwgMzApO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgZ2V0Q2FjaGVkTGl2ZUdNUChpcG9JZCkge1xyXG4gICAgY29uc3QgY2FjaGVLZXkgPSB0aGlzLmtleShcIkdNUFwiLCBgbGl2ZToke2lwb0lkfWApO1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0KGNhY2hlS2V5KTtcclxuICB9XHJcblxyXG4gIC8vIFN1YnNjcmlwdGlvbiBkYXRhIGNhY2hlXHJcbiAgYXN5bmMgY2FjaGVTdWJzY3JpcHRpb25EYXRhKHN5bWJvbCwgZGF0YSkge1xyXG4gICAgY29uc3QgY2FjaGVLZXkgPSB0aGlzLmtleShcIlNVQlNDUklQVElPTlwiLCBgZGF0YToke3N5bWJvbH1gKTtcclxuICAgIHJldHVybiB0aGlzLnNldChjYWNoZUtleSwgZGF0YSwgdGhpcy5kZWZhdWx0VFRMLlNVQlNDUklQVElPTik7XHJcbiAgfVxyXG5cclxuICBhc3luYyBnZXRDYWNoZWRTdWJzY3JpcHRpb25EYXRhKHN5bWJvbCkge1xyXG4gICAgY29uc3QgY2FjaGVLZXkgPSB0aGlzLmtleShcIlNVQlNDUklQVElPTlwiLCBgZGF0YToke3N5bWJvbH1gKTtcclxuICAgIHJldHVybiB0aGlzLmdldChjYWNoZUtleSk7XHJcbiAgfVxyXG5cclxuICAvLyBNYXJrZXQgZGVtYW5kIGNhY2hlXHJcbiAgYXN5bmMgY2FjaGVEZW1hbmREYXRhKHN5bWJvbCwgZGF0YSkge1xyXG4gICAgY29uc3QgY2FjaGVLZXkgPSB0aGlzLmtleShcIkRFTUFORFwiLCBgZGF0YToke3N5bWJvbH1gKTtcclxuICAgIHJldHVybiB0aGlzLnNldChjYWNoZUtleSwgZGF0YSwgdGhpcy5kZWZhdWx0VFRMLkRFTUFORCk7XHJcbiAgfVxyXG5cclxuICBhc3luYyBnZXRDYWNoZWREZW1hbmREYXRhKHN5bWJvbCkge1xyXG4gICAgY29uc3QgY2FjaGVLZXkgPSB0aGlzLmtleShcIkRFTUFORFwiLCBgZGF0YToke3N5bWJvbH1gKTtcclxuICAgIHJldHVybiB0aGlzLmdldChjYWNoZUtleSk7XHJcbiAgfVxyXG5cclxuICAvLyBBbGxvdG1lbnQgY2FjaGVcclxuICBhc3luYyBjYWNoZUFsbG90bWVudFN0YXR1cyhwYW5OdW1iZXIsIGFwcGxpY2F0aW9uTnVtYmVyLCBkYXRhKSB7XHJcbiAgICBjb25zdCBjYWNoZUtleSA9IHRoaXMua2V5KFxyXG4gICAgICBcIkFMTE9UTUVOVFwiLFxyXG4gICAgICBgc3RhdHVzOiR7cGFuTnVtYmVyfToke2FwcGxpY2F0aW9uTnVtYmVyfWBcclxuICAgICk7XHJcbiAgICByZXR1cm4gdGhpcy5zZXQoY2FjaGVLZXksIGRhdGEsIHRoaXMuZGVmYXVsdFRUTC5BTExPVE1FTlQpO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgZ2V0Q2FjaGVkQWxsb3RtZW50U3RhdHVzKHBhbk51bWJlciwgYXBwbGljYXRpb25OdW1iZXIpIHtcclxuICAgIGNvbnN0IGNhY2hlS2V5ID0gdGhpcy5rZXkoXHJcbiAgICAgIFwiQUxMT1RNRU5UXCIsXHJcbiAgICAgIGBzdGF0dXM6JHtwYW5OdW1iZXJ9OiR7YXBwbGljYXRpb25OdW1iZXJ9YFxyXG4gICAgKTtcclxuICAgIHJldHVybiB0aGlzLmdldChjYWNoZUtleSk7XHJcbiAgfVxyXG5cclxuICAvLyBVc2VyIHNlc3Npb24gY2FjaGVcclxuICBhc3luYyBjYWNoZVVzZXJTZXNzaW9uKHVzZXJJZCwgc2Vzc2lvbkRhdGEpIHtcclxuICAgIGNvbnN0IGNhY2hlS2V5ID0gdGhpcy5rZXkoXCJVU0VSXCIsIGBzZXNzaW9uOiR7dXNlcklkfWApO1xyXG4gICAgcmV0dXJuIHRoaXMuc2V0KGNhY2hlS2V5LCBzZXNzaW9uRGF0YSwgdGhpcy5kZWZhdWx0VFRMLlVTRVJfU0VTU0lPTik7XHJcbiAgfVxyXG5cclxuICBhc3luYyBnZXRDYWNoZWRVc2VyU2Vzc2lvbih1c2VySWQpIHtcclxuICAgIGNvbnN0IGNhY2hlS2V5ID0gdGhpcy5rZXkoXCJVU0VSXCIsIGBzZXNzaW9uOiR7dXNlcklkfWApO1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0KGNhY2hlS2V5KTtcclxuICB9XHJcblxyXG4gIC8vIEFQSSByZXNwb25zZSBjYWNoZVxyXG4gIGFzeW5jIGNhY2hlQVBJUmVzcG9uc2UoZW5kcG9pbnQsIHBhcmFtcywgZGF0YSkge1xyXG4gICAgY29uc3QgcGFyYW1LZXkgPSBPYmplY3Qua2V5cyhwYXJhbXMpXHJcbiAgICAgIC5zb3J0KClcclxuICAgICAgLm1hcCgoaykgPT4gYCR7a306JHtwYXJhbXNba119YClcclxuICAgICAgLmpvaW4oXCJ8XCIpO1xyXG4gICAgY29uc3QgY2FjaGVLZXkgPSB0aGlzLmtleShcIkFQSVwiLCBgJHtlbmRwb2ludH06JHtwYXJhbUtleX1gKTtcclxuICAgIHJldHVybiB0aGlzLnNldChjYWNoZUtleSwgZGF0YSwgdGhpcy5kZWZhdWx0VFRMLkFQSV9SRVNQT05TRSk7XHJcbiAgfVxyXG5cclxuICBhc3luYyBnZXRDYWNoZWRBUElSZXNwb25zZShlbmRwb2ludCwgcGFyYW1zKSB7XHJcbiAgICBjb25zdCBwYXJhbUtleSA9IE9iamVjdC5rZXlzKHBhcmFtcylcclxuICAgICAgLnNvcnQoKVxyXG4gICAgICAubWFwKChrKSA9PiBgJHtrfToke3BhcmFtc1trXX1gKVxyXG4gICAgICAuam9pbihcInxcIik7XHJcbiAgICBjb25zdCBjYWNoZUtleSA9IHRoaXMua2V5KFwiQVBJXCIsIGAke2VuZHBvaW50fToke3BhcmFtS2V5fWApO1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0KGNhY2hlS2V5KTtcclxuICB9XHJcblxyXG4gIC8vIFNlYXJjaCByZXN1bHRzIGNhY2hlXHJcbiAgYXN5bmMgY2FjaGVTZWFyY2hSZXN1bHRzKHF1ZXJ5LCByZXN1bHRzKSB7XHJcbiAgICBjb25zdCBjYWNoZUtleSA9IHRoaXMua2V5KFwiU0VBUkNIXCIsIGBxdWVyeToke3F1ZXJ5LnRvTG93ZXJDYXNlKCl9YCk7XHJcbiAgICByZXR1cm4gdGhpcy5zZXQoY2FjaGVLZXksIHJlc3VsdHMsIHRoaXMuZGVmYXVsdFRUTC5TRUFSQ0gpO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgZ2V0Q2FjaGVkU2VhcmNoUmVzdWx0cyhxdWVyeSkge1xyXG4gICAgY29uc3QgY2FjaGVLZXkgPSB0aGlzLmtleShcIlNFQVJDSFwiLCBgcXVlcnk6JHtxdWVyeS50b0xvd2VyQ2FzZSgpfWApO1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0KGNhY2hlS2V5KTtcclxuICB9XHJcblxyXG4gIC8vIEFuYWx5dGljcyBjYWNoZVxyXG4gIGFzeW5jIGNhY2hlQW5hbHl0aWNzKHR5cGUsIGlkZW50aWZpZXIsIGRhdGEpIHtcclxuICAgIGNvbnN0IGNhY2hlS2V5ID0gdGhpcy5rZXkoXCJBTkFMWVRJQ1NcIiwgYCR7dHlwZX06JHtpZGVudGlmaWVyfWApO1xyXG4gICAgcmV0dXJuIHRoaXMuc2V0KGNhY2hlS2V5LCBkYXRhLCB0aGlzLmRlZmF1bHRUVEwuQU5BTFlUSUNTKTtcclxuICB9XHJcblxyXG4gIGFzeW5jIGdldENhY2hlZEFuYWx5dGljcyh0eXBlLCBpZGVudGlmaWVyKSB7XHJcbiAgICBjb25zdCBjYWNoZUtleSA9IHRoaXMua2V5KFwiQU5BTFlUSUNTXCIsIGAke3R5cGV9OiR7aWRlbnRpZmllcn1gKTtcclxuICAgIHJldHVybiB0aGlzLmdldChjYWNoZUtleSk7XHJcbiAgfVxyXG5cclxuICAvLyBCYXRjaCBvcGVyYXRpb25zXHJcbiAgYXN5bmMgbWdldChrZXlzKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5yZWRpcy5tZ2V0KC4uLmtleXMpO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcihcIkNhY2hlIG1nZXQgZXJyb3I6XCIsIGVycm9yKTtcclxuXHJcbiAgICAgIC8vIEZhbGxiYWNrIHRvIGluZGl2aWR1YWwgZ2V0cyBmcm9tIG1lbW9yeSBjYWNoZVxyXG4gICAgICBjb25zdCByZXN1bHRzID0gW107XHJcbiAgICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcclxuICAgICAgICBjb25zdCBtZW1vcnlEYXRhID0gdGhpcy5tZW1vcnlDYWNoZS5nZXQoa2V5KTtcclxuICAgICAgICBpZiAobWVtb3J5RGF0YSAmJiBtZW1vcnlEYXRhLmV4cGlyZXNBdCA+IERhdGUubm93KCkpIHtcclxuICAgICAgICAgIHJlc3VsdHMucHVzaChtZW1vcnlEYXRhLnZhbHVlKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgcmVzdWx0cy5wdXNoKG51bGwpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gcmVzdWx0cztcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGFzeW5jIG1zZXQoa2V5VmFsdWVQYWlycykge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgcGFpcnMgPSBbXTtcclxuICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2Yga2V5VmFsdWVQYWlycykge1xyXG4gICAgICAgIHBhaXJzLnB1c2goXHJcbiAgICAgICAgICBrZXksXHJcbiAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgPyB2YWx1ZSA6IEpTT04uc3RyaW5naWZ5KHZhbHVlKVxyXG4gICAgICAgICk7XHJcbiAgICAgICAgLy8gQWxzbyBzZXQgaW4gbWVtb3J5IGNhY2hlXHJcbiAgICAgICAgdGhpcy5zZXRNZW1vcnlDYWNoZShrZXksIHZhbHVlKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5yZWRpcy5tc2V0KC4uLnBhaXJzKTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJDYWNoZSBtc2V0IGVycm9yOlwiLCBlcnJvcik7XHJcblxyXG4gICAgICAvLyBGYWxsYmFjayB0byBtZW1vcnkgY2FjaGUgb25seVxyXG4gICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBrZXlWYWx1ZVBhaXJzKSB7XHJcbiAgICAgICAgdGhpcy5zZXRNZW1vcnlDYWNoZShrZXksIHZhbHVlKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBDYWNoZSBpbnZhbGlkYXRpb25cclxuICBhc3luYyBpbnZhbGlkYXRlUGF0dGVybihwYXR0ZXJuKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBrZXlzID0gYXdhaXQgdGhpcy5yZWRpcy5rZXlzKHBhdHRlcm4pO1xyXG4gICAgICBpZiAoa2V5cy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgLy8gRGVsZXRlIGZyb20gUmVkaXNcclxuICAgICAgICBjb25zdCByZWRpc1Jlc3VsdCA9IGF3YWl0IHRoaXMucmVkaXMuZGVsKC4uLmtleXMpO1xyXG5cclxuICAgICAgICAvLyBEZWxldGUgZnJvbSBtZW1vcnkgY2FjaGVcclxuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XHJcbiAgICAgICAgICBpZiAodGhpcy5tZW1vcnlDYWNoZS5oYXMoa2V5KSkge1xyXG4gICAgICAgICAgICB0aGlzLm1lbW9yeUNhY2hlLmRlbGV0ZShrZXkpO1xyXG4gICAgICAgICAgICB0aGlzLm1lbW9yeUNhY2hlU2l6ZS0tO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHJlZGlzUmVzdWx0O1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiAwO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcihcIkNhY2hlIGludmFsaWRhdGlvbiBlcnJvcjpcIiwgZXJyb3IpO1xyXG5cclxuICAgICAgLy8gVHJ5IHRvIGNsZWFyIG1lbW9yeSBjYWNoZSBwYXR0ZXJucyAoc2ltcGxlIHN0cmluZyBtYXRjaGluZylcclxuICAgICAgbGV0IGNsZWFyZWQgPSAwO1xyXG4gICAgICBmb3IgKGNvbnN0IFtrZXldIG9mIHRoaXMubWVtb3J5Q2FjaGUpIHtcclxuICAgICAgICBpZiAoa2V5LmluY2x1ZGVzKHBhdHRlcm4ucmVwbGFjZShcIipcIiwgXCJcIikpKSB7XHJcbiAgICAgICAgICB0aGlzLm1lbW9yeUNhY2hlLmRlbGV0ZShrZXkpO1xyXG4gICAgICAgICAgdGhpcy5tZW1vcnlDYWNoZVNpemUtLTtcclxuICAgICAgICAgIGNsZWFyZWQrKztcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGNsZWFyZWQ7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBhc3luYyBpbnZhbGlkYXRlSVBPQ2FjaGUoaXBvSWQpIHtcclxuICAgIGNvbnN0IHBhdHRlcm5zID0gW1xyXG4gICAgICB0aGlzLmtleShcIklQT1wiLCBgZGV0YWlsOiR7aXBvSWR9YCksXHJcbiAgICAgIHRoaXMua2V5KFwiSVBPXCIsIFwibGlzdDoqXCIpLFxyXG4gICAgICB0aGlzLmtleShcIkdNUFwiLCBgKjoke2lwb0lkfWApLFxyXG4gICAgICB0aGlzLmtleShcIlNVQlNDUklQVElPTlwiLCBgKjoke2lwb0lkfWApLFxyXG4gICAgICB0aGlzLmtleShcIkRFTUFORFwiLCBgKjoke2lwb0lkfWApLFxyXG4gICAgICB0aGlzLmtleShcIlJFQUxUSU1FXCIsIGAqOiR7aXBvSWR9YCksXHJcbiAgICBdO1xyXG5cclxuICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBQcm9taXNlLmFsbFNldHRsZWQoXHJcbiAgICAgIHBhdHRlcm5zLm1hcCgocGF0dGVybikgPT4gdGhpcy5pbnZhbGlkYXRlUGF0dGVybihwYXR0ZXJuKSlcclxuICAgICk7XHJcbiAgICByZXR1cm4gcmVzdWx0cy5ldmVyeSgocmVzdWx0KSA9PiByZXN1bHQuc3RhdHVzID09PSBcImZ1bGZpbGxlZFwiKTtcclxuICB9XHJcblxyXG4gIC8vIFBlcmZvcm1hbmNlIG1vbml0b3JpbmdcclxuICBhc3luYyBnZXRDYWNoZVN0YXRzKCkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgcmVkaXNJbmZvID0gYXdhaXQgdGhpcy5yZWRpcy5pbmZvKCk7XHJcbiAgICAgIGNvbnN0IGhpdFJhdGUgPVxyXG4gICAgICAgIHRoaXMubWV0cmljcy5vcGVyYXRpb25zID4gMFxyXG4gICAgICAgICAgPyAoKHRoaXMubWV0cmljcy5oaXRzIC8gdGhpcy5tZXRyaWNzLm9wZXJhdGlvbnMpICogMTAwKS50b0ZpeGVkKDIpXHJcbiAgICAgICAgICA6IFwiMC4wMFwiO1xyXG5cclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBjb25uZWN0ZWQ6IHRydWUsXHJcbiAgICAgICAgcmVkaXM6IHtcclxuICAgICAgICAgIG1lbW9yeTogcmVkaXNJbmZvLm1hdGNoKC91c2VkX21lbW9yeV9odW1hbjooLispLyk/LlsxXT8udHJpbSgpLFxyXG4gICAgICAgICAga2V5czogcmVkaXNJbmZvLm1hdGNoKC9kYjA6a2V5cz0oXFxkKykvKT8uWzFdLFxyXG4gICAgICAgICAgaGl0czogcmVkaXNJbmZvLm1hdGNoKC9rZXlzcGFjZV9oaXRzOihcXGQrKS8pPy5bMV0sXHJcbiAgICAgICAgICBtaXNzZXM6IHJlZGlzSW5mby5tYXRjaCgva2V5c3BhY2VfbWlzc2VzOihcXGQrKS8pPy5bMV0sXHJcbiAgICAgICAgfSxcclxuICAgICAgICBsb2NhbDoge1xyXG4gICAgICAgICAgaGl0UmF0ZTogYCR7aGl0UmF0ZX0lYCxcclxuICAgICAgICAgIHRvdGFsT3BlcmF0aW9uczogdGhpcy5tZXRyaWNzLm9wZXJhdGlvbnMsXHJcbiAgICAgICAgICBoaXRzOiB0aGlzLm1ldHJpY3MuaGl0cyxcclxuICAgICAgICAgIG1pc3NlczogdGhpcy5tZXRyaWNzLm1pc3NlcyxcclxuICAgICAgICAgIGVycm9yczogdGhpcy5tZXRyaWNzLmVycm9ycyxcclxuICAgICAgICAgIG1lbW9yeUNhY2hlU2l6ZTogdGhpcy5tZW1vcnlDYWNoZVNpemUsXHJcbiAgICAgICAgICBtZW1vcnlDYWNoZUxpbWl0OiB0aGlzLm1heE1lbW9yeUNhY2hlLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXHJcbiAgICAgIH07XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zdCBoaXRSYXRlID1cclxuICAgICAgICB0aGlzLm1ldHJpY3Mub3BlcmF0aW9ucyA+IDBcclxuICAgICAgICAgID8gKCh0aGlzLm1ldHJpY3MuaGl0cyAvIHRoaXMubWV0cmljcy5vcGVyYXRpb25zKSAqIDEwMCkudG9GaXhlZCgyKVxyXG4gICAgICAgICAgOiBcIjAuMDBcIjtcclxuXHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgY29ubmVjdGVkOiBmYWxzZSxcclxuICAgICAgICBlcnJvcjogZXJyb3IubWVzc2FnZSxcclxuICAgICAgICBsb2NhbDoge1xyXG4gICAgICAgICAgaGl0UmF0ZTogYCR7aGl0UmF0ZX0lYCxcclxuICAgICAgICAgIHRvdGFsT3BlcmF0aW9uczogdGhpcy5tZXRyaWNzLm9wZXJhdGlvbnMsXHJcbiAgICAgICAgICBoaXRzOiB0aGlzLm1ldHJpY3MuaGl0cyxcclxuICAgICAgICAgIG1pc3NlczogdGhpcy5tZXRyaWNzLm1pc3NlcyxcclxuICAgICAgICAgIGVycm9yczogdGhpcy5tZXRyaWNzLmVycm9ycyxcclxuICAgICAgICAgIG1lbW9yeUNhY2hlU2l6ZTogdGhpcy5tZW1vcnlDYWNoZVNpemUsXHJcbiAgICAgICAgICBtZW1vcnlDYWNoZUxpbWl0OiB0aGlzLm1heE1lbW9yeUNhY2hlLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXHJcbiAgICAgIH07XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBDYWNoZSB3YXJtaW5nIGZvciBmcmVxdWVudGx5IGFjY2Vzc2VkIGRhdGFcclxuICBhc3luYyB3YXJtQ2FjaGUoKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zb2xlLmxvZyhcIvCflKUgU3RhcnRpbmcgY2FjaGUgd2FybS11cC4uLlwiKTtcclxuXHJcbiAgICAgIC8vIENhY2hlIGFjdGl2ZSBJUE9zXHJcbiAgICAgIGNvbnN0IGFjdGl2ZUlQT3MgPSBhd2FpdCBwcmlzbWEuaVBPLmZpbmRNYW55KHtcclxuICAgICAgICB3aGVyZToge1xyXG4gICAgICAgICAgc3RhdHVzOiB7IGluOiBbXCJvcGVuXCIsIFwidXBjb21pbmdcIl0gfSxcclxuICAgICAgICAgIGlzQWN0aXZlOiB0cnVlLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaW5jbHVkZToge1xyXG4gICAgICAgICAgZ21wOiB7IHRha2U6IDEwLCBvcmRlckJ5OiB7IHRpbWVzdGFtcDogXCJkZXNjXCIgfSB9LFxyXG4gICAgICAgICAgc3Vic2NyaXB0aW9uOiB7IHRha2U6IDUsIG9yZGVyQnk6IHsgdGltZXN0YW1wOiBcImRlc2NcIiB9IH0sXHJcbiAgICAgICAgICBhbmFseXRpY3M6IHRydWUsXHJcbiAgICAgICAgfSxcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBjb25zdCBjYWNoZVByb21pc2VzID0gYWN0aXZlSVBPcy5tYXAoKGlwbykgPT5cclxuICAgICAgICB0aGlzLmNhY2hlSVBPRGV0YWlsKGlwby5pZCwgaXBvKVxyXG4gICAgICApO1xyXG5cclxuICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoY2FjaGVQcm9taXNlcyk7XHJcblxyXG4gICAgICAvLyBDYWNoZSBJUE8gbGlzdCB3aXRoIGNvbW1vbiBmaWx0ZXJzXHJcbiAgICAgIGF3YWl0IHRoaXMuY2FjaGVJUE9MaXN0KFxyXG4gICAgICAgIGFjdGl2ZUlQT3MuZmlsdGVyKChpcG8pID0+IGlwby5zdGF0dXMgPT09IFwib3BlblwiKSxcclxuICAgICAgICB7IHN0YXR1czogXCJvcGVuXCIgfVxyXG4gICAgICApO1xyXG4gICAgICBhd2FpdCB0aGlzLmNhY2hlSVBPTGlzdChcclxuICAgICAgICBhY3RpdmVJUE9zLmZpbHRlcigoaXBvKSA9PiBpcG8uc3RhdHVzID09PSBcInVwY29taW5nXCIpLFxyXG4gICAgICAgIHsgc3RhdHVzOiBcInVwY29taW5nXCIgfVxyXG4gICAgICApO1xyXG5cclxuICAgICAgY29uc29sZS5sb2coYPCflKUgQ2FjaGUgd2FybWVkIHdpdGggJHthY3RpdmVJUE9zLmxlbmd0aH0gYWN0aXZlIElQT3NgKTtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKFwiQ2FjaGUgd2FybS11cCBmYWlsZWQ6XCIsIGVycm9yKTtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gSGVhbHRoIGNoZWNrXHJcbiAgYXN5bmMgaGVhbHRoQ2hlY2soKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCB0ZXN0S2V5ID0gXCJoZWFsdGhfY2hlY2tcIjtcclxuICAgICAgY29uc3QgdGVzdFZhbHVlID0gRGF0ZS5ub3coKS50b1N0cmluZygpO1xyXG4gICAgICBhd2FpdCB0aGlzLnNldCh0ZXN0S2V5LCB0ZXN0VmFsdWUsIDEwKTtcclxuICAgICAgY29uc3QgcmV0cmlldmVkID0gYXdhaXQgdGhpcy5nZXQodGVzdEtleSk7XHJcbiAgICAgIGF3YWl0IHRoaXMuZGVsKHRlc3RLZXkpO1xyXG5cclxuICAgICAgY29uc3QgaXNIZWFsdGh5ID0gcmV0cmlldmVkID09PSB0ZXN0VmFsdWU7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgc3RhdHVzOiBpc0hlYWx0aHkgPyBcImhlYWx0aHlcIiA6IFwiZGVncmFkZWRcIixcclxuICAgICAgICByZWRpczogaXNIZWFsdGh5LFxyXG4gICAgICAgIG1lbW9yeUNhY2hlOiB0aGlzLm1lbW9yeUNhY2hlU2l6ZSA8IHRoaXMubWF4TWVtb3J5Q2FjaGUsXHJcbiAgICAgICAgbWV0cmljczogdGhpcy5tZXRyaWNzLFxyXG4gICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxyXG4gICAgICB9O1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcihcIkNhY2hlIGhlYWx0aCBjaGVjayBmYWlsZWQ6XCIsIGVycm9yKTtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBzdGF0dXM6IFwidW5oZWFsdGh5XCIsXHJcbiAgICAgICAgcmVkaXM6IGZhbHNlLFxyXG4gICAgICAgIG1lbW9yeUNhY2hlOiB0aGlzLm1lbW9yeUNhY2hlU2l6ZSA8IHRoaXMubWF4TWVtb3J5Q2FjaGUsXHJcbiAgICAgICAgZXJyb3I6IGVycm9yLm1lc3NhZ2UsXHJcbiAgICAgICAgbWV0cmljczogdGhpcy5tZXRyaWNzLFxyXG4gICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gQ2xlYW4gZXhwaXJlZCBlbnRyaWVzIGZyb20gbWVtb3J5IGNhY2hlXHJcbiAgY2xlYW5FeHBpcmVkTWVtb3J5Q2FjaGUoKSB7XHJcbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xyXG4gICAgY29uc3QgdG9EZWxldGUgPSBbXTtcclxuXHJcbiAgICBmb3IgKGNvbnN0IFtrZXksIGRhdGFdIG9mIHRoaXMubWVtb3J5Q2FjaGUpIHtcclxuICAgICAgaWYgKGRhdGEuZXhwaXJlc0F0IDw9IG5vdykge1xyXG4gICAgICAgIHRvRGVsZXRlLnB1c2goa2V5KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZvciAoY29uc3Qga2V5IG9mIHRvRGVsZXRlKSB7XHJcbiAgICAgIHRoaXMubWVtb3J5Q2FjaGUuZGVsZXRlKGtleSk7XHJcbiAgICAgIHRoaXMubWVtb3J5Q2FjaGVTaXplLS07XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRvRGVsZXRlLmxlbmd0aDtcclxuICB9XHJcblxyXG4gIC8vIFJlc2V0IG1ldHJpY3NcclxuICByZXNldE1ldHJpY3MoKSB7XHJcbiAgICB0aGlzLm1ldHJpY3MgPSB7XHJcbiAgICAgIGhpdHM6IDAsXHJcbiAgICAgIG1pc3NlczogMCxcclxuICAgICAgZXJyb3JzOiAwLFxyXG4gICAgICBvcGVyYXRpb25zOiAwLFxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIC8vIEdldCBjYWNoZSBzaXplIGluZm9cclxuICBnZXRDYWNoZVNpemUoKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBtZW1vcnlDYWNoZTogdGhpcy5tZW1vcnlDYWNoZVNpemUsXHJcbiAgICAgIG1heE1lbW9yeUNhY2hlOiB0aGlzLm1heE1lbW9yeUNhY2hlLFxyXG4gICAgICB1dGlsaXphdGlvblBlcmNlbnQ6IChcclxuICAgICAgICAodGhpcy5tZW1vcnlDYWNoZVNpemUgLyB0aGlzLm1heE1lbW9yeUNhY2hlKSAqXHJcbiAgICAgICAgMTAwXHJcbiAgICAgICkudG9GaXhlZCgyKSxcclxuICAgIH07XHJcbiAgfVxyXG59XHJcblxyXG4vLyBFeHBvcnQgc2luZ2xldG9uIGluc3RhbmNlXHJcbmV4cG9ydCBjb25zdCBjYWNoZSA9IG5ldyBDYWNoZVNlcnZpY2UoKTtcclxuXHJcbi8vIFV0aWxpdHkgbWlkZGxld2FyZSBmb3IgY2FjaGUgbWFuYWdlbWVudFxyXG5leHBvcnQgY29uc3QgY2FjaGVNaWRkbGV3YXJlID0gKHR0bCA9IDMwMCkgPT4ge1xyXG4gIHJldHVybiBhc3luYyAocmVxLCByZXMsIG5leHQpID0+IHtcclxuICAgIGNvbnN0IGNhY2hlS2V5ID0gY2FjaGUua2V5KFxyXG4gICAgICBcIkFQSVwiLFxyXG4gICAgICBgJHtyZXEucGF0aH06JHtKU09OLnN0cmluZ2lmeShyZXEucXVlcnkpfWBcclxuICAgICk7XHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgY2FjaGVkID0gYXdhaXQgY2FjaGUuZ2V0KGNhY2hlS2V5KTtcclxuICAgICAgaWYgKGNhY2hlZCkge1xyXG4gICAgICAgIHJldHVybiByZXMuanNvbih7XHJcbiAgICAgICAgICAuLi5jYWNoZWQsXHJcbiAgICAgICAgICBjYWNoZWQ6IHRydWUsXHJcbiAgICAgICAgICBjYWNoZVRpbWVzdGFtcDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBTdG9yZSBvcmlnaW5hbCByZXMuanNvblxyXG4gICAgICBjb25zdCBvcmlnaW5hbEpzb24gPSByZXMuanNvbjtcclxuICAgICAgLy8gT3ZlcnJpZGUgcmVzLmpzb24gdG8gY2FjaGUgdGhlIHJlc3BvbnNlXHJcbiAgICAgIHJlcy5qc29uID0gZnVuY3Rpb24gKGRhdGEpIHtcclxuICAgICAgICBjYWNoZS5zZXQoY2FjaGVLZXksIGRhdGEsIHR0bCk7XHJcbiAgICAgICAgcmV0dXJuIG9yaWdpbmFsSnNvbi5jYWxsKHRoaXMsIGRhdGEpO1xyXG4gICAgICB9O1xyXG4gICAgICBuZXh0KCk7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKFwiQ2FjaGUgbWlkZGxld2FyZSBlcnJvcjpcIiwgZXJyb3IpO1xyXG4gICAgICBuZXh0KCk7XHJcbiAgICB9XHJcbiAgfTtcclxufTtcclxuXHJcbi8vIE1pZGRsZXdhcmUgdG8gaW52YWxpZGF0ZSBjYWNoZSBvbiB1cGRhdGVzXHJcbmV4cG9ydCBjb25zdCBpbnZhbGlkYXRlQ2FjaGVPblVwZGF0ZSA9IChwYXR0ZXJucykgPT4ge1xyXG4gIHJldHVybiBhc3luYyAocmVxLCByZXMsIG5leHQpID0+IHtcclxuICAgIC8vIFN0b3JlIG9yaWdpbmFsIHJlc3BvbnNlIG1ldGhvZHNcclxuICAgIGNvbnN0IG9yaWdpbmFsSnNvbiA9IHJlcy5qc29uO1xyXG4gICAgY29uc3Qgb3JpZ2luYWxTZW5kID0gcmVzLnNlbmQ7XHJcblxyXG4gICAgY29uc3QgY2xlYW51cCA9IGFzeW5jIChkYXRhKSA9PiB7XHJcbiAgICAgIGlmIChyZXMuc3RhdHVzQ29kZSA+PSAyMDAgJiYgcmVzLnN0YXR1c0NvZGUgPCAzMDApIHtcclxuICAgICAgICAvLyBTdWNjZXNzIHJlc3BvbnNlLCBpbnZhbGlkYXRlIGNhY2hlXHJcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoXHJcbiAgICAgICAgICBwYXR0ZXJucy5tYXAoKHBhdHRlcm4pID0+IGNhY2hlLmludmFsaWRhdGVQYXR0ZXJuKHBhdHRlcm4pKVxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGRhdGE7XHJcbiAgICB9O1xyXG5cclxuICAgIHJlcy5qc29uID0gZnVuY3Rpb24gKGRhdGEpIHtcclxuICAgICAgY2xlYW51cChkYXRhKTtcclxuICAgICAgcmV0dXJuIG9yaWdpbmFsSnNvbi5jYWxsKHRoaXMsIGRhdGEpO1xyXG4gICAgfTtcclxuXHJcbiAgICByZXMuc2VuZCA9IGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICAgIGNsZWFudXAoZGF0YSk7XHJcbiAgICAgIHJldHVybiBvcmlnaW5hbFNlbmQuY2FsbCh0aGlzLCBkYXRhKTtcclxuICAgIH07XHJcblxyXG4gICAgbmV4dCgpO1xyXG4gIH07XHJcbn07XHJcblxyXG4vLyBBdXRvLWNsZWFudXAgZXhwaXJlZCBtZW1vcnkgY2FjaGUgZW50cmllcyBldmVyeSA1IG1pbnV0ZXNcclxuc2V0SW50ZXJ2YWwoXHJcbiAgKCkgPT4ge1xyXG4gICAgY29uc3QgY2xlYW5lZCA9IGNhY2hlLmNsZWFuRXhwaXJlZE1lbW9yeUNhY2hlKCk7XHJcbiAgICBpZiAoY2xlYW5lZCA+IDApIHtcclxuICAgICAgY29uc29sZS5sb2coYPCfp7kgQ2xlYW5lZCB1cCAke2NsZWFuZWR9IGV4cGlyZWQgbWVtb3J5IGNhY2hlIGVudHJpZXNgKTtcclxuICAgIH1cclxuICB9LFxyXG4gIDUgKiA2MCAqIDEwMDBcclxuKTtcclxuXHJcbi8vIFBlcmlvZGljIGNhY2hlIHdhcm1pbmcgKGV2ZXJ5IGhvdXIpXHJcbnNldEludGVydmFsKFxyXG4gIGFzeW5jICgpID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGF3YWl0IGNhY2hlLndhcm1DYWNoZSgpO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcihcIlNjaGVkdWxlZCBjYWNoZSB3YXJtaW5nIGZhaWxlZDpcIiwgZXJyb3IpO1xyXG4gICAgfVxyXG4gIH0sXHJcbiAgNjAgKiA2MCAqIDEwMDBcclxuKTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNhY2hlO1xyXG4iXSwibmFtZXMiOlsiUmVkaXMiLCJwcmlzbWEiLCJDYWNoZVNlcnZpY2UiLCJjb25zdHJ1Y3RvciIsInJlZGlzIiwidXJsIiwicHJvY2VzcyIsImVudiIsIlVQU1RBU0hfUkVESVNfUkVTVF9VUkwiLCJ0b2tlbiIsIlVQU1RBU0hfUkVESVNfUkVTVF9UT0tFTiIsIm1lbW9yeUNhY2hlIiwiTWFwIiwibWVtb3J5Q2FjaGVTaXplIiwibWF4TWVtb3J5Q2FjaGUiLCJwcmVmaXhlcyIsIklQTyIsIkdNUCIsIlNVQlNDUklQVElPTiIsIkRFTUFORCIsIkFMTE9UTUVOVCIsIlVTRVIiLCJTRVNTSU9OIiwiQVBJIiwiQU5BTFlUSUNTIiwiUkVBTFRJTUUiLCJTRUFSQ0giLCJTWVNURU0iLCJkZWZhdWx0VFRMIiwiSVBPX0xJU1QiLCJJUE9fREVUQUlMIiwiR01QX0RBVEEiLCJVU0VSX1NFU1NJT04iLCJBUElfUkVTUE9OU0UiLCJtZXRyaWNzIiwiaGl0cyIsIm1pc3NlcyIsImVycm9ycyIsIm9wZXJhdGlvbnMiLCJrZXkiLCJwcmVmaXgiLCJpZGVudGlmaWVyIiwiZ2V0IiwiZGF0YSIsIkpTT04iLCJwYXJzZSIsIm1lbW9yeURhdGEiLCJleHBpcmVzQXQiLCJEYXRlIiwibm93IiwidmFsdWUiLCJlcnJvciIsImNvbnNvbGUiLCJzZXQiLCJ0dGwiLCJzZXJpYWxpemVkIiwic3RyaW5naWZ5IiwicmVzdWx0Iiwic2V0ZXgiLCJzZXRNZW1vcnlDYWNoZSIsImhhcyIsImV2aWN0T2xkZXN0TWVtb3J5Q2FjaGUiLCJlbnRyaWVzIiwiQXJyYXkiLCJmcm9tIiwic29ydCIsImEiLCJiIiwidG9SZW1vdmUiLCJNYXRoIiwibWF4IiwiZmxvb3IiLCJsZW5ndGgiLCJpIiwiZGVsZXRlIiwiZGVsIiwiZXhpc3RzIiwicmVkaXNFeGlzdHMiLCJjYWNoZUlQT0xpc3QiLCJpcG9zIiwiZmlsdGVycyIsImZpbHRlcktleSIsIk9iamVjdCIsImtleXMiLCJtYXAiLCJrIiwiam9pbiIsImNhY2hlS2V5IiwiZ2V0Q2FjaGVkSVBPTGlzdCIsImNhY2hlSVBPRGV0YWlsIiwiaXBvSWQiLCJnZXRDYWNoZWRJUE9EZXRhaWwiLCJjYWNoZVJlYWxUaW1lRGF0YSIsInR5cGUiLCJlbnJpY2hlZERhdGEiLCJ0aW1lc3RhbXAiLCJjYWNoZWRfYXQiLCJ0b0lTT1N0cmluZyIsInB1Ymxpc2giLCJ3YXJuIiwibWVzc2FnZSIsImdldFJlYWxUaW1lRGF0YSIsImNhY2hlR01QRGF0YSIsImdtcERhdGEiLCJnZXRDYWNoZWRHTVBEYXRhIiwiY2FjaGVMaXZlR01QIiwiZ21wVmFsdWUiLCJnZXRDYWNoZWRMaXZlR01QIiwiY2FjaGVTdWJzY3JpcHRpb25EYXRhIiwic3ltYm9sIiwiZ2V0Q2FjaGVkU3Vic2NyaXB0aW9uRGF0YSIsImNhY2hlRGVtYW5kRGF0YSIsImdldENhY2hlZERlbWFuZERhdGEiLCJjYWNoZUFsbG90bWVudFN0YXR1cyIsInBhbk51bWJlciIsImFwcGxpY2F0aW9uTnVtYmVyIiwiZ2V0Q2FjaGVkQWxsb3RtZW50U3RhdHVzIiwiY2FjaGVVc2VyU2Vzc2lvbiIsInVzZXJJZCIsInNlc3Npb25EYXRhIiwiZ2V0Q2FjaGVkVXNlclNlc3Npb24iLCJjYWNoZUFQSVJlc3BvbnNlIiwiZW5kcG9pbnQiLCJwYXJhbXMiLCJwYXJhbUtleSIsImdldENhY2hlZEFQSVJlc3BvbnNlIiwiY2FjaGVTZWFyY2hSZXN1bHRzIiwicXVlcnkiLCJyZXN1bHRzIiwidG9Mb3dlckNhc2UiLCJnZXRDYWNoZWRTZWFyY2hSZXN1bHRzIiwiY2FjaGVBbmFseXRpY3MiLCJnZXRDYWNoZWRBbmFseXRpY3MiLCJtZ2V0IiwicHVzaCIsIm1zZXQiLCJrZXlWYWx1ZVBhaXJzIiwicGFpcnMiLCJpbnZhbGlkYXRlUGF0dGVybiIsInBhdHRlcm4iLCJyZWRpc1Jlc3VsdCIsImNsZWFyZWQiLCJpbmNsdWRlcyIsInJlcGxhY2UiLCJpbnZhbGlkYXRlSVBPQ2FjaGUiLCJwYXR0ZXJucyIsIlByb21pc2UiLCJhbGxTZXR0bGVkIiwiZXZlcnkiLCJzdGF0dXMiLCJnZXRDYWNoZVN0YXRzIiwicmVkaXNJbmZvIiwiaW5mbyIsImhpdFJhdGUiLCJ0b0ZpeGVkIiwiY29ubmVjdGVkIiwibWVtb3J5IiwibWF0Y2giLCJ0cmltIiwibG9jYWwiLCJ0b3RhbE9wZXJhdGlvbnMiLCJtZW1vcnlDYWNoZUxpbWl0Iiwid2FybUNhY2hlIiwibG9nIiwiYWN0aXZlSVBPcyIsImlQTyIsImZpbmRNYW55Iiwid2hlcmUiLCJpbiIsImlzQWN0aXZlIiwiaW5jbHVkZSIsImdtcCIsInRha2UiLCJvcmRlckJ5Iiwic3Vic2NyaXB0aW9uIiwiYW5hbHl0aWNzIiwiY2FjaGVQcm9taXNlcyIsImlwbyIsImlkIiwiYWxsIiwiZmlsdGVyIiwiaGVhbHRoQ2hlY2siLCJ0ZXN0S2V5IiwidGVzdFZhbHVlIiwidG9TdHJpbmciLCJyZXRyaWV2ZWQiLCJpc0hlYWx0aHkiLCJjbGVhbkV4cGlyZWRNZW1vcnlDYWNoZSIsInRvRGVsZXRlIiwicmVzZXRNZXRyaWNzIiwiZ2V0Q2FjaGVTaXplIiwidXRpbGl6YXRpb25QZXJjZW50IiwiY2FjaGUiLCJjYWNoZU1pZGRsZXdhcmUiLCJyZXEiLCJyZXMiLCJuZXh0IiwicGF0aCIsImNhY2hlZCIsImpzb24iLCJjYWNoZVRpbWVzdGFtcCIsIm9yaWdpbmFsSnNvbiIsImNhbGwiLCJpbnZhbGlkYXRlQ2FjaGVPblVwZGF0ZSIsIm9yaWdpbmFsU2VuZCIsInNlbmQiLCJjbGVhbnVwIiwic3RhdHVzQ29kZSIsInNldEludGVydmFsIiwiY2xlYW5lZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./src/lib/cache.js\n");

/***/ }),

/***/ "(rsc)/./src/lib/db.js":
/*!***********************!*\
  !*** ./src/lib/db.js ***!
  \***********************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   batchOperation: () => (/* binding */ batchOperation),\n/* harmony export */   checkDBHealth: () => (/* binding */ checkDBHealth),\n/* harmony export */   checkDatabaseSeeded: () => (/* binding */ checkDatabaseSeeded),\n/* harmony export */   cleanupExpiredCache: () => (/* binding */ cleanupExpiredCache),\n/* harmony export */   cleanupOldSyncLogs: () => (/* binding */ cleanupOldSyncLogs),\n/* harmony export */   createBackupSnapshot: () => (/* binding */ createBackupSnapshot),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   getConnectionInfo: () => (/* binding */ getConnectionInfo),\n/* harmony export */   getDatabaseMetrics: () => (/* binding */ getDatabaseMetrics),\n/* harmony export */   getDatabaseSize: () => (/* binding */ getDatabaseSize),\n/* harmony export */   getSlowQueries: () => (/* binding */ getSlowQueries),\n/* harmony export */   optimizeDatabase: () => (/* binding */ optimizeDatabase),\n/* harmony export */   performMaintenance: () => (/* binding */ performMaintenance),\n/* harmony export */   prisma: () => (/* binding */ prisma),\n/* harmony export */   resetTables: () => (/* binding */ resetTables),\n/* harmony export */   withTransaction: () => (/* binding */ withTransaction)\n/* harmony export */ });\n/* harmony import */ var _prisma_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @prisma/client */ \"@prisma/client\");\n\nconst globalForPrisma = globalThis;\nconst prisma = globalForPrisma.prisma || new _prisma_client__WEBPACK_IMPORTED_MODULE_0__.PrismaClient({\n    log: [\n        \"query\",\n        \"error\",\n        \"warn\"\n    ],\n    datasources: {\n        db: {\n            url: process.env.DATABASE_URL\n        }\n    },\n    // Connection pool configuration for better performance\n    __internal: {\n        engine: {\n            connectTimeout: 60000,\n            queryTimeout: 60000\n        }\n    }\n});\nif (true) {\n    globalForPrisma.prisma = prisma;\n}\n// Database health check\nasync function checkDBHealth() {\n    try {\n        await prisma.$queryRaw`SELECT 1 as health`;\n        return {\n            status: \"healthy\",\n            timestamp: new Date().toISOString(),\n            connection: \"active\",\n            version: await getDatabaseVersion()\n        };\n    } catch (error) {\n        return {\n            status: \"unhealthy\",\n            error: error.message,\n            timestamp: new Date().toISOString(),\n            connection: \"failed\"\n        };\n    }\n}\n// Get database version\nasync function getDatabaseVersion() {\n    try {\n        const result = await prisma.$queryRaw`SELECT VERSION() as version`;\n        return result[0]?.version || \"unknown\";\n    } catch (error) {\n        return \"unknown\";\n    }\n}\n// Database cleanup utility for expired cache entries\nasync function cleanupExpiredCache() {\n    try {\n        const result = await prisma.cacheEntry.deleteMany({\n            where: {\n                expiresAt: {\n                    lt: new Date()\n                }\n            }\n        });\n        console.log(`🧹 Cleaned up ${result.count} expired cache entries`);\n        return result.count;\n    } catch (error) {\n        console.error(\"Cache cleanup failed:\", error);\n        return 0;\n    }\n}\n// Cleanup old sync logs (keep only last 30 days)\nasync function cleanupOldSyncLogs() {\n    try {\n        const thirtyDaysAgo = new Date();\n        thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);\n        const result = await prisma.syncLog.deleteMany({\n            where: {\n                createdAt: {\n                    lt: thirtyDaysAgo\n                }\n            }\n        });\n        console.log(`🧹 Cleaned up ${result.count} old sync logs`);\n        return result.count;\n    } catch (error) {\n        console.error(\"Sync logs cleanup failed:\", error);\n        return 0;\n    }\n}\n// Transaction helper for complex operations\nasync function withTransaction(callback) {\n    return await prisma.$transaction(callback, {\n        maxWait: 5000,\n        timeout: 10000,\n        isolationLevel: \"ReadCommitted\"\n    });\n}\n// Batch operations helper\nasync function batchOperation(operation, data, batchSize = 100) {\n    const results = [];\n    const errors = [];\n    for(let i = 0; i < data.length; i += batchSize){\n        const batch = data.slice(i, i + batchSize);\n        try {\n            const batchResult = await operation(batch);\n            results.push(batchResult);\n        } catch (error) {\n            errors.push({\n                batchIndex: Math.floor(i / batchSize),\n                error: error.message,\n                data: batch\n            });\n        }\n    }\n    return {\n        results,\n        errors\n    };\n}\n// Connection pool management\nasync function getConnectionInfo() {\n    try {\n        const result = await prisma.$queryRaw`\r\n      SELECT \r\n        count(*) as total_connections,\r\n        count(*) FILTER (WHERE state = 'active') as active_connections,\r\n        count(*) FILTER (WHERE state = 'idle') as idle_connections\r\n      FROM pg_stat_activity \r\n      WHERE datname = current_database()\r\n    `;\n        return result[0];\n    } catch (error) {\n        console.error(\"Failed to get connection info:\", error);\n        return null;\n    }\n}\n// Database performance metrics\nasync function getDatabaseMetrics() {\n    try {\n        const [connectionInfo, tableStats, indexStats] = await Promise.all([\n            getConnectionInfo(),\n            getTableStats(),\n            getIndexStats()\n        ]);\n        return {\n            connections: connectionInfo,\n            tables: tableStats,\n            indexes: indexStats,\n            timestamp: new Date().toISOString()\n        };\n    } catch (error) {\n        console.error(\"Failed to get database metrics:\", error);\n        return {\n            error: error.message\n        };\n    }\n}\n// Get table statistics\nasync function getTableStats() {\n    try {\n        const result = await prisma.$queryRaw`\r\n      SELECT \r\n        schemaname,\r\n        tablename,\r\n        n_tup_ins as inserts,\r\n        n_tup_upd as updates,\r\n        n_tup_del as deletes,\r\n        n_live_tup as live_tuples,\r\n        n_dead_tup as dead_tuples\r\n      FROM pg_stat_user_tables\r\n      ORDER BY n_live_tup DESC\r\n      LIMIT 10\r\n    `;\n        return result;\n    } catch (error) {\n        return [];\n    }\n}\n// Get index statistics\nasync function getIndexStats() {\n    try {\n        const result = await prisma.$queryRaw`\r\n      SELECT \r\n        schemaname,\r\n        tablename,\r\n        indexname,\r\n        idx_tup_read as tuples_read,\r\n        idx_tup_fetch as tuples_fetched\r\n      FROM pg_stat_user_indexes\r\n      WHERE idx_tup_read > 0\r\n      ORDER BY idx_tup_read DESC\r\n      LIMIT 10\r\n    `;\n        return result;\n    } catch (error) {\n        return [];\n    }\n}\n// Backup and maintenance functions\nasync function createBackupSnapshot() {\n    try {\n        const timestamp = new Date().toISOString().replace(/[:.]/g, \"-\");\n        console.log(`📦 Creating backup snapshot at ${timestamp}`);\n        // This would integrate with your backup solution\n        // For now, we'll just log the operation\n        console.log(\"✅ Backup snapshot created successfully\");\n        return {\n            success: true,\n            timestamp,\n            message: \"Backup snapshot created\"\n        };\n    } catch (error) {\n        console.error(\"Backup snapshot failed:\", error);\n        return {\n            success: false,\n            error: error.message\n        };\n    }\n}\n// Database optimization\nasync function optimizeDatabase() {\n    try {\n        console.log(\"\\uD83D\\uDD27 Starting database optimization...\");\n        // Analyze tables for better query planning\n        await prisma.$executeRaw`ANALYZE`;\n        // Vacuum to reclaim space (for PostgreSQL)\n        await prisma.$executeRaw`VACUUM (ANALYZE, VERBOSE)`;\n        console.log(\"✅ Database optimization completed\");\n        return {\n            success: true,\n            message: \"Database optimization completed\",\n            timestamp: new Date().toISOString()\n        };\n    } catch (error) {\n        console.error(\"Database optimization failed:\", error);\n        return {\n            success: false,\n            error: error.message\n        };\n    }\n}\n// Seed check - verify if database has initial data\nasync function checkDatabaseSeeded() {\n    try {\n        const ipoCount = await prisma.iPO.count();\n        const userCount = await prisma.user.count();\n        return {\n            isSeeded: ipoCount > 0 && userCount > 0,\n            counts: {\n                ipos: ipoCount,\n                users: userCount\n            }\n        };\n    } catch (error) {\n        return {\n            isSeeded: false,\n            error: error.message\n        };\n    }\n}\n// Utility function to reset specific tables (for development)\nasync function resetTables(tableNames = []) {\n    if (false) {}\n    try {\n        console.log(`🗑️  Resetting tables: ${tableNames.join(\", \")}`);\n        for (const tableName of tableNames){\n            switch(tableName.toLowerCase()){\n                case \"gmp\":\n                    await prisma.gMP.deleteMany();\n                    break;\n                case \"subscription\":\n                    await prisma.subscriptionData.deleteMany();\n                    break;\n                case \"demand\":\n                    await prisma.marketDemand.deleteMany();\n                    break;\n                case \"allotments\":\n                    await prisma.allotment.deleteMany();\n                    break;\n                case \"analytics\":\n                    await prisma.iPOAnalytics.deleteMany();\n                    break;\n                case \"synclogs\":\n                    await prisma.syncLog.deleteMany();\n                    break;\n                case \"cache\":\n                    await prisma.cacheEntry.deleteMany();\n                    break;\n                default:\n                    console.warn(`Unknown table: ${tableName}`);\n            }\n        }\n        console.log(\"✅ Tables reset successfully\");\n        return {\n            success: true\n        };\n    } catch (error) {\n        console.error(\"Table reset failed:\", error);\n        return {\n            success: false,\n            error: error.message\n        };\n    }\n}\n// Get database size and usage information\nasync function getDatabaseSize() {\n    try {\n        const result = await prisma.$queryRaw`\r\n      SELECT \r\n        pg_size_pretty(pg_database_size(current_database())) as database_size,\r\n        pg_size_pretty(pg_total_relation_size('ipos')) as ipos_table_size,\r\n        pg_size_pretty(pg_total_relation_size('gmp')) as gmp_table_size,\r\n        pg_size_pretty(pg_total_relation_size('subscription_data')) as subscription_table_size\r\n    `;\n        return result[0];\n    } catch (error) {\n        console.error(\"Failed to get database size:\", error);\n        return null;\n    }\n}\n// Monitor slow queries (if available)\nasync function getSlowQueries(limit = 10) {\n    try {\n        // This requires pg_stat_statements extension\n        const result = await prisma.$queryRaw`\r\n      SELECT \r\n        query,\r\n        calls,\r\n        total_time,\r\n        mean_time,\r\n        rows\r\n      FROM pg_stat_statements\r\n      ORDER BY mean_time DESC\r\n      LIMIT ${limit}\r\n    `;\n        return result;\n    } catch (error) {\n        // Extension might not be available\n        return [];\n    }\n}\n// Periodic maintenance function\nasync function performMaintenance() {\n    try {\n        console.log(\"\\uD83D\\uDD27 Starting periodic maintenance...\");\n        const results = await Promise.allSettled([\n            cleanupExpiredCache(),\n            cleanupOldSyncLogs(),\n            optimizeDatabase()\n        ]);\n        const summary = {\n            timestamp: new Date().toISOString(),\n            operations: [\n                {\n                    name: \"cleanupExpiredCache\",\n                    status: results[0].status,\n                    result: results[0].value || results[0].reason\n                },\n                {\n                    name: \"cleanupOldSyncLogs\",\n                    status: results[1].status,\n                    result: results[1].value || results[1].reason\n                },\n                {\n                    name: \"optimizeDatabase\",\n                    status: results[2].status,\n                    result: results[2].value || results[2].reason\n                }\n            ]\n        };\n        console.log(\"✅ Periodic maintenance completed:\", summary);\n        return summary;\n    } catch (error) {\n        console.error(\"Periodic maintenance failed:\", error);\n        return {\n            error: error.message,\n            timestamp: new Date().toISOString()\n        };\n    }\n}\n// Schedule periodic maintenance (runs every 6 hours)\nif ( true && process.env.ENABLE_MAINTENANCE !== \"false\") {\n    setInterval(async ()=>{\n        try {\n            await performMaintenance();\n        } catch (error) {\n            console.error(\"Scheduled maintenance failed:\", error);\n        }\n    }, 6 * 60 * 60 * 1000); // 6 hours\n}\n// Graceful shutdown handler\nasync function gracefulShutdown() {\n    console.log(\"\\uD83D\\uDD0C Closing database connections...\");\n    try {\n        await prisma.$disconnect();\n        console.log(\"✅ Database connections closed successfully\");\n    } catch (error) {\n        console.error(\"❌ Error closing database connections:\", error);\n    }\n}\n// Handle process shutdown\nprocess.on(\"SIGINT\", gracefulShutdown);\nprocess.on(\"SIGTERM\", gracefulShutdown);\nprocess.on(\"SIGQUIT\", gracefulShutdown);\n// Handle uncaught exceptions\nprocess.on(\"uncaughtException\", async (error)=>{\n    console.error(\"Uncaught Exception:\", error);\n    await gracefulShutdown();\n    process.exit(1);\n});\nprocess.on(\"unhandledRejection\", async (reason, promise)=>{\n    console.error(\"Unhandled Rejection at:\", promise, \"reason:\", reason);\n    await gracefulShutdown();\n    process.exit(1);\n});\n// Default export\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (prisma);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUF5Q0E7SUFDekQ7QUFDRjtBQUVBLDBCQUEwQjtBQUMxQmhCLFFBQVEwRyxFQUFFLENBQUMsVUFBVUY7QUFDckJ4RyxRQUFRMEcsRUFBRSxDQUFDLFdBQVdGO0FBQ3RCeEcsUUFBUTBHLEVBQUUsQ0FBQyxXQUFXRjtBQUV0Qiw2QkFBNkI7QUFDN0J4RyxRQUFRMEcsRUFBRSxDQUFDLHFCQUFxQixPQUFPMUY7SUFDckNTLFFBQVFULEtBQUssQ0FBQyx1QkFBdUJBO0lBQ3JDLE1BQU13RjtJQUNOeEcsUUFBUTJHLElBQUksQ0FBQztBQUNmO0FBRUEzRyxRQUFRMEcsRUFBRSxDQUFDLHNCQUFzQixPQUFPTCxRQUFRTztJQUM5Q25GLFFBQVFULEtBQUssQ0FBQywyQkFBMkI0RixTQUFTLFdBQVdQO0lBQzdELE1BQU1HO0lBQ054RyxRQUFRMkcsSUFBSSxDQUFDO0FBQ2Y7QUFFQSxpQkFBaUI7QUFDakIsaUVBQWVoSCxNQUFNQSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaXBvLXRyYWNrZXIvLi9zcmMvbGliL2RiLmpzPzdmOWEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUHJpc21hQ2xpZW50IH0gZnJvbSAnQHByaXNtYS9jbGllbnQnO1xyXG5cclxuY29uc3QgZ2xvYmFsRm9yUHJpc21hID0gZ2xvYmFsVGhpcztcclxuXHJcbmV4cG9ydCBjb25zdCBwcmlzbWEgPVxyXG4gIGdsb2JhbEZvclByaXNtYS5wcmlzbWEgfHxcclxuICBuZXcgUHJpc21hQ2xpZW50KHtcclxuICAgIGxvZzogWydxdWVyeScsICdlcnJvcicsICd3YXJuJ10sXHJcbiAgICBkYXRhc291cmNlczoge1xyXG4gICAgICBkYjoge1xyXG4gICAgICAgIHVybDogcHJvY2Vzcy5lbnYuREFUQUJBU0VfVVJMLFxyXG4gICAgICB9LFxyXG4gICAgfSxcclxuICAgIC8vIENvbm5lY3Rpb24gcG9vbCBjb25maWd1cmF0aW9uIGZvciBiZXR0ZXIgcGVyZm9ybWFuY2VcclxuICAgIF9faW50ZXJuYWw6IHtcclxuICAgICAgZW5naW5lOiB7XHJcbiAgICAgICAgY29ubmVjdFRpbWVvdXQ6IDYwMDAwLFxyXG4gICAgICAgIHF1ZXJ5VGltZW91dDogNjAwMDAsXHJcbiAgICAgIH0sXHJcbiAgICB9LFxyXG4gIH0pO1xyXG5cclxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcclxuICBnbG9iYWxGb3JQcmlzbWEucHJpc21hID0gcHJpc21hO1xyXG59XHJcblxyXG4vLyBEYXRhYmFzZSBoZWFsdGggY2hlY2tcclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNoZWNrREJIZWFsdGgoKSB7XHJcbiAgdHJ5IHtcclxuICAgIGF3YWl0IHByaXNtYS4kcXVlcnlSYXdgU0VMRUNUIDEgYXMgaGVhbHRoYDtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHN0YXR1czogJ2hlYWx0aHknLFxyXG4gICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcclxuICAgICAgY29ubmVjdGlvbjogJ2FjdGl2ZScsXHJcbiAgICAgIHZlcnNpb246IGF3YWl0IGdldERhdGFiYXNlVmVyc2lvbigpLFxyXG4gICAgfTtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgc3RhdHVzOiAndW5oZWFsdGh5JyxcclxuICAgICAgZXJyb3I6IGVycm9yLm1lc3NhZ2UsXHJcbiAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxyXG4gICAgICBjb25uZWN0aW9uOiAnZmFpbGVkJyxcclxuICAgIH07XHJcbiAgfVxyXG59XHJcblxyXG4vLyBHZXQgZGF0YWJhc2UgdmVyc2lvblxyXG5hc3luYyBmdW5jdGlvbiBnZXREYXRhYmFzZVZlcnNpb24oKSB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHByaXNtYS4kcXVlcnlSYXdgU0VMRUNUIFZFUlNJT04oKSBhcyB2ZXJzaW9uYDtcclxuICAgIHJldHVybiByZXN1bHRbMF0/LnZlcnNpb24gfHwgJ3Vua25vd24nO1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICByZXR1cm4gJ3Vua25vd24nO1xyXG4gIH1cclxufVxyXG5cclxuLy8gRGF0YWJhc2UgY2xlYW51cCB1dGlsaXR5IGZvciBleHBpcmVkIGNhY2hlIGVudHJpZXNcclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNsZWFudXBFeHBpcmVkQ2FjaGUoKSB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHByaXNtYS5jYWNoZUVudHJ5LmRlbGV0ZU1hbnkoe1xyXG4gICAgICB3aGVyZToge1xyXG4gICAgICAgIGV4cGlyZXNBdDoge1xyXG4gICAgICAgICAgbHQ6IG5ldyBEYXRlKCksXHJcbiAgICAgICAgfSxcclxuICAgICAgfSxcclxuICAgIH0pO1xyXG4gICAgY29uc29sZS5sb2coYPCfp7kgQ2xlYW5lZCB1cCAke3Jlc3VsdC5jb3VudH0gZXhwaXJlZCBjYWNoZSBlbnRyaWVzYCk7XHJcbiAgICByZXR1cm4gcmVzdWx0LmNvdW50O1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdDYWNoZSBjbGVhbnVwIGZhaWxlZDonLCBlcnJvcik7XHJcbiAgICByZXR1cm4gMDtcclxuICB9XHJcbn1cclxuXHJcbi8vIENsZWFudXAgb2xkIHN5bmMgbG9ncyAoa2VlcCBvbmx5IGxhc3QgMzAgZGF5cylcclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNsZWFudXBPbGRTeW5jTG9ncygpIHtcclxuICB0cnkge1xyXG4gICAgY29uc3QgdGhpcnR5RGF5c0FnbyA9IG5ldyBEYXRlKCk7XHJcbiAgICB0aGlydHlEYXlzQWdvLnNldERhdGUodGhpcnR5RGF5c0Fnby5nZXREYXRlKCkgLSAzMCk7XHJcblxyXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcHJpc21hLnN5bmNMb2cuZGVsZXRlTWFueSh7XHJcbiAgICAgIHdoZXJlOiB7XHJcbiAgICAgICAgY3JlYXRlZEF0OiB7XHJcbiAgICAgICAgICBsdDogdGhpcnR5RGF5c0FnbyxcclxuICAgICAgICB9LFxyXG4gICAgICB9LFxyXG4gICAgfSk7XHJcbiAgICBjb25zb2xlLmxvZyhg8J+nuSBDbGVhbmVkIHVwICR7cmVzdWx0LmNvdW50fSBvbGQgc3luYyBsb2dzYCk7XHJcbiAgICByZXR1cm4gcmVzdWx0LmNvdW50O1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdTeW5jIGxvZ3MgY2xlYW51cCBmYWlsZWQ6JywgZXJyb3IpO1xyXG4gICAgcmV0dXJuIDA7XHJcbiAgfVxyXG59XHJcblxyXG4vLyBUcmFuc2FjdGlvbiBoZWxwZXIgZm9yIGNvbXBsZXggb3BlcmF0aW9uc1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gd2l0aFRyYW5zYWN0aW9uKGNhbGxiYWNrKSB7XHJcbiAgcmV0dXJuIGF3YWl0IHByaXNtYS4kdHJhbnNhY3Rpb24oY2FsbGJhY2ssIHtcclxuICAgIG1heFdhaXQ6IDUwMDAsIC8vIDUgc2Vjb25kc1xyXG4gICAgdGltZW91dDogMTAwMDAsIC8vIDEwIHNlY29uZHNcclxuICAgIGlzb2xhdGlvbkxldmVsOiAnUmVhZENvbW1pdHRlZCcsXHJcbiAgfSk7XHJcbn1cclxuXHJcbi8vIEJhdGNoIG9wZXJhdGlvbnMgaGVscGVyXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBiYXRjaE9wZXJhdGlvbihvcGVyYXRpb24sIGRhdGEsIGJhdGNoU2l6ZSA9IDEwMCkge1xyXG4gIGNvbnN0IHJlc3VsdHMgPSBbXTtcclxuICBjb25zdCBlcnJvcnMgPSBbXTtcclxuXHJcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSArPSBiYXRjaFNpemUpIHtcclxuICAgIGNvbnN0IGJhdGNoID0gZGF0YS5zbGljZShpLCBpICsgYmF0Y2hTaXplKTtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IGJhdGNoUmVzdWx0ID0gYXdhaXQgb3BlcmF0aW9uKGJhdGNoKTtcclxuICAgICAgcmVzdWx0cy5wdXNoKGJhdGNoUmVzdWx0KTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGVycm9ycy5wdXNoKHtcclxuICAgICAgICBiYXRjaEluZGV4OiBNYXRoLmZsb29yKGkgLyBiYXRjaFNpemUpLFxyXG4gICAgICAgIGVycm9yOiBlcnJvci5tZXNzYWdlLFxyXG4gICAgICAgIGRhdGE6IGJhdGNoLFxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiB7IHJlc3VsdHMsIGVycm9ycyB9O1xyXG59XHJcblxyXG4vLyBDb25uZWN0aW9uIHBvb2wgbWFuYWdlbWVudFxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0Q29ubmVjdGlvbkluZm8oKSB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHByaXNtYS4kcXVlcnlSYXdgXHJcbiAgICAgIFNFTEVDVCBcclxuICAgICAgICBjb3VudCgqKSBhcyB0b3RhbF9jb25uZWN0aW9ucyxcclxuICAgICAgICBjb3VudCgqKSBGSUxURVIgKFdIRVJFIHN0YXRlID0gJ2FjdGl2ZScpIGFzIGFjdGl2ZV9jb25uZWN0aW9ucyxcclxuICAgICAgICBjb3VudCgqKSBGSUxURVIgKFdIRVJFIHN0YXRlID0gJ2lkbGUnKSBhcyBpZGxlX2Nvbm5lY3Rpb25zXHJcbiAgICAgIEZST00gcGdfc3RhdF9hY3Rpdml0eSBcclxuICAgICAgV0hFUkUgZGF0bmFtZSA9IGN1cnJlbnRfZGF0YWJhc2UoKVxyXG4gICAgYDtcclxuICAgIHJldHVybiByZXN1bHRbMF07XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBnZXQgY29ubmVjdGlvbiBpbmZvOicsIGVycm9yKTtcclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxufVxyXG5cclxuLy8gRGF0YWJhc2UgcGVyZm9ybWFuY2UgbWV0cmljc1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0RGF0YWJhc2VNZXRyaWNzKCkge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCBbY29ubmVjdGlvbkluZm8sIHRhYmxlU3RhdHMsIGluZGV4U3RhdHNdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xyXG4gICAgICBnZXRDb25uZWN0aW9uSW5mbygpLFxyXG4gICAgICBnZXRUYWJsZVN0YXRzKCksXHJcbiAgICAgIGdldEluZGV4U3RhdHMoKSxcclxuICAgIF0pO1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgIGNvbm5lY3Rpb25zOiBjb25uZWN0aW9uSW5mbyxcclxuICAgICAgdGFibGVzOiB0YWJsZVN0YXRzLFxyXG4gICAgICBpbmRleGVzOiBpbmRleFN0YXRzLFxyXG4gICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcclxuICAgIH07XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBnZXQgZGF0YWJhc2UgbWV0cmljczonLCBlcnJvcik7XHJcbiAgICByZXR1cm4geyBlcnJvcjogZXJyb3IubWVzc2FnZSB9O1xyXG4gIH1cclxufVxyXG5cclxuLy8gR2V0IHRhYmxlIHN0YXRpc3RpY3NcclxuYXN5bmMgZnVuY3Rpb24gZ2V0VGFibGVTdGF0cygpIHtcclxuICB0cnkge1xyXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcHJpc21hLiRxdWVyeVJhd2BcclxuICAgICAgU0VMRUNUIFxyXG4gICAgICAgIHNjaGVtYW5hbWUsXHJcbiAgICAgICAgdGFibGVuYW1lLFxyXG4gICAgICAgIG5fdHVwX2lucyBhcyBpbnNlcnRzLFxyXG4gICAgICAgIG5fdHVwX3VwZCBhcyB1cGRhdGVzLFxyXG4gICAgICAgIG5fdHVwX2RlbCBhcyBkZWxldGVzLFxyXG4gICAgICAgIG5fbGl2ZV90dXAgYXMgbGl2ZV90dXBsZXMsXHJcbiAgICAgICAgbl9kZWFkX3R1cCBhcyBkZWFkX3R1cGxlc1xyXG4gICAgICBGUk9NIHBnX3N0YXRfdXNlcl90YWJsZXNcclxuICAgICAgT1JERVIgQlkgbl9saXZlX3R1cCBERVNDXHJcbiAgICAgIExJTUlUIDEwXHJcbiAgICBgO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgcmV0dXJuIFtdO1xyXG4gIH1cclxufVxyXG5cclxuLy8gR2V0IGluZGV4IHN0YXRpc3RpY3NcclxuYXN5bmMgZnVuY3Rpb24gZ2V0SW5kZXhTdGF0cygpIHtcclxuICB0cnkge1xyXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcHJpc21hLiRxdWVyeVJhd2BcclxuICAgICAgU0VMRUNUIFxyXG4gICAgICAgIHNjaGVtYW5hbWUsXHJcbiAgICAgICAgdGFibGVuYW1lLFxyXG4gICAgICAgIGluZGV4bmFtZSxcclxuICAgICAgICBpZHhfdHVwX3JlYWQgYXMgdHVwbGVzX3JlYWQsXHJcbiAgICAgICAgaWR4X3R1cF9mZXRjaCBhcyB0dXBsZXNfZmV0Y2hlZFxyXG4gICAgICBGUk9NIHBnX3N0YXRfdXNlcl9pbmRleGVzXHJcbiAgICAgIFdIRVJFIGlkeF90dXBfcmVhZCA+IDBcclxuICAgICAgT1JERVIgQlkgaWR4X3R1cF9yZWFkIERFU0NcclxuICAgICAgTElNSVQgMTBcclxuICAgIGA7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICByZXR1cm4gW107XHJcbiAgfVxyXG59XHJcblxyXG4vLyBCYWNrdXAgYW5kIG1haW50ZW5hbmNlIGZ1bmN0aW9uc1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY3JlYXRlQmFja3VwU25hcHNob3QoKSB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IHRpbWVzdGFtcCA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKS5yZXBsYWNlKC9bOi5dL2csICctJyk7XHJcbiAgICBjb25zb2xlLmxvZyhg8J+TpiBDcmVhdGluZyBiYWNrdXAgc25hcHNob3QgYXQgJHt0aW1lc3RhbXB9YCk7XHJcblxyXG4gICAgLy8gVGhpcyB3b3VsZCBpbnRlZ3JhdGUgd2l0aCB5b3VyIGJhY2t1cCBzb2x1dGlvblxyXG4gICAgLy8gRm9yIG5vdywgd2UnbGwganVzdCBsb2cgdGhlIG9wZXJhdGlvblxyXG4gICAgY29uc29sZS5sb2coJ+KchSBCYWNrdXAgc25hcHNob3QgY3JlYXRlZCBzdWNjZXNzZnVsbHknKTtcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBzdWNjZXNzOiB0cnVlLFxyXG4gICAgICB0aW1lc3RhbXAsXHJcbiAgICAgIG1lc3NhZ2U6ICdCYWNrdXAgc25hcHNob3QgY3JlYXRlZCcsXHJcbiAgICB9O1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdCYWNrdXAgc25hcHNob3QgZmFpbGVkOicsIGVycm9yKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxyXG4gICAgICBlcnJvcjogZXJyb3IubWVzc2FnZSxcclxuICAgIH07XHJcbiAgfVxyXG59XHJcblxyXG4vLyBEYXRhYmFzZSBvcHRpbWl6YXRpb25cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIG9wdGltaXplRGF0YWJhc2UoKSB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnNvbGUubG9nKCfwn5SnIFN0YXJ0aW5nIGRhdGFiYXNlIG9wdGltaXphdGlvbi4uLicpO1xyXG5cclxuICAgIC8vIEFuYWx5emUgdGFibGVzIGZvciBiZXR0ZXIgcXVlcnkgcGxhbm5pbmdcclxuICAgIGF3YWl0IHByaXNtYS4kZXhlY3V0ZVJhd2BBTkFMWVpFYDtcclxuXHJcbiAgICAvLyBWYWN1dW0gdG8gcmVjbGFpbSBzcGFjZSAoZm9yIFBvc3RncmVTUUwpXHJcbiAgICBhd2FpdCBwcmlzbWEuJGV4ZWN1dGVSYXdgVkFDVVVNIChBTkFMWVpFLCBWRVJCT1NFKWA7XHJcblxyXG4gICAgY29uc29sZS5sb2coJ+KchSBEYXRhYmFzZSBvcHRpbWl6YXRpb24gY29tcGxldGVkJyk7XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgc3VjY2VzczogdHJ1ZSxcclxuICAgICAgbWVzc2FnZTogJ0RhdGFiYXNlIG9wdGltaXphdGlvbiBjb21wbGV0ZWQnLFxyXG4gICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcclxuICAgIH07XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0RhdGFiYXNlIG9wdGltaXphdGlvbiBmYWlsZWQ6JywgZXJyb3IpO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgc3VjY2VzczogZmFsc2UsXHJcbiAgICAgIGVycm9yOiBlcnJvci5tZXNzYWdlLFxyXG4gICAgfTtcclxuICB9XHJcbn1cclxuXHJcbi8vIFNlZWQgY2hlY2sgLSB2ZXJpZnkgaWYgZGF0YWJhc2UgaGFzIGluaXRpYWwgZGF0YVxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY2hlY2tEYXRhYmFzZVNlZWRlZCgpIHtcclxuICB0cnkge1xyXG4gICAgY29uc3QgaXBvQ291bnQgPSBhd2FpdCBwcmlzbWEuaVBPLmNvdW50KCk7XHJcbiAgICBjb25zdCB1c2VyQ291bnQgPSBhd2FpdCBwcmlzbWEudXNlci5jb3VudCgpO1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgIGlzU2VlZGVkOiBpcG9Db3VudCA+IDAgJiYgdXNlckNvdW50ID4gMCxcclxuICAgICAgY291bnRzOiB7XHJcbiAgICAgICAgaXBvczogaXBvQ291bnQsXHJcbiAgICAgICAgdXNlcnM6IHVzZXJDb3VudCxcclxuICAgICAgfSxcclxuICAgIH07XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGlzU2VlZGVkOiBmYWxzZSxcclxuICAgICAgZXJyb3I6IGVycm9yLm1lc3NhZ2UsXHJcbiAgICB9O1xyXG4gIH1cclxufVxyXG5cclxuLy8gVXRpbGl0eSBmdW5jdGlvbiB0byByZXNldCBzcGVjaWZpYyB0YWJsZXMgKGZvciBkZXZlbG9wbWVudClcclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJlc2V0VGFibGVzKHRhYmxlTmFtZXMgPSBbXSkge1xyXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCByZXNldCB0YWJsZXMgaW4gcHJvZHVjdGlvbiBlbnZpcm9ubWVudCcpO1xyXG4gIH1cclxuXHJcbiAgdHJ5IHtcclxuICAgIGNvbnNvbGUubG9nKGDwn5eR77iPICBSZXNldHRpbmcgdGFibGVzOiAke3RhYmxlTmFtZXMuam9pbignLCAnKX1gKTtcclxuXHJcbiAgICBmb3IgKGNvbnN0IHRhYmxlTmFtZSBvZiB0YWJsZU5hbWVzKSB7XHJcbiAgICAgIHN3aXRjaCAodGFibGVOYW1lLnRvTG93ZXJDYXNlKCkpIHtcclxuICAgICAgICBjYXNlICdnbXAnOlxyXG4gICAgICAgICAgYXdhaXQgcHJpc21hLmdNUC5kZWxldGVNYW55KCk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlICdzdWJzY3JpcHRpb24nOlxyXG4gICAgICAgICAgYXdhaXQgcHJpc21hLnN1YnNjcmlwdGlvbkRhdGEuZGVsZXRlTWFueSgpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAnZGVtYW5kJzpcclxuICAgICAgICAgIGF3YWl0IHByaXNtYS5tYXJrZXREZW1hbmQuZGVsZXRlTWFueSgpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAnYWxsb3RtZW50cyc6XHJcbiAgICAgICAgICBhd2FpdCBwcmlzbWEuYWxsb3RtZW50LmRlbGV0ZU1hbnkoKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgJ2FuYWx5dGljcyc6XHJcbiAgICAgICAgICBhd2FpdCBwcmlzbWEuaVBPQW5hbHl0aWNzLmRlbGV0ZU1hbnkoKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgJ3N5bmNsb2dzJzpcclxuICAgICAgICAgIGF3YWl0IHByaXNtYS5zeW5jTG9nLmRlbGV0ZU1hbnkoKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgJ2NhY2hlJzpcclxuICAgICAgICAgIGF3YWl0IHByaXNtYS5jYWNoZUVudHJ5LmRlbGV0ZU1hbnkoKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICBjb25zb2xlLndhcm4oYFVua25vd24gdGFibGU6ICR7dGFibGVOYW1lfWApO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgY29uc29sZS5sb2coJ+KchSBUYWJsZXMgcmVzZXQgc3VjY2Vzc2Z1bGx5Jyk7XHJcbiAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlIH07XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ1RhYmxlIHJlc2V0IGZhaWxlZDonLCBlcnJvcik7XHJcbiAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IGVycm9yLm1lc3NhZ2UgfTtcclxuICB9XHJcbn1cclxuXHJcbi8vIEdldCBkYXRhYmFzZSBzaXplIGFuZCB1c2FnZSBpbmZvcm1hdGlvblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0RGF0YWJhc2VTaXplKCkge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBwcmlzbWEuJHF1ZXJ5UmF3YFxyXG4gICAgICBTRUxFQ1QgXHJcbiAgICAgICAgcGdfc2l6ZV9wcmV0dHkocGdfZGF0YWJhc2Vfc2l6ZShjdXJyZW50X2RhdGFiYXNlKCkpKSBhcyBkYXRhYmFzZV9zaXplLFxyXG4gICAgICAgIHBnX3NpemVfcHJldHR5KHBnX3RvdGFsX3JlbGF0aW9uX3NpemUoJ2lwb3MnKSkgYXMgaXBvc190YWJsZV9zaXplLFxyXG4gICAgICAgIHBnX3NpemVfcHJldHR5KHBnX3RvdGFsX3JlbGF0aW9uX3NpemUoJ2dtcCcpKSBhcyBnbXBfdGFibGVfc2l6ZSxcclxuICAgICAgICBwZ19zaXplX3ByZXR0eShwZ190b3RhbF9yZWxhdGlvbl9zaXplKCdzdWJzY3JpcHRpb25fZGF0YScpKSBhcyBzdWJzY3JpcHRpb25fdGFibGVfc2l6ZVxyXG4gICAgYDtcclxuXHJcbiAgICByZXR1cm4gcmVzdWx0WzBdO1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gZ2V0IGRhdGFiYXNlIHNpemU6JywgZXJyb3IpO1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG59XHJcblxyXG4vLyBNb25pdG9yIHNsb3cgcXVlcmllcyAoaWYgYXZhaWxhYmxlKVxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0U2xvd1F1ZXJpZXMobGltaXQgPSAxMCkge1xyXG4gIHRyeSB7XHJcbiAgICAvLyBUaGlzIHJlcXVpcmVzIHBnX3N0YXRfc3RhdGVtZW50cyBleHRlbnNpb25cclxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHByaXNtYS4kcXVlcnlSYXdgXHJcbiAgICAgIFNFTEVDVCBcclxuICAgICAgICBxdWVyeSxcclxuICAgICAgICBjYWxscyxcclxuICAgICAgICB0b3RhbF90aW1lLFxyXG4gICAgICAgIG1lYW5fdGltZSxcclxuICAgICAgICByb3dzXHJcbiAgICAgIEZST00gcGdfc3RhdF9zdGF0ZW1lbnRzXHJcbiAgICAgIE9SREVSIEJZIG1lYW5fdGltZSBERVNDXHJcbiAgICAgIExJTUlUICR7bGltaXR9XHJcbiAgICBgO1xyXG5cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIC8vIEV4dGVuc2lvbiBtaWdodCBub3QgYmUgYXZhaWxhYmxlXHJcbiAgICByZXR1cm4gW107XHJcbiAgfVxyXG59XHJcblxyXG4vLyBQZXJpb2RpYyBtYWludGVuYW5jZSBmdW5jdGlvblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcGVyZm9ybU1haW50ZW5hbmNlKCkge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zb2xlLmxvZygn8J+UpyBTdGFydGluZyBwZXJpb2RpYyBtYWludGVuYW5jZS4uLicpO1xyXG5cclxuICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBQcm9taXNlLmFsbFNldHRsZWQoW1xyXG4gICAgICBjbGVhbnVwRXhwaXJlZENhY2hlKCksXHJcbiAgICAgIGNsZWFudXBPbGRTeW5jTG9ncygpLFxyXG4gICAgICBvcHRpbWl6ZURhdGFiYXNlKCksXHJcbiAgICBdKTtcclxuXHJcbiAgICBjb25zdCBzdW1tYXJ5ID0ge1xyXG4gICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcclxuICAgICAgb3BlcmF0aW9uczogW1xyXG4gICAgICAgIHtcclxuICAgICAgICAgIG5hbWU6ICdjbGVhbnVwRXhwaXJlZENhY2hlJyxcclxuICAgICAgICAgIHN0YXR1czogcmVzdWx0c1swXS5zdGF0dXMsXHJcbiAgICAgICAgICByZXN1bHQ6IHJlc3VsdHNbMF0udmFsdWUgfHwgcmVzdWx0c1swXS5yZWFzb24sXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBuYW1lOiAnY2xlYW51cE9sZFN5bmNMb2dzJyxcclxuICAgICAgICAgIHN0YXR1czogcmVzdWx0c1sxXS5zdGF0dXMsXHJcbiAgICAgICAgICByZXN1bHQ6IHJlc3VsdHNbMV0udmFsdWUgfHwgcmVzdWx0c1sxXS5yZWFzb24sXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBuYW1lOiAnb3B0aW1pemVEYXRhYmFzZScsXHJcbiAgICAgICAgICBzdGF0dXM6IHJlc3VsdHNbMl0uc3RhdHVzLFxyXG4gICAgICAgICAgcmVzdWx0OiByZXN1bHRzWzJdLnZhbHVlIHx8IHJlc3VsdHNbMl0ucmVhc29uLFxyXG4gICAgICAgIH0sXHJcbiAgICAgIF0sXHJcbiAgICB9O1xyXG5cclxuICAgIGNvbnNvbGUubG9nKCfinIUgUGVyaW9kaWMgbWFpbnRlbmFuY2UgY29tcGxldGVkOicsIHN1bW1hcnkpO1xyXG4gICAgcmV0dXJuIHN1bW1hcnk7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ1BlcmlvZGljIG1haW50ZW5hbmNlIGZhaWxlZDonLCBlcnJvcik7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBlcnJvcjogZXJyb3IubWVzc2FnZSxcclxuICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXHJcbiAgICB9O1xyXG4gIH1cclxufVxyXG5cclxuLy8gU2NoZWR1bGUgcGVyaW9kaWMgbWFpbnRlbmFuY2UgKHJ1bnMgZXZlcnkgNiBob3VycylcclxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAndGVzdCcgJiYgcHJvY2Vzcy5lbnYuRU5BQkxFX01BSU5URU5BTkNFICE9PSAnZmFsc2UnKSB7XHJcbiAgc2V0SW50ZXJ2YWwoXHJcbiAgICBhc3luYyAoKSA9PiB7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgYXdhaXQgcGVyZm9ybU1haW50ZW5hbmNlKCk7XHJcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcignU2NoZWR1bGVkIG1haW50ZW5hbmNlIGZhaWxlZDonLCBlcnJvcik7XHJcbiAgICAgIH1cclxuICAgIH0sXHJcbiAgICA2ICogNjAgKiA2MCAqIDEwMDBcclxuICApOyAvLyA2IGhvdXJzXHJcbn1cclxuXHJcbi8vIEdyYWNlZnVsIHNodXRkb3duIGhhbmRsZXJcclxuYXN5bmMgZnVuY3Rpb24gZ3JhY2VmdWxTaHV0ZG93bigpIHtcclxuICBjb25zb2xlLmxvZygn8J+UjCBDbG9zaW5nIGRhdGFiYXNlIGNvbm5lY3Rpb25zLi4uJyk7XHJcbiAgdHJ5IHtcclxuICAgIGF3YWl0IHByaXNtYS4kZGlzY29ubmVjdCgpO1xyXG4gICAgY29uc29sZS5sb2coJ+KchSBEYXRhYmFzZSBjb25uZWN0aW9ucyBjbG9zZWQgc3VjY2Vzc2Z1bGx5Jyk7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBFcnJvciBjbG9zaW5nIGRhdGFiYXNlIGNvbm5lY3Rpb25zOicsIGVycm9yKTtcclxuICB9XHJcbn1cclxuXHJcbi8vIEhhbmRsZSBwcm9jZXNzIHNodXRkb3duXHJcbnByb2Nlc3Mub24oJ1NJR0lOVCcsIGdyYWNlZnVsU2h1dGRvd24pO1xyXG5wcm9jZXNzLm9uKCdTSUdURVJNJywgZ3JhY2VmdWxTaHV0ZG93bik7XHJcbnByb2Nlc3Mub24oJ1NJR1FVSVQnLCBncmFjZWZ1bFNodXRkb3duKTtcclxuXHJcbi8vIEhhbmRsZSB1bmNhdWdodCBleGNlcHRpb25zXHJcbnByb2Nlc3Mub24oJ3VuY2F1Z2h0RXhjZXB0aW9uJywgYXN5bmMgKGVycm9yKSA9PiB7XHJcbiAgY29uc29sZS5lcnJvcignVW5jYXVnaHQgRXhjZXB0aW9uOicsIGVycm9yKTtcclxuICBhd2FpdCBncmFjZWZ1bFNodXRkb3duKCk7XHJcbiAgcHJvY2Vzcy5leGl0KDEpO1xyXG59KTtcclxuXHJcbnByb2Nlc3Mub24oJ3VuaGFuZGxlZFJlamVjdGlvbicsIGFzeW5jIChyZWFzb24sIHByb21pc2UpID0+IHtcclxuICBjb25zb2xlLmVycm9yKCdVbmhhbmRsZWQgUmVqZWN0aW9uIGF0OicsIHByb21pc2UsICdyZWFzb246JywgcmVhc29uKTtcclxuICBhd2FpdCBncmFjZWZ1bFNodXRkb3duKCk7XHJcbiAgcHJvY2Vzcy5leGl0KDEpO1xyXG59KTtcclxuXHJcbi8vIERlZmF1bHQgZXhwb3J0XHJcbmV4cG9ydCBkZWZhdWx0IHByaXNtYTtcclxuIl0sIm5hbWVzIjpbIlByaXNtYUNsaWVudCIsImdsb2JhbEZvclByaXNtYSIsImdsb2JhbFRoaXMiLCJwcmlzbWEiLCJsb2ciLCJkYXRhc291cmNlcyIsImRiIiwidXJsIiwicHJvY2VzcyIsImVudiIsIkRBVEFCQVNFX1VSTCIsIl9faW50ZXJuYWwiLCJlbmdpbmUiLCJjb25uZWN0VGltZW91dCIsInF1ZXJ5VGltZW91dCIsImNoZWNrREJIZWFsdGgiLCIkcXVlcnlSYXciLCJzdGF0dXMiLCJ0aW1lc3RhbXAiLCJEYXRlIiwidG9JU09TdHJpbmciLCJjb25uZWN0aW9uIiwidmVyc2lvbiIsImdldERhdGFiYXNlVmVyc2lvbiIsImVycm9yIiwibWVzc2FnZSIsInJlc3VsdCIsImNsZWFudXBFeHBpcmVkQ2FjaGUiLCJjYWNoZUVudHJ5IiwiZGVsZXRlTWFueSIsIndoZXJlIiwiZXhwaXJlc0F0IiwibHQiLCJjb25zb2xlIiwiY291bnQiLCJjbGVhbnVwT2xkU3luY0xvZ3MiLCJ0aGlydHlEYXlzQWdvIiwic2V0RGF0ZSIsImdldERhdGUiLCJzeW5jTG9nIiwiY3JlYXRlZEF0Iiwid2l0aFRyYW5zYWN0aW9uIiwiY2FsbGJhY2siLCIkdHJhbnNhY3Rpb24iLCJtYXhXYWl0IiwidGltZW91dCIsImlzb2xhdGlvbkxldmVsIiwiYmF0Y2hPcGVyYXRpb24iLCJvcGVyYXRpb24iLCJkYXRhIiwiYmF0Y2hTaXplIiwicmVzdWx0cyIsImVycm9ycyIsImkiLCJsZW5ndGgiLCJiYXRjaCIsInNsaWNlIiwiYmF0Y2hSZXN1bHQiLCJwdXNoIiwiYmF0Y2hJbmRleCIsIk1hdGgiLCJmbG9vciIsImdldENvbm5lY3Rpb25JbmZvIiwiZ2V0RGF0YWJhc2VNZXRyaWNzIiwiY29ubmVjdGlvbkluZm8iLCJ0YWJsZVN0YXRzIiwiaW5kZXhTdGF0cyIsIlByb21pc2UiLCJhbGwiLCJnZXRUYWJsZVN0YXRzIiwiZ2V0SW5kZXhTdGF0cyIsImNvbm5lY3Rpb25zIiwidGFibGVzIiwiaW5kZXhlcyIsImNyZWF0ZUJhY2t1cFNuYXBzaG90IiwicmVwbGFjZSIsInN1Y2Nlc3MiLCJvcHRpbWl6ZURhdGFiYXNlIiwiJGV4ZWN1dGVSYXciLCJjaGVja0RhdGFiYXNlU2VlZGVkIiwiaXBvQ291bnQiLCJpUE8iLCJ1c2VyQ291bnQiLCJ1c2VyIiwiaXNTZWVkZWQiLCJjb3VudHMiLCJpcG9zIiwidXNlcnMiLCJyZXNldFRhYmxlcyIsInRhYmxlTmFtZXMiLCJFcnJvciIsImpvaW4iLCJ0YWJsZU5hbWUiLCJ0b0xvd2VyQ2FzZSIsImdNUCIsInN1YnNjcmlwdGlvbkRhdGEiLCJtYXJrZXREZW1hbmQiLCJhbGxvdG1lbnQiLCJpUE9BbmFseXRpY3MiLCJ3YXJuIiwiZ2V0RGF0YWJhc2VTaXplIiwiZ2V0U2xvd1F1ZXJpZXMiLCJsaW1pdCIsInBlcmZvcm1NYWludGVuYW5jZSIsImFsbFNldHRsZWQiLCJzdW1tYXJ5Iiwib3BlcmF0aW9ucyIsIm5hbWUiLCJ2YWx1ZSIsInJlYXNvbiIsIkVOQUJMRV9NQUlOVEVOQU5DRSIsInNldEludGVydmFsIiwiZ3JhY2VmdWxTaHV0ZG93biIsIiRkaXNjb25uZWN0Iiwib24iLCJleGl0IiwicHJvbWlzZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./src/lib/db.js\n");

/***/ }),

/***/ "(rsc)/./src/lib/websocket.js":
/*!******************************!*\
  !*** ./src/lib/websocket.js ***!
  \******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   io: () => (/* binding */ io),\n/* harmony export */   webSocketService: () => (/* binding */ webSocketService)\n/* harmony export */ });\n/* harmony import */ var socket_io__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! socket.io */ \"(rsc)/./node_modules/socket.io/wrapper.mjs\");\n/* harmony import */ var http__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! http */ \"http\");\n/* harmony import */ var _cache_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./cache.js */ \"(rsc)/./src/lib/cache.js\");\n/* harmony import */ var _db_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./db.js */ \"(rsc)/./src/lib/db.js\");\n\n\n\n\nclass WebSocketService {\n    constructor(){\n        this.io = null;\n        this.server = null;\n        this.connectedClients = new Map();\n        this.roomSubscriptions = new Map();\n        this.port = process.env.WEBSOCKET_PORT || 3001;\n        // Event types for real-time updates\n        this.events = {\n            IPO_UPDATE: \"ipo:update\",\n            GMP_UPDATE: \"gmp:update\",\n            SUBSCRIPTION_UPDATE: \"subscription:update\",\n            DEMAND_UPDATE: \"demand:update\",\n            ALLOTMENT_UPDATE: \"allotment:update\",\n            SYSTEM_STATUS: \"system:status\",\n            ANALYTICS_UPDATE: \"analytics:update\",\n            NEWS_UPDATE: \"news:update\",\n            ALERT_TRIGGERED: \"alert:triggered\"\n        };\n        // Rate limiting configuration\n        this.rateLimits = new Map();\n        this.maxEventsPerSecond = 20;\n        this.maxSubscriptionsPerClient = 100;\n        // Performance monitoring\n        this.metrics = {\n            totalConnections: 0,\n            currentConnections: 0,\n            totalMessages: 0,\n            totalSubscriptions: 0,\n            errors: 0,\n            startTime: Date.now(),\n            averageResponseTime: 0,\n            peakConnections: 0\n        };\n        // Connection health tracking\n        this.connectionHealth = new Map();\n        // Message queue for offline clients\n        this.messageQueue = new Map();\n        this.maxQueueSize = 50;\n    }\n    // Initialize WebSocket server with enhanced configuration\n    initialize() {\n        try {\n            this.server = (0,http__WEBPACK_IMPORTED_MODULE_1__.createServer)();\n            this.io = new socket_io__WEBPACK_IMPORTED_MODULE_0__.Server(this.server, {\n                cors: {\n                    origin: process.env.FRONTEND_URL || \"http://localhost:3000\",\n                    methods: [\n                        \"GET\",\n                        \"POST\"\n                    ],\n                    credentials: true\n                },\n                pingTimeout: 60000,\n                pingInterval: 25000,\n                maxHttpBufferSize: 2e6,\n                transports: [\n                    \"websocket\",\n                    \"polling\"\n                ],\n                allowEIO3: true,\n                // Connection rate limiting\n                connectTimeout: 45000,\n                upgradeTimeout: 10000\n            });\n            this.setupEventHandlers();\n            this.startHeartbeat();\n            this.startMetricsCollection();\n            this.startHealthMonitoring();\n            console.log(\"\\uD83D\\uDD0C WebSocket service initialized successfully\");\n            return this;\n        } catch (error) {\n            console.error(\"❌ Failed to initialize WebSocket service:\", error);\n            throw error;\n        }\n    }\n    // Start the WebSocket server\n    async start() {\n        try {\n            await new Promise((resolve, reject)=>{\n                this.server.listen(this.port, (err)=>{\n                    if (err) {\n                        reject(err);\n                    } else {\n                        console.log(`🚀 WebSocket server running on port ${this.port}`);\n                        console.log(`🌐 Accepting connections from: ${process.env.FRONTEND_URL || \"http://localhost:3000\"}`);\n                        resolve();\n                    }\n                });\n            });\n            // Start periodic cleanup\n            this.startPeriodicCleanup();\n        } catch (error) {\n            console.error(\"❌ Failed to start WebSocket server:\", error);\n            throw error;\n        }\n    }\n    // Enhanced event handlers\n    setupEventHandlers() {\n        this.io.on(\"connection\", (socket)=>{\n            this.handleClientConnection(socket);\n            this.setupClientEventListeners(socket);\n            // Track metrics\n            this.metrics.totalConnections++;\n            this.metrics.currentConnections++;\n            this.metrics.peakConnections = Math.max(this.metrics.peakConnections, this.metrics.currentConnections);\n        });\n        // Handle server errors\n        this.io.on(\"error\", (error)=>{\n            console.error(\"\\uD83D\\uDD0C WebSocket server error:\", error);\n            this.metrics.errors++;\n        });\n    }\n    handleClientConnection(socket) {\n        const clientIP = socket.handshake.address;\n        const userAgent = socket.handshake.headers[\"user-agent\"] || \"Unknown\";\n        console.log(`🔌 Client connected: ${socket.id} from ${clientIP}`);\n        const clientInfo = {\n            socket,\n            connectedAt: new Date(),\n            subscriptions: new Set(),\n            lastActivity: new Date(),\n            subscriptionCount: 0,\n            messageCount: 0,\n            userAgent,\n            ipAddress: clientIP,\n            isHealthy: true,\n            lastPing: Date.now(),\n            reconnectCount: 0\n        };\n        this.connectedClients.set(socket.id, clientInfo);\n        this.connectionHealth.set(socket.id, {\n            status: \"connected\",\n            latency: 0,\n            lastSeen: Date.now()\n        });\n        // Send connection confirmation with server info\n        socket.emit(\"connected\", {\n            socketId: socket.id,\n            timestamp: Date.now(),\n            serverVersion: \"1.0.0\",\n            availableEvents: Object.values(this.events),\n            maxSubscriptions: this.maxSubscriptionsPerClient,\n            rateLimits: {\n                maxEventsPerSecond: this.maxEventsPerSecond\n            },\n            features: {\n                realTimeUpdates: true,\n                batchSubscriptions: true,\n                messageQueue: true,\n                analytics: true\n            }\n        });\n        // Send queued messages if any\n        this.sendQueuedMessages(socket.id);\n    }\n    setupClientEventListeners(socket) {\n        // IPO subscription with enhanced features\n        socket.on(\"subscribe:ipo\", async (data)=>{\n            await this.handleSubscription(socket, \"ipo\", data, async ()=>{\n                const { ipoId, symbol, includeAnalytics = false } = data;\n                if (ipoId) {\n                    socket.join(`ipo:${ipoId}`);\n                    this.addSubscription(socket.id, \"ipo\", ipoId);\n                    // Send current data immediately\n                    const ipoData = await this.getCurrentIPOData(ipoId);\n                    if (ipoData) {\n                        socket.emit(this.events.IPO_UPDATE, {\n                            ipoId,\n                            data: ipoData,\n                            type: \"initial_data\",\n                            timestamp: Date.now()\n                        });\n                        // Send analytics if requested\n                        if (includeAnalytics && ipoData.analytics) {\n                            socket.emit(this.events.ANALYTICS_UPDATE, {\n                                ipoId,\n                                data: ipoData.analytics,\n                                type: \"initial_analytics\",\n                                timestamp: Date.now()\n                            });\n                        }\n                    }\n                }\n            });\n        });\n        // Enhanced GMP subscription\n        socket.on(\"subscribe:gmp\", async (data)=>{\n            await this.handleSubscription(socket, \"gmp\", data, async ()=>{\n                const { ipoId, symbol, historical = false, alertThreshold = null } = data;\n                if (ipoId) {\n                    socket.join(`gmp:${ipoId}`);\n                    this.addSubscription(socket.id, \"gmp\", ipoId);\n                    // Send current GMP data\n                    const gmpData = await _cache_js__WEBPACK_IMPORTED_MODULE_2__.cache.getRealTimeData(\"GMP\", ipoId);\n                    if (gmpData) {\n                        socket.emit(this.events.GMP_UPDATE, {\n                            ipoId,\n                            data: gmpData,\n                            type: \"current\",\n                            timestamp: Date.now()\n                        });\n                    }\n                    // Send historical data if requested\n                    if (historical) {\n                        const historicalGMP = await this.getHistoricalGMPData(ipoId, 30);\n                        socket.emit(\"gmp:historical\", {\n                            ipoId,\n                            data: historicalGMP,\n                            type: \"historical\",\n                            days: 30\n                        });\n                    }\n                    // Set up alert threshold if provided\n                    if (alertThreshold !== null) {\n                        this.setupGMPAlert(socket.id, ipoId, alertThreshold);\n                    }\n                }\n            });\n        });\n        // Real-time subscription data updates\n        socket.on(\"subscribe:subscription\", async (data)=>{\n            await this.handleSubscription(socket, \"subscription\", data, async ()=>{\n                const { symbol, categories = [], realTime = true } = data;\n                socket.join(`subscription:${symbol}`);\n                this.addSubscription(socket.id, \"subscription\", symbol);\n                // Send current subscription data\n                const subData = await _cache_js__WEBPACK_IMPORTED_MODULE_2__.cache.getRealTimeData(\"SUBSCRIPTION\", symbol);\n                if (subData) {\n                    const filteredData = categories.length > 0 ? subData.data?.filter((item)=>categories.includes(item.category)) : subData;\n                    socket.emit(this.events.SUBSCRIPTION_UPDATE, {\n                        symbol,\n                        data: filteredData,\n                        categories: categories.length > 0 ? categories : \"all\",\n                        timestamp: Date.now()\n                    });\n                }\n            });\n        });\n        // Market demand updates with price filtering\n        socket.on(\"subscribe:demand\", async (data)=>{\n            await this.handleSubscription(socket, \"demand\", data, async ()=>{\n                const { symbol, priceRange = null, cutOffOnly = false } = data;\n                socket.join(`demand:${symbol}`);\n                this.addSubscription(socket.id, \"demand\", symbol);\n                // Send current demand data\n                const demandData = await _cache_js__WEBPACK_IMPORTED_MODULE_2__.cache.getRealTimeData(\"DEMAND\", symbol);\n                if (demandData) {\n                    let filteredData = demandData.data || [];\n                    // Apply filters\n                    if (cutOffOnly) {\n                        filteredData = filteredData.filter((item)=>item.cutOffIndicator);\n                    }\n                    if (priceRange && priceRange.min !== undefined && priceRange.max !== undefined) {\n                        filteredData = filteredData.filter((item)=>item.price >= priceRange.min && item.price <= priceRange.max);\n                    }\n                    socket.emit(this.events.DEMAND_UPDATE, {\n                        symbol,\n                        data: filteredData,\n                        filters: {\n                            priceRange,\n                            cutOffOnly\n                        },\n                        timestamp: Date.now()\n                    });\n                }\n            });\n        });\n        // Analytics subscription with customizable metrics\n        socket.on(\"subscribe:analytics\", async (data)=>{\n            await this.handleSubscription(socket, \"analytics\", data, async ()=>{\n                const { ipoId, type = \"all\", metrics = [], updateInterval = 30000 } = data;\n                socket.join(`analytics:${ipoId}`);\n                this.addSubscription(socket.id, \"analytics\", ipoId);\n                // Send current analytics\n                const analytics = await this.getCurrentAnalytics(ipoId, type);\n                if (analytics) {\n                    const filteredAnalytics = metrics.length > 0 ? this.filterAnalyticsByMetrics(analytics, metrics) : analytics;\n                    socket.emit(this.events.ANALYTICS_UPDATE, {\n                        ipoId,\n                        type,\n                        data: filteredAnalytics,\n                        metrics: metrics.length > 0 ? metrics : \"all\",\n                        timestamp: Date.now()\n                    });\n                }\n            });\n        });\n        // System status subscription\n        socket.on(\"subscribe:system\", async ()=>{\n            socket.join(\"system:status\");\n            this.addSubscription(socket.id, \"system\", \"status\");\n            // Send current system status\n            const systemStatus = await this.getSystemStatus();\n            socket.emit(this.events.SYSTEM_STATUS, {\n                ...systemStatus,\n                type: \"current_status\",\n                timestamp: Date.now()\n            });\n        });\n        // Batch subscription for multiple IPOs with advanced options\n        socket.on(\"subscribe:batch\", async (data)=>{\n            const { subscriptions = [], options = {} } = data;\n            const { maxSubscriptions = 20, skipErrors = true } = options;\n            const results = [];\n            // Limit batch size\n            const limitedSubscriptions = subscriptions.slice(0, maxSubscriptions);\n            for (const sub of limitedSubscriptions){\n                try {\n                    await this.handleSingleSubscription(socket, sub);\n                    results.push({\n                        ...sub,\n                        status: \"success\"\n                    });\n                } catch (error) {\n                    results.push({\n                        ...sub,\n                        status: \"error\",\n                        error: error.message\n                    });\n                    if (!skipErrors) {\n                        break;\n                    }\n                }\n            }\n            socket.emit(\"subscribe:batch:result\", {\n                results,\n                processed: results.length,\n                successful: results.filter((r)=>r.status === \"success\").length,\n                errors: results.filter((r)=>r.status === \"error\").length,\n                timestamp: Date.now()\n            });\n        });\n        // Enhanced unsubscribe with patterns\n        socket.on(\"unsubscribe\", (data)=>{\n            const { type, identifier, pattern } = data;\n            if (pattern === \"all\") {\n                this.unsubscribeAll(socket.id);\n                socket.emit(\"unsubscribe:result\", {\n                    pattern: \"all\",\n                    status: \"success\",\n                    message: \"Unsubscribed from all events\"\n                });\n            } else if (type && identifier) {\n                const roomKey = `${type}:${identifier}`;\n                socket.leave(roomKey);\n                this.removeSubscription(socket.id, type, identifier);\n                socket.emit(\"unsubscribe:result\", {\n                    type,\n                    identifier,\n                    status: \"success\"\n                });\n            } else if (type) {\n                // Unsubscribe from all subscriptions of a specific type\n                this.unsubscribeByType(socket.id, type);\n                socket.emit(\"unsubscribe:result\", {\n                    type,\n                    status: \"success\",\n                    message: `Unsubscribed from all ${type} events`\n                });\n            }\n        });\n        // Enhanced heartbeat with performance metrics\n        socket.on(\"ping\", (data)=>{\n            const client = this.connectedClients.get(socket.id);\n            const now = Date.now();\n            if (client) {\n                client.lastActivity = new Date();\n                client.messageCount++;\n                client.lastPing = now;\n            }\n            // Calculate latency\n            const latency = data?.timestamp ? now - data.timestamp : 0;\n            this.connectionHealth.set(socket.id, {\n                status: \"healthy\",\n                latency,\n                lastSeen: now\n            });\n            socket.emit(\"pong\", {\n                timestamp: now,\n                serverUptime: now - this.metrics.startTime,\n                latency,\n                clientInfo: client ? {\n                    subscriptions: client.subscriptionCount,\n                    messages: client.messageCount,\n                    connectedFor: now - client.connectedAt.getTime()\n                } : null\n            });\n        });\n        // Client info and statistics request\n        socket.on(\"client:info\", ()=>{\n            const client = this.connectedClients.get(socket.id);\n            const health = this.connectionHealth.get(socket.id);\n            if (client) {\n                socket.emit(\"client:info\", {\n                    socketId: socket.id,\n                    connectedAt: client.connectedAt,\n                    subscriptions: Array.from(client.subscriptions),\n                    subscriptionCount: client.subscriptionCount,\n                    messageCount: client.messageCount,\n                    userAgent: client.userAgent,\n                    ipAddress: client.ipAddress,\n                    health: health || {\n                        status: \"unknown\"\n                    },\n                    serverMetrics: {\n                        totalConnections: this.metrics.currentConnections,\n                        serverUptime: Date.now() - this.metrics.startTime\n                    }\n                });\n            }\n        });\n        // Request server statistics\n        socket.on(\"server:stats\", ()=>{\n            if (this.isAuthorized(socket)) {\n                // Only for authorized clients\n                const stats = this.getDetailedStats();\n                socket.emit(\"server:stats\", stats);\n            } else {\n                socket.emit(\"error\", {\n                    type: \"unauthorized\",\n                    message: \"Not authorized to view server statistics\"\n                });\n            }\n        });\n        // Error handling\n        socket.on(\"error\", (error)=>{\n            console.error(`🔌 Socket error for ${socket.id}:`, error);\n            this.metrics.errors++;\n            const client = this.connectedClients.get(socket.id);\n            if (client) {\n                client.isHealthy = false;\n            }\n            this.connectionHealth.set(socket.id, {\n                status: \"error\",\n                error: error.message,\n                lastSeen: Date.now()\n            });\n        });\n        // Disconnect handling with cleanup\n        socket.on(\"disconnect\", (reason)=>{\n            console.log(`🔌 Client disconnected: ${socket.id}, reason: ${reason}`);\n            const client = this.connectedClients.get(socket.id);\n            if (client) {\n                // Store disconnection info for potential reconnection\n                this.handleClientDisconnection(socket.id, reason);\n            }\n            this.cleanupClient(socket.id);\n            this.metrics.currentConnections--;\n        });\n        // Reconnection handling\n        socket.on(\"reconnect\", (data)=>{\n            console.log(`🔄 Client reconnected: ${socket.id}`);\n            const client = this.connectedClients.get(socket.id);\n            if (client) {\n                client.reconnectCount++;\n                client.lastActivity = new Date();\n                // Send queued messages\n                this.sendQueuedMessages(socket.id);\n            }\n        });\n    }\n    // Enhanced subscription handling with validation\n    async handleSubscription(socket, type, data, subscriptionLogic) {\n        try {\n            const client = this.connectedClients.get(socket.id);\n            if (!client) {\n                throw new Error(\"Client not found\");\n            }\n            // Check subscription limits\n            if (client.subscriptionCount >= this.maxSubscriptionsPerClient) {\n                throw new Error(`Maximum subscriptions limit reached (${this.maxSubscriptionsPerClient})`);\n            }\n            // Check rate limits\n            if (!this.checkRateLimit(socket.id, type)) {\n                throw new Error(\"Rate limit exceeded. Please slow down.\");\n            }\n            // Validate subscription data\n            this.validateSubscriptionData(type, data);\n            // Execute subscription logic\n            await subscriptionLogic();\n            // Update client info\n            client.lastActivity = new Date();\n            client.messageCount++;\n            // Send success confirmation\n            socket.emit(\"subscribe:success\", {\n                type,\n                data,\n                timestamp: Date.now(),\n                subscriptionCount: client.subscriptionCount\n            });\n        } catch (error) {\n            console.error(`Subscription failed for ${socket.id}:`, error.message);\n            socket.emit(\"subscribe:error\", {\n                type: \"subscription_failed\",\n                message: error.message,\n                subscriptionType: type,\n                data,\n                timestamp: Date.now()\n            });\n        }\n    }\n    // Validate subscription data\n    validateSubscriptionData(type, data) {\n        switch(type){\n            case \"ipo\":\n                if (!data.ipoId && !data.symbol) {\n                    throw new Error(\"Either ipoId or symbol is required for IPO subscription\");\n                }\n                break;\n            case \"gmp\":\n                if (!data.ipoId && !data.symbol) {\n                    throw new Error(\"Either ipoId or symbol is required for GMP subscription\");\n                }\n                break;\n            case \"subscription\":\n            case \"demand\":\n                if (!data.symbol) {\n                    throw new Error(\"Symbol is required for subscription/demand data\");\n                }\n                break;\n            case \"analytics\":\n                if (!data.ipoId) {\n                    throw new Error(\"IPO ID is required for analytics subscription\");\n                }\n                break;\n        }\n    }\n    // Handle single subscription (for batch operations)\n    async handleSingleSubscription(socket, { type, ipoId, symbol, options = {} }) {\n        switch(type){\n            case \"ipo\":\n                if (ipoId) {\n                    socket.join(`ipo:${ipoId}`);\n                    this.addSubscription(socket.id, \"ipo\", ipoId);\n                }\n                break;\n            case \"gmp\":\n                if (ipoId) {\n                    socket.join(`gmp:${ipoId}`);\n                    this.addSubscription(socket.id, \"gmp\", ipoId);\n                }\n                break;\n            case \"subscription\":\n                if (symbol) {\n                    socket.join(`subscription:${symbol}`);\n                    this.addSubscription(socket.id, \"subscription\", symbol);\n                }\n                break;\n            case \"demand\":\n                if (symbol) {\n                    socket.join(`demand:${symbol}`);\n                    this.addSubscription(socket.id, \"demand\", symbol);\n                }\n                break;\n            case \"analytics\":\n                if (ipoId) {\n                    socket.join(`analytics:${ipoId}`);\n                    this.addSubscription(socket.id, \"analytics\", ipoId);\n                }\n                break;\n            default:\n                throw new Error(`Unknown subscription type: ${type}`);\n        }\n    }\n    // Enhanced rate limiting\n    checkRateLimit(socketId, eventType) {\n        const key = `${socketId}:${eventType}`;\n        const now = Date.now();\n        const windowStart = Math.floor(now / 1000) * 1000;\n        if (!this.rateLimits.has(key)) {\n            this.rateLimits.set(key, {\n                count: 0,\n                windowStart\n            });\n        }\n        const limit = this.rateLimits.get(key);\n        if (limit.windowStart !== windowStart) {\n            limit.count = 0;\n            limit.windowStart = windowStart;\n        }\n        if (limit.count >= this.maxEventsPerSecond) {\n            return false;\n        }\n        limit.count++;\n        return true;\n    }\n    // Subscription management\n    addSubscription(socketId, type, identifier) {\n        const client = this.connectedClients.get(socketId);\n        if (client) {\n            const subscriptionKey = `${type}:${identifier}`;\n            client.subscriptions.add(subscriptionKey);\n            client.subscriptionCount = client.subscriptions.size;\n            // Track room subscriptions\n            if (!this.roomSubscriptions.has(subscriptionKey)) {\n                this.roomSubscriptions.set(subscriptionKey, new Set());\n            }\n            this.roomSubscriptions.get(subscriptionKey).add(socketId);\n            this.metrics.totalSubscriptions++;\n        }\n    }\n    removeSubscription(socketId, type, identifier) {\n        const client = this.connectedClients.get(socketId);\n        if (client) {\n            const subscriptionKey = `${type}:${identifier}`;\n            client.subscriptions.delete(subscriptionKey);\n            client.subscriptionCount = client.subscriptions.size;\n            // Remove from room subscriptions\n            const roomSubs = this.roomSubscriptions.get(subscriptionKey);\n            if (roomSubs) {\n                roomSubs.delete(socketId);\n                if (roomSubs.size === 0) {\n                    this.roomSubscriptions.delete(subscriptionKey);\n                }\n            }\n        }\n    }\n    unsubscribeAll(socketId) {\n        const client = this.connectedClients.get(socketId);\n        if (client) {\n            for (const subscription of client.subscriptions){\n                const [type, identifier] = subscription.split(\":\");\n                client.socket.leave(subscription);\n                this.removeSubscription(socketId, type, identifier);\n            }\n        }\n    }\n    unsubscribeByType(socketId, type) {\n        const client = this.connectedClients.get(socketId);\n        if (client) {\n            const subscriptionsToRemove = Array.from(client.subscriptions).filter((sub)=>sub.startsWith(`${type}:`));\n            for (const subscription of subscriptionsToRemove){\n                const [, identifier] = subscription.split(\":\");\n                client.socket.leave(subscription);\n                this.removeSubscription(socketId, type, identifier);\n            }\n        }\n    }\n    // Enhanced broadcasting methods\n    async broadcastIPOUpdate(ipoId, updateData, options = {}) {\n        try {\n            const { priority = \"normal\", excludeSocket = null, includeAnalytics = false } = options;\n            if (!this.checkBroadcastRateLimit(\"ipo\", ipoId)) {\n                return;\n            }\n            const room = `ipo:${ipoId}`;\n            const subscriberCount = this.roomSubscriptions.get(room)?.size || 0;\n            if (subscriberCount > 0) {\n                const enrichedData = {\n                    ipoId,\n                    data: updateData,\n                    timestamp: Date.now(),\n                    priority,\n                    server: process.env.SERVER_ID || \"ws-1\",\n                    type: \"update\"\n                };\n                if (includeAnalytics && updateData.analytics) {\n                    enrichedData.analytics = updateData.analytics;\n                }\n                if (excludeSocket) {\n                    this.io.to(room).except(excludeSocket).emit(this.events.IPO_UPDATE, enrichedData);\n                } else {\n                    this.io.to(room).emit(this.events.IPO_UPDATE, enrichedData);\n                }\n                console.log(`📡 IPO update broadcast to ${subscriberCount} clients for IPO ${ipoId}`);\n                this.metrics.totalMessages++;\n                // Queue message for offline clients if critical\n                if (priority === \"high\") {\n                    this.queueMessageForOfflineClients(room, enrichedData);\n                }\n            }\n        } catch (error) {\n            console.error(\"Error broadcasting IPO update:\", error);\n            this.metrics.errors++;\n        }\n    }\n    async broadcastGMPUpdate(ipoId, gmpData, options = {}) {\n        try {\n            const { historical = false, alertCheck = true } = options;\n            if (!this.checkBroadcastRateLimit(\"gmp\", ipoId)) {\n                return;\n            }\n            const room = `gmp:${ipoId}`;\n            const subscriberCount = this.roomSubscriptions.get(room)?.size || 0;\n            if (subscriberCount > 0) {\n                const change = await this.calculateGMPChange(ipoId, gmpData.value);\n                const enrichedData = {\n                    ipoId,\n                    data: gmpData,\n                    timestamp: Date.now(),\n                    historical,\n                    change,\n                    trend: this.calculateGMPTrend(change),\n                    volatility: await this.calculateGMPVolatility(ipoId)\n                };\n                this.io.to(room).emit(this.events.GMP_UPDATE, enrichedData);\n                console.log(`💰 GMP update broadcast to ${subscriberCount} clients for IPO ${ipoId} (Value: ${gmpData.value})`);\n                this.metrics.totalMessages++;\n                // Check for GMP alerts\n                if (alertCheck) {\n                    this.checkGMPAlerts(ipoId, gmpData.value);\n                }\n            }\n        } catch (error) {\n            console.error(\"Error broadcasting GMP update:\", error);\n            this.metrics.errors++;\n        }\n    }\n    async broadcastSubscriptionUpdate(symbol, subscriptionData, options = {}) {\n        try {\n            const { category = null, alertOnOversubscription = true } = options;\n            if (!this.checkBroadcastRateLimit(\"subscription\", symbol)) {\n                return;\n            }\n            const room = `subscription:${symbol}`;\n            const subscriberCount = this.roomSubscriptions.get(room)?.size || 0;\n            if (subscriberCount > 0) {\n                const enrichedData = {\n                    symbol,\n                    data: subscriptionData,\n                    timestamp: Date.now(),\n                    category,\n                    overallSubscription: this.calculateOverallSubscription(subscriptionData),\n                    isOversubscribed: this.isOversubscribed(subscriptionData)\n                };\n                this.io.to(room).emit(this.events.SUBSCRIPTION_UPDATE, enrichedData);\n                console.log(`📊 Subscription update broadcast to ${subscriberCount} clients for ${symbol}`);\n                this.metrics.totalMessages++;\n                // Alert on oversubscription\n                if (alertOnOversubscription && enrichedData.isOversubscribed) {\n                    this.broadcastAlert(\"oversubscription\", {\n                        symbol,\n                        subscription: enrichedData.overallSubscription,\n                        timestamp: Date.now()\n                    });\n                }\n            }\n        } catch (error) {\n            console.error(\"Error broadcasting subscription update:\", error);\n            this.metrics.errors++;\n        }\n    }\n    async broadcastDemandUpdate(symbol, demandData, options = {}) {\n        try {\n            const { priceLevel = null } = options;\n            if (!this.checkBroadcastRateLimit(\"demand\", symbol)) {\n                return;\n            }\n            const room = `demand:${symbol}`;\n            const subscriberCount = this.roomSubscriptions.get(room)?.size || 0;\n            if (subscriberCount > 0) {\n                const enrichedData = {\n                    symbol,\n                    data: demandData,\n                    timestamp: Date.now(),\n                    priceLevel,\n                    totalDemand: this.calculateTotalDemand(demandData),\n                    cutOffDemand: this.calculateCutOffDemand(demandData)\n                };\n                this.io.to(room).emit(this.events.DEMAND_UPDATE, enrichedData);\n                console.log(`📈 Demand update broadcast to ${subscriberCount} clients for ${symbol}`);\n                this.metrics.totalMessages++;\n            }\n        } catch (error) {\n            console.error(\"Error broadcasting demand update:\", error);\n            this.metrics.errors++;\n        }\n    }\n    async broadcastAnalyticsUpdate(ipoId, analyticsData, options = {}) {\n        try {\n            const { type = \"general\", metrics = null } = options;\n            if (!this.checkBroadcastRateLimit(\"analytics\", ipoId)) {\n                return;\n            }\n            const room = `analytics:${ipoId}`;\n            const subscriberCount = this.roomSubscriptions.get(room)?.size || 0;\n            if (subscriberCount > 0) {\n                const enrichedData = {\n                    ipoId,\n                    type,\n                    data: analyticsData,\n                    metrics,\n                    timestamp: Date.now(),\n                    insights: await this.generateAnalyticsInsights(analyticsData)\n                };\n                this.io.to(room).emit(this.events.ANALYTICS_UPDATE, enrichedData);\n                console.log(`📊 Analytics update broadcast to ${subscriberCount} clients for IPO ${ipoId}`);\n                this.metrics.totalMessages++;\n            }\n        } catch (error) {\n            console.error(\"Error broadcasting analytics update:\", error);\n            this.metrics.errors++;\n        }\n    }\n    // Broadcast system status\n    async broadcastSystemStatus(status, options = {}) {\n        try {\n            const { priority = \"normal\", room = \"system:status\" } = options;\n            const subscriberCount = this.roomSubscriptions.get(room)?.size || 0;\n            if (subscriberCount > 0) {\n                const enrichedStatus = {\n                    ...status,\n                    timestamp: Date.now(),\n                    server: process.env.SERVER_ID || \"ws-1\",\n                    priority,\n                    connections: this.metrics.currentConnections\n                };\n                this.io.to(room).emit(this.events.SYSTEM_STATUS, enrichedStatus);\n                console.log(`🔔 System status broadcast to ${subscriberCount} clients`);\n                this.metrics.totalMessages++;\n            }\n        } catch (error) {\n            console.error(\"Error broadcasting system status:\", error);\n            this.metrics.errors++;\n        }\n    }\n    // Broadcast alerts\n    async broadcastAlert(alertType, alertData) {\n        try {\n            const enrichedAlert = {\n                type: alertType,\n                data: alertData,\n                timestamp: Date.now(),\n                server: process.env.SERVER_ID || \"ws-1\",\n                severity: this.getAlertSeverity(alertType)\n            };\n            // Broadcast to all connected clients\n            this.io.emit(this.events.ALERT_TRIGGERED, enrichedAlert);\n            console.log(`🚨 Alert broadcast: ${alertType}`);\n            this.metrics.totalMessages++;\n            // Store alert for queuing\n            this.queueMessageForOfflineClients(\"global\", enrichedAlert);\n        } catch (error) {\n            console.error(\"Error broadcasting alert:\", error);\n            this.metrics.errors++;\n        }\n    }\n    // Broadcast rate limiting\n    checkBroadcastRateLimit(eventType, identifier) {\n        const key = `broadcast:${eventType}:${identifier}`;\n        const now = Date.now();\n        const windowStart = Math.floor(now / 5000) * 5000; // 5-second window\n        if (!this.rateLimits.has(key)) {\n            this.rateLimits.set(key, {\n                count: 0,\n                windowStart\n            });\n        }\n        const limit = this.rateLimits.get(key);\n        if (limit.windowStart !== windowStart) {\n            limit.count = 0;\n            limit.windowStart = windowStart;\n        }\n        // Max 10 broadcasts per 5 seconds per event type\n        if (limit.count >= 10) {\n            return false;\n        }\n        limit.count++;\n        return true;\n    }\n    // Calculate GMP change and trend\n    async calculateGMPChange(ipoId, currentValue) {\n        try {\n            if (!this.previousGMPValues) {\n                this.previousGMPValues = new Map();\n            }\n            const previousValue = this.previousGMPValues.get(ipoId) || currentValue;\n            this.previousGMPValues.set(ipoId, currentValue);\n            return {\n                absolute: currentValue - previousValue,\n                percentage: previousValue > 0 ? parseFloat(((currentValue - previousValue) / previousValue * 100).toFixed(2)) : 0,\n                direction: currentValue > previousValue ? \"up\" : currentValue < previousValue ? \"down\" : \"stable\"\n            };\n        } catch (error) {\n            return {\n                absolute: 0,\n                percentage: 0,\n                direction: \"stable\"\n            };\n        }\n    }\n    calculateGMPTrend(change) {\n        if (Math.abs(change.percentage) < 1) return \"stable\";\n        if (change.percentage > 5) return \"bullish\";\n        if (change.percentage < -5) return \"bearish\";\n        return change.direction;\n    }\n    async calculateGMPVolatility(ipoId) {\n        try {\n            const recentGMP = await _db_js__WEBPACK_IMPORTED_MODULE_3__.prisma.gMP.findMany({\n                where: {\n                    ipoId\n                },\n                orderBy: {\n                    timestamp: \"desc\"\n                },\n                take: 10\n            });\n            if (recentGMP.length < 2) return 0;\n            const values = recentGMP.map((g)=>g.value);\n            const mean = values.reduce((a, b)=>a + b) / values.length;\n            const variance = values.reduce((acc, val)=>acc + Math.pow(val - mean, 2), 0) / values.length;\n            return Math.round(Math.sqrt(variance) * 100) / 100;\n        } catch (error) {\n            return 0;\n        }\n    }\n    // Subscription calculation utilities\n    calculateOverallSubscription(subscriptionData) {\n        if (!Array.isArray(subscriptionData)) return 0;\n        const ratios = subscriptionData.map((item)=>parseFloat(item.subscriptionRatio || 0));\n        return ratios.length > 0 ? Math.max(...ratios) : 0;\n    }\n    isOversubscribed(subscriptionData) {\n        return this.calculateOverallSubscription(subscriptionData) > 1;\n    }\n    calculateTotalDemand(demandData) {\n        if (!Array.isArray(demandData)) return 0;\n        return demandData.reduce((total, item)=>total + parseInt(item.absoluteQuantity || 0), 0);\n    }\n    calculateCutOffDemand(demandData) {\n        if (!Array.isArray(demandData)) return 0;\n        return demandData.filter((item)=>item.cutOffIndicator).reduce((total, item)=>total + parseInt(item.absoluteQuantity || 0), 0);\n    }\n    // Generate analytics insights\n    async generateAnalyticsInsights(analyticsData) {\n        const insights = [];\n        try {\n            if (analyticsData.gmpVolatility > 20) {\n                insights.push({\n                    type: \"warning\",\n                    message: \"High GMP volatility detected\",\n                    value: analyticsData.gmpVolatility\n                });\n            }\n            if (analyticsData.finalSubscription > 5) {\n                insights.push({\n                    type: \"positive\",\n                    message: \"Strong subscription demand\",\n                    value: analyticsData.finalSubscription\n                });\n            }\n            if (analyticsData.riskScore > 70) {\n                insights.push({\n                    type: \"caution\",\n                    message: \"High risk score\",\n                    value: analyticsData.riskScore\n                });\n            }\n        } catch (error) {\n            console.error(\"Error generating insights:\", error);\n        }\n        return insights;\n    }\n    // Data fetching methods\n    async getCurrentIPOData(ipoId) {\n        try {\n            const ipo = await _db_js__WEBPACK_IMPORTED_MODULE_3__.prisma.iPO.findUnique({\n                where: {\n                    id: ipoId\n                },\n                include: {\n                    gmp: {\n                        take: 5,\n                        orderBy: {\n                            timestamp: \"desc\"\n                        }\n                    },\n                    subscription: {\n                        orderBy: {\n                            timestamp: \"desc\"\n                        },\n                        take: 10\n                    },\n                    analytics: true,\n                    categories: true\n                }\n            });\n            return ipo;\n        } catch (error) {\n            console.error(\"Error fetching current IPO data:\", error);\n            return null;\n        }\n    }\n    async getHistoricalGMPData(ipoId, days = 30) {\n        try {\n            const startDate = new Date();\n            startDate.setDate(startDate.getDate() - days);\n            const gmpData = await _db_js__WEBPACK_IMPORTED_MODULE_3__.prisma.gMP.findMany({\n                where: {\n                    ipoId,\n                    timestamp: {\n                        gte: startDate\n                    }\n                },\n                orderBy: {\n                    timestamp: \"asc\"\n                },\n                take: 1000\n            });\n            return gmpData;\n        } catch (error) {\n            console.error(\"Error fetching historical GMP data:\", error);\n            return [];\n        }\n    }\n    async getCurrentAnalytics(ipoId, type = \"all\") {\n        try {\n            const analytics = await _db_js__WEBPACK_IMPORTED_MODULE_3__.prisma.iPOAnalytics.findUnique({\n                where: {\n                    ipoId\n                }\n            });\n            if (type === \"all\") {\n                return analytics;\n            }\n            // Return specific analytics based on type\n            const typeMapping = {\n                gmp: [\n                    \"avgGMP\",\n                    \"maxGMP\",\n                    \"minGMP\",\n                    \"gmpVolatility\"\n                ],\n                subscription: [\n                    \"finalSubscription\",\n                    \"retailSubscription\",\n                    \"qibSubscription\"\n                ],\n                prediction: [\n                    \"predictedListingGain\",\n                    \"allotmentProbability\",\n                    \"riskScore\"\n                ]\n            };\n            if (typeMapping[type] && analytics) {\n                const filteredAnalytics = {};\n                typeMapping[type].forEach((key)=>{\n                    if (analytics[key] !== undefined) {\n                        filteredAnalytics[key] = analytics[key];\n                    }\n                });\n                return filteredAnalytics;\n            }\n            return analytics;\n        } catch (error) {\n            console.error(\"Error fetching analytics:\", error);\n            return null;\n        }\n    }\n    // System status\n    async getSystemStatus() {\n        try {\n            const [dbHealth, cacheHealth] = await Promise.allSettled([\n                _db_js__WEBPACK_IMPORTED_MODULE_3__.prisma.$queryRaw`SELECT 1`,\n                _cache_js__WEBPACK_IMPORTED_MODULE_2__.cache.healthCheck()\n            ]);\n            return {\n                status: \"operational\",\n                connections: this.metrics.currentConnections,\n                uptime: Date.now() - this.metrics.startTime,\n                database: dbHealth.status === \"fulfilled\" ? \"healthy\" : \"degraded\",\n                cache: cacheHealth.status === \"fulfilled\" && cacheHealth.value.status === \"healthy\" ? \"healthy\" : \"degraded\",\n                websocket: \"healthy\",\n                version: \"1.0.0\"\n            };\n        } catch (error) {\n            return {\n                status: \"degraded\",\n                error: error.message,\n                uptime: Date.now() - this.metrics.startTime\n            };\n        }\n    }\n    // Filter analytics by specific metrics\n    filterAnalyticsByMetrics(analytics, metrics) {\n        if (!analytics || !Array.isArray(metrics)) return analytics;\n        const filtered = {};\n        metrics.forEach((metric)=>{\n            if (analytics[metric] !== undefined) {\n                filtered[metric] = analytics[metric];\n            }\n        });\n        return filtered;\n    }\n    // GMP Alert management\n    setupGMPAlert(socketId, ipoId, threshold) {\n        if (!this.gmpAlerts) {\n            this.gmpAlerts = new Map();\n        }\n        const alertKey = `${socketId}:${ipoId}`;\n        this.gmpAlerts.set(alertKey, {\n            threshold,\n            triggered: false,\n            createdAt: Date.now()\n        });\n    }\n    checkGMPAlerts(ipoId, currentGMP) {\n        if (!this.gmpAlerts) return;\n        for (const [alertKey, alert] of this.gmpAlerts){\n            const [socketId, alertIpoId] = alertKey.split(\":\");\n            if (alertIpoId === ipoId && !alert.triggered) {\n                if (currentGMP >= alert.threshold) {\n                    const client = this.connectedClients.get(socketId);\n                    if (client) {\n                        client.socket.emit(this.events.ALERT_TRIGGERED, {\n                            type: \"gmp_threshold\",\n                            ipoId,\n                            threshold: alert.threshold,\n                            currentValue: currentGMP,\n                            timestamp: Date.now()\n                        });\n                        alert.triggered = true;\n                        console.log(`🚨 GMP alert triggered for ${socketId}: ${ipoId} reached ${currentGMP}`);\n                    }\n                }\n            }\n        }\n    }\n    // Get alert severity\n    getAlertSeverity(alertType) {\n        const severityMap = {\n            gmp_threshold: \"medium\",\n            oversubscription: \"high\",\n            system_error: \"critical\",\n            connection_issue: \"low\",\n            rate_limit: \"medium\"\n        };\n        return severityMap[alertType] || \"low\";\n    }\n    // Message queuing for offline clients\n    queueMessageForOfflineClients(room, message) {\n        if (!this.messageQueue.has(room)) {\n            this.messageQueue.set(room, []);\n        }\n        const queue = this.messageQueue.get(room);\n        queue.push({\n            message,\n            timestamp: Date.now()\n        });\n        // Keep only the latest messages\n        if (queue.length > this.maxQueueSize) {\n            queue.splice(0, queue.length - this.maxQueueSize);\n        }\n    }\n    sendQueuedMessages(socketId) {\n        const client = this.connectedClients.get(socketId);\n        if (!client) return;\n        // Send queued messages for subscribed rooms\n        for (const subscription of client.subscriptions){\n            const queuedMessages = this.messageQueue.get(subscription);\n            if (queuedMessages && queuedMessages.length > 0) {\n                client.socket.emit(\"queued:messages\", {\n                    room: subscription,\n                    messages: queuedMessages,\n                    count: queuedMessages.length\n                });\n                // Clear the queue after sending\n                this.messageQueue.delete(subscription);\n            }\n        }\n    }\n    // Client disconnection handling\n    handleClientDisconnection(socketId, reason) {\n        const client = this.connectedClients.get(socketId);\n        if (client) {\n            // Store disconnection info\n            this.disconnectionLog = this.disconnectionLog || new Map();\n            this.disconnectionLog.set(socketId, {\n                reason,\n                disconnectedAt: Date.now(),\n                subscriptions: Array.from(client.subscriptions),\n                reconnectCount: client.reconnectCount\n            });\n            // Keep only recent disconnections\n            if (this.disconnectionLog.size > 1000) {\n                const entries = Array.from(this.disconnectionLog.entries());\n                entries.sort((a, b)=>b[1].disconnectedAt - a[1].disconnectedAt);\n                this.disconnectionLog = new Map(entries.slice(0, 500));\n            }\n        }\n    }\n    // Authorization check (implement based on your auth system)\n    isAuthorized(socket) {\n        // Implement your authorization logic here\n        // For now, return true for basic functionality\n        return true;\n    }\n    // Enhanced heartbeat with health monitoring\n    startHeartbeat() {\n        setInterval(()=>{\n            const now = Date.now();\n            const staleThreshold = 5 * 60 * 1000; // 5 minutes\n            const staleClients = [];\n            for (const [socketId, client] of this.connectedClients){\n                const timeSinceLastActivity = now - client.lastActivity.getTime();\n                if (timeSinceLastActivity > staleThreshold) {\n                    console.log(`🧹 Disconnecting stale client: ${socketId} (inactive for ${Math.round(timeSinceLastActivity / 1000)}s)`);\n                    client.socket.disconnect(true);\n                    staleClients.push(socketId);\n                }\n            }\n            if (staleClients.length > 0) {\n                console.log(`🧹 Cleaned up ${staleClients.length} stale connections`);\n            }\n            // Broadcast system heartbeat every 5 minutes\n            if (now % (5 * 60 * 1000) < 60000) {\n                // Within 1 minute of 5-minute mark\n                this.broadcastSystemStatus({\n                    type: \"heartbeat\",\n                    status: \"healthy\",\n                    uptime: now - this.metrics.startTime,\n                    connections: this.metrics.currentConnections,\n                    message: \"System running normally\"\n                });\n            }\n        }, 60000); // Check every minute\n    }\n    // Health monitoring\n    startHealthMonitoring() {\n        setInterval(()=>{\n            const now = Date.now();\n            // Monitor connection health\n            for (const [socketId, health] of this.connectionHealth){\n                if (now - health.lastSeen > 2 * 60 * 1000) {\n                    // 2 minutes\n                    health.status = \"stale\";\n                }\n                if (health.latency > 1000) {\n                    // High latency\n                    health.status = \"degraded\";\n                }\n            }\n            // Clean up old health records\n            const healthEntries = Array.from(this.connectionHealth.entries());\n            const activeClients = new Set(this.connectedClients.keys());\n            for (const [socketId] of healthEntries){\n                if (!activeClients.has(socketId)) {\n                    this.connectionHealth.delete(socketId);\n                }\n            }\n        }, 30000); // Every 30 seconds\n    }\n    // Metrics collection\n    startMetricsCollection() {\n        setInterval(()=>{\n            const stats = this.getDetailedStats();\n            console.log(`📊 WebSocket Metrics: Connections: ${stats.connections}, Messages: ${stats.totalMessages}, Uptime: ${Math.round(stats.uptime / 1000)}s`);\n            // Store metrics in cache for monitoring dashboards\n            _cache_js__WEBPACK_IMPORTED_MODULE_2__.cache.set(\"websocket_metrics\", stats, 300); // 5 minutes\n            // Reset hourly counters\n            const now = Date.now();\n            if (now - this.metrics.startTime > 60 * 60 * 1000) {\n                // Every hour\n                this.resetHourlyMetrics();\n            }\n        }, 30000); // Every 30 seconds\n    }\n    // Periodic cleanup\n    startPeriodicCleanup() {\n        setInterval(()=>{\n            // Clean up rate limits\n            const now = Date.now();\n            for (const [key, limit] of this.rateLimits){\n                if (now - limit.windowStart > 60000) {\n                    // 1 minute old\n                    this.rateLimits.delete(key);\n                }\n            }\n            // Clean up old GMP alerts\n            if (this.gmpAlerts) {\n                for (const [key, alert] of this.gmpAlerts){\n                    if (now - alert.createdAt > 24 * 60 * 60 * 1000) {\n                        // 24 hours old\n                        this.gmpAlerts.delete(key);\n                    }\n                }\n            }\n            // Clean up message queues\n            for (const [room, messages] of this.messageQueue){\n                const validMessages = messages.filter((msg)=>now - msg.timestamp < 60 * 60 * 1000 // Keep messages for 1 hour\n                );\n                if (validMessages.length === 0) {\n                    this.messageQueue.delete(room);\n                } else {\n                    this.messageQueue.set(room, validMessages);\n                }\n            }\n        }, 5 * 60 * 1000); // Every 5 minutes\n    }\n    // Reset hourly metrics\n    resetHourlyMetrics() {\n        this.metrics.totalMessages = 0;\n        this.metrics.errors = 0;\n        console.log(\"\\uD83D\\uDCCA Hourly metrics reset\");\n    }\n    // Enhanced statistics\n    getDetailedStats() {\n        const connections = this.connectedClients.size;\n        const rooms = Array.from(this.roomSubscriptions.keys());\n        const totalSubscriptions = Array.from(this.roomSubscriptions.values()).reduce((sum, subs)=>sum + subs.size, 0);\n        // Calculate averages\n        const avgSubscriptionsPerClient = connections > 0 ? parseFloat((totalSubscriptions / connections).toFixed(2)) : 0;\n        // Get memory usage\n        const memoryUsage = process.memoryUsage();\n        // Calculate health stats\n        const healthyConnections = Array.from(this.connectionHealth.values()).filter((h)=>h.status === \"healthy\").length;\n        return {\n            connections,\n            rooms: rooms.length,\n            subscriptions: totalSubscriptions,\n            avgSubscriptionsPerClient,\n            totalMessages: this.metrics.totalMessages,\n            totalConnections: this.metrics.totalConnections,\n            peakConnections: this.metrics.peakConnections,\n            errors: this.metrics.errors,\n            uptime: Date.now() - this.metrics.startTime,\n            rateLimitEntries: this.rateLimits.size,\n            queuedMessages: Array.from(this.messageQueue.values()).reduce((sum, msgs)=>sum + msgs.length, 0),\n            health: {\n                healthy: healthyConnections,\n                degraded: this.connectionHealth.size - healthyConnections,\n                healthRate: this.connectionHealth.size > 0 ? parseFloat((healthyConnections / this.connectionHealth.size * 100).toFixed(2)) : 100\n            },\n            memory: {\n                rss: Math.round(memoryUsage.rss / 1024 / 1024) + \"MB\",\n                heapUsed: Math.round(memoryUsage.heapUsed / 1024 / 1024) + \"MB\",\n                heapTotal: Math.round(memoryUsage.heapTotal / 1024 / 1024) + \"MB\",\n                external: Math.round(memoryUsage.external / 1024 / 1024) + \"MB\"\n            },\n            roomDetails: Object.fromEntries(Array.from(this.roomSubscriptions.entries()).map(([room, subs])=>[\n                    room,\n                    subs.size\n                ])),\n            timestamp: Date.now()\n        };\n    }\n    // Health check\n    getHealthCheck() {\n        const stats = this.getDetailedStats();\n        const isHealthy = this.io && stats.connections >= 0 && !this.isOverloaded();\n        return {\n            status: isHealthy ? \"healthy\" : \"unhealthy\",\n            uptime: stats.uptime,\n            connections: stats.connections,\n            rooms: stats.rooms,\n            subscriptions: stats.subscriptions,\n            averageLoad: this.calculateAverageLoad(),\n            memoryUsage: stats.memory,\n            health: stats.health,\n            errors: stats.errors,\n            lastErrors: this.getRecentErrors(),\n            timestamp: Date.now()\n        };\n    }\n    isOverloaded() {\n        const stats = this.getDetailedStats();\n        const memoryUsage = process.memoryUsage();\n        // Define overload thresholds\n        const maxConnections = parseInt(process.env.WS_MAX_CONNECTIONS) || 10000;\n        const maxMemoryMB = parseInt(process.env.WS_MAX_MEMORY_MB) || 1024;\n        const maxSubscriptions = parseInt(process.env.WS_MAX_SUBSCRIPTIONS) || 50000;\n        return stats.connections > maxConnections || memoryUsage.heapUsed / 1024 / 1024 > maxMemoryMB || stats.subscriptions > maxSubscriptions || stats.errors > 100 // High error rate\n        ;\n    }\n    calculateAverageLoad() {\n        const timeDiff = (Date.now() - this.metrics.startTime) / 1000;\n        const messagesPerSecond = timeDiff > 0 ? this.metrics.totalMessages / timeDiff : 0;\n        const connectionsRatio = this.connectedClients.size / 1000; // Normalize to 1000 connections\n        return parseFloat((messagesPerSecond * connectionsRatio).toFixed(2));\n    }\n    getRecentErrors() {\n        // In a production environment, you'd implement proper error logging\n        return {\n            count: this.metrics.errors,\n            lastErrorTime: this.lastErrorTime || null\n        };\n    }\n    // Client cleanup\n    cleanupClient(socketId) {\n        const client = this.connectedClients.get(socketId);\n        if (client) {\n            // Remove from all room subscriptions\n            for (const subscription of client.subscriptions){\n                const roomSubs = this.roomSubscriptions.get(subscription);\n                if (roomSubs) {\n                    roomSubs.delete(socketId);\n                    if (roomSubs.size === 0) {\n                        this.roomSubscriptions.delete(subscription);\n                    }\n                }\n            }\n            this.connectedClients.delete(socketId);\n        }\n        // Clean up connection health\n        this.connectionHealth.delete(socketId);\n        // Clean up rate limits for this client\n        const keysToDelete = [];\n        for (const [key] of this.rateLimits){\n            if (key.startsWith(socketId)) {\n                keysToDelete.push(key);\n            }\n        }\n        keysToDelete.forEach((key)=>this.rateLimits.delete(key));\n        // Clean up GMP alerts\n        if (this.gmpAlerts) {\n            const alertKeysToDelete = [];\n            for (const [key] of this.gmpAlerts){\n                if (key.startsWith(socketId)) {\n                    alertKeysToDelete.push(key);\n                }\n            }\n            alertKeysToDelete.forEach((key)=>this.gmpAlerts.delete(key));\n        }\n    }\n    // Graceful shutdown\n    async shutdown() {\n        console.log(\"\\uD83D\\uDD0C Shutting down WebSocket service...\");\n        if (this.io) {\n            // Notify all clients about shutdown\n            await this.broadcastSystemStatus({\n                type: \"shutdown\",\n                message: \"Server is shutting down for maintenance\",\n                estimatedDowntime: \"5 minutes\"\n            }, {\n                priority: \"high\"\n            });\n            // Give clients time to receive the message\n            await new Promise((resolve)=>setTimeout(resolve, 3000));\n            // Gracefully disconnect all clients\n            for (const [socketId, client] of this.connectedClients){\n                try {\n                    client.socket.emit(\"server:shutdown\", {\n                        message: \"Server shutting down\",\n                        reconnectIn: 10000\n                    });\n                    client.socket.disconnect(true);\n                } catch (error) {\n                    console.warn(`Error disconnecting client ${socketId}:`, error.message);\n                }\n            }\n            // Close the server\n            this.io.close();\n        }\n        if (this.server) {\n            this.server.close();\n        }\n        // Clear all data structures\n        this.connectedClients.clear();\n        this.roomSubscriptions.clear();\n        this.rateLimits.clear();\n        this.connectionHealth.clear();\n        this.messageQueue.clear();\n        if (this.gmpAlerts) {\n            this.gmpAlerts.clear();\n        }\n        console.log(\"✅ WebSocket service shutdown complete\");\n    }\n}\n// Export singleton instance\nconst webSocketService = new WebSocketService();\n// Initialize and start if not in test environment\nif (true) {\n    webSocketService.initialize();\n    if (process.env.AUTO_START_WEBSOCKET !== \"false\") {\n        webSocketService.start().catch((error)=>{\n            console.error(\"Failed to start WebSocket service:\", error);\n            process.exit(1);\n        });\n    }\n}\n// Graceful shutdown handlers\nprocess.on(\"SIGTERM\", async ()=>{\n    console.log(\"Received SIGTERM, shutting down WebSocket service gracefully...\");\n    await webSocketService.shutdown();\n    process.exit(0);\n});\nprocess.on(\"SIGINT\", async ()=>{\n    console.log(\"Received SIGINT, shutting down WebSocket service gracefully...\");\n    await webSocketService.shutdown();\n    process.exit(0);\n});\n// Unhandled error handling\nprocess.on(\"uncaughtException\", async (error)=>{\n    console.error(\"Uncaught Exception in WebSocket service:\", error);\n    webSocketService.lastErrorTime = Date.now();\n    webSocketService.metrics.errors++;\n    // Attempt graceful shutdown\n    try {\n        await webSocketService.shutdown();\n    } catch (shutdownError) {\n        console.error(\"Error during emergency shutdown:\", shutdownError);\n    }\n    process.exit(1);\n});\n// Export the io instance for use in other modules\nconst io = webSocketService.io;\n// Export default\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (webSocketService);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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M0MsTUFBTWpZLEtBQUs4WCxpQkFBaUI5WCxFQUFFLENBQUM7QUFFdEMsaUJBQWlCO0FBQ2pCLGlFQUFlOFgsZ0JBQWdCQSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaXBvLXRyYWNrZXIvLi9zcmMvbGliL3dlYnNvY2tldC5qcz8zYzc1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFNlcnZlciB9IGZyb20gXCJzb2NrZXQuaW9cIjtcclxuaW1wb3J0IHsgY3JlYXRlU2VydmVyIH0gZnJvbSBcImh0dHBcIjtcclxuaW1wb3J0IHsgY2FjaGUgfSBmcm9tIFwiLi9jYWNoZS5qc1wiO1xyXG5pbXBvcnQgeyBwcmlzbWEgfSBmcm9tIFwiLi9kYi5qc1wiO1xyXG5cclxuY2xhc3MgV2ViU29ja2V0U2VydmljZSB7XHJcbiAgY29uc3RydWN0b3IoKSB7XHJcbiAgICB0aGlzLmlvID0gbnVsbDtcclxuICAgIHRoaXMuc2VydmVyID0gbnVsbDtcclxuICAgIHRoaXMuY29ubmVjdGVkQ2xpZW50cyA9IG5ldyBNYXAoKTtcclxuICAgIHRoaXMucm9vbVN1YnNjcmlwdGlvbnMgPSBuZXcgTWFwKCk7XHJcbiAgICB0aGlzLnBvcnQgPSBwcm9jZXNzLmVudi5XRUJTT0NLRVRfUE9SVCB8fCAzMDAxO1xyXG5cclxuICAgIC8vIEV2ZW50IHR5cGVzIGZvciByZWFsLXRpbWUgdXBkYXRlc1xyXG4gICAgdGhpcy5ldmVudHMgPSB7XHJcbiAgICAgIElQT19VUERBVEU6IFwiaXBvOnVwZGF0ZVwiLFxyXG4gICAgICBHTVBfVVBEQVRFOiBcImdtcDp1cGRhdGVcIixcclxuICAgICAgU1VCU0NSSVBUSU9OX1VQREFURTogXCJzdWJzY3JpcHRpb246dXBkYXRlXCIsXHJcbiAgICAgIERFTUFORF9VUERBVEU6IFwiZGVtYW5kOnVwZGF0ZVwiLFxyXG4gICAgICBBTExPVE1FTlRfVVBEQVRFOiBcImFsbG90bWVudDp1cGRhdGVcIixcclxuICAgICAgU1lTVEVNX1NUQVRVUzogXCJzeXN0ZW06c3RhdHVzXCIsXHJcbiAgICAgIEFOQUxZVElDU19VUERBVEU6IFwiYW5hbHl0aWNzOnVwZGF0ZVwiLFxyXG4gICAgICBORVdTX1VQREFURTogXCJuZXdzOnVwZGF0ZVwiLFxyXG4gICAgICBBTEVSVF9UUklHR0VSRUQ6IFwiYWxlcnQ6dHJpZ2dlcmVkXCIsXHJcbiAgICB9O1xyXG5cclxuICAgIC8vIFJhdGUgbGltaXRpbmcgY29uZmlndXJhdGlvblxyXG4gICAgdGhpcy5yYXRlTGltaXRzID0gbmV3IE1hcCgpO1xyXG4gICAgdGhpcy5tYXhFdmVudHNQZXJTZWNvbmQgPSAyMDtcclxuICAgIHRoaXMubWF4U3Vic2NyaXB0aW9uc1BlckNsaWVudCA9IDEwMDtcclxuXHJcbiAgICAvLyBQZXJmb3JtYW5jZSBtb25pdG9yaW5nXHJcbiAgICB0aGlzLm1ldHJpY3MgPSB7XHJcbiAgICAgIHRvdGFsQ29ubmVjdGlvbnM6IDAsXHJcbiAgICAgIGN1cnJlbnRDb25uZWN0aW9uczogMCxcclxuICAgICAgdG90YWxNZXNzYWdlczogMCxcclxuICAgICAgdG90YWxTdWJzY3JpcHRpb25zOiAwLFxyXG4gICAgICBlcnJvcnM6IDAsXHJcbiAgICAgIHN0YXJ0VGltZTogRGF0ZS5ub3coKSxcclxuICAgICAgYXZlcmFnZVJlc3BvbnNlVGltZTogMCxcclxuICAgICAgcGVha0Nvbm5lY3Rpb25zOiAwLFxyXG4gICAgfTtcclxuXHJcbiAgICAvLyBDb25uZWN0aW9uIGhlYWx0aCB0cmFja2luZ1xyXG4gICAgdGhpcy5jb25uZWN0aW9uSGVhbHRoID0gbmV3IE1hcCgpO1xyXG5cclxuICAgIC8vIE1lc3NhZ2UgcXVldWUgZm9yIG9mZmxpbmUgY2xpZW50c1xyXG4gICAgdGhpcy5tZXNzYWdlUXVldWUgPSBuZXcgTWFwKCk7XHJcbiAgICB0aGlzLm1heFF1ZXVlU2l6ZSA9IDUwO1xyXG4gIH1cclxuXHJcbiAgLy8gSW5pdGlhbGl6ZSBXZWJTb2NrZXQgc2VydmVyIHdpdGggZW5oYW5jZWQgY29uZmlndXJhdGlvblxyXG4gIGluaXRpYWxpemUoKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICB0aGlzLnNlcnZlciA9IGNyZWF0ZVNlcnZlcigpO1xyXG4gICAgICB0aGlzLmlvID0gbmV3IFNlcnZlcih0aGlzLnNlcnZlciwge1xyXG4gICAgICAgIGNvcnM6IHtcclxuICAgICAgICAgIG9yaWdpbjogcHJvY2Vzcy5lbnYuRlJPTlRFTkRfVVJMIHx8IFwiaHR0cDovL2xvY2FsaG9zdDozMDAwXCIsXHJcbiAgICAgICAgICBtZXRob2RzOiBbXCJHRVRcIiwgXCJQT1NUXCJdLFxyXG4gICAgICAgICAgY3JlZGVudGlhbHM6IHRydWUsXHJcbiAgICAgICAgfSxcclxuICAgICAgICBwaW5nVGltZW91dDogNjAwMDAsXHJcbiAgICAgICAgcGluZ0ludGVydmFsOiAyNTAwMCxcclxuICAgICAgICBtYXhIdHRwQnVmZmVyU2l6ZTogMmU2LCAvLyAyTUJcclxuICAgICAgICB0cmFuc3BvcnRzOiBbXCJ3ZWJzb2NrZXRcIiwgXCJwb2xsaW5nXCJdLFxyXG4gICAgICAgIGFsbG93RUlPMzogdHJ1ZSxcclxuICAgICAgICAvLyBDb25uZWN0aW9uIHJhdGUgbGltaXRpbmdcclxuICAgICAgICBjb25uZWN0VGltZW91dDogNDUwMDAsXHJcbiAgICAgICAgdXBncmFkZVRpbWVvdXQ6IDEwMDAwLFxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIHRoaXMuc2V0dXBFdmVudEhhbmRsZXJzKCk7XHJcbiAgICAgIHRoaXMuc3RhcnRIZWFydGJlYXQoKTtcclxuICAgICAgdGhpcy5zdGFydE1ldHJpY3NDb2xsZWN0aW9uKCk7XHJcbiAgICAgIHRoaXMuc3RhcnRIZWFsdGhNb25pdG9yaW5nKCk7XHJcblxyXG4gICAgICBjb25zb2xlLmxvZyhcIvCflIwgV2ViU29ja2V0IHNlcnZpY2UgaW5pdGlhbGl6ZWQgc3VjY2Vzc2Z1bGx5XCIpO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCLinYwgRmFpbGVkIHRvIGluaXRpYWxpemUgV2ViU29ja2V0IHNlcnZpY2U6XCIsIGVycm9yKTtcclxuICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBTdGFydCB0aGUgV2ViU29ja2V0IHNlcnZlclxyXG4gIGFzeW5jIHN0YXJ0KCkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgIHRoaXMuc2VydmVyLmxpc3Rlbih0aGlzLnBvcnQsIChlcnIpID0+IHtcclxuICAgICAgICAgIGlmIChlcnIpIHtcclxuICAgICAgICAgICAgcmVqZWN0KGVycik7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhg8J+agCBXZWJTb2NrZXQgc2VydmVyIHJ1bm5pbmcgb24gcG9ydCAke3RoaXMucG9ydH1gKTtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXHJcbiAgICAgICAgICAgICAgYPCfjJAgQWNjZXB0aW5nIGNvbm5lY3Rpb25zIGZyb206ICR7cHJvY2Vzcy5lbnYuRlJPTlRFTkRfVVJMIHx8IFwiaHR0cDovL2xvY2FsaG9zdDozMDAwXCJ9YFxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgLy8gU3RhcnQgcGVyaW9kaWMgY2xlYW51cFxyXG4gICAgICB0aGlzLnN0YXJ0UGVyaW9kaWNDbGVhbnVwKCk7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKFwi4p2MIEZhaWxlZCB0byBzdGFydCBXZWJTb2NrZXQgc2VydmVyOlwiLCBlcnJvcik7XHJcbiAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gRW5oYW5jZWQgZXZlbnQgaGFuZGxlcnNcclxuICBzZXR1cEV2ZW50SGFuZGxlcnMoKSB7XHJcbiAgICB0aGlzLmlvLm9uKFwiY29ubmVjdGlvblwiLCAoc29ja2V0KSA9PiB7XHJcbiAgICAgIHRoaXMuaGFuZGxlQ2xpZW50Q29ubmVjdGlvbihzb2NrZXQpO1xyXG4gICAgICB0aGlzLnNldHVwQ2xpZW50RXZlbnRMaXN0ZW5lcnMoc29ja2V0KTtcclxuXHJcbiAgICAgIC8vIFRyYWNrIG1ldHJpY3NcclxuICAgICAgdGhpcy5tZXRyaWNzLnRvdGFsQ29ubmVjdGlvbnMrKztcclxuICAgICAgdGhpcy5tZXRyaWNzLmN1cnJlbnRDb25uZWN0aW9ucysrO1xyXG4gICAgICB0aGlzLm1ldHJpY3MucGVha0Nvbm5lY3Rpb25zID0gTWF0aC5tYXgoXHJcbiAgICAgICAgdGhpcy5tZXRyaWNzLnBlYWtDb25uZWN0aW9ucyxcclxuICAgICAgICB0aGlzLm1ldHJpY3MuY3VycmVudENvbm5lY3Rpb25zXHJcbiAgICAgICk7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBIYW5kbGUgc2VydmVyIGVycm9yc1xyXG4gICAgdGhpcy5pby5vbihcImVycm9yXCIsIChlcnJvcikgPT4ge1xyXG4gICAgICBjb25zb2xlLmVycm9yKFwi8J+UjCBXZWJTb2NrZXQgc2VydmVyIGVycm9yOlwiLCBlcnJvcik7XHJcbiAgICAgIHRoaXMubWV0cmljcy5lcnJvcnMrKztcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgaGFuZGxlQ2xpZW50Q29ubmVjdGlvbihzb2NrZXQpIHtcclxuICAgIGNvbnN0IGNsaWVudElQID0gc29ja2V0LmhhbmRzaGFrZS5hZGRyZXNzO1xyXG4gICAgY29uc3QgdXNlckFnZW50ID0gc29ja2V0LmhhbmRzaGFrZS5oZWFkZXJzW1widXNlci1hZ2VudFwiXSB8fCBcIlVua25vd25cIjtcclxuXHJcbiAgICBjb25zb2xlLmxvZyhg8J+UjCBDbGllbnQgY29ubmVjdGVkOiAke3NvY2tldC5pZH0gZnJvbSAke2NsaWVudElQfWApO1xyXG5cclxuICAgIGNvbnN0IGNsaWVudEluZm8gPSB7XHJcbiAgICAgIHNvY2tldCxcclxuICAgICAgY29ubmVjdGVkQXQ6IG5ldyBEYXRlKCksXHJcbiAgICAgIHN1YnNjcmlwdGlvbnM6IG5ldyBTZXQoKSxcclxuICAgICAgbGFzdEFjdGl2aXR5OiBuZXcgRGF0ZSgpLFxyXG4gICAgICBzdWJzY3JpcHRpb25Db3VudDogMCxcclxuICAgICAgbWVzc2FnZUNvdW50OiAwLFxyXG4gICAgICB1c2VyQWdlbnQsXHJcbiAgICAgIGlwQWRkcmVzczogY2xpZW50SVAsXHJcbiAgICAgIGlzSGVhbHRoeTogdHJ1ZSxcclxuICAgICAgbGFzdFBpbmc6IERhdGUubm93KCksXHJcbiAgICAgIHJlY29ubmVjdENvdW50OiAwLFxyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLmNvbm5lY3RlZENsaWVudHMuc2V0KHNvY2tldC5pZCwgY2xpZW50SW5mbyk7XHJcbiAgICB0aGlzLmNvbm5lY3Rpb25IZWFsdGguc2V0KHNvY2tldC5pZCwge1xyXG4gICAgICBzdGF0dXM6IFwiY29ubmVjdGVkXCIsXHJcbiAgICAgIGxhdGVuY3k6IDAsXHJcbiAgICAgIGxhc3RTZWVuOiBEYXRlLm5vdygpLFxyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gU2VuZCBjb25uZWN0aW9uIGNvbmZpcm1hdGlvbiB3aXRoIHNlcnZlciBpbmZvXHJcbiAgICBzb2NrZXQuZW1pdChcImNvbm5lY3RlZFwiLCB7XHJcbiAgICAgIHNvY2tldElkOiBzb2NrZXQuaWQsXHJcbiAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcclxuICAgICAgc2VydmVyVmVyc2lvbjogXCIxLjAuMFwiLFxyXG4gICAgICBhdmFpbGFibGVFdmVudHM6IE9iamVjdC52YWx1ZXModGhpcy5ldmVudHMpLFxyXG4gICAgICBtYXhTdWJzY3JpcHRpb25zOiB0aGlzLm1heFN1YnNjcmlwdGlvbnNQZXJDbGllbnQsXHJcbiAgICAgIHJhdGVMaW1pdHM6IHtcclxuICAgICAgICBtYXhFdmVudHNQZXJTZWNvbmQ6IHRoaXMubWF4RXZlbnRzUGVyU2Vjb25kLFxyXG4gICAgICB9LFxyXG4gICAgICBmZWF0dXJlczoge1xyXG4gICAgICAgIHJlYWxUaW1lVXBkYXRlczogdHJ1ZSxcclxuICAgICAgICBiYXRjaFN1YnNjcmlwdGlvbnM6IHRydWUsXHJcbiAgICAgICAgbWVzc2FnZVF1ZXVlOiB0cnVlLFxyXG4gICAgICAgIGFuYWx5dGljczogdHJ1ZSxcclxuICAgICAgfSxcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIFNlbmQgcXVldWVkIG1lc3NhZ2VzIGlmIGFueVxyXG4gICAgdGhpcy5zZW5kUXVldWVkTWVzc2FnZXMoc29ja2V0LmlkKTtcclxuICB9XHJcblxyXG4gIHNldHVwQ2xpZW50RXZlbnRMaXN0ZW5lcnMoc29ja2V0KSB7XHJcbiAgICAvLyBJUE8gc3Vic2NyaXB0aW9uIHdpdGggZW5oYW5jZWQgZmVhdHVyZXNcclxuICAgIHNvY2tldC5vbihcInN1YnNjcmliZTppcG9cIiwgYXN5bmMgKGRhdGEpID0+IHtcclxuICAgICAgYXdhaXQgdGhpcy5oYW5kbGVTdWJzY3JpcHRpb24oc29ja2V0LCBcImlwb1wiLCBkYXRhLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgY29uc3QgeyBpcG9JZCwgc3ltYm9sLCBpbmNsdWRlQW5hbHl0aWNzID0gZmFsc2UgfSA9IGRhdGE7XHJcblxyXG4gICAgICAgIGlmIChpcG9JZCkge1xyXG4gICAgICAgICAgc29ja2V0LmpvaW4oYGlwbzoke2lwb0lkfWApO1xyXG4gICAgICAgICAgdGhpcy5hZGRTdWJzY3JpcHRpb24oc29ja2V0LmlkLCBcImlwb1wiLCBpcG9JZCk7XHJcblxyXG4gICAgICAgICAgLy8gU2VuZCBjdXJyZW50IGRhdGEgaW1tZWRpYXRlbHlcclxuICAgICAgICAgIGNvbnN0IGlwb0RhdGEgPSBhd2FpdCB0aGlzLmdldEN1cnJlbnRJUE9EYXRhKGlwb0lkKTtcclxuICAgICAgICAgIGlmIChpcG9EYXRhKSB7XHJcbiAgICAgICAgICAgIHNvY2tldC5lbWl0KHRoaXMuZXZlbnRzLklQT19VUERBVEUsIHtcclxuICAgICAgICAgICAgICBpcG9JZCxcclxuICAgICAgICAgICAgICBkYXRhOiBpcG9EYXRhLFxyXG4gICAgICAgICAgICAgIHR5cGU6IFwiaW5pdGlhbF9kYXRhXCIsXHJcbiAgICAgICAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIC8vIFNlbmQgYW5hbHl0aWNzIGlmIHJlcXVlc3RlZFxyXG4gICAgICAgICAgICBpZiAoaW5jbHVkZUFuYWx5dGljcyAmJiBpcG9EYXRhLmFuYWx5dGljcykge1xyXG4gICAgICAgICAgICAgIHNvY2tldC5lbWl0KHRoaXMuZXZlbnRzLkFOQUxZVElDU19VUERBVEUsIHtcclxuICAgICAgICAgICAgICAgIGlwb0lkLFxyXG4gICAgICAgICAgICAgICAgZGF0YTogaXBvRGF0YS5hbmFseXRpY3MsXHJcbiAgICAgICAgICAgICAgICB0eXBlOiBcImluaXRpYWxfYW5hbHl0aWNzXCIsXHJcbiAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXHJcbiAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gRW5oYW5jZWQgR01QIHN1YnNjcmlwdGlvblxyXG4gICAgc29ja2V0Lm9uKFwic3Vic2NyaWJlOmdtcFwiLCBhc3luYyAoZGF0YSkgPT4ge1xyXG4gICAgICBhd2FpdCB0aGlzLmhhbmRsZVN1YnNjcmlwdGlvbihzb2NrZXQsIFwiZ21wXCIsIGRhdGEsIGFzeW5jICgpID0+IHtcclxuICAgICAgICBjb25zdCB7XHJcbiAgICAgICAgICBpcG9JZCxcclxuICAgICAgICAgIHN5bWJvbCxcclxuICAgICAgICAgIGhpc3RvcmljYWwgPSBmYWxzZSxcclxuICAgICAgICAgIGFsZXJ0VGhyZXNob2xkID0gbnVsbCxcclxuICAgICAgICB9ID0gZGF0YTtcclxuXHJcbiAgICAgICAgaWYgKGlwb0lkKSB7XHJcbiAgICAgICAgICBzb2NrZXQuam9pbihgZ21wOiR7aXBvSWR9YCk7XHJcbiAgICAgICAgICB0aGlzLmFkZFN1YnNjcmlwdGlvbihzb2NrZXQuaWQsIFwiZ21wXCIsIGlwb0lkKTtcclxuXHJcbiAgICAgICAgICAvLyBTZW5kIGN1cnJlbnQgR01QIGRhdGFcclxuICAgICAgICAgIGNvbnN0IGdtcERhdGEgPSBhd2FpdCBjYWNoZS5nZXRSZWFsVGltZURhdGEoXCJHTVBcIiwgaXBvSWQpO1xyXG4gICAgICAgICAgaWYgKGdtcERhdGEpIHtcclxuICAgICAgICAgICAgc29ja2V0LmVtaXQodGhpcy5ldmVudHMuR01QX1VQREFURSwge1xyXG4gICAgICAgICAgICAgIGlwb0lkLFxyXG4gICAgICAgICAgICAgIGRhdGE6IGdtcERhdGEsXHJcbiAgICAgICAgICAgICAgdHlwZTogXCJjdXJyZW50XCIsXHJcbiAgICAgICAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBTZW5kIGhpc3RvcmljYWwgZGF0YSBpZiByZXF1ZXN0ZWRcclxuICAgICAgICAgIGlmIChoaXN0b3JpY2FsKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGhpc3RvcmljYWxHTVAgPSBhd2FpdCB0aGlzLmdldEhpc3RvcmljYWxHTVBEYXRhKGlwb0lkLCAzMCk7XHJcbiAgICAgICAgICAgIHNvY2tldC5lbWl0KFwiZ21wOmhpc3RvcmljYWxcIiwge1xyXG4gICAgICAgICAgICAgIGlwb0lkLFxyXG4gICAgICAgICAgICAgIGRhdGE6IGhpc3RvcmljYWxHTVAsXHJcbiAgICAgICAgICAgICAgdHlwZTogXCJoaXN0b3JpY2FsXCIsXHJcbiAgICAgICAgICAgICAgZGF5czogMzAsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIFNldCB1cCBhbGVydCB0aHJlc2hvbGQgaWYgcHJvdmlkZWRcclxuICAgICAgICAgIGlmIChhbGVydFRocmVzaG9sZCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLnNldHVwR01QQWxlcnQoc29ja2V0LmlkLCBpcG9JZCwgYWxlcnRUaHJlc2hvbGQpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBSZWFsLXRpbWUgc3Vic2NyaXB0aW9uIGRhdGEgdXBkYXRlc1xyXG4gICAgc29ja2V0Lm9uKFwic3Vic2NyaWJlOnN1YnNjcmlwdGlvblwiLCBhc3luYyAoZGF0YSkgPT4ge1xyXG4gICAgICBhd2FpdCB0aGlzLmhhbmRsZVN1YnNjcmlwdGlvbihzb2NrZXQsIFwic3Vic2NyaXB0aW9uXCIsIGRhdGEsIGFzeW5jICgpID0+IHtcclxuICAgICAgICBjb25zdCB7IHN5bWJvbCwgY2F0ZWdvcmllcyA9IFtdLCByZWFsVGltZSA9IHRydWUgfSA9IGRhdGE7XHJcblxyXG4gICAgICAgIHNvY2tldC5qb2luKGBzdWJzY3JpcHRpb246JHtzeW1ib2x9YCk7XHJcbiAgICAgICAgdGhpcy5hZGRTdWJzY3JpcHRpb24oc29ja2V0LmlkLCBcInN1YnNjcmlwdGlvblwiLCBzeW1ib2wpO1xyXG5cclxuICAgICAgICAvLyBTZW5kIGN1cnJlbnQgc3Vic2NyaXB0aW9uIGRhdGFcclxuICAgICAgICBjb25zdCBzdWJEYXRhID0gYXdhaXQgY2FjaGUuZ2V0UmVhbFRpbWVEYXRhKFwiU1VCU0NSSVBUSU9OXCIsIHN5bWJvbCk7XHJcbiAgICAgICAgaWYgKHN1YkRhdGEpIHtcclxuICAgICAgICAgIGNvbnN0IGZpbHRlcmVkRGF0YSA9XHJcbiAgICAgICAgICAgIGNhdGVnb3JpZXMubGVuZ3RoID4gMFxyXG4gICAgICAgICAgICAgID8gc3ViRGF0YS5kYXRhPy5maWx0ZXIoKGl0ZW0pID0+XHJcbiAgICAgICAgICAgICAgICAgIGNhdGVnb3JpZXMuaW5jbHVkZXMoaXRlbS5jYXRlZ29yeSlcclxuICAgICAgICAgICAgICAgIClcclxuICAgICAgICAgICAgICA6IHN1YkRhdGE7XHJcblxyXG4gICAgICAgICAgc29ja2V0LmVtaXQodGhpcy5ldmVudHMuU1VCU0NSSVBUSU9OX1VQREFURSwge1xyXG4gICAgICAgICAgICBzeW1ib2wsXHJcbiAgICAgICAgICAgIGRhdGE6IGZpbHRlcmVkRGF0YSxcclxuICAgICAgICAgICAgY2F0ZWdvcmllczogY2F0ZWdvcmllcy5sZW5ndGggPiAwID8gY2F0ZWdvcmllcyA6IFwiYWxsXCIsXHJcbiAgICAgICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBNYXJrZXQgZGVtYW5kIHVwZGF0ZXMgd2l0aCBwcmljZSBmaWx0ZXJpbmdcclxuICAgIHNvY2tldC5vbihcInN1YnNjcmliZTpkZW1hbmRcIiwgYXN5bmMgKGRhdGEpID0+IHtcclxuICAgICAgYXdhaXQgdGhpcy5oYW5kbGVTdWJzY3JpcHRpb24oc29ja2V0LCBcImRlbWFuZFwiLCBkYXRhLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgY29uc3QgeyBzeW1ib2wsIHByaWNlUmFuZ2UgPSBudWxsLCBjdXRPZmZPbmx5ID0gZmFsc2UgfSA9IGRhdGE7XHJcblxyXG4gICAgICAgIHNvY2tldC5qb2luKGBkZW1hbmQ6JHtzeW1ib2x9YCk7XHJcbiAgICAgICAgdGhpcy5hZGRTdWJzY3JpcHRpb24oc29ja2V0LmlkLCBcImRlbWFuZFwiLCBzeW1ib2wpO1xyXG5cclxuICAgICAgICAvLyBTZW5kIGN1cnJlbnQgZGVtYW5kIGRhdGFcclxuICAgICAgICBjb25zdCBkZW1hbmREYXRhID0gYXdhaXQgY2FjaGUuZ2V0UmVhbFRpbWVEYXRhKFwiREVNQU5EXCIsIHN5bWJvbCk7XHJcbiAgICAgICAgaWYgKGRlbWFuZERhdGEpIHtcclxuICAgICAgICAgIGxldCBmaWx0ZXJlZERhdGEgPSBkZW1hbmREYXRhLmRhdGEgfHwgW107XHJcblxyXG4gICAgICAgICAgLy8gQXBwbHkgZmlsdGVyc1xyXG4gICAgICAgICAgaWYgKGN1dE9mZk9ubHkpIHtcclxuICAgICAgICAgICAgZmlsdGVyZWREYXRhID0gZmlsdGVyZWREYXRhLmZpbHRlcigoaXRlbSkgPT4gaXRlbS5jdXRPZmZJbmRpY2F0b3IpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGlmIChcclxuICAgICAgICAgICAgcHJpY2VSYW5nZSAmJlxyXG4gICAgICAgICAgICBwcmljZVJhbmdlLm1pbiAhPT0gdW5kZWZpbmVkICYmXHJcbiAgICAgICAgICAgIHByaWNlUmFuZ2UubWF4ICE9PSB1bmRlZmluZWRcclxuICAgICAgICAgICkge1xyXG4gICAgICAgICAgICBmaWx0ZXJlZERhdGEgPSBmaWx0ZXJlZERhdGEuZmlsdGVyKFxyXG4gICAgICAgICAgICAgIChpdGVtKSA9PlxyXG4gICAgICAgICAgICAgICAgaXRlbS5wcmljZSA+PSBwcmljZVJhbmdlLm1pbiAmJiBpdGVtLnByaWNlIDw9IHByaWNlUmFuZ2UubWF4XHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgc29ja2V0LmVtaXQodGhpcy5ldmVudHMuREVNQU5EX1VQREFURSwge1xyXG4gICAgICAgICAgICBzeW1ib2wsXHJcbiAgICAgICAgICAgIGRhdGE6IGZpbHRlcmVkRGF0YSxcclxuICAgICAgICAgICAgZmlsdGVyczogeyBwcmljZVJhbmdlLCBjdXRPZmZPbmx5IH0sXHJcbiAgICAgICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBBbmFseXRpY3Mgc3Vic2NyaXB0aW9uIHdpdGggY3VzdG9taXphYmxlIG1ldHJpY3NcclxuICAgIHNvY2tldC5vbihcInN1YnNjcmliZTphbmFseXRpY3NcIiwgYXN5bmMgKGRhdGEpID0+IHtcclxuICAgICAgYXdhaXQgdGhpcy5oYW5kbGVTdWJzY3JpcHRpb24oc29ja2V0LCBcImFuYWx5dGljc1wiLCBkYXRhLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgY29uc3Qge1xyXG4gICAgICAgICAgaXBvSWQsXHJcbiAgICAgICAgICB0eXBlID0gXCJhbGxcIixcclxuICAgICAgICAgIG1ldHJpY3MgPSBbXSxcclxuICAgICAgICAgIHVwZGF0ZUludGVydmFsID0gMzAwMDAsXHJcbiAgICAgICAgfSA9IGRhdGE7XHJcblxyXG4gICAgICAgIHNvY2tldC5qb2luKGBhbmFseXRpY3M6JHtpcG9JZH1gKTtcclxuICAgICAgICB0aGlzLmFkZFN1YnNjcmlwdGlvbihzb2NrZXQuaWQsIFwiYW5hbHl0aWNzXCIsIGlwb0lkKTtcclxuXHJcbiAgICAgICAgLy8gU2VuZCBjdXJyZW50IGFuYWx5dGljc1xyXG4gICAgICAgIGNvbnN0IGFuYWx5dGljcyA9IGF3YWl0IHRoaXMuZ2V0Q3VycmVudEFuYWx5dGljcyhpcG9JZCwgdHlwZSk7XHJcbiAgICAgICAgaWYgKGFuYWx5dGljcykge1xyXG4gICAgICAgICAgY29uc3QgZmlsdGVyZWRBbmFseXRpY3MgPVxyXG4gICAgICAgICAgICBtZXRyaWNzLmxlbmd0aCA+IDBcclxuICAgICAgICAgICAgICA/IHRoaXMuZmlsdGVyQW5hbHl0aWNzQnlNZXRyaWNzKGFuYWx5dGljcywgbWV0cmljcylcclxuICAgICAgICAgICAgICA6IGFuYWx5dGljcztcclxuXHJcbiAgICAgICAgICBzb2NrZXQuZW1pdCh0aGlzLmV2ZW50cy5BTkFMWVRJQ1NfVVBEQVRFLCB7XHJcbiAgICAgICAgICAgIGlwb0lkLFxyXG4gICAgICAgICAgICB0eXBlLFxyXG4gICAgICAgICAgICBkYXRhOiBmaWx0ZXJlZEFuYWx5dGljcyxcclxuICAgICAgICAgICAgbWV0cmljczogbWV0cmljcy5sZW5ndGggPiAwID8gbWV0cmljcyA6IFwiYWxsXCIsXHJcbiAgICAgICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBTeXN0ZW0gc3RhdHVzIHN1YnNjcmlwdGlvblxyXG4gICAgc29ja2V0Lm9uKFwic3Vic2NyaWJlOnN5c3RlbVwiLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgIHNvY2tldC5qb2luKFwic3lzdGVtOnN0YXR1c1wiKTtcclxuICAgICAgdGhpcy5hZGRTdWJzY3JpcHRpb24oc29ja2V0LmlkLCBcInN5c3RlbVwiLCBcInN0YXR1c1wiKTtcclxuXHJcbiAgICAgIC8vIFNlbmQgY3VycmVudCBzeXN0ZW0gc3RhdHVzXHJcbiAgICAgIGNvbnN0IHN5c3RlbVN0YXR1cyA9IGF3YWl0IHRoaXMuZ2V0U3lzdGVtU3RhdHVzKCk7XHJcbiAgICAgIHNvY2tldC5lbWl0KHRoaXMuZXZlbnRzLlNZU1RFTV9TVEFUVVMsIHtcclxuICAgICAgICAuLi5zeXN0ZW1TdGF0dXMsXHJcbiAgICAgICAgdHlwZTogXCJjdXJyZW50X3N0YXR1c1wiLFxyXG4gICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBCYXRjaCBzdWJzY3JpcHRpb24gZm9yIG11bHRpcGxlIElQT3Mgd2l0aCBhZHZhbmNlZCBvcHRpb25zXHJcbiAgICBzb2NrZXQub24oXCJzdWJzY3JpYmU6YmF0Y2hcIiwgYXN5bmMgKGRhdGEpID0+IHtcclxuICAgICAgY29uc3QgeyBzdWJzY3JpcHRpb25zID0gW10sIG9wdGlvbnMgPSB7fSB9ID0gZGF0YTtcclxuICAgICAgY29uc3QgeyBtYXhTdWJzY3JpcHRpb25zID0gMjAsIHNraXBFcnJvcnMgPSB0cnVlIH0gPSBvcHRpb25zO1xyXG4gICAgICBjb25zdCByZXN1bHRzID0gW107XHJcblxyXG4gICAgICAvLyBMaW1pdCBiYXRjaCBzaXplXHJcbiAgICAgIGNvbnN0IGxpbWl0ZWRTdWJzY3JpcHRpb25zID0gc3Vic2NyaXB0aW9ucy5zbGljZSgwLCBtYXhTdWJzY3JpcHRpb25zKTtcclxuXHJcbiAgICAgIGZvciAoY29uc3Qgc3ViIG9mIGxpbWl0ZWRTdWJzY3JpcHRpb25zKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIGF3YWl0IHRoaXMuaGFuZGxlU2luZ2xlU3Vic2NyaXB0aW9uKHNvY2tldCwgc3ViKTtcclxuICAgICAgICAgIHJlc3VsdHMucHVzaCh7IC4uLnN1Yiwgc3RhdHVzOiBcInN1Y2Nlc3NcIiB9KTtcclxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgcmVzdWx0cy5wdXNoKHsgLi4uc3ViLCBzdGF0dXM6IFwiZXJyb3JcIiwgZXJyb3I6IGVycm9yLm1lc3NhZ2UgfSk7XHJcbiAgICAgICAgICBpZiAoIXNraXBFcnJvcnMpIHtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBzb2NrZXQuZW1pdChcInN1YnNjcmliZTpiYXRjaDpyZXN1bHRcIiwge1xyXG4gICAgICAgIHJlc3VsdHMsXHJcbiAgICAgICAgcHJvY2Vzc2VkOiByZXN1bHRzLmxlbmd0aCxcclxuICAgICAgICBzdWNjZXNzZnVsOiByZXN1bHRzLmZpbHRlcigocikgPT4gci5zdGF0dXMgPT09IFwic3VjY2Vzc1wiKS5sZW5ndGgsXHJcbiAgICAgICAgZXJyb3JzOiByZXN1bHRzLmZpbHRlcigocikgPT4gci5zdGF0dXMgPT09IFwiZXJyb3JcIikubGVuZ3RoLFxyXG4gICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBFbmhhbmNlZCB1bnN1YnNjcmliZSB3aXRoIHBhdHRlcm5zXHJcbiAgICBzb2NrZXQub24oXCJ1bnN1YnNjcmliZVwiLCAoZGF0YSkgPT4ge1xyXG4gICAgICBjb25zdCB7IHR5cGUsIGlkZW50aWZpZXIsIHBhdHRlcm4gfSA9IGRhdGE7XHJcblxyXG4gICAgICBpZiAocGF0dGVybiA9PT0gXCJhbGxcIikge1xyXG4gICAgICAgIHRoaXMudW5zdWJzY3JpYmVBbGwoc29ja2V0LmlkKTtcclxuICAgICAgICBzb2NrZXQuZW1pdChcInVuc3Vic2NyaWJlOnJlc3VsdFwiLCB7XHJcbiAgICAgICAgICBwYXR0ZXJuOiBcImFsbFwiLFxyXG4gICAgICAgICAgc3RhdHVzOiBcInN1Y2Nlc3NcIixcclxuICAgICAgICAgIG1lc3NhZ2U6IFwiVW5zdWJzY3JpYmVkIGZyb20gYWxsIGV2ZW50c1wiLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9IGVsc2UgaWYgKHR5cGUgJiYgaWRlbnRpZmllcikge1xyXG4gICAgICAgIGNvbnN0IHJvb21LZXkgPSBgJHt0eXBlfToke2lkZW50aWZpZXJ9YDtcclxuICAgICAgICBzb2NrZXQubGVhdmUocm9vbUtleSk7XHJcbiAgICAgICAgdGhpcy5yZW1vdmVTdWJzY3JpcHRpb24oc29ja2V0LmlkLCB0eXBlLCBpZGVudGlmaWVyKTtcclxuICAgICAgICBzb2NrZXQuZW1pdChcInVuc3Vic2NyaWJlOnJlc3VsdFwiLCB7XHJcbiAgICAgICAgICB0eXBlLFxyXG4gICAgICAgICAgaWRlbnRpZmllcixcclxuICAgICAgICAgIHN0YXR1czogXCJzdWNjZXNzXCIsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0gZWxzZSBpZiAodHlwZSkge1xyXG4gICAgICAgIC8vIFVuc3Vic2NyaWJlIGZyb20gYWxsIHN1YnNjcmlwdGlvbnMgb2YgYSBzcGVjaWZpYyB0eXBlXHJcbiAgICAgICAgdGhpcy51bnN1YnNjcmliZUJ5VHlwZShzb2NrZXQuaWQsIHR5cGUpO1xyXG4gICAgICAgIHNvY2tldC5lbWl0KFwidW5zdWJzY3JpYmU6cmVzdWx0XCIsIHtcclxuICAgICAgICAgIHR5cGUsXHJcbiAgICAgICAgICBzdGF0dXM6IFwic3VjY2Vzc1wiLFxyXG4gICAgICAgICAgbWVzc2FnZTogYFVuc3Vic2NyaWJlZCBmcm9tIGFsbCAke3R5cGV9IGV2ZW50c2AsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIC8vIEVuaGFuY2VkIGhlYXJ0YmVhdCB3aXRoIHBlcmZvcm1hbmNlIG1ldHJpY3NcclxuICAgIHNvY2tldC5vbihcInBpbmdcIiwgKGRhdGEpID0+IHtcclxuICAgICAgY29uc3QgY2xpZW50ID0gdGhpcy5jb25uZWN0ZWRDbGllbnRzLmdldChzb2NrZXQuaWQpO1xyXG4gICAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xyXG5cclxuICAgICAgaWYgKGNsaWVudCkge1xyXG4gICAgICAgIGNsaWVudC5sYXN0QWN0aXZpdHkgPSBuZXcgRGF0ZSgpO1xyXG4gICAgICAgIGNsaWVudC5tZXNzYWdlQ291bnQrKztcclxuICAgICAgICBjbGllbnQubGFzdFBpbmcgPSBub3c7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIENhbGN1bGF0ZSBsYXRlbmN5XHJcbiAgICAgIGNvbnN0IGxhdGVuY3kgPSBkYXRhPy50aW1lc3RhbXAgPyBub3cgLSBkYXRhLnRpbWVzdGFtcCA6IDA7XHJcbiAgICAgIHRoaXMuY29ubmVjdGlvbkhlYWx0aC5zZXQoc29ja2V0LmlkLCB7XHJcbiAgICAgICAgc3RhdHVzOiBcImhlYWx0aHlcIixcclxuICAgICAgICBsYXRlbmN5LFxyXG4gICAgICAgIGxhc3RTZWVuOiBub3csXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgc29ja2V0LmVtaXQoXCJwb25nXCIsIHtcclxuICAgICAgICB0aW1lc3RhbXA6IG5vdyxcclxuICAgICAgICBzZXJ2ZXJVcHRpbWU6IG5vdyAtIHRoaXMubWV0cmljcy5zdGFydFRpbWUsXHJcbiAgICAgICAgbGF0ZW5jeSxcclxuICAgICAgICBjbGllbnRJbmZvOiBjbGllbnRcclxuICAgICAgICAgID8ge1xyXG4gICAgICAgICAgICAgIHN1YnNjcmlwdGlvbnM6IGNsaWVudC5zdWJzY3JpcHRpb25Db3VudCxcclxuICAgICAgICAgICAgICBtZXNzYWdlczogY2xpZW50Lm1lc3NhZ2VDb3VudCxcclxuICAgICAgICAgICAgICBjb25uZWN0ZWRGb3I6IG5vdyAtIGNsaWVudC5jb25uZWN0ZWRBdC5nZXRUaW1lKCksXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIDogbnVsbCxcclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBDbGllbnQgaW5mbyBhbmQgc3RhdGlzdGljcyByZXF1ZXN0XHJcbiAgICBzb2NrZXQub24oXCJjbGllbnQ6aW5mb1wiLCAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuY29ubmVjdGVkQ2xpZW50cy5nZXQoc29ja2V0LmlkKTtcclxuICAgICAgY29uc3QgaGVhbHRoID0gdGhpcy5jb25uZWN0aW9uSGVhbHRoLmdldChzb2NrZXQuaWQpO1xyXG5cclxuICAgICAgaWYgKGNsaWVudCkge1xyXG4gICAgICAgIHNvY2tldC5lbWl0KFwiY2xpZW50OmluZm9cIiwge1xyXG4gICAgICAgICAgc29ja2V0SWQ6IHNvY2tldC5pZCxcclxuICAgICAgICAgIGNvbm5lY3RlZEF0OiBjbGllbnQuY29ubmVjdGVkQXQsXHJcbiAgICAgICAgICBzdWJzY3JpcHRpb25zOiBBcnJheS5mcm9tKGNsaWVudC5zdWJzY3JpcHRpb25zKSxcclxuICAgICAgICAgIHN1YnNjcmlwdGlvbkNvdW50OiBjbGllbnQuc3Vic2NyaXB0aW9uQ291bnQsXHJcbiAgICAgICAgICBtZXNzYWdlQ291bnQ6IGNsaWVudC5tZXNzYWdlQ291bnQsXHJcbiAgICAgICAgICB1c2VyQWdlbnQ6IGNsaWVudC51c2VyQWdlbnQsXHJcbiAgICAgICAgICBpcEFkZHJlc3M6IGNsaWVudC5pcEFkZHJlc3MsXHJcbiAgICAgICAgICBoZWFsdGg6IGhlYWx0aCB8fCB7IHN0YXR1czogXCJ1bmtub3duXCIgfSxcclxuICAgICAgICAgIHNlcnZlck1ldHJpY3M6IHtcclxuICAgICAgICAgICAgdG90YWxDb25uZWN0aW9uczogdGhpcy5tZXRyaWNzLmN1cnJlbnRDb25uZWN0aW9ucyxcclxuICAgICAgICAgICAgc2VydmVyVXB0aW1lOiBEYXRlLm5vdygpIC0gdGhpcy5tZXRyaWNzLnN0YXJ0VGltZSxcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIC8vIFJlcXVlc3Qgc2VydmVyIHN0YXRpc3RpY3NcclxuICAgIHNvY2tldC5vbihcInNlcnZlcjpzdGF0c1wiLCAoKSA9PiB7XHJcbiAgICAgIGlmICh0aGlzLmlzQXV0aG9yaXplZChzb2NrZXQpKSB7XHJcbiAgICAgICAgLy8gT25seSBmb3IgYXV0aG9yaXplZCBjbGllbnRzXHJcbiAgICAgICAgY29uc3Qgc3RhdHMgPSB0aGlzLmdldERldGFpbGVkU3RhdHMoKTtcclxuICAgICAgICBzb2NrZXQuZW1pdChcInNlcnZlcjpzdGF0c1wiLCBzdGF0cyk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgc29ja2V0LmVtaXQoXCJlcnJvclwiLCB7XHJcbiAgICAgICAgICB0eXBlOiBcInVuYXV0aG9yaXplZFwiLFxyXG4gICAgICAgICAgbWVzc2FnZTogXCJOb3QgYXV0aG9yaXplZCB0byB2aWV3IHNlcnZlciBzdGF0aXN0aWNzXCIsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIC8vIEVycm9yIGhhbmRsaW5nXHJcbiAgICBzb2NrZXQub24oXCJlcnJvclwiLCAoZXJyb3IpID0+IHtcclxuICAgICAgY29uc29sZS5lcnJvcihg8J+UjCBTb2NrZXQgZXJyb3IgZm9yICR7c29ja2V0LmlkfTpgLCBlcnJvcik7XHJcbiAgICAgIHRoaXMubWV0cmljcy5lcnJvcnMrKztcclxuXHJcbiAgICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuY29ubmVjdGVkQ2xpZW50cy5nZXQoc29ja2V0LmlkKTtcclxuICAgICAgaWYgKGNsaWVudCkge1xyXG4gICAgICAgIGNsaWVudC5pc0hlYWx0aHkgPSBmYWxzZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy5jb25uZWN0aW9uSGVhbHRoLnNldChzb2NrZXQuaWQsIHtcclxuICAgICAgICBzdGF0dXM6IFwiZXJyb3JcIixcclxuICAgICAgICBlcnJvcjogZXJyb3IubWVzc2FnZSxcclxuICAgICAgICBsYXN0U2VlbjogRGF0ZS5ub3coKSxcclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBEaXNjb25uZWN0IGhhbmRsaW5nIHdpdGggY2xlYW51cFxyXG4gICAgc29ja2V0Lm9uKFwiZGlzY29ubmVjdFwiLCAocmVhc29uKSA9PiB7XHJcbiAgICAgIGNvbnNvbGUubG9nKGDwn5SMIENsaWVudCBkaXNjb25uZWN0ZWQ6ICR7c29ja2V0LmlkfSwgcmVhc29uOiAke3JlYXNvbn1gKTtcclxuXHJcbiAgICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuY29ubmVjdGVkQ2xpZW50cy5nZXQoc29ja2V0LmlkKTtcclxuICAgICAgaWYgKGNsaWVudCkge1xyXG4gICAgICAgIC8vIFN0b3JlIGRpc2Nvbm5lY3Rpb24gaW5mbyBmb3IgcG90ZW50aWFsIHJlY29ubmVjdGlvblxyXG4gICAgICAgIHRoaXMuaGFuZGxlQ2xpZW50RGlzY29ubmVjdGlvbihzb2NrZXQuaWQsIHJlYXNvbik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMuY2xlYW51cENsaWVudChzb2NrZXQuaWQpO1xyXG4gICAgICB0aGlzLm1ldHJpY3MuY3VycmVudENvbm5lY3Rpb25zLS07XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBSZWNvbm5lY3Rpb24gaGFuZGxpbmdcclxuICAgIHNvY2tldC5vbihcInJlY29ubmVjdFwiLCAoZGF0YSkgPT4ge1xyXG4gICAgICBjb25zb2xlLmxvZyhg8J+UhCBDbGllbnQgcmVjb25uZWN0ZWQ6ICR7c29ja2V0LmlkfWApO1xyXG4gICAgICBjb25zdCBjbGllbnQgPSB0aGlzLmNvbm5lY3RlZENsaWVudHMuZ2V0KHNvY2tldC5pZCk7XHJcbiAgICAgIGlmIChjbGllbnQpIHtcclxuICAgICAgICBjbGllbnQucmVjb25uZWN0Q291bnQrKztcclxuICAgICAgICBjbGllbnQubGFzdEFjdGl2aXR5ID0gbmV3IERhdGUoKTtcclxuXHJcbiAgICAgICAgLy8gU2VuZCBxdWV1ZWQgbWVzc2FnZXNcclxuICAgICAgICB0aGlzLnNlbmRRdWV1ZWRNZXNzYWdlcyhzb2NrZXQuaWQpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8vIEVuaGFuY2VkIHN1YnNjcmlwdGlvbiBoYW5kbGluZyB3aXRoIHZhbGlkYXRpb25cclxuICBhc3luYyBoYW5kbGVTdWJzY3JpcHRpb24oc29ja2V0LCB0eXBlLCBkYXRhLCBzdWJzY3JpcHRpb25Mb2dpYykge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgY2xpZW50ID0gdGhpcy5jb25uZWN0ZWRDbGllbnRzLmdldChzb2NrZXQuaWQpO1xyXG5cclxuICAgICAgaWYgKCFjbGllbnQpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDbGllbnQgbm90IGZvdW5kXCIpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBDaGVjayBzdWJzY3JpcHRpb24gbGltaXRzXHJcbiAgICAgIGlmIChjbGllbnQuc3Vic2NyaXB0aW9uQ291bnQgPj0gdGhpcy5tYXhTdWJzY3JpcHRpb25zUGVyQ2xpZW50KSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICAgICAgYE1heGltdW0gc3Vic2NyaXB0aW9ucyBsaW1pdCByZWFjaGVkICgke3RoaXMubWF4U3Vic2NyaXB0aW9uc1BlckNsaWVudH0pYFxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIENoZWNrIHJhdGUgbGltaXRzXHJcbiAgICAgIGlmICghdGhpcy5jaGVja1JhdGVMaW1pdChzb2NrZXQuaWQsIHR5cGUpKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUmF0ZSBsaW1pdCBleGNlZWRlZC4gUGxlYXNlIHNsb3cgZG93bi5cIik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFZhbGlkYXRlIHN1YnNjcmlwdGlvbiBkYXRhXHJcbiAgICAgIHRoaXMudmFsaWRhdGVTdWJzY3JpcHRpb25EYXRhKHR5cGUsIGRhdGEpO1xyXG5cclxuICAgICAgLy8gRXhlY3V0ZSBzdWJzY3JpcHRpb24gbG9naWNcclxuICAgICAgYXdhaXQgc3Vic2NyaXB0aW9uTG9naWMoKTtcclxuXHJcbiAgICAgIC8vIFVwZGF0ZSBjbGllbnQgaW5mb1xyXG4gICAgICBjbGllbnQubGFzdEFjdGl2aXR5ID0gbmV3IERhdGUoKTtcclxuICAgICAgY2xpZW50Lm1lc3NhZ2VDb3VudCsrO1xyXG5cclxuICAgICAgLy8gU2VuZCBzdWNjZXNzIGNvbmZpcm1hdGlvblxyXG4gICAgICBzb2NrZXQuZW1pdChcInN1YnNjcmliZTpzdWNjZXNzXCIsIHtcclxuICAgICAgICB0eXBlLFxyXG4gICAgICAgIGRhdGEsXHJcbiAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxyXG4gICAgICAgIHN1YnNjcmlwdGlvbkNvdW50OiBjbGllbnQuc3Vic2NyaXB0aW9uQ291bnQsXHJcbiAgICAgIH0pO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcihgU3Vic2NyaXB0aW9uIGZhaWxlZCBmb3IgJHtzb2NrZXQuaWR9OmAsIGVycm9yLm1lc3NhZ2UpO1xyXG4gICAgICBzb2NrZXQuZW1pdChcInN1YnNjcmliZTplcnJvclwiLCB7XHJcbiAgICAgICAgdHlwZTogXCJzdWJzY3JpcHRpb25fZmFpbGVkXCIsXHJcbiAgICAgICAgbWVzc2FnZTogZXJyb3IubWVzc2FnZSxcclxuICAgICAgICBzdWJzY3JpcHRpb25UeXBlOiB0eXBlLFxyXG4gICAgICAgIGRhdGEsXHJcbiAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIFZhbGlkYXRlIHN1YnNjcmlwdGlvbiBkYXRhXHJcbiAgdmFsaWRhdGVTdWJzY3JpcHRpb25EYXRhKHR5cGUsIGRhdGEpIHtcclxuICAgIHN3aXRjaCAodHlwZSkge1xyXG4gICAgICBjYXNlIFwiaXBvXCI6XHJcbiAgICAgICAgaWYgKCFkYXRhLmlwb0lkICYmICFkYXRhLnN5bWJvbCkge1xyXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICAgICAgICBcIkVpdGhlciBpcG9JZCBvciBzeW1ib2wgaXMgcmVxdWlyZWQgZm9yIElQTyBzdWJzY3JpcHRpb25cIlxyXG4gICAgICAgICAgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgXCJnbXBcIjpcclxuICAgICAgICBpZiAoIWRhdGEuaXBvSWQgJiYgIWRhdGEuc3ltYm9sKSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXHJcbiAgICAgICAgICAgIFwiRWl0aGVyIGlwb0lkIG9yIHN5bWJvbCBpcyByZXF1aXJlZCBmb3IgR01QIHN1YnNjcmlwdGlvblwiXHJcbiAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSBcInN1YnNjcmlwdGlvblwiOlxyXG4gICAgICBjYXNlIFwiZGVtYW5kXCI6XHJcbiAgICAgICAgaWYgKCFkYXRhLnN5bWJvbCkge1xyXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU3ltYm9sIGlzIHJlcXVpcmVkIGZvciBzdWJzY3JpcHRpb24vZGVtYW5kIGRhdGFcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIFwiYW5hbHl0aWNzXCI6XHJcbiAgICAgICAgaWYgKCFkYXRhLmlwb0lkKSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJUE8gSUQgaXMgcmVxdWlyZWQgZm9yIGFuYWx5dGljcyBzdWJzY3JpcHRpb25cIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gSGFuZGxlIHNpbmdsZSBzdWJzY3JpcHRpb24gKGZvciBiYXRjaCBvcGVyYXRpb25zKVxyXG4gIGFzeW5jIGhhbmRsZVNpbmdsZVN1YnNjcmlwdGlvbihcclxuICAgIHNvY2tldCxcclxuICAgIHsgdHlwZSwgaXBvSWQsIHN5bWJvbCwgb3B0aW9ucyA9IHt9IH1cclxuICApIHtcclxuICAgIHN3aXRjaCAodHlwZSkge1xyXG4gICAgICBjYXNlIFwiaXBvXCI6XHJcbiAgICAgICAgaWYgKGlwb0lkKSB7XHJcbiAgICAgICAgICBzb2NrZXQuam9pbihgaXBvOiR7aXBvSWR9YCk7XHJcbiAgICAgICAgICB0aGlzLmFkZFN1YnNjcmlwdGlvbihzb2NrZXQuaWQsIFwiaXBvXCIsIGlwb0lkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgXCJnbXBcIjpcclxuICAgICAgICBpZiAoaXBvSWQpIHtcclxuICAgICAgICAgIHNvY2tldC5qb2luKGBnbXA6JHtpcG9JZH1gKTtcclxuICAgICAgICAgIHRoaXMuYWRkU3Vic2NyaXB0aW9uKHNvY2tldC5pZCwgXCJnbXBcIiwgaXBvSWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSBcInN1YnNjcmlwdGlvblwiOlxyXG4gICAgICAgIGlmIChzeW1ib2wpIHtcclxuICAgICAgICAgIHNvY2tldC5qb2luKGBzdWJzY3JpcHRpb246JHtzeW1ib2x9YCk7XHJcbiAgICAgICAgICB0aGlzLmFkZFN1YnNjcmlwdGlvbihzb2NrZXQuaWQsIFwic3Vic2NyaXB0aW9uXCIsIHN5bWJvbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIFwiZGVtYW5kXCI6XHJcbiAgICAgICAgaWYgKHN5bWJvbCkge1xyXG4gICAgICAgICAgc29ja2V0LmpvaW4oYGRlbWFuZDoke3N5bWJvbH1gKTtcclxuICAgICAgICAgIHRoaXMuYWRkU3Vic2NyaXB0aW9uKHNvY2tldC5pZCwgXCJkZW1hbmRcIiwgc3ltYm9sKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgXCJhbmFseXRpY3NcIjpcclxuICAgICAgICBpZiAoaXBvSWQpIHtcclxuICAgICAgICAgIHNvY2tldC5qb2luKGBhbmFseXRpY3M6JHtpcG9JZH1gKTtcclxuICAgICAgICAgIHRoaXMuYWRkU3Vic2NyaXB0aW9uKHNvY2tldC5pZCwgXCJhbmFseXRpY3NcIiwgaXBvSWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBicmVhaztcclxuICAgICAgZGVmYXVsdDpcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gc3Vic2NyaXB0aW9uIHR5cGU6ICR7dHlwZX1gKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIEVuaGFuY2VkIHJhdGUgbGltaXRpbmdcclxuICBjaGVja1JhdGVMaW1pdChzb2NrZXRJZCwgZXZlbnRUeXBlKSB7XHJcbiAgICBjb25zdCBrZXkgPSBgJHtzb2NrZXRJZH06JHtldmVudFR5cGV9YDtcclxuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XHJcbiAgICBjb25zdCB3aW5kb3dTdGFydCA9IE1hdGguZmxvb3Iobm93IC8gMTAwMCkgKiAxMDAwO1xyXG5cclxuICAgIGlmICghdGhpcy5yYXRlTGltaXRzLmhhcyhrZXkpKSB7XHJcbiAgICAgIHRoaXMucmF0ZUxpbWl0cy5zZXQoa2V5LCB7IGNvdW50OiAwLCB3aW5kb3dTdGFydCB9KTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBsaW1pdCA9IHRoaXMucmF0ZUxpbWl0cy5nZXQoa2V5KTtcclxuXHJcbiAgICBpZiAobGltaXQud2luZG93U3RhcnQgIT09IHdpbmRvd1N0YXJ0KSB7XHJcbiAgICAgIGxpbWl0LmNvdW50ID0gMDtcclxuICAgICAgbGltaXQud2luZG93U3RhcnQgPSB3aW5kb3dTdGFydDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAobGltaXQuY291bnQgPj0gdGhpcy5tYXhFdmVudHNQZXJTZWNvbmQpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIGxpbWl0LmNvdW50Kys7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcblxyXG4gIC8vIFN1YnNjcmlwdGlvbiBtYW5hZ2VtZW50XHJcbiAgYWRkU3Vic2NyaXB0aW9uKHNvY2tldElkLCB0eXBlLCBpZGVudGlmaWVyKSB7XHJcbiAgICBjb25zdCBjbGllbnQgPSB0aGlzLmNvbm5lY3RlZENsaWVudHMuZ2V0KHNvY2tldElkKTtcclxuICAgIGlmIChjbGllbnQpIHtcclxuICAgICAgY29uc3Qgc3Vic2NyaXB0aW9uS2V5ID0gYCR7dHlwZX06JHtpZGVudGlmaWVyfWA7XHJcbiAgICAgIGNsaWVudC5zdWJzY3JpcHRpb25zLmFkZChzdWJzY3JpcHRpb25LZXkpO1xyXG4gICAgICBjbGllbnQuc3Vic2NyaXB0aW9uQ291bnQgPSBjbGllbnQuc3Vic2NyaXB0aW9ucy5zaXplO1xyXG5cclxuICAgICAgLy8gVHJhY2sgcm9vbSBzdWJzY3JpcHRpb25zXHJcbiAgICAgIGlmICghdGhpcy5yb29tU3Vic2NyaXB0aW9ucy5oYXMoc3Vic2NyaXB0aW9uS2V5KSkge1xyXG4gICAgICAgIHRoaXMucm9vbVN1YnNjcmlwdGlvbnMuc2V0KHN1YnNjcmlwdGlvbktleSwgbmV3IFNldCgpKTtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLnJvb21TdWJzY3JpcHRpb25zLmdldChzdWJzY3JpcHRpb25LZXkpLmFkZChzb2NrZXRJZCk7XHJcblxyXG4gICAgICB0aGlzLm1ldHJpY3MudG90YWxTdWJzY3JpcHRpb25zKys7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZW1vdmVTdWJzY3JpcHRpb24oc29ja2V0SWQsIHR5cGUsIGlkZW50aWZpZXIpIHtcclxuICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuY29ubmVjdGVkQ2xpZW50cy5nZXQoc29ja2V0SWQpO1xyXG4gICAgaWYgKGNsaWVudCkge1xyXG4gICAgICBjb25zdCBzdWJzY3JpcHRpb25LZXkgPSBgJHt0eXBlfToke2lkZW50aWZpZXJ9YDtcclxuICAgICAgY2xpZW50LnN1YnNjcmlwdGlvbnMuZGVsZXRlKHN1YnNjcmlwdGlvbktleSk7XHJcbiAgICAgIGNsaWVudC5zdWJzY3JpcHRpb25Db3VudCA9IGNsaWVudC5zdWJzY3JpcHRpb25zLnNpemU7XHJcblxyXG4gICAgICAvLyBSZW1vdmUgZnJvbSByb29tIHN1YnNjcmlwdGlvbnNcclxuICAgICAgY29uc3Qgcm9vbVN1YnMgPSB0aGlzLnJvb21TdWJzY3JpcHRpb25zLmdldChzdWJzY3JpcHRpb25LZXkpO1xyXG4gICAgICBpZiAocm9vbVN1YnMpIHtcclxuICAgICAgICByb29tU3Vicy5kZWxldGUoc29ja2V0SWQpO1xyXG4gICAgICAgIGlmIChyb29tU3Vicy5zaXplID09PSAwKSB7XHJcbiAgICAgICAgICB0aGlzLnJvb21TdWJzY3JpcHRpb25zLmRlbGV0ZShzdWJzY3JpcHRpb25LZXkpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgdW5zdWJzY3JpYmVBbGwoc29ja2V0SWQpIHtcclxuICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuY29ubmVjdGVkQ2xpZW50cy5nZXQoc29ja2V0SWQpO1xyXG4gICAgaWYgKGNsaWVudCkge1xyXG4gICAgICBmb3IgKGNvbnN0IHN1YnNjcmlwdGlvbiBvZiBjbGllbnQuc3Vic2NyaXB0aW9ucykge1xyXG4gICAgICAgIGNvbnN0IFt0eXBlLCBpZGVudGlmaWVyXSA9IHN1YnNjcmlwdGlvbi5zcGxpdChcIjpcIik7XHJcbiAgICAgICAgY2xpZW50LnNvY2tldC5sZWF2ZShzdWJzY3JpcHRpb24pO1xyXG4gICAgICAgIHRoaXMucmVtb3ZlU3Vic2NyaXB0aW9uKHNvY2tldElkLCB0eXBlLCBpZGVudGlmaWVyKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgdW5zdWJzY3JpYmVCeVR5cGUoc29ja2V0SWQsIHR5cGUpIHtcclxuICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuY29ubmVjdGVkQ2xpZW50cy5nZXQoc29ja2V0SWQpO1xyXG4gICAgaWYgKGNsaWVudCkge1xyXG4gICAgICBjb25zdCBzdWJzY3JpcHRpb25zVG9SZW1vdmUgPSBBcnJheS5mcm9tKGNsaWVudC5zdWJzY3JpcHRpb25zKS5maWx0ZXIoXHJcbiAgICAgICAgKHN1YikgPT4gc3ViLnN0YXJ0c1dpdGgoYCR7dHlwZX06YClcclxuICAgICAgKTtcclxuXHJcbiAgICAgIGZvciAoY29uc3Qgc3Vic2NyaXB0aW9uIG9mIHN1YnNjcmlwdGlvbnNUb1JlbW92ZSkge1xyXG4gICAgICAgIGNvbnN0IFssIGlkZW50aWZpZXJdID0gc3Vic2NyaXB0aW9uLnNwbGl0KFwiOlwiKTtcclxuICAgICAgICBjbGllbnQuc29ja2V0LmxlYXZlKHN1YnNjcmlwdGlvbik7XHJcbiAgICAgICAgdGhpcy5yZW1vdmVTdWJzY3JpcHRpb24oc29ja2V0SWQsIHR5cGUsIGlkZW50aWZpZXIpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBFbmhhbmNlZCBicm9hZGNhc3RpbmcgbWV0aG9kc1xyXG4gIGFzeW5jIGJyb2FkY2FzdElQT1VwZGF0ZShpcG9JZCwgdXBkYXRlRGF0YSwgb3B0aW9ucyA9IHt9KSB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCB7XHJcbiAgICAgICAgcHJpb3JpdHkgPSBcIm5vcm1hbFwiLFxyXG4gICAgICAgIGV4Y2x1ZGVTb2NrZXQgPSBudWxsLFxyXG4gICAgICAgIGluY2x1ZGVBbmFseXRpY3MgPSBmYWxzZSxcclxuICAgICAgfSA9IG9wdGlvbnM7XHJcblxyXG4gICAgICBpZiAoIXRoaXMuY2hlY2tCcm9hZGNhc3RSYXRlTGltaXQoXCJpcG9cIiwgaXBvSWQpKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCByb29tID0gYGlwbzoke2lwb0lkfWA7XHJcbiAgICAgIGNvbnN0IHN1YnNjcmliZXJDb3VudCA9IHRoaXMucm9vbVN1YnNjcmlwdGlvbnMuZ2V0KHJvb20pPy5zaXplIHx8IDA7XHJcblxyXG4gICAgICBpZiAoc3Vic2NyaWJlckNvdW50ID4gMCkge1xyXG4gICAgICAgIGNvbnN0IGVucmljaGVkRGF0YSA9IHtcclxuICAgICAgICAgIGlwb0lkLFxyXG4gICAgICAgICAgZGF0YTogdXBkYXRlRGF0YSxcclxuICAgICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcclxuICAgICAgICAgIHByaW9yaXR5LFxyXG4gICAgICAgICAgc2VydmVyOiBwcm9jZXNzLmVudi5TRVJWRVJfSUQgfHwgXCJ3cy0xXCIsXHJcbiAgICAgICAgICB0eXBlOiBcInVwZGF0ZVwiLFxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGlmIChpbmNsdWRlQW5hbHl0aWNzICYmIHVwZGF0ZURhdGEuYW5hbHl0aWNzKSB7XHJcbiAgICAgICAgICBlbnJpY2hlZERhdGEuYW5hbHl0aWNzID0gdXBkYXRlRGF0YS5hbmFseXRpY3M7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoZXhjbHVkZVNvY2tldCkge1xyXG4gICAgICAgICAgdGhpcy5pb1xyXG4gICAgICAgICAgICAudG8ocm9vbSlcclxuICAgICAgICAgICAgLmV4Y2VwdChleGNsdWRlU29ja2V0KVxyXG4gICAgICAgICAgICAuZW1pdCh0aGlzLmV2ZW50cy5JUE9fVVBEQVRFLCBlbnJpY2hlZERhdGEpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB0aGlzLmlvLnRvKHJvb20pLmVtaXQodGhpcy5ldmVudHMuSVBPX1VQREFURSwgZW5yaWNoZWREYXRhKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICAgICAgYPCfk6EgSVBPIHVwZGF0ZSBicm9hZGNhc3QgdG8gJHtzdWJzY3JpYmVyQ291bnR9IGNsaWVudHMgZm9yIElQTyAke2lwb0lkfWBcclxuICAgICAgICApO1xyXG4gICAgICAgIHRoaXMubWV0cmljcy50b3RhbE1lc3NhZ2VzKys7XHJcblxyXG4gICAgICAgIC8vIFF1ZXVlIG1lc3NhZ2UgZm9yIG9mZmxpbmUgY2xpZW50cyBpZiBjcml0aWNhbFxyXG4gICAgICAgIGlmIChwcmlvcml0eSA9PT0gXCJoaWdoXCIpIHtcclxuICAgICAgICAgIHRoaXMucXVldWVNZXNzYWdlRm9yT2ZmbGluZUNsaWVudHMocm9vbSwgZW5yaWNoZWREYXRhKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBicm9hZGNhc3RpbmcgSVBPIHVwZGF0ZTpcIiwgZXJyb3IpO1xyXG4gICAgICB0aGlzLm1ldHJpY3MuZXJyb3JzKys7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBhc3luYyBicm9hZGNhc3RHTVBVcGRhdGUoaXBvSWQsIGdtcERhdGEsIG9wdGlvbnMgPSB7fSkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgeyBoaXN0b3JpY2FsID0gZmFsc2UsIGFsZXJ0Q2hlY2sgPSB0cnVlIH0gPSBvcHRpb25zO1xyXG5cclxuICAgICAgaWYgKCF0aGlzLmNoZWNrQnJvYWRjYXN0UmF0ZUxpbWl0KFwiZ21wXCIsIGlwb0lkKSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3Qgcm9vbSA9IGBnbXA6JHtpcG9JZH1gO1xyXG4gICAgICBjb25zdCBzdWJzY3JpYmVyQ291bnQgPSB0aGlzLnJvb21TdWJzY3JpcHRpb25zLmdldChyb29tKT8uc2l6ZSB8fCAwO1xyXG5cclxuICAgICAgaWYgKHN1YnNjcmliZXJDb3VudCA+IDApIHtcclxuICAgICAgICBjb25zdCBjaGFuZ2UgPSBhd2FpdCB0aGlzLmNhbGN1bGF0ZUdNUENoYW5nZShpcG9JZCwgZ21wRGF0YS52YWx1ZSk7XHJcbiAgICAgICAgY29uc3QgZW5yaWNoZWREYXRhID0ge1xyXG4gICAgICAgICAgaXBvSWQsXHJcbiAgICAgICAgICBkYXRhOiBnbXBEYXRhLFxyXG4gICAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxyXG4gICAgICAgICAgaGlzdG9yaWNhbCxcclxuICAgICAgICAgIGNoYW5nZSxcclxuICAgICAgICAgIHRyZW5kOiB0aGlzLmNhbGN1bGF0ZUdNUFRyZW5kKGNoYW5nZSksXHJcbiAgICAgICAgICB2b2xhdGlsaXR5OiBhd2FpdCB0aGlzLmNhbGN1bGF0ZUdNUFZvbGF0aWxpdHkoaXBvSWQpLFxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHRoaXMuaW8udG8ocm9vbSkuZW1pdCh0aGlzLmV2ZW50cy5HTVBfVVBEQVRFLCBlbnJpY2hlZERhdGEpO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICAgICAgYPCfkrAgR01QIHVwZGF0ZSBicm9hZGNhc3QgdG8gJHtzdWJzY3JpYmVyQ291bnR9IGNsaWVudHMgZm9yIElQTyAke2lwb0lkfSAoVmFsdWU6ICR7Z21wRGF0YS52YWx1ZX0pYFxyXG4gICAgICAgICk7XHJcbiAgICAgICAgdGhpcy5tZXRyaWNzLnRvdGFsTWVzc2FnZXMrKztcclxuXHJcbiAgICAgICAgLy8gQ2hlY2sgZm9yIEdNUCBhbGVydHNcclxuICAgICAgICBpZiAoYWxlcnRDaGVjaykge1xyXG4gICAgICAgICAgdGhpcy5jaGVja0dNUEFsZXJ0cyhpcG9JZCwgZ21wRGF0YS52YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgYnJvYWRjYXN0aW5nIEdNUCB1cGRhdGU6XCIsIGVycm9yKTtcclxuICAgICAgdGhpcy5tZXRyaWNzLmVycm9ycysrO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgYXN5bmMgYnJvYWRjYXN0U3Vic2NyaXB0aW9uVXBkYXRlKHN5bWJvbCwgc3Vic2NyaXB0aW9uRGF0YSwgb3B0aW9ucyA9IHt9KSB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCB7IGNhdGVnb3J5ID0gbnVsbCwgYWxlcnRPbk92ZXJzdWJzY3JpcHRpb24gPSB0cnVlIH0gPSBvcHRpb25zO1xyXG5cclxuICAgICAgaWYgKCF0aGlzLmNoZWNrQnJvYWRjYXN0UmF0ZUxpbWl0KFwic3Vic2NyaXB0aW9uXCIsIHN5bWJvbCkpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IHJvb20gPSBgc3Vic2NyaXB0aW9uOiR7c3ltYm9sfWA7XHJcbiAgICAgIGNvbnN0IHN1YnNjcmliZXJDb3VudCA9IHRoaXMucm9vbVN1YnNjcmlwdGlvbnMuZ2V0KHJvb20pPy5zaXplIHx8IDA7XHJcblxyXG4gICAgICBpZiAoc3Vic2NyaWJlckNvdW50ID4gMCkge1xyXG4gICAgICAgIGNvbnN0IGVucmljaGVkRGF0YSA9IHtcclxuICAgICAgICAgIHN5bWJvbCxcclxuICAgICAgICAgIGRhdGE6IHN1YnNjcmlwdGlvbkRhdGEsXHJcbiAgICAgICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXHJcbiAgICAgICAgICBjYXRlZ29yeSxcclxuICAgICAgICAgIG92ZXJhbGxTdWJzY3JpcHRpb246XHJcbiAgICAgICAgICAgIHRoaXMuY2FsY3VsYXRlT3ZlcmFsbFN1YnNjcmlwdGlvbihzdWJzY3JpcHRpb25EYXRhKSxcclxuICAgICAgICAgIGlzT3ZlcnN1YnNjcmliZWQ6IHRoaXMuaXNPdmVyc3Vic2NyaWJlZChzdWJzY3JpcHRpb25EYXRhKSxcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICB0aGlzLmlvLnRvKHJvb20pLmVtaXQodGhpcy5ldmVudHMuU1VCU0NSSVBUSU9OX1VQREFURSwgZW5yaWNoZWREYXRhKTtcclxuICAgICAgICBjb25zb2xlLmxvZyhcclxuICAgICAgICAgIGDwn5OKIFN1YnNjcmlwdGlvbiB1cGRhdGUgYnJvYWRjYXN0IHRvICR7c3Vic2NyaWJlckNvdW50fSBjbGllbnRzIGZvciAke3N5bWJvbH1gXHJcbiAgICAgICAgKTtcclxuICAgICAgICB0aGlzLm1ldHJpY3MudG90YWxNZXNzYWdlcysrO1xyXG5cclxuICAgICAgICAvLyBBbGVydCBvbiBvdmVyc3Vic2NyaXB0aW9uXHJcbiAgICAgICAgaWYgKGFsZXJ0T25PdmVyc3Vic2NyaXB0aW9uICYmIGVucmljaGVkRGF0YS5pc092ZXJzdWJzY3JpYmVkKSB7XHJcbiAgICAgICAgICB0aGlzLmJyb2FkY2FzdEFsZXJ0KFwib3ZlcnN1YnNjcmlwdGlvblwiLCB7XHJcbiAgICAgICAgICAgIHN5bWJvbCxcclxuICAgICAgICAgICAgc3Vic2NyaXB0aW9uOiBlbnJpY2hlZERhdGEub3ZlcmFsbFN1YnNjcmlwdGlvbixcclxuICAgICAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgYnJvYWRjYXN0aW5nIHN1YnNjcmlwdGlvbiB1cGRhdGU6XCIsIGVycm9yKTtcclxuICAgICAgdGhpcy5tZXRyaWNzLmVycm9ycysrO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgYXN5bmMgYnJvYWRjYXN0RGVtYW5kVXBkYXRlKHN5bWJvbCwgZGVtYW5kRGF0YSwgb3B0aW9ucyA9IHt9KSB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCB7IHByaWNlTGV2ZWwgPSBudWxsIH0gPSBvcHRpb25zO1xyXG5cclxuICAgICAgaWYgKCF0aGlzLmNoZWNrQnJvYWRjYXN0UmF0ZUxpbWl0KFwiZGVtYW5kXCIsIHN5bWJvbCkpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IHJvb20gPSBgZGVtYW5kOiR7c3ltYm9sfWA7XHJcbiAgICAgIGNvbnN0IHN1YnNjcmliZXJDb3VudCA9IHRoaXMucm9vbVN1YnNjcmlwdGlvbnMuZ2V0KHJvb20pPy5zaXplIHx8IDA7XHJcblxyXG4gICAgICBpZiAoc3Vic2NyaWJlckNvdW50ID4gMCkge1xyXG4gICAgICAgIGNvbnN0IGVucmljaGVkRGF0YSA9IHtcclxuICAgICAgICAgIHN5bWJvbCxcclxuICAgICAgICAgIGRhdGE6IGRlbWFuZERhdGEsXHJcbiAgICAgICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXHJcbiAgICAgICAgICBwcmljZUxldmVsLFxyXG4gICAgICAgICAgdG90YWxEZW1hbmQ6IHRoaXMuY2FsY3VsYXRlVG90YWxEZW1hbmQoZGVtYW5kRGF0YSksXHJcbiAgICAgICAgICBjdXRPZmZEZW1hbmQ6IHRoaXMuY2FsY3VsYXRlQ3V0T2ZmRGVtYW5kKGRlbWFuZERhdGEpLFxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHRoaXMuaW8udG8ocm9vbSkuZW1pdCh0aGlzLmV2ZW50cy5ERU1BTkRfVVBEQVRFLCBlbnJpY2hlZERhdGEpO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICAgICAgYPCfk4ggRGVtYW5kIHVwZGF0ZSBicm9hZGNhc3QgdG8gJHtzdWJzY3JpYmVyQ291bnR9IGNsaWVudHMgZm9yICR7c3ltYm9sfWBcclxuICAgICAgICApO1xyXG4gICAgICAgIHRoaXMubWV0cmljcy50b3RhbE1lc3NhZ2VzKys7XHJcbiAgICAgIH1cclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBicm9hZGNhc3RpbmcgZGVtYW5kIHVwZGF0ZTpcIiwgZXJyb3IpO1xyXG4gICAgICB0aGlzLm1ldHJpY3MuZXJyb3JzKys7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBhc3luYyBicm9hZGNhc3RBbmFseXRpY3NVcGRhdGUoaXBvSWQsIGFuYWx5dGljc0RhdGEsIG9wdGlvbnMgPSB7fSkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgeyB0eXBlID0gXCJnZW5lcmFsXCIsIG1ldHJpY3MgPSBudWxsIH0gPSBvcHRpb25zO1xyXG5cclxuICAgICAgaWYgKCF0aGlzLmNoZWNrQnJvYWRjYXN0UmF0ZUxpbWl0KFwiYW5hbHl0aWNzXCIsIGlwb0lkKSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3Qgcm9vbSA9IGBhbmFseXRpY3M6JHtpcG9JZH1gO1xyXG4gICAgICBjb25zdCBzdWJzY3JpYmVyQ291bnQgPSB0aGlzLnJvb21TdWJzY3JpcHRpb25zLmdldChyb29tKT8uc2l6ZSB8fCAwO1xyXG5cclxuICAgICAgaWYgKHN1YnNjcmliZXJDb3VudCA+IDApIHtcclxuICAgICAgICBjb25zdCBlbnJpY2hlZERhdGEgPSB7XHJcbiAgICAgICAgICBpcG9JZCxcclxuICAgICAgICAgIHR5cGUsXHJcbiAgICAgICAgICBkYXRhOiBhbmFseXRpY3NEYXRhLFxyXG4gICAgICAgICAgbWV0cmljcyxcclxuICAgICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcclxuICAgICAgICAgIGluc2lnaHRzOiBhd2FpdCB0aGlzLmdlbmVyYXRlQW5hbHl0aWNzSW5zaWdodHMoYW5hbHl0aWNzRGF0YSksXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgdGhpcy5pby50byhyb29tKS5lbWl0KHRoaXMuZXZlbnRzLkFOQUxZVElDU19VUERBVEUsIGVucmljaGVkRGF0YSk7XHJcbiAgICAgICAgY29uc29sZS5sb2coXHJcbiAgICAgICAgICBg8J+TiiBBbmFseXRpY3MgdXBkYXRlIGJyb2FkY2FzdCB0byAke3N1YnNjcmliZXJDb3VudH0gY2xpZW50cyBmb3IgSVBPICR7aXBvSWR9YFxyXG4gICAgICAgICk7XHJcbiAgICAgICAgdGhpcy5tZXRyaWNzLnRvdGFsTWVzc2FnZXMrKztcclxuICAgICAgfVxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGJyb2FkY2FzdGluZyBhbmFseXRpY3MgdXBkYXRlOlwiLCBlcnJvcik7XHJcbiAgICAgIHRoaXMubWV0cmljcy5lcnJvcnMrKztcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIEJyb2FkY2FzdCBzeXN0ZW0gc3RhdHVzXHJcbiAgYXN5bmMgYnJvYWRjYXN0U3lzdGVtU3RhdHVzKHN0YXR1cywgb3B0aW9ucyA9IHt9KSB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCB7IHByaW9yaXR5ID0gXCJub3JtYWxcIiwgcm9vbSA9IFwic3lzdGVtOnN0YXR1c1wiIH0gPSBvcHRpb25zO1xyXG4gICAgICBjb25zdCBzdWJzY3JpYmVyQ291bnQgPSB0aGlzLnJvb21TdWJzY3JpcHRpb25zLmdldChyb29tKT8uc2l6ZSB8fCAwO1xyXG5cclxuICAgICAgaWYgKHN1YnNjcmliZXJDb3VudCA+IDApIHtcclxuICAgICAgICBjb25zdCBlbnJpY2hlZFN0YXR1cyA9IHtcclxuICAgICAgICAgIC4uLnN0YXR1cyxcclxuICAgICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcclxuICAgICAgICAgIHNlcnZlcjogcHJvY2Vzcy5lbnYuU0VSVkVSX0lEIHx8IFwid3MtMVwiLFxyXG4gICAgICAgICAgcHJpb3JpdHksXHJcbiAgICAgICAgICBjb25uZWN0aW9uczogdGhpcy5tZXRyaWNzLmN1cnJlbnRDb25uZWN0aW9ucyxcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICB0aGlzLmlvLnRvKHJvb20pLmVtaXQodGhpcy5ldmVudHMuU1lTVEVNX1NUQVRVUywgZW5yaWNoZWRTdGF0dXMpO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGDwn5SUIFN5c3RlbSBzdGF0dXMgYnJvYWRjYXN0IHRvICR7c3Vic2NyaWJlckNvdW50fSBjbGllbnRzYCk7XHJcbiAgICAgICAgdGhpcy5tZXRyaWNzLnRvdGFsTWVzc2FnZXMrKztcclxuICAgICAgfVxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGJyb2FkY2FzdGluZyBzeXN0ZW0gc3RhdHVzOlwiLCBlcnJvcik7XHJcbiAgICAgIHRoaXMubWV0cmljcy5lcnJvcnMrKztcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIEJyb2FkY2FzdCBhbGVydHNcclxuICBhc3luYyBicm9hZGNhc3RBbGVydChhbGVydFR5cGUsIGFsZXJ0RGF0YSkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgZW5yaWNoZWRBbGVydCA9IHtcclxuICAgICAgICB0eXBlOiBhbGVydFR5cGUsXHJcbiAgICAgICAgZGF0YTogYWxlcnREYXRhLFxyXG4gICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcclxuICAgICAgICBzZXJ2ZXI6IHByb2Nlc3MuZW52LlNFUlZFUl9JRCB8fCBcIndzLTFcIixcclxuICAgICAgICBzZXZlcml0eTogdGhpcy5nZXRBbGVydFNldmVyaXR5KGFsZXJ0VHlwZSksXHJcbiAgICAgIH07XHJcblxyXG4gICAgICAvLyBCcm9hZGNhc3QgdG8gYWxsIGNvbm5lY3RlZCBjbGllbnRzXHJcbiAgICAgIHRoaXMuaW8uZW1pdCh0aGlzLmV2ZW50cy5BTEVSVF9UUklHR0VSRUQsIGVucmljaGVkQWxlcnQpO1xyXG4gICAgICBjb25zb2xlLmxvZyhg8J+aqCBBbGVydCBicm9hZGNhc3Q6ICR7YWxlcnRUeXBlfWApO1xyXG4gICAgICB0aGlzLm1ldHJpY3MudG90YWxNZXNzYWdlcysrO1xyXG5cclxuICAgICAgLy8gU3RvcmUgYWxlcnQgZm9yIHF1ZXVpbmdcclxuICAgICAgdGhpcy5xdWV1ZU1lc3NhZ2VGb3JPZmZsaW5lQ2xpZW50cyhcImdsb2JhbFwiLCBlbnJpY2hlZEFsZXJ0KTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBicm9hZGNhc3RpbmcgYWxlcnQ6XCIsIGVycm9yKTtcclxuICAgICAgdGhpcy5tZXRyaWNzLmVycm9ycysrO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gQnJvYWRjYXN0IHJhdGUgbGltaXRpbmdcclxuICBjaGVja0Jyb2FkY2FzdFJhdGVMaW1pdChldmVudFR5cGUsIGlkZW50aWZpZXIpIHtcclxuICAgIGNvbnN0IGtleSA9IGBicm9hZGNhc3Q6JHtldmVudFR5cGV9OiR7aWRlbnRpZmllcn1gO1xyXG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcclxuICAgIGNvbnN0IHdpbmRvd1N0YXJ0ID0gTWF0aC5mbG9vcihub3cgLyA1MDAwKSAqIDUwMDA7IC8vIDUtc2Vjb25kIHdpbmRvd1xyXG5cclxuICAgIGlmICghdGhpcy5yYXRlTGltaXRzLmhhcyhrZXkpKSB7XHJcbiAgICAgIHRoaXMucmF0ZUxpbWl0cy5zZXQoa2V5LCB7IGNvdW50OiAwLCB3aW5kb3dTdGFydCB9KTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBsaW1pdCA9IHRoaXMucmF0ZUxpbWl0cy5nZXQoa2V5KTtcclxuXHJcbiAgICBpZiAobGltaXQud2luZG93U3RhcnQgIT09IHdpbmRvd1N0YXJ0KSB7XHJcbiAgICAgIGxpbWl0LmNvdW50ID0gMDtcclxuICAgICAgbGltaXQud2luZG93U3RhcnQgPSB3aW5kb3dTdGFydDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBNYXggMTAgYnJvYWRjYXN0cyBwZXIgNSBzZWNvbmRzIHBlciBldmVudCB0eXBlXHJcbiAgICBpZiAobGltaXQuY291bnQgPj0gMTApIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIGxpbWl0LmNvdW50Kys7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcblxyXG4gIC8vIENhbGN1bGF0ZSBHTVAgY2hhbmdlIGFuZCB0cmVuZFxyXG4gIGFzeW5jIGNhbGN1bGF0ZUdNUENoYW5nZShpcG9JZCwgY3VycmVudFZhbHVlKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICBpZiAoIXRoaXMucHJldmlvdXNHTVBWYWx1ZXMpIHtcclxuICAgICAgICB0aGlzLnByZXZpb3VzR01QVmFsdWVzID0gbmV3IE1hcCgpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCBwcmV2aW91c1ZhbHVlID0gdGhpcy5wcmV2aW91c0dNUFZhbHVlcy5nZXQoaXBvSWQpIHx8IGN1cnJlbnRWYWx1ZTtcclxuICAgICAgdGhpcy5wcmV2aW91c0dNUFZhbHVlcy5zZXQoaXBvSWQsIGN1cnJlbnRWYWx1ZSk7XHJcblxyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIGFic29sdXRlOiBjdXJyZW50VmFsdWUgLSBwcmV2aW91c1ZhbHVlLFxyXG4gICAgICAgIHBlcmNlbnRhZ2U6XHJcbiAgICAgICAgICBwcmV2aW91c1ZhbHVlID4gMFxyXG4gICAgICAgICAgICA/IHBhcnNlRmxvYXQoXHJcbiAgICAgICAgICAgICAgICAoXHJcbiAgICAgICAgICAgICAgICAgICgoY3VycmVudFZhbHVlIC0gcHJldmlvdXNWYWx1ZSkgLyBwcmV2aW91c1ZhbHVlKSAqXHJcbiAgICAgICAgICAgICAgICAgIDEwMFxyXG4gICAgICAgICAgICAgICAgKS50b0ZpeGVkKDIpXHJcbiAgICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICA6IDAsXHJcbiAgICAgICAgZGlyZWN0aW9uOlxyXG4gICAgICAgICAgY3VycmVudFZhbHVlID4gcHJldmlvdXNWYWx1ZVxyXG4gICAgICAgICAgICA/IFwidXBcIlxyXG4gICAgICAgICAgICA6IGN1cnJlbnRWYWx1ZSA8IHByZXZpb3VzVmFsdWVcclxuICAgICAgICAgICAgICA/IFwiZG93blwiXHJcbiAgICAgICAgICAgICAgOiBcInN0YWJsZVwiLFxyXG4gICAgICB9O1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgcmV0dXJuIHsgYWJzb2x1dGU6IDAsIHBlcmNlbnRhZ2U6IDAsIGRpcmVjdGlvbjogXCJzdGFibGVcIiB9O1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgY2FsY3VsYXRlR01QVHJlbmQoY2hhbmdlKSB7XHJcbiAgICBpZiAoTWF0aC5hYnMoY2hhbmdlLnBlcmNlbnRhZ2UpIDwgMSkgcmV0dXJuIFwic3RhYmxlXCI7XHJcbiAgICBpZiAoY2hhbmdlLnBlcmNlbnRhZ2UgPiA1KSByZXR1cm4gXCJidWxsaXNoXCI7XHJcbiAgICBpZiAoY2hhbmdlLnBlcmNlbnRhZ2UgPCAtNSkgcmV0dXJuIFwiYmVhcmlzaFwiO1xyXG4gICAgcmV0dXJuIGNoYW5nZS5kaXJlY3Rpb247XHJcbiAgfVxyXG5cclxuICBhc3luYyBjYWxjdWxhdGVHTVBWb2xhdGlsaXR5KGlwb0lkKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCByZWNlbnRHTVAgPSBhd2FpdCBwcmlzbWEuZ01QLmZpbmRNYW55KHtcclxuICAgICAgICB3aGVyZTogeyBpcG9JZCB9LFxyXG4gICAgICAgIG9yZGVyQnk6IHsgdGltZXN0YW1wOiBcImRlc2NcIiB9LFxyXG4gICAgICAgIHRha2U6IDEwLFxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGlmIChyZWNlbnRHTVAubGVuZ3RoIDwgMikgcmV0dXJuIDA7XHJcblxyXG4gICAgICBjb25zdCB2YWx1ZXMgPSByZWNlbnRHTVAubWFwKChnKSA9PiBnLnZhbHVlKTtcclxuICAgICAgY29uc3QgbWVhbiA9IHZhbHVlcy5yZWR1Y2UoKGEsIGIpID0+IGEgKyBiKSAvIHZhbHVlcy5sZW5ndGg7XHJcbiAgICAgIGNvbnN0IHZhcmlhbmNlID1cclxuICAgICAgICB2YWx1ZXMucmVkdWNlKChhY2MsIHZhbCkgPT4gYWNjICsgTWF0aC5wb3codmFsIC0gbWVhbiwgMiksIDApIC9cclxuICAgICAgICB2YWx1ZXMubGVuZ3RoO1xyXG5cclxuICAgICAgcmV0dXJuIE1hdGgucm91bmQoTWF0aC5zcXJ0KHZhcmlhbmNlKSAqIDEwMCkgLyAxMDA7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICByZXR1cm4gMDtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIFN1YnNjcmlwdGlvbiBjYWxjdWxhdGlvbiB1dGlsaXRpZXNcclxuICBjYWxjdWxhdGVPdmVyYWxsU3Vic2NyaXB0aW9uKHN1YnNjcmlwdGlvbkRhdGEpIHtcclxuICAgIGlmICghQXJyYXkuaXNBcnJheShzdWJzY3JpcHRpb25EYXRhKSkgcmV0dXJuIDA7XHJcblxyXG4gICAgY29uc3QgcmF0aW9zID0gc3Vic2NyaXB0aW9uRGF0YS5tYXAoKGl0ZW0pID0+XHJcbiAgICAgIHBhcnNlRmxvYXQoaXRlbS5zdWJzY3JpcHRpb25SYXRpbyB8fCAwKVxyXG4gICAgKTtcclxuICAgIHJldHVybiByYXRpb3MubGVuZ3RoID4gMCA/IE1hdGgubWF4KC4uLnJhdGlvcykgOiAwO1xyXG4gIH1cclxuXHJcbiAgaXNPdmVyc3Vic2NyaWJlZChzdWJzY3JpcHRpb25EYXRhKSB7XHJcbiAgICByZXR1cm4gdGhpcy5jYWxjdWxhdGVPdmVyYWxsU3Vic2NyaXB0aW9uKHN1YnNjcmlwdGlvbkRhdGEpID4gMTtcclxuICB9XHJcblxyXG4gIGNhbGN1bGF0ZVRvdGFsRGVtYW5kKGRlbWFuZERhdGEpIHtcclxuICAgIGlmICghQXJyYXkuaXNBcnJheShkZW1hbmREYXRhKSkgcmV0dXJuIDA7XHJcblxyXG4gICAgcmV0dXJuIGRlbWFuZERhdGEucmVkdWNlKFxyXG4gICAgICAodG90YWwsIGl0ZW0pID0+IHRvdGFsICsgcGFyc2VJbnQoaXRlbS5hYnNvbHV0ZVF1YW50aXR5IHx8IDApLFxyXG4gICAgICAwXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgY2FsY3VsYXRlQ3V0T2ZmRGVtYW5kKGRlbWFuZERhdGEpIHtcclxuICAgIGlmICghQXJyYXkuaXNBcnJheShkZW1hbmREYXRhKSkgcmV0dXJuIDA7XHJcblxyXG4gICAgcmV0dXJuIGRlbWFuZERhdGFcclxuICAgICAgLmZpbHRlcigoaXRlbSkgPT4gaXRlbS5jdXRPZmZJbmRpY2F0b3IpXHJcbiAgICAgIC5yZWR1Y2UoKHRvdGFsLCBpdGVtKSA9PiB0b3RhbCArIHBhcnNlSW50KGl0ZW0uYWJzb2x1dGVRdWFudGl0eSB8fCAwKSwgMCk7XHJcbiAgfVxyXG5cclxuICAvLyBHZW5lcmF0ZSBhbmFseXRpY3MgaW5zaWdodHNcclxuICBhc3luYyBnZW5lcmF0ZUFuYWx5dGljc0luc2lnaHRzKGFuYWx5dGljc0RhdGEpIHtcclxuICAgIGNvbnN0IGluc2lnaHRzID0gW107XHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgaWYgKGFuYWx5dGljc0RhdGEuZ21wVm9sYXRpbGl0eSA+IDIwKSB7XHJcbiAgICAgICAgaW5zaWdodHMucHVzaCh7XHJcbiAgICAgICAgICB0eXBlOiBcIndhcm5pbmdcIixcclxuICAgICAgICAgIG1lc3NhZ2U6IFwiSGlnaCBHTVAgdm9sYXRpbGl0eSBkZXRlY3RlZFwiLFxyXG4gICAgICAgICAgdmFsdWU6IGFuYWx5dGljc0RhdGEuZ21wVm9sYXRpbGl0eSxcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGFuYWx5dGljc0RhdGEuZmluYWxTdWJzY3JpcHRpb24gPiA1KSB7XHJcbiAgICAgICAgaW5zaWdodHMucHVzaCh7XHJcbiAgICAgICAgICB0eXBlOiBcInBvc2l0aXZlXCIsXHJcbiAgICAgICAgICBtZXNzYWdlOiBcIlN0cm9uZyBzdWJzY3JpcHRpb24gZGVtYW5kXCIsXHJcbiAgICAgICAgICB2YWx1ZTogYW5hbHl0aWNzRGF0YS5maW5hbFN1YnNjcmlwdGlvbixcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGFuYWx5dGljc0RhdGEucmlza1Njb3JlID4gNzApIHtcclxuICAgICAgICBpbnNpZ2h0cy5wdXNoKHtcclxuICAgICAgICAgIHR5cGU6IFwiY2F1dGlvblwiLFxyXG4gICAgICAgICAgbWVzc2FnZTogXCJIaWdoIHJpc2sgc2NvcmVcIixcclxuICAgICAgICAgIHZhbHVlOiBhbmFseXRpY3NEYXRhLnJpc2tTY29yZSxcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGdlbmVyYXRpbmcgaW5zaWdodHM6XCIsIGVycm9yKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gaW5zaWdodHM7XHJcbiAgfVxyXG5cclxuICAvLyBEYXRhIGZldGNoaW5nIG1ldGhvZHNcclxuICBhc3luYyBnZXRDdXJyZW50SVBPRGF0YShpcG9JZCkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgaXBvID0gYXdhaXQgcHJpc21hLmlQTy5maW5kVW5pcXVlKHtcclxuICAgICAgICB3aGVyZTogeyBpZDogaXBvSWQgfSxcclxuICAgICAgICBpbmNsdWRlOiB7XHJcbiAgICAgICAgICBnbXA6IHtcclxuICAgICAgICAgICAgdGFrZTogNSxcclxuICAgICAgICAgICAgb3JkZXJCeTogeyB0aW1lc3RhbXA6IFwiZGVzY1wiIH0sXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgc3Vic2NyaXB0aW9uOiB7XHJcbiAgICAgICAgICAgIG9yZGVyQnk6IHsgdGltZXN0YW1wOiBcImRlc2NcIiB9LFxyXG4gICAgICAgICAgICB0YWtlOiAxMCxcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBhbmFseXRpY3M6IHRydWUsXHJcbiAgICAgICAgICBjYXRlZ29yaWVzOiB0cnVlLFxyXG4gICAgICAgIH0sXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgcmV0dXJuIGlwbztcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBmZXRjaGluZyBjdXJyZW50IElQTyBkYXRhOlwiLCBlcnJvcik7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgYXN5bmMgZ2V0SGlzdG9yaWNhbEdNUERhdGEoaXBvSWQsIGRheXMgPSAzMCkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3Qgc3RhcnREYXRlID0gbmV3IERhdGUoKTtcclxuICAgICAgc3RhcnREYXRlLnNldERhdGUoc3RhcnREYXRlLmdldERhdGUoKSAtIGRheXMpO1xyXG5cclxuICAgICAgY29uc3QgZ21wRGF0YSA9IGF3YWl0IHByaXNtYS5nTVAuZmluZE1hbnkoe1xyXG4gICAgICAgIHdoZXJlOiB7XHJcbiAgICAgICAgICBpcG9JZCxcclxuICAgICAgICAgIHRpbWVzdGFtcDoge1xyXG4gICAgICAgICAgICBndGU6IHN0YXJ0RGF0ZSxcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgfSxcclxuICAgICAgICBvcmRlckJ5OiB7IHRpbWVzdGFtcDogXCJhc2NcIiB9LFxyXG4gICAgICAgIHRha2U6IDEwMDAsIC8vIExpbWl0IGZvciBwZXJmb3JtYW5jZVxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIHJldHVybiBnbXBEYXRhO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGZldGNoaW5nIGhpc3RvcmljYWwgR01QIGRhdGE6XCIsIGVycm9yKTtcclxuICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgYXN5bmMgZ2V0Q3VycmVudEFuYWx5dGljcyhpcG9JZCwgdHlwZSA9IFwiYWxsXCIpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IGFuYWx5dGljcyA9IGF3YWl0IHByaXNtYS5pUE9BbmFseXRpY3MuZmluZFVuaXF1ZSh7XHJcbiAgICAgICAgd2hlcmU6IHsgaXBvSWQgfSxcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBpZiAodHlwZSA9PT0gXCJhbGxcIikge1xyXG4gICAgICAgIHJldHVybiBhbmFseXRpY3M7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFJldHVybiBzcGVjaWZpYyBhbmFseXRpY3MgYmFzZWQgb24gdHlwZVxyXG4gICAgICBjb25zdCB0eXBlTWFwcGluZyA9IHtcclxuICAgICAgICBnbXA6IFtcImF2Z0dNUFwiLCBcIm1heEdNUFwiLCBcIm1pbkdNUFwiLCBcImdtcFZvbGF0aWxpdHlcIl0sXHJcbiAgICAgICAgc3Vic2NyaXB0aW9uOiBbXHJcbiAgICAgICAgICBcImZpbmFsU3Vic2NyaXB0aW9uXCIsXHJcbiAgICAgICAgICBcInJldGFpbFN1YnNjcmlwdGlvblwiLFxyXG4gICAgICAgICAgXCJxaWJTdWJzY3JpcHRpb25cIixcclxuICAgICAgICBdLFxyXG4gICAgICAgIHByZWRpY3Rpb246IFtcclxuICAgICAgICAgIFwicHJlZGljdGVkTGlzdGluZ0dhaW5cIixcclxuICAgICAgICAgIFwiYWxsb3RtZW50UHJvYmFiaWxpdHlcIixcclxuICAgICAgICAgIFwicmlza1Njb3JlXCIsXHJcbiAgICAgICAgXSxcclxuICAgICAgfTtcclxuXHJcbiAgICAgIGlmICh0eXBlTWFwcGluZ1t0eXBlXSAmJiBhbmFseXRpY3MpIHtcclxuICAgICAgICBjb25zdCBmaWx0ZXJlZEFuYWx5dGljcyA9IHt9O1xyXG4gICAgICAgIHR5cGVNYXBwaW5nW3R5cGVdLmZvckVhY2goKGtleSkgPT4ge1xyXG4gICAgICAgICAgaWYgKGFuYWx5dGljc1trZXldICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgZmlsdGVyZWRBbmFseXRpY3Nba2V5XSA9IGFuYWx5dGljc1trZXldO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBmaWx0ZXJlZEFuYWx5dGljcztcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIGFuYWx5dGljcztcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBmZXRjaGluZyBhbmFseXRpY3M6XCIsIGVycm9yKTtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBTeXN0ZW0gc3RhdHVzXHJcbiAgYXN5bmMgZ2V0U3lzdGVtU3RhdHVzKCkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgW2RiSGVhbHRoLCBjYWNoZUhlYWx0aF0gPSBhd2FpdCBQcm9taXNlLmFsbFNldHRsZWQoW1xyXG4gICAgICAgIHByaXNtYS4kcXVlcnlSYXdgU0VMRUNUIDFgLFxyXG4gICAgICAgIGNhY2hlLmhlYWx0aENoZWNrKCksXHJcbiAgICAgIF0pO1xyXG5cclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBzdGF0dXM6IFwib3BlcmF0aW9uYWxcIixcclxuICAgICAgICBjb25uZWN0aW9uczogdGhpcy5tZXRyaWNzLmN1cnJlbnRDb25uZWN0aW9ucyxcclxuICAgICAgICB1cHRpbWU6IERhdGUubm93KCkgLSB0aGlzLm1ldHJpY3Muc3RhcnRUaW1lLFxyXG4gICAgICAgIGRhdGFiYXNlOiBkYkhlYWx0aC5zdGF0dXMgPT09IFwiZnVsZmlsbGVkXCIgPyBcImhlYWx0aHlcIiA6IFwiZGVncmFkZWRcIixcclxuICAgICAgICBjYWNoZTpcclxuICAgICAgICAgIGNhY2hlSGVhbHRoLnN0YXR1cyA9PT0gXCJmdWxmaWxsZWRcIiAmJlxyXG4gICAgICAgICAgY2FjaGVIZWFsdGgudmFsdWUuc3RhdHVzID09PSBcImhlYWx0aHlcIlxyXG4gICAgICAgICAgICA/IFwiaGVhbHRoeVwiXHJcbiAgICAgICAgICAgIDogXCJkZWdyYWRlZFwiLFxyXG4gICAgICAgIHdlYnNvY2tldDogXCJoZWFsdGh5XCIsXHJcbiAgICAgICAgdmVyc2lvbjogXCIxLjAuMFwiLFxyXG4gICAgICB9O1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBzdGF0dXM6IFwiZGVncmFkZWRcIixcclxuICAgICAgICBlcnJvcjogZXJyb3IubWVzc2FnZSxcclxuICAgICAgICB1cHRpbWU6IERhdGUubm93KCkgLSB0aGlzLm1ldHJpY3Muc3RhcnRUaW1lLFxyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gRmlsdGVyIGFuYWx5dGljcyBieSBzcGVjaWZpYyBtZXRyaWNzXHJcbiAgZmlsdGVyQW5hbHl0aWNzQnlNZXRyaWNzKGFuYWx5dGljcywgbWV0cmljcykge1xyXG4gICAgaWYgKCFhbmFseXRpY3MgfHwgIUFycmF5LmlzQXJyYXkobWV0cmljcykpIHJldHVybiBhbmFseXRpY3M7XHJcblxyXG4gICAgY29uc3QgZmlsdGVyZWQgPSB7fTtcclxuICAgIG1ldHJpY3MuZm9yRWFjaCgobWV0cmljKSA9PiB7XHJcbiAgICAgIGlmIChhbmFseXRpY3NbbWV0cmljXSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgZmlsdGVyZWRbbWV0cmljXSA9IGFuYWx5dGljc1ttZXRyaWNdO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gZmlsdGVyZWQ7XHJcbiAgfVxyXG5cclxuICAvLyBHTVAgQWxlcnQgbWFuYWdlbWVudFxyXG4gIHNldHVwR01QQWxlcnQoc29ja2V0SWQsIGlwb0lkLCB0aHJlc2hvbGQpIHtcclxuICAgIGlmICghdGhpcy5nbXBBbGVydHMpIHtcclxuICAgICAgdGhpcy5nbXBBbGVydHMgPSBuZXcgTWFwKCk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgYWxlcnRLZXkgPSBgJHtzb2NrZXRJZH06JHtpcG9JZH1gO1xyXG4gICAgdGhpcy5nbXBBbGVydHMuc2V0KGFsZXJ0S2V5LCB7XHJcbiAgICAgIHRocmVzaG9sZCxcclxuICAgICAgdHJpZ2dlcmVkOiBmYWxzZSxcclxuICAgICAgY3JlYXRlZEF0OiBEYXRlLm5vdygpLFxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBjaGVja0dNUEFsZXJ0cyhpcG9JZCwgY3VycmVudEdNUCkge1xyXG4gICAgaWYgKCF0aGlzLmdtcEFsZXJ0cykgcmV0dXJuO1xyXG5cclxuICAgIGZvciAoY29uc3QgW2FsZXJ0S2V5LCBhbGVydF0gb2YgdGhpcy5nbXBBbGVydHMpIHtcclxuICAgICAgY29uc3QgW3NvY2tldElkLCBhbGVydElwb0lkXSA9IGFsZXJ0S2V5LnNwbGl0KFwiOlwiKTtcclxuXHJcbiAgICAgIGlmIChhbGVydElwb0lkID09PSBpcG9JZCAmJiAhYWxlcnQudHJpZ2dlcmVkKSB7XHJcbiAgICAgICAgaWYgKGN1cnJlbnRHTVAgPj0gYWxlcnQudGhyZXNob2xkKSB7XHJcbiAgICAgICAgICBjb25zdCBjbGllbnQgPSB0aGlzLmNvbm5lY3RlZENsaWVudHMuZ2V0KHNvY2tldElkKTtcclxuICAgICAgICAgIGlmIChjbGllbnQpIHtcclxuICAgICAgICAgICAgY2xpZW50LnNvY2tldC5lbWl0KHRoaXMuZXZlbnRzLkFMRVJUX1RSSUdHRVJFRCwge1xyXG4gICAgICAgICAgICAgIHR5cGU6IFwiZ21wX3RocmVzaG9sZFwiLFxyXG4gICAgICAgICAgICAgIGlwb0lkLFxyXG4gICAgICAgICAgICAgIHRocmVzaG9sZDogYWxlcnQudGhyZXNob2xkLFxyXG4gICAgICAgICAgICAgIGN1cnJlbnRWYWx1ZTogY3VycmVudEdNUCxcclxuICAgICAgICAgICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgYWxlcnQudHJpZ2dlcmVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXHJcbiAgICAgICAgICAgICAgYPCfmqggR01QIGFsZXJ0IHRyaWdnZXJlZCBmb3IgJHtzb2NrZXRJZH06ICR7aXBvSWR9IHJlYWNoZWQgJHtjdXJyZW50R01QfWBcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIEdldCBhbGVydCBzZXZlcml0eVxyXG4gIGdldEFsZXJ0U2V2ZXJpdHkoYWxlcnRUeXBlKSB7XHJcbiAgICBjb25zdCBzZXZlcml0eU1hcCA9IHtcclxuICAgICAgZ21wX3RocmVzaG9sZDogXCJtZWRpdW1cIixcclxuICAgICAgb3ZlcnN1YnNjcmlwdGlvbjogXCJoaWdoXCIsXHJcbiAgICAgIHN5c3RlbV9lcnJvcjogXCJjcml0aWNhbFwiLFxyXG4gICAgICBjb25uZWN0aW9uX2lzc3VlOiBcImxvd1wiLFxyXG4gICAgICByYXRlX2xpbWl0OiBcIm1lZGl1bVwiLFxyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gc2V2ZXJpdHlNYXBbYWxlcnRUeXBlXSB8fCBcImxvd1wiO1xyXG4gIH1cclxuXHJcbiAgLy8gTWVzc2FnZSBxdWV1aW5nIGZvciBvZmZsaW5lIGNsaWVudHNcclxuICBxdWV1ZU1lc3NhZ2VGb3JPZmZsaW5lQ2xpZW50cyhyb29tLCBtZXNzYWdlKSB7XHJcbiAgICBpZiAoIXRoaXMubWVzc2FnZVF1ZXVlLmhhcyhyb29tKSkge1xyXG4gICAgICB0aGlzLm1lc3NhZ2VRdWV1ZS5zZXQocm9vbSwgW10pO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHF1ZXVlID0gdGhpcy5tZXNzYWdlUXVldWUuZ2V0KHJvb20pO1xyXG4gICAgcXVldWUucHVzaCh7XHJcbiAgICAgIG1lc3NhZ2UsXHJcbiAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIEtlZXAgb25seSB0aGUgbGF0ZXN0IG1lc3NhZ2VzXHJcbiAgICBpZiAocXVldWUubGVuZ3RoID4gdGhpcy5tYXhRdWV1ZVNpemUpIHtcclxuICAgICAgcXVldWUuc3BsaWNlKDAsIHF1ZXVlLmxlbmd0aCAtIHRoaXMubWF4UXVldWVTaXplKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHNlbmRRdWV1ZWRNZXNzYWdlcyhzb2NrZXRJZCkge1xyXG4gICAgY29uc3QgY2xpZW50ID0gdGhpcy5jb25uZWN0ZWRDbGllbnRzLmdldChzb2NrZXRJZCk7XHJcbiAgICBpZiAoIWNsaWVudCkgcmV0dXJuO1xyXG5cclxuICAgIC8vIFNlbmQgcXVldWVkIG1lc3NhZ2VzIGZvciBzdWJzY3JpYmVkIHJvb21zXHJcbiAgICBmb3IgKGNvbnN0IHN1YnNjcmlwdGlvbiBvZiBjbGllbnQuc3Vic2NyaXB0aW9ucykge1xyXG4gICAgICBjb25zdCBxdWV1ZWRNZXNzYWdlcyA9IHRoaXMubWVzc2FnZVF1ZXVlLmdldChzdWJzY3JpcHRpb24pO1xyXG4gICAgICBpZiAocXVldWVkTWVzc2FnZXMgJiYgcXVldWVkTWVzc2FnZXMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIGNsaWVudC5zb2NrZXQuZW1pdChcInF1ZXVlZDptZXNzYWdlc1wiLCB7XHJcbiAgICAgICAgICByb29tOiBzdWJzY3JpcHRpb24sXHJcbiAgICAgICAgICBtZXNzYWdlczogcXVldWVkTWVzc2FnZXMsXHJcbiAgICAgICAgICBjb3VudDogcXVldWVkTWVzc2FnZXMubGVuZ3RoLFxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICAvLyBDbGVhciB0aGUgcXVldWUgYWZ0ZXIgc2VuZGluZ1xyXG4gICAgICAgIHRoaXMubWVzc2FnZVF1ZXVlLmRlbGV0ZShzdWJzY3JpcHRpb24pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBDbGllbnQgZGlzY29ubmVjdGlvbiBoYW5kbGluZ1xyXG4gIGhhbmRsZUNsaWVudERpc2Nvbm5lY3Rpb24oc29ja2V0SWQsIHJlYXNvbikge1xyXG4gICAgY29uc3QgY2xpZW50ID0gdGhpcy5jb25uZWN0ZWRDbGllbnRzLmdldChzb2NrZXRJZCk7XHJcbiAgICBpZiAoY2xpZW50KSB7XHJcbiAgICAgIC8vIFN0b3JlIGRpc2Nvbm5lY3Rpb24gaW5mb1xyXG4gICAgICB0aGlzLmRpc2Nvbm5lY3Rpb25Mb2cgPSB0aGlzLmRpc2Nvbm5lY3Rpb25Mb2cgfHwgbmV3IE1hcCgpO1xyXG4gICAgICB0aGlzLmRpc2Nvbm5lY3Rpb25Mb2cuc2V0KHNvY2tldElkLCB7XHJcbiAgICAgICAgcmVhc29uLFxyXG4gICAgICAgIGRpc2Nvbm5lY3RlZEF0OiBEYXRlLm5vdygpLFxyXG4gICAgICAgIHN1YnNjcmlwdGlvbnM6IEFycmF5LmZyb20oY2xpZW50LnN1YnNjcmlwdGlvbnMpLFxyXG4gICAgICAgIHJlY29ubmVjdENvdW50OiBjbGllbnQucmVjb25uZWN0Q291bnQsXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgLy8gS2VlcCBvbmx5IHJlY2VudCBkaXNjb25uZWN0aW9uc1xyXG4gICAgICBpZiAodGhpcy5kaXNjb25uZWN0aW9uTG9nLnNpemUgPiAxMDAwKSB7XHJcbiAgICAgICAgY29uc3QgZW50cmllcyA9IEFycmF5LmZyb20odGhpcy5kaXNjb25uZWN0aW9uTG9nLmVudHJpZXMoKSk7XHJcbiAgICAgICAgZW50cmllcy5zb3J0KChhLCBiKSA9PiBiWzFdLmRpc2Nvbm5lY3RlZEF0IC0gYVsxXS5kaXNjb25uZWN0ZWRBdCk7XHJcbiAgICAgICAgdGhpcy5kaXNjb25uZWN0aW9uTG9nID0gbmV3IE1hcChlbnRyaWVzLnNsaWNlKDAsIDUwMCkpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBBdXRob3JpemF0aW9uIGNoZWNrIChpbXBsZW1lbnQgYmFzZWQgb24geW91ciBhdXRoIHN5c3RlbSlcclxuICBpc0F1dGhvcml6ZWQoc29ja2V0KSB7XHJcbiAgICAvLyBJbXBsZW1lbnQgeW91ciBhdXRob3JpemF0aW9uIGxvZ2ljIGhlcmVcclxuICAgIC8vIEZvciBub3csIHJldHVybiB0cnVlIGZvciBiYXNpYyBmdW5jdGlvbmFsaXR5XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcblxyXG4gIC8vIEVuaGFuY2VkIGhlYXJ0YmVhdCB3aXRoIGhlYWx0aCBtb25pdG9yaW5nXHJcbiAgc3RhcnRIZWFydGJlYXQoKSB7XHJcbiAgICBzZXRJbnRlcnZhbCgoKSA9PiB7XHJcbiAgICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XHJcbiAgICAgIGNvbnN0IHN0YWxlVGhyZXNob2xkID0gNSAqIDYwICogMTAwMDsgLy8gNSBtaW51dGVzXHJcbiAgICAgIGNvbnN0IHN0YWxlQ2xpZW50cyA9IFtdO1xyXG5cclxuICAgICAgZm9yIChjb25zdCBbc29ja2V0SWQsIGNsaWVudF0gb2YgdGhpcy5jb25uZWN0ZWRDbGllbnRzKSB7XHJcbiAgICAgICAgY29uc3QgdGltZVNpbmNlTGFzdEFjdGl2aXR5ID0gbm93IC0gY2xpZW50Lmxhc3RBY3Rpdml0eS5nZXRUaW1lKCk7XHJcblxyXG4gICAgICAgIGlmICh0aW1lU2luY2VMYXN0QWN0aXZpdHkgPiBzdGFsZVRocmVzaG9sZCkge1xyXG4gICAgICAgICAgY29uc29sZS5sb2coXHJcbiAgICAgICAgICAgIGDwn6e5IERpc2Nvbm5lY3Rpbmcgc3RhbGUgY2xpZW50OiAke3NvY2tldElkfSAoaW5hY3RpdmUgZm9yICR7TWF0aC5yb3VuZCh0aW1lU2luY2VMYXN0QWN0aXZpdHkgLyAxMDAwKX1zKWBcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgICBjbGllbnQuc29ja2V0LmRpc2Nvbm5lY3QodHJ1ZSk7XHJcbiAgICAgICAgICBzdGFsZUNsaWVudHMucHVzaChzb2NrZXRJZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoc3RhbGVDbGllbnRzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICBjb25zb2xlLmxvZyhg8J+nuSBDbGVhbmVkIHVwICR7c3RhbGVDbGllbnRzLmxlbmd0aH0gc3RhbGUgY29ubmVjdGlvbnNgKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQnJvYWRjYXN0IHN5c3RlbSBoZWFydGJlYXQgZXZlcnkgNSBtaW51dGVzXHJcbiAgICAgIGlmIChub3cgJSAoNSAqIDYwICogMTAwMCkgPCA2MDAwMCkge1xyXG4gICAgICAgIC8vIFdpdGhpbiAxIG1pbnV0ZSBvZiA1LW1pbnV0ZSBtYXJrXHJcbiAgICAgICAgdGhpcy5icm9hZGNhc3RTeXN0ZW1TdGF0dXMoe1xyXG4gICAgICAgICAgdHlwZTogXCJoZWFydGJlYXRcIixcclxuICAgICAgICAgIHN0YXR1czogXCJoZWFsdGh5XCIsXHJcbiAgICAgICAgICB1cHRpbWU6IG5vdyAtIHRoaXMubWV0cmljcy5zdGFydFRpbWUsXHJcbiAgICAgICAgICBjb25uZWN0aW9uczogdGhpcy5tZXRyaWNzLmN1cnJlbnRDb25uZWN0aW9ucyxcclxuICAgICAgICAgIG1lc3NhZ2U6IFwiU3lzdGVtIHJ1bm5pbmcgbm9ybWFsbHlcIixcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfSwgNjAwMDApOyAvLyBDaGVjayBldmVyeSBtaW51dGVcclxuICB9XHJcblxyXG4gIC8vIEhlYWx0aCBtb25pdG9yaW5nXHJcbiAgc3RhcnRIZWFsdGhNb25pdG9yaW5nKCkge1xyXG4gICAgc2V0SW50ZXJ2YWwoKCkgPT4ge1xyXG4gICAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xyXG5cclxuICAgICAgLy8gTW9uaXRvciBjb25uZWN0aW9uIGhlYWx0aFxyXG4gICAgICBmb3IgKGNvbnN0IFtzb2NrZXRJZCwgaGVhbHRoXSBvZiB0aGlzLmNvbm5lY3Rpb25IZWFsdGgpIHtcclxuICAgICAgICBpZiAobm93IC0gaGVhbHRoLmxhc3RTZWVuID4gMiAqIDYwICogMTAwMCkge1xyXG4gICAgICAgICAgLy8gMiBtaW51dGVzXHJcbiAgICAgICAgICBoZWFsdGguc3RhdHVzID0gXCJzdGFsZVwiO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGhlYWx0aC5sYXRlbmN5ID4gMTAwMCkge1xyXG4gICAgICAgICAgLy8gSGlnaCBsYXRlbmN5XHJcbiAgICAgICAgICBoZWFsdGguc3RhdHVzID0gXCJkZWdyYWRlZFwiO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQ2xlYW4gdXAgb2xkIGhlYWx0aCByZWNvcmRzXHJcbiAgICAgIGNvbnN0IGhlYWx0aEVudHJpZXMgPSBBcnJheS5mcm9tKHRoaXMuY29ubmVjdGlvbkhlYWx0aC5lbnRyaWVzKCkpO1xyXG4gICAgICBjb25zdCBhY3RpdmVDbGllbnRzID0gbmV3IFNldCh0aGlzLmNvbm5lY3RlZENsaWVudHMua2V5cygpKTtcclxuXHJcbiAgICAgIGZvciAoY29uc3QgW3NvY2tldElkXSBvZiBoZWFsdGhFbnRyaWVzKSB7XHJcbiAgICAgICAgaWYgKCFhY3RpdmVDbGllbnRzLmhhcyhzb2NrZXRJZCkpIHtcclxuICAgICAgICAgIHRoaXMuY29ubmVjdGlvbkhlYWx0aC5kZWxldGUoc29ja2V0SWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSwgMzAwMDApOyAvLyBFdmVyeSAzMCBzZWNvbmRzXHJcbiAgfVxyXG5cclxuICAvLyBNZXRyaWNzIGNvbGxlY3Rpb25cclxuICBzdGFydE1ldHJpY3NDb2xsZWN0aW9uKCkge1xyXG4gICAgc2V0SW50ZXJ2YWwoKCkgPT4ge1xyXG4gICAgICBjb25zdCBzdGF0cyA9IHRoaXMuZ2V0RGV0YWlsZWRTdGF0cygpO1xyXG4gICAgICBjb25zb2xlLmxvZyhcclxuICAgICAgICBg8J+TiiBXZWJTb2NrZXQgTWV0cmljczogQ29ubmVjdGlvbnM6ICR7c3RhdHMuY29ubmVjdGlvbnN9LCBNZXNzYWdlczogJHtzdGF0cy50b3RhbE1lc3NhZ2VzfSwgVXB0aW1lOiAke01hdGgucm91bmQoc3RhdHMudXB0aW1lIC8gMTAwMCl9c2BcclxuICAgICAgKTtcclxuXHJcbiAgICAgIC8vIFN0b3JlIG1ldHJpY3MgaW4gY2FjaGUgZm9yIG1vbml0b3JpbmcgZGFzaGJvYXJkc1xyXG4gICAgICBjYWNoZS5zZXQoXCJ3ZWJzb2NrZXRfbWV0cmljc1wiLCBzdGF0cywgMzAwKTsgLy8gNSBtaW51dGVzXHJcblxyXG4gICAgICAvLyBSZXNldCBob3VybHkgY291bnRlcnNcclxuICAgICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcclxuICAgICAgaWYgKG5vdyAtIHRoaXMubWV0cmljcy5zdGFydFRpbWUgPiA2MCAqIDYwICogMTAwMCkge1xyXG4gICAgICAgIC8vIEV2ZXJ5IGhvdXJcclxuICAgICAgICB0aGlzLnJlc2V0SG91cmx5TWV0cmljcygpO1xyXG4gICAgICB9XHJcbiAgICB9LCAzMDAwMCk7IC8vIEV2ZXJ5IDMwIHNlY29uZHNcclxuICB9XHJcblxyXG4gIC8vIFBlcmlvZGljIGNsZWFudXBcclxuICBzdGFydFBlcmlvZGljQ2xlYW51cCgpIHtcclxuICAgIHNldEludGVydmFsKFxyXG4gICAgICAoKSA9PiB7XHJcbiAgICAgICAgLy8gQ2xlYW4gdXAgcmF0ZSBsaW1pdHNcclxuICAgICAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xyXG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgbGltaXRdIG9mIHRoaXMucmF0ZUxpbWl0cykge1xyXG4gICAgICAgICAgaWYgKG5vdyAtIGxpbWl0LndpbmRvd1N0YXJ0ID4gNjAwMDApIHtcclxuICAgICAgICAgICAgLy8gMSBtaW51dGUgb2xkXHJcbiAgICAgICAgICAgIHRoaXMucmF0ZUxpbWl0cy5kZWxldGUoa2V5KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIENsZWFuIHVwIG9sZCBHTVAgYWxlcnRzXHJcbiAgICAgICAgaWYgKHRoaXMuZ21wQWxlcnRzKSB7XHJcbiAgICAgICAgICBmb3IgKGNvbnN0IFtrZXksIGFsZXJ0XSBvZiB0aGlzLmdtcEFsZXJ0cykge1xyXG4gICAgICAgICAgICBpZiAobm93IC0gYWxlcnQuY3JlYXRlZEF0ID4gMjQgKiA2MCAqIDYwICogMTAwMCkge1xyXG4gICAgICAgICAgICAgIC8vIDI0IGhvdXJzIG9sZFxyXG4gICAgICAgICAgICAgIHRoaXMuZ21wQWxlcnRzLmRlbGV0ZShrZXkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDbGVhbiB1cCBtZXNzYWdlIHF1ZXVlc1xyXG4gICAgICAgIGZvciAoY29uc3QgW3Jvb20sIG1lc3NhZ2VzXSBvZiB0aGlzLm1lc3NhZ2VRdWV1ZSkge1xyXG4gICAgICAgICAgY29uc3QgdmFsaWRNZXNzYWdlcyA9IG1lc3NhZ2VzLmZpbHRlcihcclxuICAgICAgICAgICAgKG1zZykgPT4gbm93IC0gbXNnLnRpbWVzdGFtcCA8IDYwICogNjAgKiAxMDAwIC8vIEtlZXAgbWVzc2FnZXMgZm9yIDEgaG91clxyXG4gICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICBpZiAodmFsaWRNZXNzYWdlcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgdGhpcy5tZXNzYWdlUXVldWUuZGVsZXRlKHJvb20pO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5tZXNzYWdlUXVldWUuc2V0KHJvb20sIHZhbGlkTWVzc2FnZXMpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfSxcclxuICAgICAgNSAqIDYwICogMTAwMFxyXG4gICAgKTsgLy8gRXZlcnkgNSBtaW51dGVzXHJcbiAgfVxyXG5cclxuICAvLyBSZXNldCBob3VybHkgbWV0cmljc1xyXG4gIHJlc2V0SG91cmx5TWV0cmljcygpIHtcclxuICAgIHRoaXMubWV0cmljcy50b3RhbE1lc3NhZ2VzID0gMDtcclxuICAgIHRoaXMubWV0cmljcy5lcnJvcnMgPSAwO1xyXG4gICAgY29uc29sZS5sb2coXCLwn5OKIEhvdXJseSBtZXRyaWNzIHJlc2V0XCIpO1xyXG4gIH1cclxuXHJcbiAgLy8gRW5oYW5jZWQgc3RhdGlzdGljc1xyXG4gIGdldERldGFpbGVkU3RhdHMoKSB7XHJcbiAgICBjb25zdCBjb25uZWN0aW9ucyA9IHRoaXMuY29ubmVjdGVkQ2xpZW50cy5zaXplO1xyXG4gICAgY29uc3Qgcm9vbXMgPSBBcnJheS5mcm9tKHRoaXMucm9vbVN1YnNjcmlwdGlvbnMua2V5cygpKTtcclxuICAgIGNvbnN0IHRvdGFsU3Vic2NyaXB0aW9ucyA9IEFycmF5LmZyb20oXHJcbiAgICAgIHRoaXMucm9vbVN1YnNjcmlwdGlvbnMudmFsdWVzKClcclxuICAgICkucmVkdWNlKChzdW0sIHN1YnMpID0+IHN1bSArIHN1YnMuc2l6ZSwgMCk7XHJcblxyXG4gICAgLy8gQ2FsY3VsYXRlIGF2ZXJhZ2VzXHJcbiAgICBjb25zdCBhdmdTdWJzY3JpcHRpb25zUGVyQ2xpZW50ID1cclxuICAgICAgY29ubmVjdGlvbnMgPiAwXHJcbiAgICAgICAgPyBwYXJzZUZsb2F0KCh0b3RhbFN1YnNjcmlwdGlvbnMgLyBjb25uZWN0aW9ucykudG9GaXhlZCgyKSlcclxuICAgICAgICA6IDA7XHJcblxyXG4gICAgLy8gR2V0IG1lbW9yeSB1c2FnZVxyXG4gICAgY29uc3QgbWVtb3J5VXNhZ2UgPSBwcm9jZXNzLm1lbW9yeVVzYWdlKCk7XHJcblxyXG4gICAgLy8gQ2FsY3VsYXRlIGhlYWx0aCBzdGF0c1xyXG4gICAgY29uc3QgaGVhbHRoeUNvbm5lY3Rpb25zID0gQXJyYXkuZnJvbShcclxuICAgICAgdGhpcy5jb25uZWN0aW9uSGVhbHRoLnZhbHVlcygpXHJcbiAgICApLmZpbHRlcigoaCkgPT4gaC5zdGF0dXMgPT09IFwiaGVhbHRoeVwiKS5sZW5ndGg7XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgY29ubmVjdGlvbnMsXHJcbiAgICAgIHJvb21zOiByb29tcy5sZW5ndGgsXHJcbiAgICAgIHN1YnNjcmlwdGlvbnM6IHRvdGFsU3Vic2NyaXB0aW9ucyxcclxuICAgICAgYXZnU3Vic2NyaXB0aW9uc1BlckNsaWVudCxcclxuICAgICAgdG90YWxNZXNzYWdlczogdGhpcy5tZXRyaWNzLnRvdGFsTWVzc2FnZXMsXHJcbiAgICAgIHRvdGFsQ29ubmVjdGlvbnM6IHRoaXMubWV0cmljcy50b3RhbENvbm5lY3Rpb25zLFxyXG4gICAgICBwZWFrQ29ubmVjdGlvbnM6IHRoaXMubWV0cmljcy5wZWFrQ29ubmVjdGlvbnMsXHJcbiAgICAgIGVycm9yczogdGhpcy5tZXRyaWNzLmVycm9ycyxcclxuICAgICAgdXB0aW1lOiBEYXRlLm5vdygpIC0gdGhpcy5tZXRyaWNzLnN0YXJ0VGltZSxcclxuICAgICAgcmF0ZUxpbWl0RW50cmllczogdGhpcy5yYXRlTGltaXRzLnNpemUsXHJcbiAgICAgIHF1ZXVlZE1lc3NhZ2VzOiBBcnJheS5mcm9tKHRoaXMubWVzc2FnZVF1ZXVlLnZhbHVlcygpKS5yZWR1Y2UoXHJcbiAgICAgICAgKHN1bSwgbXNncykgPT4gc3VtICsgbXNncy5sZW5ndGgsXHJcbiAgICAgICAgMFxyXG4gICAgICApLFxyXG4gICAgICBoZWFsdGg6IHtcclxuICAgICAgICBoZWFsdGh5OiBoZWFsdGh5Q29ubmVjdGlvbnMsXHJcbiAgICAgICAgZGVncmFkZWQ6IHRoaXMuY29ubmVjdGlvbkhlYWx0aC5zaXplIC0gaGVhbHRoeUNvbm5lY3Rpb25zLFxyXG4gICAgICAgIGhlYWx0aFJhdGU6XHJcbiAgICAgICAgICB0aGlzLmNvbm5lY3Rpb25IZWFsdGguc2l6ZSA+IDBcclxuICAgICAgICAgICAgPyBwYXJzZUZsb2F0KFxyXG4gICAgICAgICAgICAgICAgKFxyXG4gICAgICAgICAgICAgICAgICAoaGVhbHRoeUNvbm5lY3Rpb25zIC8gdGhpcy5jb25uZWN0aW9uSGVhbHRoLnNpemUpICpcclxuICAgICAgICAgICAgICAgICAgMTAwXHJcbiAgICAgICAgICAgICAgICApLnRvRml4ZWQoMilcclxuICAgICAgICAgICAgICApXHJcbiAgICAgICAgICAgIDogMTAwLFxyXG4gICAgICB9LFxyXG4gICAgICBtZW1vcnk6IHtcclxuICAgICAgICByc3M6IE1hdGgucm91bmQobWVtb3J5VXNhZ2UucnNzIC8gMTAyNCAvIDEwMjQpICsgXCJNQlwiLFxyXG4gICAgICAgIGhlYXBVc2VkOiBNYXRoLnJvdW5kKG1lbW9yeVVzYWdlLmhlYXBVc2VkIC8gMTAyNCAvIDEwMjQpICsgXCJNQlwiLFxyXG4gICAgICAgIGhlYXBUb3RhbDogTWF0aC5yb3VuZChtZW1vcnlVc2FnZS5oZWFwVG90YWwgLyAxMDI0IC8gMTAyNCkgKyBcIk1CXCIsXHJcbiAgICAgICAgZXh0ZXJuYWw6IE1hdGgucm91bmQobWVtb3J5VXNhZ2UuZXh0ZXJuYWwgLyAxMDI0IC8gMTAyNCkgKyBcIk1CXCIsXHJcbiAgICAgIH0sXHJcbiAgICAgIHJvb21EZXRhaWxzOiBPYmplY3QuZnJvbUVudHJpZXMoXHJcbiAgICAgICAgQXJyYXkuZnJvbSh0aGlzLnJvb21TdWJzY3JpcHRpb25zLmVudHJpZXMoKSkubWFwKChbcm9vbSwgc3Vic10pID0+IFtcclxuICAgICAgICAgIHJvb20sXHJcbiAgICAgICAgICBzdWJzLnNpemUsXHJcbiAgICAgICAgXSlcclxuICAgICAgKSxcclxuICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIC8vIEhlYWx0aCBjaGVja1xyXG4gIGdldEhlYWx0aENoZWNrKCkge1xyXG4gICAgY29uc3Qgc3RhdHMgPSB0aGlzLmdldERldGFpbGVkU3RhdHMoKTtcclxuICAgIGNvbnN0IGlzSGVhbHRoeSA9IHRoaXMuaW8gJiYgc3RhdHMuY29ubmVjdGlvbnMgPj0gMCAmJiAhdGhpcy5pc092ZXJsb2FkZWQoKTtcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBzdGF0dXM6IGlzSGVhbHRoeSA/IFwiaGVhbHRoeVwiIDogXCJ1bmhlYWx0aHlcIixcclxuICAgICAgdXB0aW1lOiBzdGF0cy51cHRpbWUsXHJcbiAgICAgIGNvbm5lY3Rpb25zOiBzdGF0cy5jb25uZWN0aW9ucyxcclxuICAgICAgcm9vbXM6IHN0YXRzLnJvb21zLFxyXG4gICAgICBzdWJzY3JpcHRpb25zOiBzdGF0cy5zdWJzY3JpcHRpb25zLFxyXG4gICAgICBhdmVyYWdlTG9hZDogdGhpcy5jYWxjdWxhdGVBdmVyYWdlTG9hZCgpLFxyXG4gICAgICBtZW1vcnlVc2FnZTogc3RhdHMubWVtb3J5LFxyXG4gICAgICBoZWFsdGg6IHN0YXRzLmhlYWx0aCxcclxuICAgICAgZXJyb3JzOiBzdGF0cy5lcnJvcnMsXHJcbiAgICAgIGxhc3RFcnJvcnM6IHRoaXMuZ2V0UmVjZW50RXJyb3JzKCksXHJcbiAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICBpc092ZXJsb2FkZWQoKSB7XHJcbiAgICBjb25zdCBzdGF0cyA9IHRoaXMuZ2V0RGV0YWlsZWRTdGF0cygpO1xyXG4gICAgY29uc3QgbWVtb3J5VXNhZ2UgPSBwcm9jZXNzLm1lbW9yeVVzYWdlKCk7XHJcblxyXG4gICAgLy8gRGVmaW5lIG92ZXJsb2FkIHRocmVzaG9sZHNcclxuICAgIGNvbnN0IG1heENvbm5lY3Rpb25zID0gcGFyc2VJbnQocHJvY2Vzcy5lbnYuV1NfTUFYX0NPTk5FQ1RJT05TKSB8fCAxMDAwMDtcclxuICAgIGNvbnN0IG1heE1lbW9yeU1CID0gcGFyc2VJbnQocHJvY2Vzcy5lbnYuV1NfTUFYX01FTU9SWV9NQikgfHwgMTAyNDtcclxuICAgIGNvbnN0IG1heFN1YnNjcmlwdGlvbnMgPVxyXG4gICAgICBwYXJzZUludChwcm9jZXNzLmVudi5XU19NQVhfU1VCU0NSSVBUSU9OUykgfHwgNTAwMDA7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgc3RhdHMuY29ubmVjdGlvbnMgPiBtYXhDb25uZWN0aW9ucyB8fFxyXG4gICAgICBtZW1vcnlVc2FnZS5oZWFwVXNlZCAvIDEwMjQgLyAxMDI0ID4gbWF4TWVtb3J5TUIgfHxcclxuICAgICAgc3RhdHMuc3Vic2NyaXB0aW9ucyA+IG1heFN1YnNjcmlwdGlvbnMgfHxcclxuICAgICAgc3RhdHMuZXJyb3JzID4gMTAwIC8vIEhpZ2ggZXJyb3IgcmF0ZVxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIGNhbGN1bGF0ZUF2ZXJhZ2VMb2FkKCkge1xyXG4gICAgY29uc3QgdGltZURpZmYgPSAoRGF0ZS5ub3coKSAtIHRoaXMubWV0cmljcy5zdGFydFRpbWUpIC8gMTAwMDtcclxuICAgIGNvbnN0IG1lc3NhZ2VzUGVyU2Vjb25kID1cclxuICAgICAgdGltZURpZmYgPiAwID8gdGhpcy5tZXRyaWNzLnRvdGFsTWVzc2FnZXMgLyB0aW1lRGlmZiA6IDA7XHJcbiAgICBjb25zdCBjb25uZWN0aW9uc1JhdGlvID0gdGhpcy5jb25uZWN0ZWRDbGllbnRzLnNpemUgLyAxMDAwOyAvLyBOb3JtYWxpemUgdG8gMTAwMCBjb25uZWN0aW9uc1xyXG5cclxuICAgIHJldHVybiBwYXJzZUZsb2F0KChtZXNzYWdlc1BlclNlY29uZCAqIGNvbm5lY3Rpb25zUmF0aW8pLnRvRml4ZWQoMikpO1xyXG4gIH1cclxuXHJcbiAgZ2V0UmVjZW50RXJyb3JzKCkge1xyXG4gICAgLy8gSW4gYSBwcm9kdWN0aW9uIGVudmlyb25tZW50LCB5b3UnZCBpbXBsZW1lbnQgcHJvcGVyIGVycm9yIGxvZ2dpbmdcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGNvdW50OiB0aGlzLm1ldHJpY3MuZXJyb3JzLFxyXG4gICAgICBsYXN0RXJyb3JUaW1lOiB0aGlzLmxhc3RFcnJvclRpbWUgfHwgbnVsbCxcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICAvLyBDbGllbnQgY2xlYW51cFxyXG4gIGNsZWFudXBDbGllbnQoc29ja2V0SWQpIHtcclxuICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuY29ubmVjdGVkQ2xpZW50cy5nZXQoc29ja2V0SWQpO1xyXG4gICAgaWYgKGNsaWVudCkge1xyXG4gICAgICAvLyBSZW1vdmUgZnJvbSBhbGwgcm9vbSBzdWJzY3JpcHRpb25zXHJcbiAgICAgIGZvciAoY29uc3Qgc3Vic2NyaXB0aW9uIG9mIGNsaWVudC5zdWJzY3JpcHRpb25zKSB7XHJcbiAgICAgICAgY29uc3Qgcm9vbVN1YnMgPSB0aGlzLnJvb21TdWJzY3JpcHRpb25zLmdldChzdWJzY3JpcHRpb24pO1xyXG4gICAgICAgIGlmIChyb29tU3Vicykge1xyXG4gICAgICAgICAgcm9vbVN1YnMuZGVsZXRlKHNvY2tldElkKTtcclxuICAgICAgICAgIGlmIChyb29tU3Vicy5zaXplID09PSAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMucm9vbVN1YnNjcmlwdGlvbnMuZGVsZXRlKHN1YnNjcmlwdGlvbik7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuY29ubmVjdGVkQ2xpZW50cy5kZWxldGUoc29ja2V0SWQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIENsZWFuIHVwIGNvbm5lY3Rpb24gaGVhbHRoXHJcbiAgICB0aGlzLmNvbm5lY3Rpb25IZWFsdGguZGVsZXRlKHNvY2tldElkKTtcclxuXHJcbiAgICAvLyBDbGVhbiB1cCByYXRlIGxpbWl0cyBmb3IgdGhpcyBjbGllbnRcclxuICAgIGNvbnN0IGtleXNUb0RlbGV0ZSA9IFtdO1xyXG4gICAgZm9yIChjb25zdCBba2V5XSBvZiB0aGlzLnJhdGVMaW1pdHMpIHtcclxuICAgICAgaWYgKGtleS5zdGFydHNXaXRoKHNvY2tldElkKSkge1xyXG4gICAgICAgIGtleXNUb0RlbGV0ZS5wdXNoKGtleSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGtleXNUb0RlbGV0ZS5mb3JFYWNoKChrZXkpID0+IHRoaXMucmF0ZUxpbWl0cy5kZWxldGUoa2V5KSk7XHJcblxyXG4gICAgLy8gQ2xlYW4gdXAgR01QIGFsZXJ0c1xyXG4gICAgaWYgKHRoaXMuZ21wQWxlcnRzKSB7XHJcbiAgICAgIGNvbnN0IGFsZXJ0S2V5c1RvRGVsZXRlID0gW107XHJcbiAgICAgIGZvciAoY29uc3QgW2tleV0gb2YgdGhpcy5nbXBBbGVydHMpIHtcclxuICAgICAgICBpZiAoa2V5LnN0YXJ0c1dpdGgoc29ja2V0SWQpKSB7XHJcbiAgICAgICAgICBhbGVydEtleXNUb0RlbGV0ZS5wdXNoKGtleSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGFsZXJ0S2V5c1RvRGVsZXRlLmZvckVhY2goKGtleSkgPT4gdGhpcy5nbXBBbGVydHMuZGVsZXRlKGtleSkpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gR3JhY2VmdWwgc2h1dGRvd25cclxuICBhc3luYyBzaHV0ZG93bigpIHtcclxuICAgIGNvbnNvbGUubG9nKFwi8J+UjCBTaHV0dGluZyBkb3duIFdlYlNvY2tldCBzZXJ2aWNlLi4uXCIpO1xyXG5cclxuICAgIGlmICh0aGlzLmlvKSB7XHJcbiAgICAgIC8vIE5vdGlmeSBhbGwgY2xpZW50cyBhYm91dCBzaHV0ZG93blxyXG4gICAgICBhd2FpdCB0aGlzLmJyb2FkY2FzdFN5c3RlbVN0YXR1cyhcclxuICAgICAgICB7XHJcbiAgICAgICAgICB0eXBlOiBcInNodXRkb3duXCIsXHJcbiAgICAgICAgICBtZXNzYWdlOiBcIlNlcnZlciBpcyBzaHV0dGluZyBkb3duIGZvciBtYWludGVuYW5jZVwiLFxyXG4gICAgICAgICAgZXN0aW1hdGVkRG93bnRpbWU6IFwiNSBtaW51dGVzXCIsXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7IHByaW9yaXR5OiBcImhpZ2hcIiB9XHJcbiAgICAgICk7XHJcblxyXG4gICAgICAvLyBHaXZlIGNsaWVudHMgdGltZSB0byByZWNlaXZlIHRoZSBtZXNzYWdlXHJcbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDMwMDApKTtcclxuXHJcbiAgICAgIC8vIEdyYWNlZnVsbHkgZGlzY29ubmVjdCBhbGwgY2xpZW50c1xyXG4gICAgICBmb3IgKGNvbnN0IFtzb2NrZXRJZCwgY2xpZW50XSBvZiB0aGlzLmNvbm5lY3RlZENsaWVudHMpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgY2xpZW50LnNvY2tldC5lbWl0KFwic2VydmVyOnNodXRkb3duXCIsIHtcclxuICAgICAgICAgICAgbWVzc2FnZTogXCJTZXJ2ZXIgc2h1dHRpbmcgZG93blwiLFxyXG4gICAgICAgICAgICByZWNvbm5lY3RJbjogMTAwMDAsIC8vIFN1Z2dlc3QgcmVjb25uZWN0IGluIDEwIHNlY29uZHNcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgY2xpZW50LnNvY2tldC5kaXNjb25uZWN0KHRydWUpO1xyXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICBjb25zb2xlLndhcm4oXHJcbiAgICAgICAgICAgIGBFcnJvciBkaXNjb25uZWN0aW5nIGNsaWVudCAke3NvY2tldElkfTpgLFxyXG4gICAgICAgICAgICBlcnJvci5tZXNzYWdlXHJcbiAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQ2xvc2UgdGhlIHNlcnZlclxyXG4gICAgICB0aGlzLmlvLmNsb3NlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMuc2VydmVyKSB7XHJcbiAgICAgIHRoaXMuc2VydmVyLmNsb3NlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ2xlYXIgYWxsIGRhdGEgc3RydWN0dXJlc1xyXG4gICAgdGhpcy5jb25uZWN0ZWRDbGllbnRzLmNsZWFyKCk7XHJcbiAgICB0aGlzLnJvb21TdWJzY3JpcHRpb25zLmNsZWFyKCk7XHJcbiAgICB0aGlzLnJhdGVMaW1pdHMuY2xlYXIoKTtcclxuICAgIHRoaXMuY29ubmVjdGlvbkhlYWx0aC5jbGVhcigpO1xyXG4gICAgdGhpcy5tZXNzYWdlUXVldWUuY2xlYXIoKTtcclxuXHJcbiAgICBpZiAodGhpcy5nbXBBbGVydHMpIHtcclxuICAgICAgdGhpcy5nbXBBbGVydHMuY2xlYXIoKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zb2xlLmxvZyhcIuKchSBXZWJTb2NrZXQgc2VydmljZSBzaHV0ZG93biBjb21wbGV0ZVwiKTtcclxuICB9XHJcbn1cclxuXHJcbi8vIEV4cG9ydCBzaW5nbGV0b24gaW5zdGFuY2VcclxuZXhwb3J0IGNvbnN0IHdlYlNvY2tldFNlcnZpY2UgPSBuZXcgV2ViU29ja2V0U2VydmljZSgpO1xyXG5cclxuLy8gSW5pdGlhbGl6ZSBhbmQgc3RhcnQgaWYgbm90IGluIHRlc3QgZW52aXJvbm1lbnRcclxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInRlc3RcIikge1xyXG4gIHdlYlNvY2tldFNlcnZpY2UuaW5pdGlhbGl6ZSgpO1xyXG5cclxuICBpZiAocHJvY2Vzcy5lbnYuQVVUT19TVEFSVF9XRUJTT0NLRVQgIT09IFwiZmFsc2VcIikge1xyXG4gICAgd2ViU29ja2V0U2VydmljZS5zdGFydCgpLmNhdGNoKChlcnJvcikgPT4ge1xyXG4gICAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIHN0YXJ0IFdlYlNvY2tldCBzZXJ2aWNlOlwiLCBlcnJvcik7XHJcbiAgICAgIHByb2Nlc3MuZXhpdCgxKTtcclxuICAgIH0pO1xyXG4gIH1cclxufVxyXG5cclxuLy8gR3JhY2VmdWwgc2h1dGRvd24gaGFuZGxlcnNcclxucHJvY2Vzcy5vbihcIlNJR1RFUk1cIiwgYXN5bmMgKCkgPT4ge1xyXG4gIGNvbnNvbGUubG9nKFxyXG4gICAgXCJSZWNlaXZlZCBTSUdURVJNLCBzaHV0dGluZyBkb3duIFdlYlNvY2tldCBzZXJ2aWNlIGdyYWNlZnVsbHkuLi5cIlxyXG4gICk7XHJcbiAgYXdhaXQgd2ViU29ja2V0U2VydmljZS5zaHV0ZG93bigpO1xyXG4gIHByb2Nlc3MuZXhpdCgwKTtcclxufSk7XHJcblxyXG5wcm9jZXNzLm9uKFwiU0lHSU5UXCIsIGFzeW5jICgpID0+IHtcclxuICBjb25zb2xlLmxvZyhcIlJlY2VpdmVkIFNJR0lOVCwgc2h1dHRpbmcgZG93biBXZWJTb2NrZXQgc2VydmljZSBncmFjZWZ1bGx5Li4uXCIpO1xyXG4gIGF3YWl0IHdlYlNvY2tldFNlcnZpY2Uuc2h1dGRvd24oKTtcclxuICBwcm9jZXNzLmV4aXQoMCk7XHJcbn0pO1xyXG5cclxuLy8gVW5oYW5kbGVkIGVycm9yIGhhbmRsaW5nXHJcbnByb2Nlc3Mub24oXCJ1bmNhdWdodEV4Y2VwdGlvblwiLCBhc3luYyAoZXJyb3IpID0+IHtcclxuICBjb25zb2xlLmVycm9yKFwiVW5jYXVnaHQgRXhjZXB0aW9uIGluIFdlYlNvY2tldCBzZXJ2aWNlOlwiLCBlcnJvcik7XHJcbiAgd2ViU29ja2V0U2VydmljZS5sYXN0RXJyb3JUaW1lID0gRGF0ZS5ub3coKTtcclxuICB3ZWJTb2NrZXRTZXJ2aWNlLm1ldHJpY3MuZXJyb3JzKys7XHJcblxyXG4gIC8vIEF0dGVtcHQgZ3JhY2VmdWwgc2h1dGRvd25cclxuICB0cnkge1xyXG4gICAgYXdhaXQgd2ViU29ja2V0U2VydmljZS5zaHV0ZG93bigpO1xyXG4gIH0gY2F0Y2ggKHNodXRkb3duRXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBkdXJpbmcgZW1lcmdlbmN5IHNodXRkb3duOlwiLCBzaHV0ZG93bkVycm9yKTtcclxuICB9XHJcblxyXG4gIHByb2Nlc3MuZXhpdCgxKTtcclxufSk7XHJcblxyXG4vLyBFeHBvcnQgdGhlIGlvIGluc3RhbmNlIGZvciB1c2UgaW4gb3RoZXIgbW9kdWxlc1xyXG5leHBvcnQgY29uc3QgaW8gPSB3ZWJTb2NrZXRTZXJ2aWNlLmlvO1xyXG5cclxuLy8gRXhwb3J0IGRlZmF1bHRcclxuZXhwb3J0IGRlZmF1bHQgd2ViU29ja2V0U2VydmljZTtcclxuIl0sIm5hbWVzIjpbIlNlcnZlciIsImNyZWF0ZVNlcnZlciIsImNhY2hlIiwicHJpc21hIiwiV2ViU29ja2V0U2VydmljZSIsImNvbnN0cnVjdG9yIiwiaW8iLCJzZXJ2ZXIiLCJjb25uZWN0ZWRDbGllbnRzIiwiTWFwIiwicm9vbVN1YnNjcmlwdGlvbnMiLCJwb3J0IiwicHJvY2VzcyIsImVudiIsIldFQlNPQ0tFVF9QT1JUIiwiZXZlbnRzIiwiSVBPX1VQREFURSIsIkdNUF9VUERBVEUiLCJTVUJTQ1JJUFRJT05fVVBEQVRFIiwiREVNQU5EX1VQREFURSIsIkFMTE9UTUVOVF9VUERBVEUiLCJTWVNURU1fU1RBVFVTIiwiQU5BTFlUSUNTX1VQREFURSIsIk5FV1NfVVBEQVRFIiwiQUxFUlRfVFJJR0dFUkVEIiwicmF0ZUxpbWl0cyIsIm1heEV2ZW50c1BlclNlY29uZCIsIm1heFN1YnNjcmlwdGlvbnNQZXJDbGllbnQiLCJtZXRyaWNzIiwidG90YWxDb25uZWN0aW9ucyIsImN1cnJlbnRDb25uZWN0aW9ucyIsInRvdGFsTWVzc2FnZXMiLCJ0b3RhbFN1YnNjcmlwdGlvbnMiLCJlcnJvcnMiLCJzdGFydFRpbWUiLCJEYXRlIiwibm93IiwiYXZlcmFnZVJlc3BvbnNlVGltZSIsInBlYWtDb25uZWN0aW9ucyIsImNvbm5lY3Rpb25IZWFsdGgiLCJtZXNzYWdlUXVldWUiLCJtYXhRdWV1ZVNpemUiLCJpbml0aWFsaXplIiwiY29ycyIsIm9yaWdpbiIsIkZST05URU5EX1VSTCIsIm1ldGhvZHMiLCJjcmVkZW50aWFscyIsInBpbmdUaW1lb3V0IiwicGluZ0ludGVydmFsIiwibWF4SHR0cEJ1ZmZlclNpemUiLCJ0cmFuc3BvcnRzIiwiYWxsb3dFSU8zIiwiY29ubmVjdFRpbWVvdXQiLCJ1cGdyYWRlVGltZW91dCIsInNldHVwRXZlbnRIYW5kbGVycyIsInN0YXJ0SGVhcnRiZWF0Iiwic3RhcnRNZXRyaWNzQ29sbGVjdGlvbiIsInN0YXJ0SGVhbHRoTW9uaXRvcmluZyIsImNvbnNvbGUiLCJsb2ciLCJlcnJvciIsInN0YXJ0IiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJsaXN0ZW4iLCJlcnIiLCJzdGFydFBlcmlvZGljQ2xlYW51cCIsIm9uIiwic29ja2V0IiwiaGFuZGxlQ2xpZW50Q29ubmVjdGlvbiIsInNldHVwQ2xpZW50RXZlbnRMaXN0ZW5lcnMiLCJNYXRoIiwibWF4IiwiY2xpZW50SVAiLCJoYW5kc2hha2UiLCJhZGRyZXNzIiwidXNlckFnZW50IiwiaGVhZGVycyIsImlkIiwiY2xpZW50SW5mbyIsImNvbm5lY3RlZEF0Iiwic3Vic2NyaXB0aW9ucyIsIlNldCIsImxhc3RBY3Rpdml0eSIsInN1YnNjcmlwdGlvbkNvdW50IiwibWVzc2FnZUNvdW50IiwiaXBBZGRyZXNzIiwiaXNIZWFsdGh5IiwibGFzdFBpbmciLCJyZWNvbm5lY3RDb3VudCIsInNldCIsInN0YXR1cyIsImxhdGVuY3kiLCJsYXN0U2VlbiIsImVtaXQiLCJzb2NrZXRJZCIsInRpbWVzdGFtcCIsInNlcnZlclZlcnNpb24iLCJhdmFpbGFibGVFdmVudHMiLCJPYmplY3QiLCJ2YWx1ZXMiLCJtYXhTdWJzY3JpcHRpb25zIiwiZmVhdHVyZXMiLCJyZWFsVGltZVVwZGF0ZXMiLCJiYXRjaFN1YnNjcmlwdGlvbnMiLCJhbmFseXRpY3MiLCJzZW5kUXVldWVkTWVzc2FnZXMiLCJkYXRhIiwiaGFuZGxlU3Vic2NyaXB0aW9uIiwiaXBvSWQiLCJzeW1ib2wiLCJpbmNsdWRlQW5hbHl0aWNzIiwiam9pbiIsImFkZFN1YnNjcmlwdGlvbiIsImlwb0RhdGEiLCJnZXRDdXJyZW50SVBPRGF0YSIsInR5cGUiLCJoaXN0b3JpY2FsIiwiYWxlcnRUaHJlc2hvbGQiLCJnbXBEYXRhIiwiZ2V0UmVhbFRpbWVEYXRhIiwiaGlzdG9yaWNhbEdNUCIsImdldEhpc3RvcmljYWxHTVBEYXRhIiwiZGF5cyIsInNldHVwR01QQWxlcnQiLCJjYXRlZ29yaWVzIiwicmVhbFRpbWUiLCJzdWJEYXRhIiwiZmlsdGVyZWREYXRhIiwibGVuZ3RoIiwiZmlsdGVyIiwiaXRlbSIsImluY2x1ZGVzIiwiY2F0ZWdvcnkiLCJwcmljZVJhbmdlIiwiY3V0T2ZmT25seSIsImRlbWFuZERhdGEiLCJjdXRPZmZJbmRpY2F0b3IiLCJtaW4iLCJ1bmRlZmluZWQiLCJwcmljZSIsImZpbHRlcnMiLCJ1cGRhdGVJbnRlcnZhbCIsImdldEN1cnJlbnRBbmFseXRpY3MiLCJmaWx0ZXJlZEFuYWx5dGljcyIsImZpbHRlckFuYWx5dGljc0J5TWV0cmljcyIsInN5c3RlbVN0YXR1cyIsImdldFN5c3RlbVN0YXR1cyIsIm9wdGlvbnMiLCJza2lwRXJyb3JzIiwicmVzdWx0cyIsImxpbWl0ZWRTdWJzY3JpcHRpb25zIiwic2xpY2UiLCJzdWIiLCJoYW5kbGVTaW5nbGVTdWJzY3JpcHRpb24iLCJwdXNoIiwibWVzc2FnZSIsInByb2Nlc3NlZCIsInN1Y2Nlc3NmdWwiLCJyIiwiaWRlbnRpZmllciIsInBhdHRlcm4iLCJ1bnN1YnNjcmliZUFsbCIsInJvb21LZXkiLCJsZWF2ZSIsInJlbW92ZVN1YnNjcmlwdGlvbiIsInVuc3Vic2NyaWJlQnlUeXBlIiwiY2xpZW50IiwiZ2V0Iiwic2VydmVyVXB0aW1lIiwibWVzc2FnZXMiLCJjb25uZWN0ZWRGb3IiLCJnZXRUaW1lIiwiaGVhbHRoIiwiQXJyYXkiLCJmcm9tIiwic2VydmVyTWV0cmljcyIsImlzQXV0aG9yaXplZCIsInN0YXRzIiwiZ2V0RGV0YWlsZWRTdGF0cyIsInJlYXNvbiIsImhhbmRsZUNsaWVudERpc2Nvbm5lY3Rpb24iLCJjbGVhbnVwQ2xpZW50Iiwic3Vic2NyaXB0aW9uTG9naWMiLCJFcnJvciIsImNoZWNrUmF0ZUxpbWl0IiwidmFsaWRhdGVTdWJzY3JpcHRpb25EYXRhIiwic3Vic2NyaXB0aW9uVHlwZSIsImV2ZW50VHlwZSIsImtleSIsIndpbmRvd1N0YXJ0IiwiZmxvb3IiLCJoYXMiLCJjb3VudCIsImxpbWl0Iiwic3Vic2NyaXB0aW9uS2V5IiwiYWRkIiwic2l6ZSIsImRlbGV0ZSIsInJvb21TdWJzIiwic3Vic2NyaXB0aW9uIiwic3BsaXQiLCJzdWJzY3JpcHRpb25zVG9SZW1vdmUiLCJzdGFydHNXaXRoIiwiYnJvYWRjYXN0SVBPVXBkYXRlIiwidXBkYXRlRGF0YSIsInByaW9yaXR5IiwiZXhjbHVkZVNvY2tldCIsImNoZWNrQnJvYWRjYXN0UmF0ZUxpbWl0Iiwicm9vbSIsInN1YnNjcmliZXJDb3VudCIsImVucmljaGVkRGF0YSIsIlNFUlZFUl9JRCIsInRvIiwiZXhjZXB0IiwicXVldWVNZXNzYWdlRm9yT2ZmbGluZUNsaWVudHMiLCJicm9hZGNhc3RHTVBVcGRhdGUiLCJhbGVydENoZWNrIiwiY2hhbmdlIiwiY2FsY3VsYXRlR01QQ2hhbmdlIiwidmFsdWUiLCJ0cmVuZCIsImNhbGN1bGF0ZUdNUFRyZW5kIiwidm9sYXRpbGl0eSIsImNhbGN1bGF0ZUdNUFZvbGF0aWxpdHkiLCJjaGVja0dNUEFsZXJ0cyIsImJyb2FkY2FzdFN1YnNjcmlwdGlvblVwZGF0ZSIsInN1YnNjcmlwdGlvbkRhdGEiLCJhbGVydE9uT3ZlcnN1YnNjcmlwdGlvbiIsIm92ZXJhbGxTdWJzY3JpcHRpb24iLCJjYWxjdWxhdGVPdmVyYWxsU3Vic2NyaXB0aW9uIiwiaXNPdmVyc3Vic2NyaWJlZCIsImJyb2FkY2FzdEFsZXJ0IiwiYnJvYWRjYXN0RGVtYW5kVXBkYXRlIiwicHJpY2VMZXZlbCIsInRvdGFsRGVtYW5kIiwiY2FsY3VsYXRlVG90YWxEZW1hbmQiLCJjdXRPZmZEZW1hbmQiLCJjYWxjdWxhdGVDdXRPZmZEZW1hbmQiLCJicm9hZGNhc3RBbmFseXRpY3NVcGRhdGUiLCJhbmFseXRpY3NEYXRhIiwiaW5zaWdodHMiLCJnZW5lcmF0ZUFuYWx5dGljc0luc2lnaHRzIiwiYnJvYWRjYXN0U3lzdGVtU3RhdHVzIiwiZW5yaWNoZWRTdGF0dXMiLCJjb25uZWN0aW9ucyIsImFsZXJ0VHlwZSIsImFsZXJ0RGF0YSIsImVucmljaGVkQWxlcnQiLCJzZXZlcml0eSIsImdldEFsZXJ0U2V2ZXJpdHkiLCJjdXJyZW50VmFsdWUiLCJwcmV2aW91c0dNUFZhbHVlcyIsInByZXZpb3VzVmFsdWUiLCJhYnNvbHV0ZSIsInBlcmNlbnRhZ2UiLCJwYXJzZUZsb2F0IiwidG9GaXhlZCIsImRpcmVjdGlvbiIsImFicyIsInJlY2VudEdNUCIsImdNUCIsImZpbmRNYW55Iiwid2hlcmUiLCJvcmRlckJ5IiwidGFrZSIsIm1hcCIsImciLCJtZWFuIiwicmVkdWNlIiwiYSIsImIiLCJ2YXJpYW5jZSIsImFjYyIsInZhbCIsInBvdyIsInJvdW5kIiwic3FydCIsImlzQXJyYXkiLCJyYXRpb3MiLCJzdWJzY3JpcHRpb25SYXRpbyIsInRvdGFsIiwicGFyc2VJbnQiLCJhYnNvbHV0ZVF1YW50aXR5IiwiZ21wVm9sYXRpbGl0eSIsImZpbmFsU3Vic2NyaXB0aW9uIiwicmlza1Njb3JlIiwiaXBvIiwiaVBPIiwiZmluZFVuaXF1ZSIsImluY2x1ZGUiLCJnbXAiLCJzdGFydERhdGUiLCJzZXREYXRlIiwiZ2V0RGF0ZSIsImd0ZSIsImlQT0FuYWx5dGljcyIsInR5cGVNYXBwaW5nIiwicHJlZGljdGlvbiIsImZvckVhY2giLCJkYkhlYWx0aCIsImNhY2hlSGVhbHRoIiwiYWxsU2V0dGxlZCIsIiRxdWVyeVJhdyIsImhlYWx0aENoZWNrIiwidXB0aW1lIiwiZGF0YWJhc2UiLCJ3ZWJzb2NrZXQiLCJ2ZXJzaW9uIiwiZmlsdGVyZWQiLCJtZXRyaWMiLCJ0aHJlc2hvbGQiLCJnbXBBbGVydHMiLCJhbGVydEtleSIsInRyaWdnZXJlZCIsImNyZWF0ZWRBdCIsImN1cnJlbnRHTVAiLCJhbGVydCIsImFsZXJ0SXBvSWQiLCJzZXZlcml0eU1hcCIsImdtcF90aHJlc2hvbGQiLCJvdmVyc3Vic2NyaXB0aW9uIiwic3lzdGVtX2Vycm9yIiwiY29ubmVjdGlvbl9pc3N1ZSIsInJhdGVfbGltaXQiLCJxdWV1ZSIsInNwbGljZSIsInF1ZXVlZE1lc3NhZ2VzIiwiZGlzY29ubmVjdGlvbkxvZyIsImRpc2Nvbm5lY3RlZEF0IiwiZW50cmllcyIsInNvcnQiLCJzZXRJbnRlcnZhbCIsInN0YWxlVGhyZXNob2xkIiwic3RhbGVDbGllbnRzIiwidGltZVNpbmNlTGFzdEFjdGl2aXR5IiwiZGlzY29ubmVjdCIsImhlYWx0aEVudHJpZXMiLCJhY3RpdmVDbGllbnRzIiwia2V5cyIsInJlc2V0SG91cmx5TWV0cmljcyIsInZhbGlkTWVzc2FnZXMiLCJtc2ciLCJyb29tcyIsInN1bSIsInN1YnMiLCJhdmdTdWJzY3JpcHRpb25zUGVyQ2xpZW50IiwibWVtb3J5VXNhZ2UiLCJoZWFsdGh5Q29ubmVjdGlvbnMiLCJoIiwicmF0ZUxpbWl0RW50cmllcyIsIm1zZ3MiLCJoZWFsdGh5IiwiZGVncmFkZWQiLCJoZWFsdGhSYXRlIiwibWVtb3J5IiwicnNzIiwiaGVhcFVzZWQiLCJoZWFwVG90YWwiLCJleHRlcm5hbCIsInJvb21EZXRhaWxzIiwiZnJvbUVudHJpZXMiLCJnZXRIZWFsdGhDaGVjayIsImlzT3ZlcmxvYWRlZCIsImF2ZXJhZ2VMb2FkIiwiY2FsY3VsYXRlQXZlcmFnZUxvYWQiLCJsYXN0RXJyb3JzIiwiZ2V0UmVjZW50RXJyb3JzIiwibWF4Q29ubmVjdGlvbnMiLCJXU19NQVhfQ09OTkVDVElPTlMiLCJtYXhNZW1vcnlNQiIsIldTX01BWF9NRU1PUllfTUIiLCJXU19NQVhfU1VCU0NSSVBUSU9OUyIsInRpbWVEaWZmIiwibWVzc2FnZXNQZXJTZWNvbmQiLCJjb25uZWN0aW9uc1JhdGlvIiwibGFzdEVycm9yVGltZSIsImtleXNUb0RlbGV0ZSIsImFsZXJ0S2V5c1RvRGVsZXRlIiwic2h1dGRvd24iLCJlc3RpbWF0ZWREb3dudGltZSIsInNldFRpbWVvdXQiLCJyZWNvbm5lY3RJbiIsIndhcm4iLCJjbG9zZSIsImNsZWFyIiwid2ViU29ja2V0U2VydmljZSIsIkFVVE9fU1RBUlRfV0VCU09DS0VUIiwiY2F0Y2giLCJleGl0Iiwic2h1dGRvd25FcnJvciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./src/lib/websocket.js\n");

/***/ }),

/***/ "(rsc)/./src/services/prediction-service.js":
/*!********************************************!*\
  !*** ./src/services/prediction-service.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   getEnsemblePrediction: () => (/* binding */ getEnsemblePrediction),\n/* harmony export */   predictAllotmentProbability: () => (/* binding */ predictAllotmentProbability),\n/* harmony export */   predictGMPPrice: () => (/* binding */ predictGMPPrice),\n/* harmony export */   predictIPOSuccess: () => (/* binding */ predictIPOSuccess),\n/* harmony export */   predictListingGain: () => (/* binding */ predictListingGain),\n/* harmony export */   predictMarketSentiment: () => (/* binding */ predictMarketSentiment),\n/* harmony export */   predictSubscriptionTrend: () => (/* binding */ predictSubscriptionTrend),\n/* harmony export */   predictionService: () => (/* binding */ predictionService)\n/* harmony export */ });\n/* harmony import */ var _lib_cache_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/cache.js */ \"(rsc)/./src/lib/cache.js\");\n/* harmony import */ var _lib_db_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/db.js */ \"(rsc)/./src/lib/db.js\");\n/* harmony import */ var _lib_websocket_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/websocket.js */ \"(rsc)/./src/lib/websocket.js\");\n/* harmony import */ var _lib_analytics_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../lib/analytics.js */ \"(rsc)/./src/lib/analytics.js\");\n\n\n\n\nclass PredictionService {\n    constructor(){\n        this.isRunning = false;\n        this.predictionModels = new Map();\n        this.trainingData = new Map();\n        this.modelAccuracy = new Map();\n        this.activePredictions = new Map();\n        // Prediction configuration\n        this.predictionConfig = {\n            UPDATE_INTERVAL: 5 * 60 * 1000,\n            TRAINING_INTERVAL: 60 * 60 * 1000,\n            ACCURACY_CHECK_INTERVAL: 30 * 60 * 1000,\n            MIN_TRAINING_DATA: 50,\n            CONFIDENCE_THRESHOLD: 0.7,\n            PREDICTION_HORIZON: 7,\n            MAX_RETRIES: 3\n        };\n        // Prediction models and their configurations\n        this.models = {\n            LISTING_GAIN: {\n                name: \"Listing Gain Prediction\",\n                type: \"regression\",\n                features: [\n                    \"avgGMP\",\n                    \"gmpVolatility\",\n                    \"subscriptionRatio\",\n                    \"qibSubscription\",\n                    \"retailSubscription\",\n                    \"nibSubscription\",\n                    \"issueSize\",\n                    \"lotSize\",\n                    \"priceRange\",\n                    \"marketSentiment\",\n                    \"sectorPerformance\",\n                    \"marketCap\",\n                    \"promoterHolding\",\n                    \"faceValue\",\n                    \"premiumDiscount\",\n                    \"registrarReputation\",\n                    \"leadManagers\",\n                    \"gmpTrend\",\n                    \"volumeWeightedGMP\",\n                    \"daysSinceOpen\"\n                ],\n                target: \"listingGainPercentage\",\n                accuracy: 0,\n                lastTrained: null,\n                sampleCount: 0,\n                enabled: true\n            },\n            ALLOTMENT_PROBABILITY: {\n                name: \"Allotment Probability Prediction\",\n                type: \"classification\",\n                features: [\n                    \"subscriptionRatio\",\n                    \"category\",\n                    \"applicationAmount\",\n                    \"lotQuantity\",\n                    \"biddingDay\",\n                    \"userHistory\",\n                    \"applicationTime\",\n                    \"applicationMethod\",\n                    \"brokerType\",\n                    \"bankType\",\n                    \"panCardAge\",\n                    \"dematAccountAge\",\n                    \"previousAllotments\",\n                    \"investmentPattern\",\n                    \"geographicLocation\"\n                ],\n                target: \"allotmentStatus\",\n                accuracy: 0,\n                lastTrained: null,\n                sampleCount: 0,\n                enabled: true\n            },\n            SUBSCRIPTION_TREND: {\n                name: \"Subscription Trend Prediction\",\n                type: \"time_series\",\n                features: [\n                    \"currentSubscription\",\n                    \"hourlyVelocity\",\n                    \"timeRemaining\",\n                    \"dayOfWeek\",\n                    \"timeOfDay\",\n                    \"marketConditions\",\n                    \"newssentiment\",\n                    \"competitorIPOs\",\n                    \"seasonality\",\n                    \"economicIndicators\",\n                    \"sectorTrends\",\n                    \"mediaAttention\"\n                ],\n                target: \"finalSubscriptionRatio\",\n                accuracy: 0,\n                lastTrained: null,\n                sampleCount: 0,\n                enabled: true\n            },\n            GMP_PREDICTION: {\n                name: \"GMP Price Prediction\",\n                type: \"time_series\",\n                features: [\n                    \"historicalGMP\",\n                    \"volume\",\n                    \"marketSentiment\",\n                    \"newsEvents\",\n                    \"competitorPerformance\",\n                    \"marketIndices\",\n                    \"sectorPE\",\n                    \"companyPE\",\n                    \"subscriptionStatus\",\n                    \"daysToListing\",\n                    \"marketVolatility\",\n                    \"tradingVolume\"\n                ],\n                target: \"nextGMPValue\",\n                accuracy: 0,\n                lastTrained: null,\n                sampleCount: 0,\n                enabled: true\n            },\n            MARKET_SENTIMENT: {\n                name: \"Market Sentiment Prediction\",\n                type: \"classification\",\n                features: [\n                    \"newsAnalysis\",\n                    \"socialMediaMentions\",\n                    \"analystRecommendations\",\n                    \"marketTrends\",\n                    \"economicIndicators\",\n                    \"sectorPerformance\",\n                    \"competitorNews\",\n                    \"managementReputation\",\n                    \"financialMetrics\",\n                    \"industryGrowth\",\n                    \"regulatoryChanges\",\n                    \"globalMarkets\"\n                ],\n                target: \"sentimentScore\",\n                accuracy: 0,\n                lastTrained: null,\n                sampleCount: 0,\n                enabled: true\n            },\n            IPO_SUCCESS: {\n                name: \"IPO Success Prediction\",\n                type: \"classification\",\n                features: [\n                    \"companyAge\",\n                    \"revenue\",\n                    \"profitability\",\n                    \"growthRate\",\n                    \"marketShare\",\n                    \"competitorAnalysis\",\n                    \"managementTeam\",\n                    \"businessModel\",\n                    \"scalability\",\n                    \"financialHealth\",\n                    \"debtRatio\",\n                    \"cashFlow\",\n                    \"marketTiming\",\n                    \"valuationMetrics\",\n                    \"riskFactors\",\n                    \"regulatoryEnvironment\"\n                ],\n                target: \"ipoSuccessCategory\",\n                accuracy: 0,\n                lastTrained: null,\n                sampleCount: 0,\n                enabled: true\n            }\n        };\n        // Performance tracking\n        this.performance = {\n            totalPredictions: 0,\n            accuratePredictions: 0,\n            totalTrainingSessions: 0,\n            averageTrainingTime: 0,\n            averagePredictionTime: 0,\n            modelUpdates: 0,\n            lastAccuracyCheck: null\n        };\n        // Real-time prediction cache\n        this.predictionCache = new Map();\n        this.cacheTTL = {\n            LISTING_GAIN: 30 * 60 * 1000,\n            ALLOTMENT_PROBABILITY: 60 * 60 * 1000,\n            SUBSCRIPTION_TREND: 10 * 60 * 1000,\n            GMP_PREDICTION: 5 * 60 * 1000,\n            MARKET_SENTIMENT: 15 * 60 * 1000,\n            IPO_SUCCESS: 24 * 60 * 60 * 1000\n        };\n        // Active intervals\n        this.activeIntervals = new Map();\n        // Feature engineering pipeline\n        this.featureProcessors = new Map();\n        this.initializeFeatureProcessors();\n        // Model ensemble weights\n        this.ensembleWeights = new Map();\n        this.initializeEnsembleWeights();\n        console.log(\"\\uD83D\\uDD2E Prediction Service initialized\");\n    }\n    // Start comprehensive prediction service\n    async start() {\n        if (this.isRunning) {\n            console.log(\"⚠️  Prediction Service is already running\");\n            return;\n        }\n        try {\n            console.log(\"\\uD83D\\uDE80 Starting Enhanced Prediction Service...\");\n            // Initialize prediction models\n            await this.initializePredictionModels();\n            // Load training data\n            await this.loadTrainingData();\n            // Train initial models\n            await this.trainAllModels();\n            // Start prediction workflows\n            this.startPredictionWorkflows();\n            // Start model training scheduler\n            this.startModelTraining();\n            // Start accuracy monitoring\n            this.startAccuracyMonitoring();\n            // Start performance monitoring\n            this.startPerformanceMonitoring();\n            // Start maintenance tasks\n            this.startMaintenanceTasks();\n            this.isRunning = true;\n            console.log(\"✅ Enhanced Prediction Service started successfully\");\n            console.log(`🔮 ${Object.keys(this.models).length} prediction models active`);\n            // Broadcast service start\n            await _lib_websocket_js__WEBPACK_IMPORTED_MODULE_2__.webSocketService.broadcastSystemStatus({\n                type: \"prediction_service_started\",\n                models: Object.keys(this.models).length,\n                accuracy: this.getOverallAccuracy(),\n                timestamp: Date.now()\n            });\n        } catch (error) {\n            console.error(\"❌ Failed to start Prediction Service:\", error);\n            throw error;\n        }\n    }\n    // Initialize prediction models\n    async initializePredictionModels() {\n        console.log(\"\\uD83E\\uDDE0 Initializing prediction models...\");\n        try {\n            for (const [modelKey, modelConfig] of Object.entries(this.models)){\n                // Initialize model structure\n                const model = {\n                    ...modelConfig,\n                    weights: new Map(),\n                    biases: new Map(),\n                    normalizers: new Map(),\n                    featureImportance: new Map(),\n                    trainingHistory: [],\n                    predictions: [],\n                    lastPrediction: null,\n                    isReady: false\n                };\n                // Load existing model if available\n                const savedModel = await this.loadSavedModel(modelKey);\n                if (savedModel) {\n                    Object.assign(model, savedModel);\n                    model.isReady = true;\n                    console.log(`📂 Loaded saved model: ${modelKey}`);\n                }\n                this.predictionModels.set(modelKey, model);\n                // Initialize ensemble weights\n                this.ensembleWeights.set(modelKey, 1.0 / Object.keys(this.models).length);\n            }\n            console.log(`✅ Initialized ${this.predictionModels.size} prediction models`);\n        } catch (error) {\n            console.error(\"❌ Failed to initialize prediction models:\", error);\n            throw error;\n        }\n    }\n    // Load training data from database\n    async loadTrainingData() {\n        console.log(\"\\uD83D\\uDCCA Loading training data...\");\n        try {\n            // Load IPO historical data\n            const ipos = await _lib_db_js__WEBPACK_IMPORTED_MODULE_1__.prisma.iPO.findMany({\n                where: {\n                    status: \"listed\",\n                    listingDate: {\n                        not: null\n                    }\n                },\n                include: {\n                    gmpData: {\n                        orderBy: {\n                            timestamp: \"desc\"\n                        }\n                    },\n                    subscriptionData: {\n                        orderBy: {\n                            timestamp: \"desc\"\n                        }\n                    },\n                    allotmentData: true,\n                    analytics: true,\n                    watchlists: true,\n                    alerts: true\n                }\n            });\n            // Process training data for each model\n            for (const [modelKey, model] of this.predictionModels){\n                const trainingSet = await this.prepareTrainingData(modelKey, ipos);\n                this.trainingData.set(modelKey, trainingSet);\n                console.log(`📈 Prepared ${trainingSet.length} training samples for ${modelKey}`);\n            }\n            console.log(`✅ Loaded training data for ${this.predictionModels.size} models`);\n        } catch (error) {\n            console.error(\"❌ Failed to load training data:\", error);\n            throw error;\n        }\n    }\n    // Prepare training data for specific model\n    async prepareTrainingData(modelKey, ipos) {\n        const model = this.predictionModels.get(modelKey);\n        const trainingSet = [];\n        try {\n            for (const ipo of ipos){\n                // Extract features based on model configuration\n                const features = await this.extractFeatures(modelKey, ipo);\n                const target = await this.extractTarget(modelKey, ipo);\n                if (features && target !== null && target !== undefined) {\n                    trainingSet.push({\n                        id: ipo.id,\n                        symbol: ipo.symbol,\n                        features,\n                        target,\n                        timestamp: ipo.listingDate,\n                        metadata: {\n                            issueSize: ipo.issueSize,\n                            sector: ipo.sector,\n                            registrar: ipo.registrar\n                        }\n                    });\n                }\n            }\n            // Validate and clean training data\n            return this.validateTrainingData(trainingSet, model);\n        } catch (error) {\n            console.error(`Error preparing training data for ${modelKey}:`, error);\n            return [];\n        }\n    }\n    // Extract features for model training/prediction\n    async extractFeatures(modelKey, ipo) {\n        const model = this.predictionModels.get(modelKey);\n        const features = {};\n        try {\n            for (const featureName of model.features){\n                const processor = this.featureProcessors.get(featureName);\n                if (processor) {\n                    features[featureName] = await processor(ipo);\n                } else {\n                    features[featureName] = this.extractBasicFeature(featureName, ipo);\n                }\n            }\n            return features;\n        } catch (error) {\n            console.error(`Error extracting features for ${modelKey}:`, error);\n            return null;\n        }\n    }\n    // Extract target variable for training\n    async extractTarget(modelKey, ipo) {\n        const model = this.predictionModels.get(modelKey);\n        try {\n            switch(model.target){\n                case \"listingGainPercentage\":\n                    return this.calculateListingGain(ipo);\n                case \"allotmentStatus\":\n                    return this.getAllotmentStatus(ipo);\n                case \"finalSubscriptionRatio\":\n                    return this.getFinalSubscriptionRatio(ipo);\n                case \"nextGMPValue\":\n                    return this.getNextGMPValue(ipo);\n                case \"sentimentScore\":\n                    return this.getSentimentScore(ipo);\n                case \"ipoSuccessCategory\":\n                    return this.getIPOSuccessCategory(ipo);\n                default:\n                    return null;\n            }\n        } catch (error) {\n            console.error(`Error extracting target for ${modelKey}:`, error);\n            return null;\n        }\n    }\n    // Initialize feature processors\n    initializeFeatureProcessors() {\n        // GMP-related features\n        this.featureProcessors.set(\"avgGMP\", async (ipo)=>{\n            const gmpValues = ipo.gmp?.map((g)=>g.value) || [];\n            return gmpValues.length > 0 ? gmpValues.reduce((a, b)=>a + b, 0) / gmpValues.length : 0;\n        });\n        this.featureProcessors.set(\"gmpVolatility\", async (ipo)=>{\n            const gmpValues = ipo.gmp?.map((g)=>g.value) || [];\n            if (gmpValues.length < 2) return 0;\n            const mean = gmpValues.reduce((a, b)=>a + b, 0) / gmpValues.length;\n            const variance = gmpValues.reduce((sum, val)=>sum + Math.pow(val - mean, 2), 0) / gmpValues.length;\n            return Math.sqrt(variance);\n        });\n        this.featureProcessors.set(\"gmpTrend\", async (ipo)=>{\n            const gmpValues = ipo.gmp?.map((g)=>g.value) || [];\n            if (gmpValues.length < 3) return 0;\n            const recentAvg = gmpValues.slice(0, 3).reduce((a, b)=>a + b, 0) / 3;\n            const olderAvg = gmpValues.slice(-3).reduce((a, b)=>a + b, 0) / 3;\n            return olderAvg > 0 ? (recentAvg - olderAvg) / olderAvg : 0;\n        });\n        // Subscription-related features\n        this.featureProcessors.set(\"subscriptionRatio\", async (ipo)=>{\n            const latest = ipo.subscription?.[0];\n            return latest?.subscriptionRatio || 0;\n        });\n        this.featureProcessors.set(\"qibSubscription\", async (ipo)=>{\n            const qibSub = ipo.subscription?.find((s)=>s.category === \"QIB\");\n            return qibSub?.subscriptionRatio || 0;\n        });\n        this.featureProcessors.set(\"retailSubscription\", async (ipo)=>{\n            const retailSub = ipo.subscription?.find((s)=>s.category === \"RETAIL\");\n            return retailSub?.subscriptionRatio || 0;\n        });\n        // Market and timing features\n        this.featureProcessors.set(\"daysSinceOpen\", async (ipo)=>{\n            const openDate = new Date(ipo.openDate);\n            const now = new Date();\n            return Math.ceil((now - openDate) / (1000 * 60 * 60 * 24));\n        });\n        this.featureProcessors.set(\"marketSentiment\", async (ipo)=>{\n            // Mock market sentiment - in production, integrate with news/social media APIs\n            return Math.random() * 2 - 1; // Range: -1 to 1\n        });\n        this.featureProcessors.set(\"sectorPerformance\", async (ipo)=>{\n            // Mock sector performance - in production, fetch from market data APIs\n            return Math.random() * 0.2 - 0.1; // Range: -10% to 10%\n        });\n        // Company-specific features\n        this.featureProcessors.set(\"issueSize\", async (ipo)=>{\n            return Number(ipo.issueSize || 0) / 1000000000; // Normalize to billions\n        });\n        this.featureProcessors.set(\"priceRange\", async (ipo)=>{\n            return ipo.maxPrice > 0 ? (ipo.maxPrice - ipo.minPrice) / ipo.maxPrice : 0;\n        });\n        console.log(`🔧 Initialized ${this.featureProcessors.size} feature processors`);\n    }\n    // Initialize ensemble weights\n    initializeEnsembleWeights() {\n        const modelCount = Object.keys(this.models).length;\n        const baseWeight = 1.0 / modelCount;\n        for (const modelKey of Object.keys(this.models)){\n            this.ensembleWeights.set(modelKey, baseWeight);\n        }\n        console.log(\"⚖️  Initialized ensemble weights\");\n    }\n    // Train all models\n    async trainAllModels() {\n        console.log(\"\\uD83C\\uDFAF Training all prediction models...\");\n        for (const [modelKey, model] of this.predictionModels){\n            try {\n                if (model.enabled) {\n                    await this.trainModel(modelKey);\n                }\n            } catch (error) {\n                console.error(`Error training model ${modelKey}:`, error);\n            }\n        }\n        console.log(\"✅ Completed training all models\");\n    }\n    // Train individual model\n    async trainModel(modelKey) {\n        const startTime = Date.now();\n        console.log(`🧠 Training model: ${modelKey}...`);\n        try {\n            const model = this.predictionModels.get(modelKey);\n            const trainingData = this.trainingData.get(modelKey);\n            if (!trainingData || trainingData.length < this.predictionConfig.MIN_TRAINING_DATA) {\n                console.warn(`Insufficient training data for ${modelKey}: ${trainingData?.length || 0} samples`);\n                return;\n            }\n            // Split data into training and validation sets\n            const splitIndex = Math.floor(trainingData.length * 0.8);\n            const trainSet = trainingData.slice(0, splitIndex);\n            const validationSet = trainingData.slice(splitIndex);\n            // Normalize features\n            const normalizers = this.calculateNormalizers(trainSet);\n            model.normalizers = normalizers;\n            // Train based on model type\n            let trainedWeights;\n            switch(model.type){\n                case \"regression\":\n                    trainedWeights = await this.trainRegressionModel(trainSet, normalizers);\n                    break;\n                case \"classification\":\n                    trainedWeights = await this.trainClassificationModel(trainSet, normalizers);\n                    break;\n                case \"time_series\":\n                    trainedWeights = await this.trainTimeSeriesModel(trainSet, normalizers);\n                    break;\n                default:\n                    throw new Error(`Unknown model type: ${model.type}`);\n            }\n            model.weights = trainedWeights.weights;\n            model.biases = trainedWeights.biases;\n            // Calculate accuracy on validation set\n            const accuracy = await this.validateModel(modelKey, validationSet);\n            model.accuracy = accuracy;\n            // Update model metadata\n            model.lastTrained = new Date();\n            model.sampleCount = trainSet.length;\n            model.isReady = true;\n            // Store training history\n            model.trainingHistory.push({\n                timestamp: Date.now(),\n                accuracy,\n                sampleCount: trainSet.length,\n                trainingTime: Date.now() - startTime\n            });\n            // Save model\n            await this.saveModel(modelKey, model);\n            // Update ensemble weights based on accuracy\n            this.updateEnsembleWeight(modelKey, accuracy);\n            const trainingTime = Date.now() - startTime;\n            this.updateTrainingMetrics(trainingTime);\n            console.log(`✅ Trained ${modelKey}: ${accuracy.toFixed(3)} accuracy (${trainingTime}ms)`);\n        } catch (error) {\n            console.error(`❌ Failed to train model ${modelKey}:`, error);\n            throw error;\n        }\n    }\n    // Train regression model (Linear Regression)\n    async trainRegressionModel(trainSet, normalizers) {\n        const features = trainSet[0].features;\n        const featureNames = Object.keys(features);\n        const m = trainSet.length;\n        const n = featureNames.length;\n        // Initialize weights and bias\n        const weights = new Map();\n        featureNames.forEach((name)=>weights.set(name, Math.random() * 0.01));\n        let bias = 0;\n        // Gradient descent parameters\n        const learningRate = 0.01;\n        const epochs = 1000;\n        // Training loop\n        for(let epoch = 0; epoch < epochs; epoch++){\n            let totalLoss = 0;\n            const gradients = new Map();\n            let biasGradient = 0;\n            // Initialize gradients\n            featureNames.forEach((name)=>gradients.set(name, 0));\n            // Forward pass and gradient calculation\n            for (const sample of trainSet){\n                const normalizedFeatures = this.normalizeFeatures(sample.features, normalizers);\n                // Prediction\n                let prediction = bias;\n                for (const [featureName, value] of Object.entries(normalizedFeatures)){\n                    prediction += weights.get(featureName) * value;\n                }\n                // Loss (Mean Squared Error)\n                const error = prediction - sample.target;\n                totalLoss += error * error;\n                // Gradients\n                biasGradient += error;\n                for (const [featureName, value] of Object.entries(normalizedFeatures)){\n                    gradients.set(featureName, gradients.get(featureName) + error * value);\n                }\n            }\n            // Update weights\n            bias -= learningRate * biasGradient / m;\n            for (const featureName of featureNames){\n                const currentWeight = weights.get(featureName);\n                weights.set(featureName, currentWeight - learningRate * gradients.get(featureName) / m);\n            }\n            // Early stopping check\n            if (epoch % 100 === 0) {\n                const avgLoss = totalLoss / m;\n                if (avgLoss < 0.001) break; // Convergence threshold\n            }\n        }\n        return {\n            weights,\n            biases: new Map([\n                [\n                    \"bias\",\n                    bias\n                ]\n            ])\n        };\n    }\n    // Train classification model (Logistic Regression)\n    async trainClassificationModel(trainSet, normalizers) {\n        const features = trainSet[0].features;\n        const featureNames = Object.keys(features);\n        const m = trainSet.length;\n        // Get unique classes\n        const classes = [\n            ...new Set(trainSet.map((s)=>s.target))\n        ];\n        const numClasses = classes.length;\n        // For binary classification\n        if (numClasses === 2) {\n            return this.trainBinaryClassifier(trainSet, normalizers, featureNames);\n        }\n        // For multiclass classification (One-vs-Rest)\n        const classifierWeights = new Map();\n        const classifierBiases = new Map();\n        for (const targetClass of classes){\n            // Create binary dataset for this class\n            const binaryTrainSet = trainSet.map((sample)=>({\n                    ...sample,\n                    target: sample.target === targetClass ? 1 : 0\n                }));\n            const { weights, biases } = await this.trainBinaryClassifier(binaryTrainSet, normalizers, featureNames);\n            classifierWeights.set(targetClass, weights);\n            classifierBiases.set(targetClass, biases);\n        }\n        return {\n            weights: classifierWeights,\n            biases: classifierBiases\n        };\n    }\n    // Train binary classifier\n    async trainBinaryClassifier(trainSet, normalizers, featureNames) {\n        const weights = new Map();\n        featureNames.forEach((name)=>weights.set(name, Math.random() * 0.01));\n        let bias = 0;\n        const learningRate = 0.01;\n        const epochs = 1000;\n        for(let epoch = 0; epoch < epochs; epoch++){\n            const gradients = new Map();\n            let biasGradient = 0;\n            featureNames.forEach((name)=>gradients.set(name, 0));\n            for (const sample of trainSet){\n                const normalizedFeatures = this.normalizeFeatures(sample.features, normalizers);\n                // Prediction (sigmoid)\n                let z = bias;\n                for (const [featureName, value] of Object.entries(normalizedFeatures)){\n                    z += weights.get(featureName) * value;\n                }\n                const prediction = 1 / (1 + Math.exp(-z));\n                // Gradient calculation\n                const error = prediction - sample.target;\n                biasGradient += error;\n                for (const [featureName, value] of Object.entries(normalizedFeatures)){\n                    gradients.set(featureName, gradients.get(featureName) + error * value);\n                }\n            }\n            // Update weights\n            bias -= learningRate * biasGradient / trainSet.length;\n            for (const featureName of featureNames){\n                const currentWeight = weights.get(featureName);\n                weights.set(featureName, currentWeight - learningRate * gradients.get(featureName) / trainSet.length);\n            }\n        }\n        return {\n            weights,\n            biases: new Map([\n                [\n                    \"bias\",\n                    bias\n                ]\n            ])\n        };\n    }\n    // Train time series model (Moving Average + Trend)\n    async trainTimeSeriesModel(trainSet, normalizers) {\n        // Simplified time series model using moving averages\n        const windowSizes = [\n            3,\n            5,\n            10,\n            20\n        ];\n        const weights = new Map();\n        const biases = new Map();\n        // Calculate weights for different window sizes\n        let totalError = 0;\n        let sampleCount = 0;\n        for (const windowSize of windowSizes){\n            let windowError = 0;\n            let windowSamples = 0;\n            for(let i = windowSize; i < trainSet.length; i++){\n                const historicalValues = trainSet.slice(i - windowSize, i).map((s)=>s.target);\n                const movingAverage = historicalValues.reduce((a, b)=>a + b, 0) / windowSize;\n                const actualValue = trainSet[i].target;\n                const error = Math.abs(actualValue - movingAverage);\n                windowError += error;\n                windowSamples++;\n            }\n            const avgError = windowSamples > 0 ? windowError / windowSamples : Infinity;\n            weights.set(`window_${windowSize}`, 1 / (1 + avgError));\n            totalError += windowError;\n            sampleCount += windowSamples;\n        }\n        // Normalize weights\n        const totalWeight = Array.from(weights.values()).reduce((a, b)=>a + b, 0);\n        for (const [key, weight] of weights){\n            weights.set(key, weight / totalWeight);\n        }\n        biases.set(\"trend_factor\", 0.1); // Simple trend factor\n        return {\n            weights,\n            biases\n        };\n    }\n    // Validate model accuracy\n    async validateModel(modelKey, validationSet) {\n        const model = this.predictionModels.get(modelKey);\n        if (!validationSet || validationSet.length === 0) return 0;\n        let correctPredictions = 0;\n        let totalError = 0;\n        for (const sample of validationSet){\n            const prediction = await this.makeSinglePrediction(modelKey, sample.features);\n            if (model.type === \"classification\") {\n                // For classification, check if prediction matches target\n                if (prediction.value === sample.target) {\n                    correctPredictions++;\n                }\n            } else {\n                // For regression, calculate mean absolute error\n                const error = Math.abs(prediction.value - sample.target);\n                totalError += error;\n            }\n        }\n        if (model.type === \"classification\") {\n            return correctPredictions / validationSet.length;\n        } else {\n            // Convert MAE to accuracy score (inverse relationship)\n            const mae = totalError / validationSet.length;\n            return Math.max(0, 1 - mae / 100); // Normalize to 0-1 range\n        }\n    }\n    // Make single prediction\n    async makeSinglePrediction(modelKey, features) {\n        const model = this.predictionModels.get(modelKey);\n        if (!model.isReady) {\n            throw new Error(`Model ${modelKey} is not ready for predictions`);\n        }\n        try {\n            // Normalize features\n            const normalizedFeatures = this.normalizeFeatures(features, model.normalizers);\n            // Make prediction based on model type\n            let prediction;\n            switch(model.type){\n                case \"regression\":\n                    prediction = await this.predictRegression(model, normalizedFeatures);\n                    break;\n                case \"classification\":\n                    prediction = await this.predictClassification(model, normalizedFeatures);\n                    break;\n                case \"time_series\":\n                    prediction = await this.predictTimeSeries(model, normalizedFeatures, features);\n                    break;\n                default:\n                    throw new Error(`Unknown model type: ${model.type}`);\n            }\n            return {\n                value: prediction.value,\n                confidence: prediction.confidence || 0.5,\n                modelKey,\n                timestamp: Date.now(),\n                features: Object.keys(features)\n            };\n        } catch (error) {\n            console.error(`Error making prediction with ${modelKey}:`, error);\n            throw error;\n        }\n    }\n    // Predict using regression model\n    async predictRegression(model, normalizedFeatures) {\n        let prediction = model.biases.get(\"bias\") || 0;\n        for (const [featureName, value] of Object.entries(normalizedFeatures)){\n            const weight = model.weights.get(featureName) || 0;\n            prediction += weight * value;\n        }\n        // Calculate confidence based on feature importance and model accuracy\n        const confidence = Math.min(0.95, model.accuracy * 0.8 + 0.2);\n        return {\n            value: prediction,\n            confidence\n        };\n    }\n    // Predict using classification model\n    async predictClassification(model, normalizedFeatures) {\n        if (model.weights instanceof Map && model.weights.size > 1) {\n            // Multiclass classification\n            const classScores = new Map();\n            for (const [className, classWeights] of model.weights){\n                let score = model.biases.get(className)?.get(\"bias\") || 0;\n                for (const [featureName, value] of Object.entries(normalizedFeatures)){\n                    const weight = classWeights.get(featureName) || 0;\n                    score += weight * value;\n                }\n                // Apply sigmoid for probability\n                const probability = 1 / (1 + Math.exp(-score));\n                classScores.set(className, probability);\n            }\n            // Find class with highest probability\n            const bestClass = Array.from(classScores.entries()).reduce((a, b)=>a[1] > b[1] ? a : b);\n            return {\n                value: bestClass[0],\n                confidence: bestClass[1],\n                probabilities: Object.fromEntries(classScores)\n            };\n        } else {\n            // Binary classification\n            let score = model.biases.get(\"bias\") || 0;\n            for (const [featureName, value] of Object.entries(normalizedFeatures)){\n                const weight = model.weights.get(featureName) || 0;\n                score += weight * value;\n            }\n            const probability = 1 / (1 + Math.exp(-score));\n            return {\n                value: probability > 0.5 ? 1 : 0,\n                confidence: Math.abs(probability - 0.5) * 2,\n                probability\n            };\n        }\n    }\n    // Predict using time series model\n    async predictTimeSeries(model, normalizedFeatures, originalFeatures) {\n        let prediction = 0;\n        let totalWeight = 0;\n        // Use weighted moving averages\n        for (const [weightKey, weight] of model.weights){\n            if (weightKey.startsWith(\"window_\")) {\n                const windowSize = parseInt(weightKey.split(\"_\")[1]);\n                // For simplicity, use current value as base\n                // In production, you'd use actual historical data\n                const currentValue = originalFeatures.historicalGMP || originalFeatures.currentValue || 0;\n                prediction += weight * currentValue;\n                totalWeight += weight;\n            }\n        }\n        // Apply trend factor\n        const trendFactor = model.biases.get(\"trend_factor\") || 0;\n        prediction *= 1 + trendFactor;\n        const confidence = Math.min(0.9, model.accuracy * 0.7 + 0.3);\n        return {\n            value: prediction,\n            confidence\n        };\n    }\n    // Start prediction workflows\n    startPredictionWorkflows() {\n        // Real-time prediction updates\n        const predictionInterval = setInterval(async ()=>{\n            await this.updateRealTimePredictions();\n        }, this.predictionConfig.UPDATE_INTERVAL);\n        this.activeIntervals.set(\"PREDICTIONS\", predictionInterval);\n        console.log(\"\\uD83D\\uDD2E Started prediction workflows\");\n    }\n    // Update real-time predictions\n    async updateRealTimePredictions() {\n        try {\n            // Get active IPOs that need predictions\n            const activeIPOs = await _lib_db_js__WEBPACK_IMPORTED_MODULE_1__.prisma.iPO.findMany({\n                where: {\n                    isActive: true,\n                    status: {\n                        in: [\n                            \"upcoming\",\n                            \"open\",\n                            \"closed\"\n                        ]\n                    }\n                },\n                include: {\n                    gmp: {\n                        orderBy: {\n                            timestamp: \"desc\"\n                        },\n                        take: 20\n                    },\n                    subscription: {\n                        orderBy: {\n                            timestamp: \"desc\"\n                        },\n                        take: 20\n                    },\n                    analytics: true\n                }\n            });\n            let predictionsUpdated = 0;\n            for (const ipo of activeIPOs){\n                try {\n                    // Update predictions for each model\n                    for (const [modelKey, model] of this.predictionModels){\n                        if (model.isReady && model.enabled) {\n                            await this.updateIPOPrediction(modelKey, ipo);\n                            predictionsUpdated++;\n                        }\n                    }\n                } catch (error) {\n                    console.error(`Error updating predictions for IPO ${ipo.symbol}:`, error);\n                }\n            }\n            console.log(`🔮 Updated ${predictionsUpdated} predictions for ${activeIPOs.length} IPOs`);\n        } catch (error) {\n            console.error(\"Error updating real-time predictions:\", error);\n        }\n    }\n    // Update prediction for specific IPO and model\n    async updateIPOPrediction(modelKey, ipo) {\n        try {\n            // Check cache first\n            const cacheKey = `prediction:${modelKey}:${ipo.id}`;\n            const cached = this.predictionCache.get(cacheKey);\n            if (cached && Date.now() - cached.timestamp < this.cacheTTL[modelKey]) {\n                return cached.prediction;\n            }\n            // Extract features for current IPO\n            const features = await this.extractFeatures(modelKey, ipo);\n            if (!features) return null;\n            // Make prediction\n            const prediction = await this.makeSinglePrediction(modelKey, features);\n            // Cache prediction\n            this.predictionCache.set(cacheKey, {\n                prediction,\n                timestamp: Date.now()\n            });\n            // Store prediction in database\n            await this.storePrediction(ipo.id, modelKey, prediction);\n            // Broadcast prediction update\n            await this.broadcastPredictionUpdate(ipo, modelKey, prediction);\n            return prediction;\n        } catch (error) {\n            console.error(`Error updating prediction for ${modelKey}:`, error);\n            return null;\n        }\n    }\n    // Store prediction in database\n    async storePrediction(ipoId, modelKey, prediction) {\n        try {\n            await _lib_db_js__WEBPACK_IMPORTED_MODULE_1__.prisma.prediction.upsert({\n                where: {\n                    ipoId_modelType: {\n                        ipoId,\n                        modelType: modelKey\n                    }\n                },\n                update: {\n                    predictedValue: prediction.value,\n                    confidence: prediction.confidence,\n                    features: JSON.stringify(prediction.features),\n                    updatedAt: new Date()\n                },\n                create: {\n                    ipoId,\n                    modelType: modelKey,\n                    predictedValue: prediction.value,\n                    confidence: prediction.confidence,\n                    features: JSON.stringify(prediction.features),\n                    createdAt: new Date()\n                }\n            });\n        } catch (error) {\n            console.error(\"Error storing prediction:\", error);\n        }\n    }\n    // Broadcast prediction update via WebSocket\n    async broadcastPredictionUpdate(ipo, modelKey, prediction) {\n        try {\n            const updateData = {\n                ipoId: ipo.id,\n                symbol: ipo.symbol,\n                modelType: modelKey,\n                prediction: prediction.value,\n                confidence: prediction.confidence,\n                timestamp: Date.now(),\n                features: prediction.features\n            };\n            await _lib_websocket_js__WEBPACK_IMPORTED_MODULE_2__.webSocketService.broadcastAnalyticsUpdate(ipo.id, {\n                predictions: {\n                    [modelKey]: updateData\n                },\n                type: \"prediction_update\"\n            });\n        } catch (error) {\n            console.error(\"Error broadcasting prediction update:\", error);\n        }\n    }\n    // Public API methods\n    async predictListingGain(ipoId) {\n        return await this.getPrediction(ipoId, \"LISTING_GAIN\");\n    }\n    async predictAllotmentProbability(userId, ipoId, applicationData) {\n        const features = {\n            ...applicationData,\n            userHistory: await this.getUserHistory(userId),\n            applicationTime: Date.now()\n        };\n        return await this.makeSinglePrediction(\"ALLOTMENT_PROBABILITY\", features);\n    }\n    async predictSubscriptionTrend(ipoId) {\n        return await this.getPrediction(ipoId, \"SUBSCRIPTION_TREND\");\n    }\n    async predictGMPPrice(ipoId, horizon = 1) {\n        return await this.getPrediction(ipoId, \"GMP_PREDICTION\");\n    }\n    async predictMarketSentiment(ipoId) {\n        return await this.getPrediction(ipoId, \"MARKET_SENTIMENT\");\n    }\n    async predictIPOSuccess(ipoId) {\n        return await this.getPrediction(ipoId, \"IPO_SUCCESS\");\n    }\n    // Get ensemble prediction combining multiple models\n    async getEnsemblePrediction(ipoId, predictionType) {\n        try {\n            const relevantModels = this.getRelevantModels(predictionType);\n            const predictions = [];\n            let totalWeight = 0;\n            for (const modelKey of relevantModels){\n                try {\n                    const prediction = await this.getPrediction(ipoId, modelKey);\n                    if (prediction && prediction.confidence > this.predictionConfig.CONFIDENCE_THRESHOLD) {\n                        const weight = this.ensembleWeights.get(modelKey) * prediction.confidence;\n                        predictions.push({\n                            prediction,\n                            weight\n                        });\n                        totalWeight += weight;\n                    }\n                } catch (error) {\n                    console.warn(`Model ${modelKey} failed:`, error.message);\n                }\n            }\n            if (predictions.length === 0) {\n                throw new Error(\"No valid predictions available\");\n            }\n            // Calculate weighted average\n            let ensembleValue = 0;\n            let ensembleConfidence = 0;\n            for (const { prediction, weight } of predictions){\n                const normalizedWeight = weight / totalWeight;\n                ensembleValue += prediction.value * normalizedWeight;\n                ensembleConfidence += prediction.confidence * normalizedWeight;\n            }\n            return {\n                value: ensembleValue,\n                confidence: ensembleConfidence,\n                modelCount: predictions.length,\n                models: predictions.map((p)=>p.prediction.modelKey),\n                ensemble: true,\n                timestamp: Date.now()\n            };\n        } catch (error) {\n            console.error(\"Error getting ensemble prediction:\", error);\n            throw error;\n        }\n    }\n    // Get prediction from cache or generate new one\n    async getPrediction(ipoId, modelKey) {\n        try {\n            const cacheKey = `prediction:${modelKey}:${ipoId}`;\n            const cached = this.predictionCache.get(cacheKey);\n            if (cached && Date.now() - cached.timestamp < this.cacheTTL[modelKey]) {\n                return cached.prediction;\n            }\n            // Get IPO data\n            const ipo = await _lib_db_js__WEBPACK_IMPORTED_MODULE_1__.prisma.iPO.findUnique({\n                where: {\n                    id: ipoId\n                },\n                include: {\n                    gmp: {\n                        orderBy: {\n                            timestamp: \"desc\"\n                        },\n                        take: 20\n                    },\n                    subscription: {\n                        orderBy: {\n                            timestamp: \"desc\"\n                        },\n                        take: 20\n                    },\n                    analytics: true\n                }\n            });\n            if (!ipo) {\n                throw new Error(`IPO not found: ${ipoId}`);\n            }\n            return await this.updateIPOPrediction(modelKey, ipo);\n        } catch (error) {\n            console.error(`Error getting prediction for ${modelKey}:`, error);\n            throw error;\n        }\n    }\n    // Helper methods\n    calculateNormalizers(trainSet) {\n        const normalizers = new Map();\n        const featureNames = Object.keys(trainSet[0].features);\n        for (const featureName of featureNames){\n            const values = trainSet.map((sample)=>sample.features[featureName]).filter((v)=>v !== null && v !== undefined);\n            if (values.length > 0) {\n                const min = Math.min(...values);\n                const max = Math.max(...values);\n                const mean = values.reduce((a, b)=>a + b, 0) / values.length;\n                const std = Math.sqrt(values.reduce((sum, val)=>sum + Math.pow(val - mean, 2), 0) / values.length);\n                normalizers.set(featureName, {\n                    min,\n                    max,\n                    mean,\n                    std\n                });\n            }\n        }\n        return normalizers;\n    }\n    normalizeFeatures(features, normalizers) {\n        const normalized = {};\n        for (const [featureName, value] of Object.entries(features)){\n            const norm = normalizers.get(featureName);\n            if (norm && value !== null && value !== undefined) {\n                // Z-score normalization\n                normalized[featureName] = norm.std > 0 ? (value - norm.mean) / norm.std : 0;\n            } else {\n                normalized[featureName] = 0;\n            }\n        }\n        return normalized;\n    }\n    extractBasicFeature(featureName, ipo) {\n        switch(featureName){\n            case \"lotSize\":\n                return ipo.lotSize || 0;\n            case \"faceValue\":\n                return ipo.faceValue || 0;\n            case \"minPrice\":\n                return ipo.minPrice || 0;\n            case \"maxPrice\":\n                return ipo.maxPrice || 0;\n            default:\n                return 0;\n        }\n    }\n    // Target extraction methods\n    calculateListingGain(ipo) {\n        if (!ipo.listingPrice || !ipo.maxPrice) return null;\n        return (ipo.listingPrice - ipo.maxPrice) / ipo.maxPrice * 100;\n    }\n    getAllotmentStatus(ipo) {\n        // This would come from actual allotment data\n        return Math.random() > 0.3 ? \"allotted\" : \"not_allotted\";\n    }\n    getFinalSubscriptionRatio(ipo) {\n        const finalSub = ipo.subscription?.find((s)=>s.category === \"OVERALL\") || ipo.subscription?.[0];\n        return finalSub?.subscriptionRatio || 0;\n    }\n    getNextGMPValue(ipo) {\n        const gmpValues = ipo.gmp?.map((g)=>g.value) || [];\n        return gmpValues.length > 0 ? gmpValues[0] : 0;\n    }\n    getSentimentScore(ipo) {\n        // Mock sentiment - in production, analyze news/social media\n        return Math.random() * 2 - 1; // -1 to 1\n    }\n    getIPOSuccessCategory(ipo) {\n        const gain = this.calculateListingGain(ipo);\n        if (gain === null) return \"unknown\";\n        if (gain > 20) return \"highly_successful\";\n        if (gain > 0) return \"successful\";\n        return \"unsuccessful\";\n    }\n    validateTrainingData(trainingSet, model) {\n        return trainingSet.filter((sample)=>{\n            // Remove samples with missing critical features\n            const features = sample.features;\n            const requiredFeatures = model.features.slice(0, 5); // Top 5 critical features\n            return requiredFeatures.every((feature)=>features[feature] !== null && features[feature] !== undefined && !isNaN(features[feature]));\n        });\n    }\n    getRelevantModels(predictionType) {\n        const modelGroups = {\n            listing_performance: [\n                \"LISTING_GAIN\",\n                \"GMP_PREDICTION\",\n                \"MARKET_SENTIMENT\"\n            ],\n            subscription_analysis: [\n                \"SUBSCRIPTION_TREND\",\n                \"MARKET_SENTIMENT\"\n            ],\n            allotment_chances: [\n                \"ALLOTMENT_PROBABILITY\",\n                \"SUBSCRIPTION_TREND\"\n            ],\n            overall_success: [\n                \"IPO_SUCCESS\",\n                \"LISTING_GAIN\",\n                \"MARKET_SENTIMENT\"\n            ]\n        };\n        return modelGroups[predictionType] || [\n            predictionType\n        ];\n    }\n    async getUserHistory(userId) {\n        try {\n            const applications = await _lib_db_js__WEBPACK_IMPORTED_MODULE_1__.prisma.userApplication.findMany({\n                where: {\n                    userId\n                },\n                include: {\n                    ipo: true\n                }\n            });\n            return {\n                totalApplications: applications.length,\n                allottedCount: applications.filter((a)=>a.allotmentStatus === \"allotted\").length,\n                averageAmount: applications.reduce((sum, a)=>sum + (a.amount || 0), 0) / applications.length,\n                recentActivity: applications.length > 0 ? Date.now() - new Date(applications[0].submittedAt).getTime() : 0\n            };\n        } catch (error) {\n            return {\n                totalApplications: 0,\n                allottedCount: 0,\n                averageAmount: 0,\n                recentActivity: 0\n            };\n        }\n    }\n    updateEnsembleWeight(modelKey, accuracy) {\n        const currentWeight = this.ensembleWeights.get(modelKey);\n        const newWeight = currentWeight * 0.7 + accuracy * 0.3; // Weighted update\n        this.ensembleWeights.set(modelKey, newWeight);\n        // Normalize weights\n        const totalWeight = Array.from(this.ensembleWeights.values()).reduce((a, b)=>a + b, 0);\n        for (const [key, weight] of this.ensembleWeights){\n            this.ensembleWeights.set(key, weight / totalWeight);\n        }\n    }\n    // Model persistence\n    async saveModel(modelKey, model) {\n        try {\n            const modelData = {\n                modelKey,\n                weights: Object.fromEntries(model.weights),\n                biases: Object.fromEntries(model.biases),\n                normalizers: Object.fromEntries(model.normalizers),\n                accuracy: model.accuracy,\n                sampleCount: model.sampleCount,\n                lastTrained: model.lastTrained\n            };\n            await _lib_cache_js__WEBPACK_IMPORTED_MODULE_0__.cache.set(_lib_cache_js__WEBPACK_IMPORTED_MODULE_0__.cache.key(\"MODEL\", `saved:${modelKey}`), modelData, 7 * 24 * 60 * 60 // 7 days\n            );\n        } catch (error) {\n            console.error(`Error saving model ${modelKey}:`, error);\n        }\n    }\n    async loadSavedModel(modelKey) {\n        try {\n            const modelData = await _lib_cache_js__WEBPACK_IMPORTED_MODULE_0__.cache.get(_lib_cache_js__WEBPACK_IMPORTED_MODULE_0__.cache.key(\"MODEL\", `saved:${modelKey}`));\n            if (modelData) {\n                return {\n                    weights: new Map(Object.entries(modelData.weights)),\n                    biases: new Map(Object.entries(modelData.biases)),\n                    normalizers: new Map(Object.entries(modelData.normalizers)),\n                    accuracy: modelData.accuracy,\n                    sampleCount: modelData.sampleCount,\n                    lastTrained: new Date(modelData.lastTrained)\n                };\n            }\n            return null;\n        } catch (error) {\n            console.error(`Error loading model ${modelKey}:`, error);\n            return null;\n        }\n    }\n    // Model training scheduler\n    startModelTraining() {\n        const trainingInterval = setInterval(async ()=>{\n            await this.scheduledModelTraining();\n        }, this.predictionConfig.TRAINING_INTERVAL);\n        this.activeIntervals.set(\"TRAINING\", trainingInterval);\n        console.log(\"\\uD83C\\uDFAF Started model training scheduler\");\n    }\n    async scheduledModelTraining() {\n        try {\n            console.log(\"\\uD83D\\uDD04 Running scheduled model training...\");\n            // Reload training data\n            await this.loadTrainingData();\n            // Train models that need updates\n            for (const [modelKey, model] of this.predictionModels){\n                if (model.enabled && this.shouldRetrainModel(model)) {\n                    await this.trainModel(modelKey);\n                }\n            }\n            this.performance.totalTrainingSessions++;\n        } catch (error) {\n            console.error(\"Error in scheduled model training:\", error);\n        }\n    }\n    shouldRetrainModel(model) {\n        if (!model.lastTrained) return true;\n        const daysSinceTraining = (Date.now() - model.lastTrained.getTime()) / (1000 * 60 * 60 * 24);\n        const trainingDataSize = this.trainingData.get(model.name)?.length || 0;\n        // Retrain if:\n        // - Model hasn't been trained in 7 days\n        // - Training data has grown significantly\n        // - Model accuracy is below threshold\n        return daysSinceTraining > 7 || trainingDataSize > model.sampleCount * 1.2 || model.accuracy < 0.6;\n    }\n    // Accuracy monitoring\n    startAccuracyMonitoring() {\n        const accuracyInterval = setInterval(async ()=>{\n            await this.checkPredictionAccuracy();\n        }, this.predictionConfig.ACCURACY_CHECK_INTERVAL);\n        this.activeIntervals.set(\"ACCURACY_CHECK\", accuracyInterval);\n        console.log(\"\\uD83D\\uDCCA Started accuracy monitoring\");\n    }\n    async checkPredictionAccuracy() {\n        try {\n            console.log(\"\\uD83D\\uDCCA Checking prediction accuracy...\");\n            // Get recent predictions with actual outcomes\n            const recentPredictions = await _lib_db_js__WEBPACK_IMPORTED_MODULE_1__.prisma.prediction.findMany({\n                where: {\n                    createdAt: {\n                        gte: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000)\n                    }\n                },\n                include: {\n                    ipo: {\n                        select: {\n                            listingPrice: true,\n                            maxPrice: true,\n                            status: true\n                        }\n                    }\n                }\n            });\n            const accuracyByModel = new Map();\n            for (const prediction of recentPredictions){\n                if (prediction.ipo.status === \"listed\" && prediction.ipo.listingPrice) {\n                    const actualGain = this.calculateListingGain(prediction.ipo);\n                    if (actualGain !== null) {\n                        const error = Math.abs(prediction.predictedValue - actualGain);\n                        const accuracy = Math.max(0, 1 - error / 100); // Convert to 0-1 range\n                        if (!accuracyByModel.has(prediction.modelType)) {\n                            accuracyByModel.set(prediction.modelType, []);\n                        }\n                        accuracyByModel.get(prediction.modelType).push(accuracy);\n                    }\n                }\n            }\n            // Update model accuracies\n            for (const [modelKey, accuracies] of accuracyByModel){\n                const avgAccuracy = accuracies.reduce((a, b)=>a + b, 0) / accuracies.length;\n                const model = this.predictionModels.get(modelKey);\n                if (model) {\n                    model.accuracy = avgAccuracy;\n                    this.updateEnsembleWeight(modelKey, avgAccuracy);\n                }\n            }\n            this.performance.lastAccuracyCheck = Date.now();\n        } catch (error) {\n            console.error(\"Error checking prediction accuracy:\", error);\n        }\n    }\n    // Performance monitoring\n    startPerformanceMonitoring() {\n        const performanceInterval = setInterval(()=>{\n            this.logPerformanceMetrics();\n        }, 5 * 60 * 1000); // Every 5 minutes\n        this.activeIntervals.set(\"PERFORMANCE\", performanceInterval);\n        console.log(\"\\uD83D\\uDCCA Started prediction performance monitoring\");\n    }\n    updateTrainingMetrics(trainingTime) {\n        this.performance.averageTrainingTime = (this.performance.averageTrainingTime * this.performance.totalTrainingSessions + trainingTime) / (this.performance.totalTrainingSessions + 1);\n    }\n    logPerformanceMetrics() {\n        const metrics = this.getPerformanceMetrics();\n        console.log(\"\\uD83D\\uDCCA Prediction Service Performance:\", metrics);\n        // Store metrics in cache\n        _lib_cache_js__WEBPACK_IMPORTED_MODULE_0__.cache.set(\"prediction_service_metrics\", metrics, 300);\n    }\n    getPerformanceMetrics() {\n        const overallAccuracy = this.getOverallAccuracy();\n        const modelStatus = {};\n        for (const [modelKey, model] of this.predictionModels){\n            modelStatus[modelKey] = {\n                accuracy: model.accuracy,\n                isReady: model.isReady,\n                sampleCount: model.sampleCount,\n                lastTrained: model.lastTrained?.toISOString()\n            };\n        }\n        return {\n            totalPredictions: this.performance.totalPredictions,\n            overallAccuracy: `${(overallAccuracy * 100).toFixed(2)}%`,\n            totalTrainingSessions: this.performance.totalTrainingSessions,\n            averageTrainingTime: Math.round(this.performance.averageTrainingTime),\n            modelUpdates: this.performance.modelUpdates,\n            activePredictions: this.predictionCache.size,\n            modelStatus,\n            lastAccuracyCheck: this.performance.lastAccuracyCheck ? new Date(this.performance.lastAccuracyCheck).toISOString() : null\n        };\n    }\n    getOverallAccuracy() {\n        const accuracies = Array.from(this.predictionModels.values()).filter((model)=>model.isReady).map((model)=>model.accuracy);\n        return accuracies.length > 0 ? accuracies.reduce((a, b)=>a + b, 0) / accuracies.length : 0;\n    }\n    // Maintenance tasks\n    startMaintenanceTasks() {\n        const maintenanceInterval = setInterval(()=>{\n            this.performMaintenance();\n        }, 60 * 60 * 1000); // Every hour\n        this.activeIntervals.set(\"MAINTENANCE\", maintenanceInterval);\n        console.log(\"\\uD83E\\uDDF9 Started prediction service maintenance tasks\");\n    }\n    performMaintenance() {\n        const now = Date.now();\n        // Clean up old cached predictions\n        for (const [cacheKey, data] of this.predictionCache){\n            const modelKey = cacheKey.split(\":\")[1];\n            const ttl = this.cacheTTL[modelKey] || 30 * 60 * 1000;\n            if (now - data.timestamp > ttl * 2) {\n                // Keep for 2x TTL\n                this.predictionCache.delete(cacheKey);\n            }\n        }\n        // Clean up old model training history\n        for (const model of this.predictionModels.values()){\n            if (model.trainingHistory.length > 100) {\n                model.trainingHistory = model.trainingHistory.slice(-50); // Keep last 50\n            }\n        }\n        console.log(\"\\uD83E\\uDDF9 Prediction service maintenance completed\");\n    }\n    // Service status and health check\n    getStatus() {\n        return {\n            isRunning: this.isRunning,\n            models: Object.keys(this.models).length,\n            readyModels: Array.from(this.predictionModels.values()).filter((m)=>m.isReady).length,\n            performance: this.getPerformanceMetrics(),\n            activePredictions: this.predictionCache.size,\n            ensembleWeights: Object.fromEntries(this.ensembleWeights),\n            activeIntervals: this.activeIntervals.size,\n            timestamp: new Date().toISOString()\n        };\n    }\n    async healthCheck() {\n        try {\n            // Check model readiness\n            const readyModels = Array.from(this.predictionModels.values()).filter((m)=>m.isReady).length;\n            const totalModels = this.predictionModels.size;\n            // Check database connectivity\n            const dbCheck = await _lib_db_js__WEBPACK_IMPORTED_MODULE_1__.prisma.prediction.findFirst();\n            // Check cache connectivity\n            const cacheCheck = await _lib_cache_js__WEBPACK_IMPORTED_MODULE_0__.cache.healthCheck();\n            const isHealthy = this.isRunning && readyModels > 0 && dbCheck !== undefined && cacheCheck.status === \"healthy\";\n            return {\n                status: isHealthy ? \"healthy\" : \"degraded\",\n                isRunning: this.isRunning,\n                database: dbCheck !== undefined ? \"connected\" : \"disconnected\",\n                cache: cacheCheck.status,\n                models: {\n                    total: totalModels,\n                    ready: readyModels,\n                    readiness: `${readyModels}/${totalModels}`\n                },\n                performance: this.getPerformanceMetrics(),\n                timestamp: new Date().toISOString()\n            };\n        } catch (error) {\n            return {\n                status: \"unhealthy\",\n                error: error.message,\n                timestamp: new Date().toISOString()\n            };\n        }\n    }\n    // Stop service gracefully\n    async stop() {\n        console.log(\"\\uD83D\\uDED1 Stopping Prediction Service...\");\n        this.isRunning = false;\n        // Clear all active intervals\n        for (const [name, intervalId] of this.activeIntervals){\n            clearInterval(intervalId);\n            console.log(`⏹️  Stopped ${name} interval`);\n        }\n        this.activeIntervals.clear();\n        // Save all models\n        for (const [modelKey, model] of this.predictionModels){\n            try {\n                if (model.isReady) {\n                    await this.saveModel(modelKey, model);\n                }\n            } catch (error) {\n                console.error(`Error saving model ${modelKey}:`, error);\n            }\n        }\n        // Broadcast shutdown notification\n        try {\n            await _lib_websocket_js__WEBPACK_IMPORTED_MODULE_2__.webSocketService.broadcastSystemStatus({\n                type: \"prediction_service_shutdown\",\n                message: \"Prediction service has been stopped\",\n                finalMetrics: this.getPerformanceMetrics(),\n                timestamp: Date.now()\n            }, {\n                priority: \"high\"\n            });\n        } catch (error) {\n            console.error(\"Error broadcasting shutdown:\", error);\n        }\n        // Clear data structures\n        this.predictionModels.clear();\n        this.trainingData.clear();\n        this.modelAccuracy.clear();\n        this.activePredictions.clear();\n        this.predictionCache.clear();\n        this.featureProcessors.clear();\n        this.ensembleWeights.clear();\n        console.log(\"✅ Prediction Service stopped gracefully\");\n        console.log(\"\\uD83D\\uDCCA Final Performance Metrics:\", this.getPerformanceMetrics());\n    }\n}\n// Export singleton instance\nconst predictionService = new PredictionService();\n// Auto-start if not in test environment\nif ( true && process.env.AUTO_START_PREDICTION_SERVICE !== \"false\") {\n    predictionService.start().catch((error)=>{\n        console.error(\"Failed to auto-start Prediction Service:\", error);\n        process.exit(1);\n    });\n}\n// Graceful shutdown handlers\nconst gracefulShutdown = async (signal)=>{\n    console.log(`🛑 Received ${signal}, shutting down Prediction Service gracefully...`);\n    try {\n        await predictionService.stop();\n        process.exit(0);\n    } catch (error) {\n        console.error(\"Error during graceful shutdown:\", error);\n        process.exit(1);\n    }\n};\nprocess.on(\"SIGTERM\", ()=>gracefulShutdown(\"SIGTERM\"));\nprocess.on(\"SIGINT\", ()=>gracefulShutdown(\"SIGINT\"));\nprocess.on(\"SIGQUIT\", ()=>gracefulShutdown(\"SIGQUIT\"));\n// Export additional utilities\nconst { predictListingGain, predictAllotmentProbability, predictSubscriptionTrend, predictGMPPrice, predictMarketSentiment, predictIPOSuccess, getEnsemblePrediction } = predictionService;\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (predictionService);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9zcmMvc2VydmljZXMvcHJlZGljdGlvbi1zZXJ2aWNlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBd0M7QUFDRjtBQUNpQjtBQUNBO0FBRXZELE1BQU1JO0lBQ0pDLGFBQWM7UUFDWixJQUFJLENBQUNDLFNBQVMsR0FBRztRQUNqQixJQUFJLENBQUNDLGdCQUFnQixHQUFHLElBQUlDO1FBQzVCLElBQUksQ0FBQ0MsWUFBWSxHQUFHLElBQUlEO1FBQ3hCLElBQUksQ0FBQ0UsYUFBYSxHQUFHLElBQUlGO1FBQ3pCLElBQUksQ0FBQ0csaUJBQWlCLEdBQUcsSUFBSUg7UUFFN0IsMkJBQTJCO1FBQzNCLElBQUksQ0FBQ0ksZ0JBQWdCLEdBQUc7WUFDdEJDLGlCQUFpQixJQUFJLEtBQUs7WUFDMUJDLG1CQUFtQixLQUFLLEtBQUs7WUFDN0JDLHlCQUF5QixLQUFLLEtBQUs7WUFDbkNDLG1CQUFtQjtZQUNuQkMsc0JBQXNCO1lBQ3RCQyxvQkFBb0I7WUFDcEJDLGFBQWE7UUFDZjtRQUVBLDZDQUE2QztRQUM3QyxJQUFJLENBQUNDLE1BQU0sR0FBRztZQUNaQyxjQUFjO2dCQUNaQyxNQUFNO2dCQUNOQyxNQUFNO2dCQUNOQyxVQUFVO29CQUNSO29CQUNBO29CQUNBO29CQUNBO29CQUNBO29CQUNBO29CQUNBO29CQUNBO29CQUNBO29CQUNBO29CQUNBO29CQUNBO29CQUNBO29CQUNBO29CQUNBO29CQUNBO29CQUNBO29CQUNBO29CQUNBO29CQUNBO2lCQUNEO2dCQUNEQyxRQUFRO2dCQUNSQyxVQUFVO2dCQUNWQyxhQUFhO2dCQUNiQyxhQUFhO2dCQUNiQyxTQUFTO1lBQ1g7WUFFQUMsdUJBQXVCO2dCQUNyQlIsTUFBTTtnQkFDTkMsTUFBTTtnQkFDTkMsVUFBVTtvQkFDUjtvQkFDQTtvQkFDQTtvQkFDQTtvQkFDQTtvQkFDQTtvQkFDQTtvQkFDQTtvQkFDQTtvQkFDQTtvQkFDQTtvQkFDQTtvQkFDQTtvQkFDQTtvQkFDQTtpQkFDRDtnQkFD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RUFBRSxDQUFDLFVBQVUsSUFBTUYsaUJBQWlCO0FBQzVDTCxRQUFRTyxFQUFFLENBQUMsV0FBVyxJQUFNRixpQkFBaUI7QUFFN0MsOEJBQThCO0FBQ3ZCLE1BQU0sRUFDWDNHLGtCQUFrQixFQUNsQkUsMkJBQTJCLEVBQzNCTSx3QkFBd0IsRUFDeEJDLGVBQWUsRUFDZkUsc0JBQXNCLEVBQ3RCQyxpQkFBaUIsRUFDakJDLHFCQUFxQixFQUN0QixHQUFHd0Ysa0JBQWtCO0FBRXRCLGlFQUFlQSxpQkFBaUJBLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pcG8tdHJhY2tlci8uL3NyYy9zZXJ2aWNlcy9wcmVkaWN0aW9uLXNlcnZpY2UuanM/YTlmMCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjYWNoZSB9IGZyb20gJy4uL2xpYi9jYWNoZS5qcyc7XHJcbmltcG9ydCB7IHByaXNtYSB9IGZyb20gJy4uL2xpYi9kYi5qcyc7XHJcbmltcG9ydCB7IHdlYlNvY2tldFNlcnZpY2UgfSBmcm9tICcuLi9saWIvd2Vic29ja2V0LmpzJztcclxuaW1wb3J0IHsgYW5hbHl0aWNzU2VydmljZSB9IGZyb20gJy4uL2xpYi9hbmFseXRpY3MuanMnO1xyXG5cclxuY2xhc3MgUHJlZGljdGlvblNlcnZpY2Uge1xyXG4gIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgdGhpcy5pc1J1bm5pbmcgPSBmYWxzZTtcclxuICAgIHRoaXMucHJlZGljdGlvbk1vZGVscyA9IG5ldyBNYXAoKTtcclxuICAgIHRoaXMudHJhaW5pbmdEYXRhID0gbmV3IE1hcCgpO1xyXG4gICAgdGhpcy5tb2RlbEFjY3VyYWN5ID0gbmV3IE1hcCgpO1xyXG4gICAgdGhpcy5hY3RpdmVQcmVkaWN0aW9ucyA9IG5ldyBNYXAoKTtcclxuXHJcbiAgICAvLyBQcmVkaWN0aW9uIGNvbmZpZ3VyYXRpb25cclxuICAgIHRoaXMucHJlZGljdGlvbkNvbmZpZyA9IHtcclxuICAgICAgVVBEQVRFX0lOVEVSVkFMOiA1ICogNjAgKiAxMDAwLCAvLyA1IG1pbnV0ZXNcclxuICAgICAgVFJBSU5JTkdfSU5URVJWQUw6IDYwICogNjAgKiAxMDAwLCAvLyAxIGhvdXJcclxuICAgICAgQUNDVVJBQ1lfQ0hFQ0tfSU5URVJWQUw6IDMwICogNjAgKiAxMDAwLCAvLyAzMCBtaW51dGVzXHJcbiAgICAgIE1JTl9UUkFJTklOR19EQVRBOiA1MCwgLy8gTWluaW11bSByZWNvcmRzIGZvciB0cmFpbmluZ1xyXG4gICAgICBDT05GSURFTkNFX1RIUkVTSE9MRDogMC43LCAvLyBNaW5pbXVtIGNvbmZpZGVuY2UgZm9yIHByZWRpY3Rpb25zXHJcbiAgICAgIFBSRURJQ1RJT05fSE9SSVpPTjogNywgLy8gRGF5cyB0byBwcmVkaWN0IGFoZWFkXHJcbiAgICAgIE1BWF9SRVRSSUVTOiAzLFxyXG4gICAgfTtcclxuXHJcbiAgICAvLyBQcmVkaWN0aW9uIG1vZGVscyBhbmQgdGhlaXIgY29uZmlndXJhdGlvbnNcclxuICAgIHRoaXMubW9kZWxzID0ge1xyXG4gICAgICBMSVNUSU5HX0dBSU46IHtcclxuICAgICAgICBuYW1lOiAnTGlzdGluZyBHYWluIFByZWRpY3Rpb24nLFxyXG4gICAgICAgIHR5cGU6ICdyZWdyZXNzaW9uJyxcclxuICAgICAgICBmZWF0dXJlczogW1xyXG4gICAgICAgICAgJ2F2Z0dNUCcsXHJcbiAgICAgICAgICAnZ21wVm9sYXRpbGl0eScsXHJcbiAgICAgICAgICAnc3Vic2NyaXB0aW9uUmF0aW8nLFxyXG4gICAgICAgICAgJ3FpYlN1YnNjcmlwdGlvbicsXHJcbiAgICAgICAgICAncmV0YWlsU3Vic2NyaXB0aW9uJyxcclxuICAgICAgICAgICduaWJTdWJzY3JpcHRpb24nLFxyXG4gICAgICAgICAgJ2lzc3VlU2l6ZScsXHJcbiAgICAgICAgICAnbG90U2l6ZScsXHJcbiAgICAgICAgICAncHJpY2VSYW5nZScsXHJcbiAgICAgICAgICAnbWFya2V0U2VudGltZW50JyxcclxuICAgICAgICAgICdzZWN0b3JQZXJmb3JtYW5jZScsXHJcbiAgICAgICAgICAnbWFya2V0Q2FwJyxcclxuICAgICAgICAgICdwcm9tb3RlckhvbGRpbmcnLFxyXG4gICAgICAgICAgJ2ZhY2VWYWx1ZScsXHJcbiAgICAgICAgICAncHJlbWl1bURpc2NvdW50JyxcclxuICAgICAgICAgICdyZWdpc3RyYXJSZXB1dGF0aW9uJyxcclxuICAgICAgICAgICdsZWFkTWFuYWdlcnMnLFxyXG4gICAgICAgICAgJ2dtcFRyZW5kJyxcclxuICAgICAgICAgICd2b2x1bWVXZWlnaHRlZEdNUCcsXHJcbiAgICAgICAgICAnZGF5c1NpbmNlT3BlbicsXHJcbiAgICAgICAgXSxcclxuICAgICAgICB0YXJnZXQ6ICdsaXN0aW5nR2FpblBlcmNlbnRhZ2UnLFxyXG4gICAgICAgIGFjY3VyYWN5OiAwLFxyXG4gICAgICAgIGxhc3RUcmFpbmVkOiBudWxsLFxyXG4gICAgICAgIHNhbXBsZUNvdW50OiAwLFxyXG4gICAgICAgIGVuYWJsZWQ6IHRydWUsXHJcbiAgICAgIH0sXHJcblxyXG4gICAgICBBTExPVE1FTlRfUFJPQkFCSUxJVFk6IHtcclxuICAgICAgICBuYW1lOiAnQWxsb3RtZW50IFByb2JhYmlsaXR5IFByZWRpY3Rpb24nLFxyXG4gICAgICAgIHR5cGU6ICdjbGFzc2lmaWNhdGlvbicsXHJcbiAgICAgICAgZmVhdHVyZXM6IFtcclxuICAgICAgICAgICdzdWJzY3JpcHRpb25SYXRpbycsXHJcbiAgICAgICAgICAnY2F0ZWdvcnknLFxyXG4gICAgICAgICAgJ2FwcGxpY2F0aW9uQW1vdW50JyxcclxuICAgICAgICAgICdsb3RRdWFudGl0eScsXHJcbiAgICAgICAgICAnYmlkZGluZ0RheScsXHJcbiAgICAgICAgICAndXNlckhpc3RvcnknLFxyXG4gICAgICAgICAgJ2FwcGxpY2F0aW9uVGltZScsXHJcbiAgICAgICAgICAnYXBwbGljYXRpb25NZXRob2QnLFxyXG4gICAgICAgICAgJ2Jyb2tlclR5cGUnLFxyXG4gICAgICAgICAgJ2JhbmtUeXBlJyxcclxuICAgICAgICAgICdwYW5DYXJkQWdlJyxcclxuICAgICAgICAgICdkZW1hdEFjY291bnRBZ2UnLFxyXG4gICAgICAgICAgJ3ByZXZpb3VzQWxsb3RtZW50cycsXHJcbiAgICAgICAgICAnaW52ZXN0bWVudFBhdHRlcm4nLFxyXG4gICAgICAgICAgJ2dlb2dyYXBoaWNMb2NhdGlvbicsXHJcbiAgICAgICAgXSxcclxuICAgICAgICB0YXJnZXQ6ICdhbGxvdG1lbnRTdGF0dXMnLFxyXG4gICAgICAgIGFjY3VyYWN5OiAwLFxyXG4gICAgICAgIGxhc3RUcmFpbmVkOiBudWxsLFxyXG4gICAgICAgIHNhbXBsZUNvdW50OiAwLFxyXG4gICAgICAgIGVuYWJsZWQ6IHRydWUsXHJcbiAgICAgIH0sXHJcblxyXG4gICAgICBTVUJTQ1JJUFRJT05fVFJFTkQ6IHtcclxuICAgICAgICBuYW1lOiAnU3Vic2NyaXB0aW9uIFRyZW5kIFByZWRpY3Rpb24nLFxyXG4gICAgICAgIHR5cGU6ICd0aW1lX3NlcmllcycsXHJcbiAgICAgICAgZmVhdHVyZXM6IFtcclxuICAgICAgICAgICdjdXJyZW50U3Vic2NyaXB0aW9uJyxcclxuICAgICAgICAgICdob3VybHlWZWxvY2l0eScsXHJcbiAgICAgICAgICAndGltZVJlbWFpbmluZycsXHJcbiAgICAgICAgICAnZGF5T2ZXZWVrJyxcclxuICAgICAgICAgICd0aW1lT2ZEYXknLFxyXG4gICAgICAgICAgJ21hcmtldENvbmRpdGlvbnMnLFxyXG4gICAgICAgICAgJ25ld3NzZW50aW1lbnQnLFxyXG4gICAgICAgICAgJ2NvbXBldGl0b3JJUE9zJyxcclxuICAgICAgICAgICdzZWFzb25hbGl0eScsXHJcbiAgICAgICAgICAnZWNvbm9taWNJbmRpY2F0b3JzJyxcclxuICAgICAgICAgICdzZWN0b3JUcmVuZHMnLFxyXG4gICAgICAgICAgJ21lZGlhQXR0ZW50aW9uJyxcclxuICAgICAgICBdLFxyXG4gICAgICAgIHRhcmdldDogJ2ZpbmFsU3Vic2NyaXB0aW9uUmF0aW8nLFxyXG4gICAgICAgIGFjY3VyYWN5OiAwLFxyXG4gICAgICAgIGxhc3RUcmFpbmVkOiBudWxsLFxyXG4gICAgICAgIHNhbXBsZUNvdW50OiAwLFxyXG4gICAgICAgIGVuYWJsZWQ6IHRydWUsXHJcbiAgICAgIH0sXHJcblxyXG4gICAgICBHTVBfUFJFRElDVElPTjoge1xyXG4gICAgICAgIG5hbWU6ICdHTVAgUHJpY2UgUHJlZGljdGlvbicsXHJcbiAgICAgICAgdHlwZTogJ3RpbWVfc2VyaWVzJyxcclxuICAgICAgICBmZWF0dXJlczogW1xyXG4gICAgICAgICAgJ2hpc3RvcmljYWxHTVAnLFxyXG4gICAgICAgICAgJ3ZvbHVtZScsXHJcbiAgICAgICAgICAnbWFya2V0U2VudGltZW50JyxcclxuICAgICAgICAgICduZXdzRXZlbnRzJyxcclxuICAgICAgICAgICdjb21wZXRpdG9yUGVyZm9ybWFuY2UnLFxyXG4gICAgICAgICAgJ21hcmtldEluZGljZXMnLFxyXG4gICAgICAgICAgJ3NlY3RvclBFJyxcclxuICAgICAgICAgICdjb21wYW55UEUnLFxyXG4gICAgICAgICAgJ3N1YnNjcmlwdGlvblN0YXR1cycsXHJcbiAgICAgICAgICAnZGF5c1RvTGlzdGluZycsXHJcbiAgICAgICAgICAnbWFya2V0Vm9sYXRpbGl0eScsXHJcbiAgICAgICAgICAndHJhZGluZ1ZvbHVtZScsXHJcbiAgICAgICAgXSxcclxuICAgICAgICB0YXJnZXQ6ICduZXh0R01QVmFsdWUnLFxyXG4gICAgICAgIGFjY3VyYWN5OiAwLFxyXG4gICAgICAgIGxhc3RUcmFpbmVkOiBudWxsLFxyXG4gICAgICAgIHNhbXBsZUNvdW50OiAwLFxyXG4gICAgICAgIGVuYWJsZWQ6IHRydWUsXHJcbiAgICAgIH0sXHJcblxyXG4gICAgICBNQVJLRVRfU0VOVElNRU5UOiB7XHJcbiAgICAgICAgbmFtZTogJ01hcmtldCBTZW50aW1lbnQgUHJlZGljdGlvbicsXHJcbiAgICAgICAgdHlwZTogJ2NsYXNzaWZpY2F0aW9uJyxcclxuICAgICAgICBmZWF0dXJlczogW1xyXG4gICAgICAgICAgJ25ld3NBbmFseXNpcycsXHJcbiAgICAgICAgICAnc29jaWFsTWVkaWFNZW50aW9ucycsXHJcbiAgICAgICAgICAnYW5hbHlzdFJlY29tbWVuZGF0aW9ucycsXHJcbiAgICAgICAgICAnbWFya2V0VHJlbmRzJyxcclxuICAgICAgICAgICdlY29ub21pY0luZGljYXRvcnMnLFxyXG4gICAgICAgICAgJ3NlY3RvclBlcmZvcm1hbmNlJyxcclxuICAgICAgICAgICdjb21wZXRpdG9yTmV3cycsXHJcbiAgICAgICAgICAnbWFuYWdlbWVudFJlcHV0YXRpb24nLFxyXG4gICAgICAgICAgJ2ZpbmFuY2lhbE1ldHJpY3MnLFxyXG4gICAgICAgICAgJ2luZHVzdHJ5R3Jvd3RoJyxcclxuICAgICAgICAgICdyZWd1bGF0b3J5Q2hhbmdlcycsXHJcbiAgICAgICAgICAnZ2xvYmFsTWFya2V0cycsXHJcbiAgICAgICAgXSxcclxuICAgICAgICB0YXJnZXQ6ICdzZW50aW1lbnRTY29yZScsXHJcbiAgICAgICAgYWNjdXJhY3k6IDAsXHJcbiAgICAgICAgbGFzdFRyYWluZWQ6IG51bGwsXHJcbiAgICAgICAgc2FtcGxlQ291bnQ6IDAsXHJcbiAgICAgICAgZW5hYmxlZDogdHJ1ZSxcclxuICAgICAgfSxcclxuXHJcbiAgICAgIElQT19TVUNDRVNTOiB7XHJcbiAgICAgICAgbmFtZTogJ0lQTyBTdWNjZXNzIFByZWRpY3Rpb24nLFxyXG4gICAgICAgIHR5cGU6ICdjbGFzc2lmaWNhdGlvbicsXHJcbiAgICAgICAgZmVhdHVyZXM6IFtcclxuICAgICAgICAgICdjb21wYW55QWdlJyxcclxuICAgICAgICAgICdyZXZlbnVlJyxcclxuICAgICAgICAgICdwcm9maXRhYmlsaXR5JyxcclxuICAgICAgICAgICdncm93dGhSYXRlJyxcclxuICAgICAgICAgICdtYXJrZXRTaGFyZScsXHJcbiAgICAgICAgICAnY29tcGV0aXRvckFuYWx5c2lzJyxcclxuICAgICAgICAgICdtYW5hZ2VtZW50VGVhbScsXHJcbiAgICAgICAgICAnYnVzaW5lc3NNb2RlbCcsXHJcbiAgICAgICAgICAnc2NhbGFiaWxpdHknLFxyXG4gICAgICAgICAgJ2ZpbmFuY2lhbEhlYWx0aCcsXHJcbiAgICAgICAgICAnZGVidFJhdGlvJyxcclxuICAgICAgICAgICdjYXNoRmxvdycsXHJcbiAgICAgICAgICAnbWFya2V0VGltaW5nJyxcclxuICAgICAgICAgICd2YWx1YXRpb25NZXRyaWNzJyxcclxuICAgICAgICAgICdyaXNrRmFjdG9ycycsXHJcbiAgICAgICAgICAncmVndWxhdG9yeUVudmlyb25tZW50JyxcclxuICAgICAgICBdLFxyXG4gICAgICAgIHRhcmdldDogJ2lwb1N1Y2Nlc3NDYXRlZ29yeScsXHJcbiAgICAgICAgYWNjdXJhY3k6IDAsXHJcbiAgICAgICAgbGFzdFRyYWluZWQ6IG51bGwsXHJcbiAgICAgICAgc2FtcGxlQ291bnQ6IDAsXHJcbiAgICAgICAgZW5hYmxlZDogdHJ1ZSxcclxuICAgICAgfSxcclxuICAgIH07XHJcblxyXG4gICAgLy8gUGVyZm9ybWFuY2UgdHJhY2tpbmdcclxuICAgIHRoaXMucGVyZm9ybWFuY2UgPSB7XHJcbiAgICAgIHRvdGFsUHJlZGljdGlvbnM6IDAsXHJcbiAgICAgIGFjY3VyYXRlUHJlZGljdGlvbnM6IDAsXHJcbiAgICAgIHRvdGFsVHJhaW5pbmdTZXNzaW9uczogMCxcclxuICAgICAgYXZlcmFnZVRyYWluaW5nVGltZTogMCxcclxuICAgICAgYXZlcmFnZVByZWRpY3Rpb25UaW1lOiAwLFxyXG4gICAgICBtb2RlbFVwZGF0ZXM6IDAsXHJcbiAgICAgIGxhc3RBY2N1cmFjeUNoZWNrOiBudWxsLFxyXG4gICAgfTtcclxuXHJcbiAgICAvLyBSZWFsLXRpbWUgcHJlZGljdGlvbiBjYWNoZVxyXG4gICAgdGhpcy5wcmVkaWN0aW9uQ2FjaGUgPSBuZXcgTWFwKCk7XHJcbiAgICB0aGlzLmNhY2hlVFRMID0ge1xyXG4gICAgICBMSVNUSU5HX0dBSU46IDMwICogNjAgKiAxMDAwLCAvLyAzMCBtaW51dGVzXHJcbiAgICAgIEFMTE9UTUVOVF9QUk9CQUJJTElUWTogNjAgKiA2MCAqIDEwMDAsIC8vIDEgaG91clxyXG4gICAgICBTVUJTQ1JJUFRJT05fVFJFTkQ6IDEwICogNjAgKiAxMDAwLCAvLyAxMCBtaW51dGVzXHJcbiAgICAgIEdNUF9QUkVESUNUSU9OOiA1ICogNjAgKiAxMDAwLCAvLyA1IG1pbnV0ZXNcclxuICAgICAgTUFSS0VUX1NFTlRJTUVOVDogMTUgKiA2MCAqIDEwMDAsIC8vIDE1IG1pbnV0ZXNcclxuICAgICAgSVBPX1NVQ0NFU1M6IDI0ICogNjAgKiA2MCAqIDEwMDAsIC8vIDI0IGhvdXJzXHJcbiAgICB9O1xyXG5cclxuICAgIC8vIEFjdGl2ZSBpbnRlcnZhbHNcclxuICAgIHRoaXMuYWN0aXZlSW50ZXJ2YWxzID0gbmV3IE1hcCgpO1xyXG5cclxuICAgIC8vIEZlYXR1cmUgZW5naW5lZXJpbmcgcGlwZWxpbmVcclxuICAgIHRoaXMuZmVhdHVyZVByb2Nlc3NvcnMgPSBuZXcgTWFwKCk7XHJcbiAgICB0aGlzLmluaXRpYWxpemVGZWF0dXJlUHJvY2Vzc29ycygpO1xyXG5cclxuICAgIC8vIE1vZGVsIGVuc2VtYmxlIHdlaWdodHNcclxuICAgIHRoaXMuZW5zZW1ibGVXZWlnaHRzID0gbmV3IE1hcCgpO1xyXG4gICAgdGhpcy5pbml0aWFsaXplRW5zZW1ibGVXZWlnaHRzKCk7XHJcblxyXG4gICAgY29uc29sZS5sb2coJ/CflK4gUHJlZGljdGlvbiBTZXJ2aWNlIGluaXRpYWxpemVkJyk7XHJcbiAgfVxyXG5cclxuICAvLyBTdGFydCBjb21wcmVoZW5zaXZlIHByZWRpY3Rpb24gc2VydmljZVxyXG4gIGFzeW5jIHN0YXJ0KCkge1xyXG4gICAgaWYgKHRoaXMuaXNSdW5uaW5nKSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKCfimqDvuI8gIFByZWRpY3Rpb24gU2VydmljZSBpcyBhbHJlYWR5IHJ1bm5pbmcnKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKCfwn5qAIFN0YXJ0aW5nIEVuaGFuY2VkIFByZWRpY3Rpb24gU2VydmljZS4uLicpO1xyXG5cclxuICAgICAgLy8gSW5pdGlhbGl6ZSBwcmVkaWN0aW9uIG1vZGVsc1xyXG4gICAgICBhd2FpdCB0aGlzLmluaXRpYWxpemVQcmVkaWN0aW9uTW9kZWxzKCk7XHJcblxyXG4gICAgICAvLyBMb2FkIHRyYWluaW5nIGRhdGFcclxuICAgICAgYXdhaXQgdGhpcy5sb2FkVHJhaW5pbmdEYXRhKCk7XHJcblxyXG4gICAgICAvLyBUcmFpbiBpbml0aWFsIG1vZGVsc1xyXG4gICAgICBhd2FpdCB0aGlzLnRyYWluQWxsTW9kZWxzKCk7XHJcblxyXG4gICAgICAvLyBTdGFydCBwcmVkaWN0aW9uIHdvcmtmbG93c1xyXG4gICAgICB0aGlzLnN0YXJ0UHJlZGljdGlvbldvcmtmbG93cygpO1xyXG5cclxuICAgICAgLy8gU3RhcnQgbW9kZWwgdHJhaW5pbmcgc2NoZWR1bGVyXHJcbiAgICAgIHRoaXMuc3RhcnRNb2RlbFRyYWluaW5nKCk7XHJcblxyXG4gICAgICAvLyBTdGFydCBhY2N1cmFjeSBtb25pdG9yaW5nXHJcbiAgICAgIHRoaXMuc3RhcnRBY2N1cmFjeU1vbml0b3JpbmcoKTtcclxuXHJcbiAgICAgIC8vIFN0YXJ0IHBlcmZvcm1hbmNlIG1vbml0b3JpbmdcclxuICAgICAgdGhpcy5zdGFydFBlcmZvcm1hbmNlTW9uaXRvcmluZygpO1xyXG5cclxuICAgICAgLy8gU3RhcnQgbWFpbnRlbmFuY2UgdGFza3NcclxuICAgICAgdGhpcy5zdGFydE1haW50ZW5hbmNlVGFza3MoKTtcclxuXHJcbiAgICAgIHRoaXMuaXNSdW5uaW5nID0gdHJ1ZTtcclxuXHJcbiAgICAgIGNvbnNvbGUubG9nKCfinIUgRW5oYW5jZWQgUHJlZGljdGlvbiBTZXJ2aWNlIHN0YXJ0ZWQgc3VjY2Vzc2Z1bGx5Jyk7XHJcbiAgICAgIGNvbnNvbGUubG9nKGDwn5SuICR7T2JqZWN0LmtleXModGhpcy5tb2RlbHMpLmxlbmd0aH0gcHJlZGljdGlvbiBtb2RlbHMgYWN0aXZlYCk7XHJcblxyXG4gICAgICAvLyBCcm9hZGNhc3Qgc2VydmljZSBzdGFydFxyXG4gICAgICBhd2FpdCB3ZWJTb2NrZXRTZXJ2aWNlLmJyb2FkY2FzdFN5c3RlbVN0YXR1cyh7XHJcbiAgICAgICAgdHlwZTogJ3ByZWRpY3Rpb25fc2VydmljZV9zdGFydGVkJyxcclxuICAgICAgICBtb2RlbHM6IE9iamVjdC5rZXlzKHRoaXMubW9kZWxzKS5sZW5ndGgsXHJcbiAgICAgICAgYWNjdXJhY3k6IHRoaXMuZ2V0T3ZlcmFsbEFjY3VyYWN5KCksXHJcbiAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxyXG4gICAgICB9KTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBGYWlsZWQgdG8gc3RhcnQgUHJlZGljdGlvbiBTZXJ2aWNlOicsIGVycm9yKTtcclxuICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBJbml0aWFsaXplIHByZWRpY3Rpb24gbW9kZWxzXHJcbiAgYXN5bmMgaW5pdGlhbGl6ZVByZWRpY3Rpb25Nb2RlbHMoKSB7XHJcbiAgICBjb25zb2xlLmxvZygn8J+noCBJbml0aWFsaXppbmcgcHJlZGljdGlvbiBtb2RlbHMuLi4nKTtcclxuXHJcbiAgICB0cnkge1xyXG4gICAgICBmb3IgKGNvbnN0IFttb2RlbEtleSwgbW9kZWxDb25maWddIG9mIE9iamVjdC5lbnRyaWVzKHRoaXMubW9kZWxzKSkge1xyXG4gICAgICAgIC8vIEluaXRpYWxpemUgbW9kZWwgc3RydWN0dXJlXHJcbiAgICAgICAgY29uc3QgbW9kZWwgPSB7XHJcbiAgICAgICAgICAuLi5tb2RlbENvbmZpZyxcclxuICAgICAgICAgIHdlaWdodHM6IG5ldyBNYXAoKSxcclxuICAgICAgICAgIGJpYXNlczogbmV3IE1hcCgpLFxyXG4gICAgICAgICAgbm9ybWFsaXplcnM6IG5ldyBNYXAoKSxcclxuICAgICAgICAgIGZlYXR1cmVJbXBvcnRhbmNlOiBuZXcgTWFwKCksXHJcbiAgICAgICAgICB0cmFpbmluZ0hpc3Rvcnk6IFtdLFxyXG4gICAgICAgICAgcHJlZGljdGlvbnM6IFtdLFxyXG4gICAgICAgICAgbGFzdFByZWRpY3Rpb246IG51bGwsXHJcbiAgICAgICAgICBpc1JlYWR5OiBmYWxzZSxcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvLyBMb2FkIGV4aXN0aW5nIG1vZGVsIGlmIGF2YWlsYWJsZVxyXG4gICAgICAgIGNvbnN0IHNhdmVkTW9kZWwgPSBhd2FpdCB0aGlzLmxvYWRTYXZlZE1vZGVsKG1vZGVsS2V5KTtcclxuICAgICAgICBpZiAoc2F2ZWRNb2RlbCkge1xyXG4gICAgICAgICAgT2JqZWN0LmFzc2lnbihtb2RlbCwgc2F2ZWRNb2RlbCk7XHJcbiAgICAgICAgICBtb2RlbC5pc1JlYWR5ID0gdHJ1ZTtcclxuICAgICAgICAgIGNvbnNvbGUubG9nKGDwn5OCIExvYWRlZCBzYXZlZCBtb2RlbDogJHttb2RlbEtleX1gKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMucHJlZGljdGlvbk1vZGVscy5zZXQobW9kZWxLZXksIG1vZGVsKTtcclxuXHJcbiAgICAgICAgLy8gSW5pdGlhbGl6ZSBlbnNlbWJsZSB3ZWlnaHRzXHJcbiAgICAgICAgdGhpcy5lbnNlbWJsZVdlaWdodHMuc2V0KG1vZGVsS2V5LCAxLjAgLyBPYmplY3Qua2V5cyh0aGlzLm1vZGVscykubGVuZ3RoKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc29sZS5sb2coYOKchSBJbml0aWFsaXplZCAke3RoaXMucHJlZGljdGlvbk1vZGVscy5zaXplfSBwcmVkaWN0aW9uIG1vZGVsc2ApO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcign4p2MIEZhaWxlZCB0byBpbml0aWFsaXplIHByZWRpY3Rpb24gbW9kZWxzOicsIGVycm9yKTtcclxuICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBMb2FkIHRyYWluaW5nIGRhdGEgZnJvbSBkYXRhYmFzZVxyXG4gIGFzeW5jIGxvYWRUcmFpbmluZ0RhdGEoKSB7XHJcbiAgICBjb25zb2xlLmxvZygn8J+TiiBMb2FkaW5nIHRyYWluaW5nIGRhdGEuLi4nKTtcclxuXHJcbiAgICB0cnkge1xyXG4gICAgICAvLyBMb2FkIElQTyBoaXN0b3JpY2FsIGRhdGFcclxuICAgICAgY29uc3QgaXBvcyA9IGF3YWl0IHByaXNtYS5pUE8uZmluZE1hbnkoe1xyXG4gICAgICAgIHdoZXJlOiB7XHJcbiAgICAgICAgICBzdGF0dXM6ICdsaXN0ZWQnLFxyXG4gICAgICAgICAgbGlzdGluZ0RhdGU6IHsgbm90OiBudWxsIH0sXHJcbiAgICAgICAgfSxcclxuICAgICAgICBpbmNsdWRlOiB7XHJcbiAgICAgICAgICBnbXBEYXRhOiB7XHJcbiAgICAgICAgICAgIG9yZGVyQnk6IHsgdGltZXN0YW1wOiAnZGVzYycgfSxcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBzdWJzY3JpcHRpb25EYXRhOiB7XHJcbiAgICAgICAgICAgIG9yZGVyQnk6IHsgdGltZXN0YW1wOiAnZGVzYycgfSxcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBhbGxvdG1lbnREYXRhOiB0cnVlLFxyXG4gICAgICAgICAgYW5hbHl0aWNzOiB0cnVlLFxyXG4gICAgICAgICAgd2F0Y2hsaXN0czogdHJ1ZSxcclxuICAgICAgICAgIGFsZXJ0czogdHJ1ZSxcclxuICAgICAgICB9LFxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIC8vIFByb2Nlc3MgdHJhaW5pbmcgZGF0YSBmb3IgZWFjaCBtb2RlbFxyXG4gICAgICBmb3IgKGNvbnN0IFttb2RlbEtleSwgbW9kZWxdIG9mIHRoaXMucHJlZGljdGlvbk1vZGVscykge1xyXG4gICAgICAgIGNvbnN0IHRyYWluaW5nU2V0ID0gYXdhaXQgdGhpcy5wcmVwYXJlVHJhaW5pbmdEYXRhKG1vZGVsS2V5LCBpcG9zKTtcclxuICAgICAgICB0aGlzLnRyYWluaW5nRGF0YS5zZXQobW9kZWxLZXksIHRyYWluaW5nU2V0KTtcclxuXHJcbiAgICAgICAgY29uc29sZS5sb2coYPCfk4ggUHJlcGFyZWQgJHt0cmFpbmluZ1NldC5sZW5ndGh9IHRyYWluaW5nIHNhbXBsZXMgZm9yICR7bW9kZWxLZXl9YCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnNvbGUubG9nKGDinIUgTG9hZGVkIHRyYWluaW5nIGRhdGEgZm9yICR7dGhpcy5wcmVkaWN0aW9uTW9kZWxzLnNpemV9IG1vZGVsc2ApO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcign4p2MIEZhaWxlZCB0byBsb2FkIHRyYWluaW5nIGRhdGE6JywgZXJyb3IpO1xyXG4gICAgICB0aHJvdyBlcnJvcjtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIFByZXBhcmUgdHJhaW5pbmcgZGF0YSBmb3Igc3BlY2lmaWMgbW9kZWxcclxuICBhc3luYyBwcmVwYXJlVHJhaW5pbmdEYXRhKG1vZGVsS2V5LCBpcG9zKSB7XHJcbiAgICBjb25zdCBtb2RlbCA9IHRoaXMucHJlZGljdGlvbk1vZGVscy5nZXQobW9kZWxLZXkpO1xyXG4gICAgY29uc3QgdHJhaW5pbmdTZXQgPSBbXTtcclxuXHJcbiAgICB0cnkge1xyXG4gICAgICBmb3IgKGNvbnN0IGlwbyBvZiBpcG9zKSB7XHJcbiAgICAgICAgLy8gRXh0cmFjdCBmZWF0dXJlcyBiYXNlZCBvbiBtb2RlbCBjb25maWd1cmF0aW9uXHJcbiAgICAgICAgY29uc3QgZmVhdHVyZXMgPSBhd2FpdCB0aGlzLmV4dHJhY3RGZWF0dXJlcyhtb2RlbEtleSwgaXBvKTtcclxuICAgICAgICBjb25zdCB0YXJnZXQgPSBhd2FpdCB0aGlzLmV4dHJhY3RUYXJnZXQobW9kZWxLZXksIGlwbyk7XHJcblxyXG4gICAgICAgIGlmIChmZWF0dXJlcyAmJiB0YXJnZXQgIT09IG51bGwgJiYgdGFyZ2V0ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgIHRyYWluaW5nU2V0LnB1c2goe1xyXG4gICAgICAgICAgICBpZDogaXBvLmlkLFxyXG4gICAgICAgICAgICBzeW1ib2w6IGlwby5zeW1ib2wsXHJcbiAgICAgICAgICAgIGZlYXR1cmVzLFxyXG4gICAgICAgICAgICB0YXJnZXQsXHJcbiAgICAgICAgICAgIHRpbWVzdGFtcDogaXBvLmxpc3RpbmdEYXRlLFxyXG4gICAgICAgICAgICBtZXRhZGF0YToge1xyXG4gICAgICAgICAgICAgIGlzc3VlU2l6ZTogaXBvLmlzc3VlU2l6ZSxcclxuICAgICAgICAgICAgICBzZWN0b3I6IGlwby5zZWN0b3IsXHJcbiAgICAgICAgICAgICAgcmVnaXN0cmFyOiBpcG8ucmVnaXN0cmFyLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBWYWxpZGF0ZSBhbmQgY2xlYW4gdHJhaW5pbmcgZGF0YVxyXG4gICAgICByZXR1cm4gdGhpcy52YWxpZGF0ZVRyYWluaW5nRGF0YSh0cmFpbmluZ1NldCwgbW9kZWwpO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgcHJlcGFyaW5nIHRyYWluaW5nIGRhdGEgZm9yICR7bW9kZWxLZXl9OmAsIGVycm9yKTtcclxuICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gRXh0cmFjdCBmZWF0dXJlcyBmb3IgbW9kZWwgdHJhaW5pbmcvcHJlZGljdGlvblxyXG4gIGFzeW5jIGV4dHJhY3RGZWF0dXJlcyhtb2RlbEtleSwgaXBvKSB7XHJcbiAgICBjb25zdCBtb2RlbCA9IHRoaXMucHJlZGljdGlvbk1vZGVscy5nZXQobW9kZWxLZXkpO1xyXG4gICAgY29uc3QgZmVhdHVyZXMgPSB7fTtcclxuXHJcbiAgICB0cnkge1xyXG4gICAgICBmb3IgKGNvbnN0IGZlYXR1cmVOYW1lIG9mIG1vZGVsLmZlYXR1cmVzKSB7XHJcbiAgICAgICAgY29uc3QgcHJvY2Vzc29yID0gdGhpcy5mZWF0dXJlUHJvY2Vzc29ycy5nZXQoZmVhdHVyZU5hbWUpO1xyXG4gICAgICAgIGlmIChwcm9jZXNzb3IpIHtcclxuICAgICAgICAgIGZlYXR1cmVzW2ZlYXR1cmVOYW1lXSA9IGF3YWl0IHByb2Nlc3NvcihpcG8pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBmZWF0dXJlc1tmZWF0dXJlTmFtZV0gPSB0aGlzLmV4dHJhY3RCYXNpY0ZlYXR1cmUoZmVhdHVyZU5hbWUsIGlwbyk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gZmVhdHVyZXM7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBleHRyYWN0aW5nIGZlYXR1cmVzIGZvciAke21vZGVsS2V5fTpgLCBlcnJvcik7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gRXh0cmFjdCB0YXJnZXQgdmFyaWFibGUgZm9yIHRyYWluaW5nXHJcbiAgYXN5bmMgZXh0cmFjdFRhcmdldChtb2RlbEtleSwgaXBvKSB7XHJcbiAgICBjb25zdCBtb2RlbCA9IHRoaXMucHJlZGljdGlvbk1vZGVscy5nZXQobW9kZWxLZXkpO1xyXG5cclxuICAgIHRyeSB7XHJcbiAgICAgIHN3aXRjaCAobW9kZWwudGFyZ2V0KSB7XHJcbiAgICAgICAgY2FzZSAnbGlzdGluZ0dhaW5QZXJjZW50YWdlJzpcclxuICAgICAgICAgIHJldHVybiB0aGlzLmNhbGN1bGF0ZUxpc3RpbmdHYWluKGlwbyk7XHJcblxyXG4gICAgICAgIGNhc2UgJ2FsbG90bWVudFN0YXR1cyc6XHJcbiAgICAgICAgICByZXR1cm4gdGhpcy5nZXRBbGxvdG1lbnRTdGF0dXMoaXBvKTtcclxuXHJcbiAgICAgICAgY2FzZSAnZmluYWxTdWJzY3JpcHRpb25SYXRpbyc6XHJcbiAgICAgICAgICByZXR1cm4gdGhpcy5nZXRGaW5hbFN1YnNjcmlwdGlvblJhdGlvKGlwbyk7XHJcblxyXG4gICAgICAgIGNhc2UgJ25leHRHTVBWYWx1ZSc6XHJcbiAgICAgICAgICByZXR1cm4gdGhpcy5nZXROZXh0R01QVmFsdWUoaXBvKTtcclxuXHJcbiAgICAgICAgY2FzZSAnc2VudGltZW50U2NvcmUnOlxyXG4gICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U2VudGltZW50U2NvcmUoaXBvKTtcclxuXHJcbiAgICAgICAgY2FzZSAnaXBvU3VjY2Vzc0NhdGVnb3J5JzpcclxuICAgICAgICAgIHJldHVybiB0aGlzLmdldElQT1N1Y2Nlc3NDYXRlZ29yeShpcG8pO1xyXG5cclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgIH1cclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGV4dHJhY3RpbmcgdGFyZ2V0IGZvciAke21vZGVsS2V5fTpgLCBlcnJvcik7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gSW5pdGlhbGl6ZSBmZWF0dXJlIHByb2Nlc3NvcnNcclxuICBpbml0aWFsaXplRmVhdHVyZVByb2Nlc3NvcnMoKSB7XHJcbiAgICAvLyBHTVAtcmVsYXRlZCBmZWF0dXJlc1xyXG4gICAgdGhpcy5mZWF0dXJlUHJvY2Vzc29ycy5zZXQoJ2F2Z0dNUCcsIGFzeW5jIChpcG8pID0+IHtcclxuICAgICAgY29uc3QgZ21wVmFsdWVzID0gaXBvLmdtcD8ubWFwKChnKSA9PiBnLnZhbHVlKSB8fCBbXTtcclxuICAgICAgcmV0dXJuIGdtcFZhbHVlcy5sZW5ndGggPiAwID8gZ21wVmFsdWVzLnJlZHVjZSgoYSwgYikgPT4gYSArIGIsIDApIC8gZ21wVmFsdWVzLmxlbmd0aCA6IDA7XHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLmZlYXR1cmVQcm9jZXNzb3JzLnNldCgnZ21wVm9sYXRpbGl0eScsIGFzeW5jIChpcG8pID0+IHtcclxuICAgICAgY29uc3QgZ21wVmFsdWVzID0gaXBvLmdtcD8ubWFwKChnKSA9PiBnLnZhbHVlKSB8fCBbXTtcclxuICAgICAgaWYgKGdtcFZhbHVlcy5sZW5ndGggPCAyKSByZXR1cm4gMDtcclxuXHJcbiAgICAgIGNvbnN0IG1lYW4gPSBnbXBWYWx1ZXMucmVkdWNlKChhLCBiKSA9PiBhICsgYiwgMCkgLyBnbXBWYWx1ZXMubGVuZ3RoO1xyXG4gICAgICBjb25zdCB2YXJpYW5jZSA9XHJcbiAgICAgICAgZ21wVmFsdWVzLnJlZHVjZSgoc3VtLCB2YWwpID0+IHN1bSArIE1hdGgucG93KHZhbCAtIG1lYW4sIDIpLCAwKSAvIGdtcFZhbHVlcy5sZW5ndGg7XHJcbiAgICAgIHJldHVybiBNYXRoLnNxcnQodmFyaWFuY2UpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy5mZWF0dXJlUHJvY2Vzc29ycy5zZXQoJ2dtcFRyZW5kJywgYXN5bmMgKGlwbykgPT4ge1xyXG4gICAgICBjb25zdCBnbXBWYWx1ZXMgPSBpcG8uZ21wPy5tYXAoKGcpID0+IGcudmFsdWUpIHx8IFtdO1xyXG4gICAgICBpZiAoZ21wVmFsdWVzLmxlbmd0aCA8IDMpIHJldHVybiAwO1xyXG5cclxuICAgICAgY29uc3QgcmVjZW50QXZnID0gZ21wVmFsdWVzLnNsaWNlKDAsIDMpLnJlZHVjZSgoYSwgYikgPT4gYSArIGIsIDApIC8gMztcclxuICAgICAgY29uc3Qgb2xkZXJBdmcgPSBnbXBWYWx1ZXMuc2xpY2UoLTMpLnJlZHVjZSgoYSwgYikgPT4gYSArIGIsIDApIC8gMztcclxuICAgICAgcmV0dXJuIG9sZGVyQXZnID4gMCA/IChyZWNlbnRBdmcgLSBvbGRlckF2ZykgLyBvbGRlckF2ZyA6IDA7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBTdWJzY3JpcHRpb24tcmVsYXRlZCBmZWF0dXJlc1xyXG4gICAgdGhpcy5mZWF0dXJlUHJvY2Vzc29ycy5zZXQoJ3N1YnNjcmlwdGlvblJhdGlvJywgYXN5bmMgKGlwbykgPT4ge1xyXG4gICAgICBjb25zdCBsYXRlc3QgPSBpcG8uc3Vic2NyaXB0aW9uPy5bMF07XHJcbiAgICAgIHJldHVybiBsYXRlc3Q/LnN1YnNjcmlwdGlvblJhdGlvIHx8IDA7XHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLmZlYXR1cmVQcm9jZXNzb3JzLnNldCgncWliU3Vic2NyaXB0aW9uJywgYXN5bmMgKGlwbykgPT4ge1xyXG4gICAgICBjb25zdCBxaWJTdWIgPSBpcG8uc3Vic2NyaXB0aW9uPy5maW5kKChzKSA9PiBzLmNhdGVnb3J5ID09PSAnUUlCJyk7XHJcbiAgICAgIHJldHVybiBxaWJTdWI/LnN1YnNjcmlwdGlvblJhdGlvIHx8IDA7XHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLmZlYXR1cmVQcm9jZXNzb3JzLnNldCgncmV0YWlsU3Vic2NyaXB0aW9uJywgYXN5bmMgKGlwbykgPT4ge1xyXG4gICAgICBjb25zdCByZXRhaWxTdWIgPSBpcG8uc3Vic2NyaXB0aW9uPy5maW5kKChzKSA9PiBzLmNhdGVnb3J5ID09PSAnUkVUQUlMJyk7XHJcbiAgICAgIHJldHVybiByZXRhaWxTdWI/LnN1YnNjcmlwdGlvblJhdGlvIHx8IDA7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBNYXJrZXQgYW5kIHRpbWluZyBmZWF0dXJlc1xyXG4gICAgdGhpcy5mZWF0dXJlUHJvY2Vzc29ycy5zZXQoJ2RheXNTaW5jZU9wZW4nLCBhc3luYyAoaXBvKSA9PiB7XHJcbiAgICAgIGNvbnN0IG9wZW5EYXRlID0gbmV3IERhdGUoaXBvLm9wZW5EYXRlKTtcclxuICAgICAgY29uc3Qgbm93ID0gbmV3IERhdGUoKTtcclxuICAgICAgcmV0dXJuIE1hdGguY2VpbCgobm93IC0gb3BlbkRhdGUpIC8gKDEwMDAgKiA2MCAqIDYwICogMjQpKTtcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMuZmVhdHVyZVByb2Nlc3NvcnMuc2V0KCdtYXJrZXRTZW50aW1lbnQnLCBhc3luYyAoaXBvKSA9PiB7XHJcbiAgICAgIC8vIE1vY2sgbWFya2V0IHNlbnRpbWVudCAtIGluIHByb2R1Y3Rpb24sIGludGVncmF0ZSB3aXRoIG5ld3Mvc29jaWFsIG1lZGlhIEFQSXNcclxuICAgICAgcmV0dXJuIE1hdGgucmFuZG9tKCkgKiAyIC0gMTsgLy8gUmFuZ2U6IC0xIHRvIDFcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMuZmVhdHVyZVByb2Nlc3NvcnMuc2V0KCdzZWN0b3JQZXJmb3JtYW5jZScsIGFzeW5jIChpcG8pID0+IHtcclxuICAgICAgLy8gTW9jayBzZWN0b3IgcGVyZm9ybWFuY2UgLSBpbiBwcm9kdWN0aW9uLCBmZXRjaCBmcm9tIG1hcmtldCBkYXRhIEFQSXNcclxuICAgICAgcmV0dXJuIE1hdGgucmFuZG9tKCkgKiAwLjIgLSAwLjE7IC8vIFJhbmdlOiAtMTAlIHRvIDEwJVxyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gQ29tcGFueS1zcGVjaWZpYyBmZWF0dXJlc1xyXG4gICAgdGhpcy5mZWF0dXJlUHJvY2Vzc29ycy5zZXQoJ2lzc3VlU2l6ZScsIGFzeW5jIChpcG8pID0+IHtcclxuICAgICAgcmV0dXJuIE51bWJlcihpcG8uaXNzdWVTaXplIHx8IDApIC8gMTAwMDAwMDAwMDsgLy8gTm9ybWFsaXplIHRvIGJpbGxpb25zXHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLmZlYXR1cmVQcm9jZXNzb3JzLnNldCgncHJpY2VSYW5nZScsIGFzeW5jIChpcG8pID0+IHtcclxuICAgICAgcmV0dXJuIGlwby5tYXhQcmljZSA+IDAgPyAoaXBvLm1heFByaWNlIC0gaXBvLm1pblByaWNlKSAvIGlwby5tYXhQcmljZSA6IDA7XHJcbiAgICB9KTtcclxuXHJcbiAgICBjb25zb2xlLmxvZyhg8J+UpyBJbml0aWFsaXplZCAke3RoaXMuZmVhdHVyZVByb2Nlc3NvcnMuc2l6ZX0gZmVhdHVyZSBwcm9jZXNzb3JzYCk7XHJcbiAgfVxyXG5cclxuICAvLyBJbml0aWFsaXplIGVuc2VtYmxlIHdlaWdodHNcclxuICBpbml0aWFsaXplRW5zZW1ibGVXZWlnaHRzKCkge1xyXG4gICAgY29uc3QgbW9kZWxDb3VudCA9IE9iamVjdC5rZXlzKHRoaXMubW9kZWxzKS5sZW5ndGg7XHJcbiAgICBjb25zdCBiYXNlV2VpZ2h0ID0gMS4wIC8gbW9kZWxDb3VudDtcclxuXHJcbiAgICBmb3IgKGNvbnN0IG1vZGVsS2V5IG9mIE9iamVjdC5rZXlzKHRoaXMubW9kZWxzKSkge1xyXG4gICAgICB0aGlzLmVuc2VtYmxlV2VpZ2h0cy5zZXQobW9kZWxLZXksIGJhc2VXZWlnaHQpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnNvbGUubG9nKCfimpbvuI8gIEluaXRpYWxpemVkIGVuc2VtYmxlIHdlaWdodHMnKTtcclxuICB9XHJcblxyXG4gIC8vIFRyYWluIGFsbCBtb2RlbHNcclxuICBhc3luYyB0cmFpbkFsbE1vZGVscygpIHtcclxuICAgIGNvbnNvbGUubG9nKCfwn46vIFRyYWluaW5nIGFsbCBwcmVkaWN0aW9uIG1vZGVscy4uLicpO1xyXG5cclxuICAgIGZvciAoY29uc3QgW21vZGVsS2V5LCBtb2RlbF0gb2YgdGhpcy5wcmVkaWN0aW9uTW9kZWxzKSB7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgaWYgKG1vZGVsLmVuYWJsZWQpIHtcclxuICAgICAgICAgIGF3YWl0IHRoaXMudHJhaW5Nb2RlbChtb2RlbEtleSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIHRyYWluaW5nIG1vZGVsICR7bW9kZWxLZXl9OmAsIGVycm9yKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNvbnNvbGUubG9nKCfinIUgQ29tcGxldGVkIHRyYWluaW5nIGFsbCBtb2RlbHMnKTtcclxuICB9XHJcblxyXG4gIC8vIFRyYWluIGluZGl2aWR1YWwgbW9kZWxcclxuICBhc3luYyB0cmFpbk1vZGVsKG1vZGVsS2V5KSB7XHJcbiAgICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xyXG4gICAgY29uc29sZS5sb2coYPCfp6AgVHJhaW5pbmcgbW9kZWw6ICR7bW9kZWxLZXl9Li4uYCk7XHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgbW9kZWwgPSB0aGlzLnByZWRpY3Rpb25Nb2RlbHMuZ2V0KG1vZGVsS2V5KTtcclxuICAgICAgY29uc3QgdHJhaW5pbmdEYXRhID0gdGhpcy50cmFpbmluZ0RhdGEuZ2V0KG1vZGVsS2V5KTtcclxuXHJcbiAgICAgIGlmICghdHJhaW5pbmdEYXRhIHx8IHRyYWluaW5nRGF0YS5sZW5ndGggPCB0aGlzLnByZWRpY3Rpb25Db25maWcuTUlOX1RSQUlOSU5HX0RBVEEpIHtcclxuICAgICAgICBjb25zb2xlLndhcm4oXHJcbiAgICAgICAgICBgSW5zdWZmaWNpZW50IHRyYWluaW5nIGRhdGEgZm9yICR7bW9kZWxLZXl9OiAke3RyYWluaW5nRGF0YT8ubGVuZ3RoIHx8IDB9IHNhbXBsZXNgXHJcbiAgICAgICAgKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFNwbGl0IGRhdGEgaW50byB0cmFpbmluZyBhbmQgdmFsaWRhdGlvbiBzZXRzXHJcbiAgICAgIGNvbnN0IHNwbGl0SW5kZXggPSBNYXRoLmZsb29yKHRyYWluaW5nRGF0YS5sZW5ndGggKiAwLjgpO1xyXG4gICAgICBjb25zdCB0cmFpblNldCA9IHRyYWluaW5nRGF0YS5zbGljZSgwLCBzcGxpdEluZGV4KTtcclxuICAgICAgY29uc3QgdmFsaWRhdGlvblNldCA9IHRyYWluaW5nRGF0YS5zbGljZShzcGxpdEluZGV4KTtcclxuXHJcbiAgICAgIC8vIE5vcm1hbGl6ZSBmZWF0dXJlc1xyXG4gICAgICBjb25zdCBub3JtYWxpemVycyA9IHRoaXMuY2FsY3VsYXRlTm9ybWFsaXplcnModHJhaW5TZXQpO1xyXG4gICAgICBtb2RlbC5ub3JtYWxpemVycyA9IG5vcm1hbGl6ZXJzO1xyXG5cclxuICAgICAgLy8gVHJhaW4gYmFzZWQgb24gbW9kZWwgdHlwZVxyXG4gICAgICBsZXQgdHJhaW5lZFdlaWdodHM7XHJcbiAgICAgIHN3aXRjaCAobW9kZWwudHlwZSkge1xyXG4gICAgICAgIGNhc2UgJ3JlZ3Jlc3Npb24nOlxyXG4gICAgICAgICAgdHJhaW5lZFdlaWdodHMgPSBhd2FpdCB0aGlzLnRyYWluUmVncmVzc2lvbk1vZGVsKHRyYWluU2V0LCBub3JtYWxpemVycyk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlICdjbGFzc2lmaWNhdGlvbic6XHJcbiAgICAgICAgICB0cmFpbmVkV2VpZ2h0cyA9IGF3YWl0IHRoaXMudHJhaW5DbGFzc2lmaWNhdGlvbk1vZGVsKHRyYWluU2V0LCBub3JtYWxpemVycyk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlICd0aW1lX3Nlcmllcyc6XHJcbiAgICAgICAgICB0cmFpbmVkV2VpZ2h0cyA9IGF3YWl0IHRoaXMudHJhaW5UaW1lU2VyaWVzTW9kZWwodHJhaW5TZXQsIG5vcm1hbGl6ZXJzKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gbW9kZWwgdHlwZTogJHttb2RlbC50eXBlfWApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBtb2RlbC53ZWlnaHRzID0gdHJhaW5lZFdlaWdodHMud2VpZ2h0cztcclxuICAgICAgbW9kZWwuYmlhc2VzID0gdHJhaW5lZFdlaWdodHMuYmlhc2VzO1xyXG5cclxuICAgICAgLy8gQ2FsY3VsYXRlIGFjY3VyYWN5IG9uIHZhbGlkYXRpb24gc2V0XHJcbiAgICAgIGNvbnN0IGFjY3VyYWN5ID0gYXdhaXQgdGhpcy52YWxpZGF0ZU1vZGVsKG1vZGVsS2V5LCB2YWxpZGF0aW9uU2V0KTtcclxuICAgICAgbW9kZWwuYWNjdXJhY3kgPSBhY2N1cmFjeTtcclxuXHJcbiAgICAgIC8vIFVwZGF0ZSBtb2RlbCBtZXRhZGF0YVxyXG4gICAgICBtb2RlbC5sYXN0VHJhaW5lZCA9IG5ldyBEYXRlKCk7XHJcbiAgICAgIG1vZGVsLnNhbXBsZUNvdW50ID0gdHJhaW5TZXQubGVuZ3RoO1xyXG4gICAgICBtb2RlbC5pc1JlYWR5ID0gdHJ1ZTtcclxuXHJcbiAgICAgIC8vIFN0b3JlIHRyYWluaW5nIGhpc3RvcnlcclxuICAgICAgbW9kZWwudHJhaW5pbmdIaXN0b3J5LnB1c2goe1xyXG4gICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcclxuICAgICAgICBhY2N1cmFjeSxcclxuICAgICAgICBzYW1wbGVDb3VudDogdHJhaW5TZXQubGVuZ3RoLFxyXG4gICAgICAgIHRyYWluaW5nVGltZTogRGF0ZS5ub3coKSAtIHN0YXJ0VGltZSxcclxuICAgICAgfSk7XHJcblxyXG4gICAgICAvLyBTYXZlIG1vZGVsXHJcbiAgICAgIGF3YWl0IHRoaXMuc2F2ZU1vZGVsKG1vZGVsS2V5LCBtb2RlbCk7XHJcblxyXG4gICAgICAvLyBVcGRhdGUgZW5zZW1ibGUgd2VpZ2h0cyBiYXNlZCBvbiBhY2N1cmFjeVxyXG4gICAgICB0aGlzLnVwZGF0ZUVuc2VtYmxlV2VpZ2h0KG1vZGVsS2V5LCBhY2N1cmFjeSk7XHJcblxyXG4gICAgICBjb25zdCB0cmFpbmluZ1RpbWUgPSBEYXRlLm5vdygpIC0gc3RhcnRUaW1lO1xyXG4gICAgICB0aGlzLnVwZGF0ZVRyYWluaW5nTWV0cmljcyh0cmFpbmluZ1RpbWUpO1xyXG5cclxuICAgICAgY29uc29sZS5sb2coYOKchSBUcmFpbmVkICR7bW9kZWxLZXl9OiAke2FjY3VyYWN5LnRvRml4ZWQoMyl9IGFjY3VyYWN5ICgke3RyYWluaW5nVGltZX1tcylgKTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoYOKdjCBGYWlsZWQgdG8gdHJhaW4gbW9kZWwgJHttb2RlbEtleX06YCwgZXJyb3IpO1xyXG4gICAgICB0aHJvdyBlcnJvcjtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIFRyYWluIHJlZ3Jlc3Npb24gbW9kZWwgKExpbmVhciBSZWdyZXNzaW9uKVxyXG4gIGFzeW5jIHRyYWluUmVncmVzc2lvbk1vZGVsKHRyYWluU2V0LCBub3JtYWxpemVycykge1xyXG4gICAgY29uc3QgZmVhdHVyZXMgPSB0cmFpblNldFswXS5mZWF0dXJlcztcclxuICAgIGNvbnN0IGZlYXR1cmVOYW1lcyA9IE9iamVjdC5rZXlzKGZlYXR1cmVzKTtcclxuICAgIGNvbnN0IG0gPSB0cmFpblNldC5sZW5ndGg7XHJcbiAgICBjb25zdCBuID0gZmVhdHVyZU5hbWVzLmxlbmd0aDtcclxuXHJcbiAgICAvLyBJbml0aWFsaXplIHdlaWdodHMgYW5kIGJpYXNcclxuICAgIGNvbnN0IHdlaWdodHMgPSBuZXcgTWFwKCk7XHJcbiAgICBmZWF0dXJlTmFtZXMuZm9yRWFjaCgobmFtZSkgPT4gd2VpZ2h0cy5zZXQobmFtZSwgTWF0aC5yYW5kb20oKSAqIDAuMDEpKTtcclxuICAgIGxldCBiaWFzID0gMDtcclxuXHJcbiAgICAvLyBHcmFkaWVudCBkZXNjZW50IHBhcmFtZXRlcnNcclxuICAgIGNvbnN0IGxlYXJuaW5nUmF0ZSA9IDAuMDE7XHJcbiAgICBjb25zdCBlcG9jaHMgPSAxMDAwO1xyXG5cclxuICAgIC8vIFRyYWluaW5nIGxvb3BcclxuICAgIGZvciAobGV0IGVwb2NoID0gMDsgZXBvY2ggPCBlcG9jaHM7IGVwb2NoKyspIHtcclxuICAgICAgbGV0IHRvdGFsTG9zcyA9IDA7XHJcbiAgICAgIGNvbnN0IGdyYWRpZW50cyA9IG5ldyBNYXAoKTtcclxuICAgICAgbGV0IGJpYXNHcmFkaWVudCA9IDA7XHJcblxyXG4gICAgICAvLyBJbml0aWFsaXplIGdyYWRpZW50c1xyXG4gICAgICBmZWF0dXJlTmFtZXMuZm9yRWFjaCgobmFtZSkgPT4gZ3JhZGllbnRzLnNldChuYW1lLCAwKSk7XHJcblxyXG4gICAgICAvLyBGb3J3YXJkIHBhc3MgYW5kIGdyYWRpZW50IGNhbGN1bGF0aW9uXHJcbiAgICAgIGZvciAoY29uc3Qgc2FtcGxlIG9mIHRyYWluU2V0KSB7XHJcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZEZlYXR1cmVzID0gdGhpcy5ub3JtYWxpemVGZWF0dXJlcyhzYW1wbGUuZmVhdHVyZXMsIG5vcm1hbGl6ZXJzKTtcclxuXHJcbiAgICAgICAgLy8gUHJlZGljdGlvblxyXG4gICAgICAgIGxldCBwcmVkaWN0aW9uID0gYmlhcztcclxuICAgICAgICBmb3IgKGNvbnN0IFtmZWF0dXJlTmFtZSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKG5vcm1hbGl6ZWRGZWF0dXJlcykpIHtcclxuICAgICAgICAgIHByZWRpY3Rpb24gKz0gd2VpZ2h0cy5nZXQoZmVhdHVyZU5hbWUpICogdmFsdWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBMb3NzIChNZWFuIFNxdWFyZWQgRXJyb3IpXHJcbiAgICAgICAgY29uc3QgZXJyb3IgPSBwcmVkaWN0aW9uIC0gc2FtcGxlLnRhcmdldDtcclxuICAgICAgICB0b3RhbExvc3MgKz0gZXJyb3IgKiBlcnJvcjtcclxuXHJcbiAgICAgICAgLy8gR3JhZGllbnRzXHJcbiAgICAgICAgYmlhc0dyYWRpZW50ICs9IGVycm9yO1xyXG4gICAgICAgIGZvciAoY29uc3QgW2ZlYXR1cmVOYW1lLCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMobm9ybWFsaXplZEZlYXR1cmVzKSkge1xyXG4gICAgICAgICAgZ3JhZGllbnRzLnNldChmZWF0dXJlTmFtZSwgZ3JhZGllbnRzLmdldChmZWF0dXJlTmFtZSkgKyBlcnJvciAqIHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFVwZGF0ZSB3ZWlnaHRzXHJcbiAgICAgIGJpYXMgLT0gKGxlYXJuaW5nUmF0ZSAqIGJpYXNHcmFkaWVudCkgLyBtO1xyXG4gICAgICBmb3IgKGNvbnN0IGZlYXR1cmVOYW1lIG9mIGZlYXR1cmVOYW1lcykge1xyXG4gICAgICAgIGNvbnN0IGN1cnJlbnRXZWlnaHQgPSB3ZWlnaHRzLmdldChmZWF0dXJlTmFtZSk7XHJcbiAgICAgICAgd2VpZ2h0cy5zZXQoZmVhdHVyZU5hbWUsIGN1cnJlbnRXZWlnaHQgLSAobGVhcm5pbmdSYXRlICogZ3JhZGllbnRzLmdldChmZWF0dXJlTmFtZSkpIC8gbSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIEVhcmx5IHN0b3BwaW5nIGNoZWNrXHJcbiAgICAgIGlmIChlcG9jaCAlIDEwMCA9PT0gMCkge1xyXG4gICAgICAgIGNvbnN0IGF2Z0xvc3MgPSB0b3RhbExvc3MgLyBtO1xyXG4gICAgICAgIGlmIChhdmdMb3NzIDwgMC4wMDEpIGJyZWFrOyAvLyBDb252ZXJnZW5jZSB0aHJlc2hvbGRcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB7IHdlaWdodHMsIGJpYXNlczogbmV3IE1hcChbWydiaWFzJywgYmlhc11dKSB9O1xyXG4gIH1cclxuXHJcbiAgLy8gVHJhaW4gY2xhc3NpZmljYXRpb24gbW9kZWwgKExvZ2lzdGljIFJlZ3Jlc3Npb24pXHJcbiAgYXN5bmMgdHJhaW5DbGFzc2lmaWNhdGlvbk1vZGVsKHRyYWluU2V0LCBub3JtYWxpemVycykge1xyXG4gICAgY29uc3QgZmVhdHVyZXMgPSB0cmFpblNldFswXS5mZWF0dXJlcztcclxuICAgIGNvbnN0IGZlYXR1cmVOYW1lcyA9IE9iamVjdC5rZXlzKGZlYXR1cmVzKTtcclxuICAgIGNvbnN0IG0gPSB0cmFpblNldC5sZW5ndGg7XHJcblxyXG4gICAgLy8gR2V0IHVuaXF1ZSBjbGFzc2VzXHJcbiAgICBjb25zdCBjbGFzc2VzID0gWy4uLm5ldyBTZXQodHJhaW5TZXQubWFwKChzKSA9PiBzLnRhcmdldCkpXTtcclxuICAgIGNvbnN0IG51bUNsYXNzZXMgPSBjbGFzc2VzLmxlbmd0aDtcclxuXHJcbiAgICAvLyBGb3IgYmluYXJ5IGNsYXNzaWZpY2F0aW9uXHJcbiAgICBpZiAobnVtQ2xhc3NlcyA9PT0gMikge1xyXG4gICAgICByZXR1cm4gdGhpcy50cmFpbkJpbmFyeUNsYXNzaWZpZXIodHJhaW5TZXQsIG5vcm1hbGl6ZXJzLCBmZWF0dXJlTmFtZXMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEZvciBtdWx0aWNsYXNzIGNsYXNzaWZpY2F0aW9uIChPbmUtdnMtUmVzdClcclxuICAgIGNvbnN0IGNsYXNzaWZpZXJXZWlnaHRzID0gbmV3IE1hcCgpO1xyXG4gICAgY29uc3QgY2xhc3NpZmllckJpYXNlcyA9IG5ldyBNYXAoKTtcclxuXHJcbiAgICBmb3IgKGNvbnN0IHRhcmdldENsYXNzIG9mIGNsYXNzZXMpIHtcclxuICAgICAgLy8gQ3JlYXRlIGJpbmFyeSBkYXRhc2V0IGZvciB0aGlzIGNsYXNzXHJcbiAgICAgIGNvbnN0IGJpbmFyeVRyYWluU2V0ID0gdHJhaW5TZXQubWFwKChzYW1wbGUpID0+ICh7XHJcbiAgICAgICAgLi4uc2FtcGxlLFxyXG4gICAgICAgIHRhcmdldDogc2FtcGxlLnRhcmdldCA9PT0gdGFyZ2V0Q2xhc3MgPyAxIDogMCxcclxuICAgICAgfSkpO1xyXG5cclxuICAgICAgY29uc3QgeyB3ZWlnaHRzLCBiaWFzZXMgfSA9IGF3YWl0IHRoaXMudHJhaW5CaW5hcnlDbGFzc2lmaWVyKFxyXG4gICAgICAgIGJpbmFyeVRyYWluU2V0LFxyXG4gICAgICAgIG5vcm1hbGl6ZXJzLFxyXG4gICAgICAgIGZlYXR1cmVOYW1lc1xyXG4gICAgICApO1xyXG4gICAgICBjbGFzc2lmaWVyV2VpZ2h0cy5zZXQodGFyZ2V0Q2xhc3MsIHdlaWdodHMpO1xyXG4gICAgICBjbGFzc2lmaWVyQmlhc2VzLnNldCh0YXJnZXRDbGFzcywgYmlhc2VzKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4geyB3ZWlnaHRzOiBjbGFzc2lmaWVyV2VpZ2h0cywgYmlhc2VzOiBjbGFzc2lmaWVyQmlhc2VzIH07XHJcbiAgfVxyXG5cclxuICAvLyBUcmFpbiBiaW5hcnkgY2xhc3NpZmllclxyXG4gIGFzeW5jIHRyYWluQmluYXJ5Q2xhc3NpZmllcih0cmFpblNldCwgbm9ybWFsaXplcnMsIGZlYXR1cmVOYW1lcykge1xyXG4gICAgY29uc3Qgd2VpZ2h0cyA9IG5ldyBNYXAoKTtcclxuICAgIGZlYXR1cmVOYW1lcy5mb3JFYWNoKChuYW1lKSA9PiB3ZWlnaHRzLnNldChuYW1lLCBNYXRoLnJhbmRvbSgpICogMC4wMSkpO1xyXG4gICAgbGV0IGJpYXMgPSAwO1xyXG5cclxuICAgIGNvbnN0IGxlYXJuaW5nUmF0ZSA9IDAuMDE7XHJcbiAgICBjb25zdCBlcG9jaHMgPSAxMDAwO1xyXG5cclxuICAgIGZvciAobGV0IGVwb2NoID0gMDsgZXBvY2ggPCBlcG9jaHM7IGVwb2NoKyspIHtcclxuICAgICAgY29uc3QgZ3JhZGllbnRzID0gbmV3IE1hcCgpO1xyXG4gICAgICBsZXQgYmlhc0dyYWRpZW50ID0gMDtcclxuICAgICAgZmVhdHVyZU5hbWVzLmZvckVhY2goKG5hbWUpID0+IGdyYWRpZW50cy5zZXQobmFtZSwgMCkpO1xyXG5cclxuICAgICAgZm9yIChjb25zdCBzYW1wbGUgb2YgdHJhaW5TZXQpIHtcclxuICAgICAgICBjb25zdCBub3JtYWxpemVkRmVhdHVyZXMgPSB0aGlzLm5vcm1hbGl6ZUZlYXR1cmVzKHNhbXBsZS5mZWF0dXJlcywgbm9ybWFsaXplcnMpO1xyXG5cclxuICAgICAgICAvLyBQcmVkaWN0aW9uIChzaWdtb2lkKVxyXG4gICAgICAgIGxldCB6ID0gYmlhcztcclxuICAgICAgICBmb3IgKGNvbnN0IFtmZWF0dXJlTmFtZSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKG5vcm1hbGl6ZWRGZWF0dXJlcykpIHtcclxuICAgICAgICAgIHogKz0gd2VpZ2h0cy5nZXQoZmVhdHVyZU5hbWUpICogdmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHByZWRpY3Rpb24gPSAxIC8gKDEgKyBNYXRoLmV4cCgteikpO1xyXG5cclxuICAgICAgICAvLyBHcmFkaWVudCBjYWxjdWxhdGlvblxyXG4gICAgICAgIGNvbnN0IGVycm9yID0gcHJlZGljdGlvbiAtIHNhbXBsZS50YXJnZXQ7XHJcbiAgICAgICAgYmlhc0dyYWRpZW50ICs9IGVycm9yO1xyXG5cclxuICAgICAgICBmb3IgKGNvbnN0IFtmZWF0dXJlTmFtZSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKG5vcm1hbGl6ZWRGZWF0dXJlcykpIHtcclxuICAgICAgICAgIGdyYWRpZW50cy5zZXQoZmVhdHVyZU5hbWUsIGdyYWRpZW50cy5nZXQoZmVhdHVyZU5hbWUpICsgZXJyb3IgKiB2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBVcGRhdGUgd2VpZ2h0c1xyXG4gICAgICBiaWFzIC09IChsZWFybmluZ1JhdGUgKiBiaWFzR3JhZGllbnQpIC8gdHJhaW5TZXQubGVuZ3RoO1xyXG4gICAgICBmb3IgKGNvbnN0IGZlYXR1cmVOYW1lIG9mIGZlYXR1cmVOYW1lcykge1xyXG4gICAgICAgIGNvbnN0IGN1cnJlbnRXZWlnaHQgPSB3ZWlnaHRzLmdldChmZWF0dXJlTmFtZSk7XHJcbiAgICAgICAgd2VpZ2h0cy5zZXQoXHJcbiAgICAgICAgICBmZWF0dXJlTmFtZSxcclxuICAgICAgICAgIGN1cnJlbnRXZWlnaHQgLSAobGVhcm5pbmdSYXRlICogZ3JhZGllbnRzLmdldChmZWF0dXJlTmFtZSkpIC8gdHJhaW5TZXQubGVuZ3RoXHJcbiAgICAgICAgKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB7IHdlaWdodHMsIGJpYXNlczogbmV3IE1hcChbWydiaWFzJywgYmlhc11dKSB9O1xyXG4gIH1cclxuXHJcbiAgLy8gVHJhaW4gdGltZSBzZXJpZXMgbW9kZWwgKE1vdmluZyBBdmVyYWdlICsgVHJlbmQpXHJcbiAgYXN5bmMgdHJhaW5UaW1lU2VyaWVzTW9kZWwodHJhaW5TZXQsIG5vcm1hbGl6ZXJzKSB7XHJcbiAgICAvLyBTaW1wbGlmaWVkIHRpbWUgc2VyaWVzIG1vZGVsIHVzaW5nIG1vdmluZyBhdmVyYWdlc1xyXG4gICAgY29uc3Qgd2luZG93U2l6ZXMgPSBbMywgNSwgMTAsIDIwXTtcclxuICAgIGNvbnN0IHdlaWdodHMgPSBuZXcgTWFwKCk7XHJcbiAgICBjb25zdCBiaWFzZXMgPSBuZXcgTWFwKCk7XHJcblxyXG4gICAgLy8gQ2FsY3VsYXRlIHdlaWdodHMgZm9yIGRpZmZlcmVudCB3aW5kb3cgc2l6ZXNcclxuICAgIGxldCB0b3RhbEVycm9yID0gMDtcclxuICAgIGxldCBzYW1wbGVDb3VudCA9IDA7XHJcblxyXG4gICAgZm9yIChjb25zdCB3aW5kb3dTaXplIG9mIHdpbmRvd1NpemVzKSB7XHJcbiAgICAgIGxldCB3aW5kb3dFcnJvciA9IDA7XHJcbiAgICAgIGxldCB3aW5kb3dTYW1wbGVzID0gMDtcclxuXHJcbiAgICAgIGZvciAobGV0IGkgPSB3aW5kb3dTaXplOyBpIDwgdHJhaW5TZXQubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBoaXN0b3JpY2FsVmFsdWVzID0gdHJhaW5TZXQuc2xpY2UoaSAtIHdpbmRvd1NpemUsIGkpLm1hcCgocykgPT4gcy50YXJnZXQpO1xyXG4gICAgICAgIGNvbnN0IG1vdmluZ0F2ZXJhZ2UgPSBoaXN0b3JpY2FsVmFsdWVzLnJlZHVjZSgoYSwgYikgPT4gYSArIGIsIDApIC8gd2luZG93U2l6ZTtcclxuXHJcbiAgICAgICAgY29uc3QgYWN0dWFsVmFsdWUgPSB0cmFpblNldFtpXS50YXJnZXQ7XHJcbiAgICAgICAgY29uc3QgZXJyb3IgPSBNYXRoLmFicyhhY3R1YWxWYWx1ZSAtIG1vdmluZ0F2ZXJhZ2UpO1xyXG5cclxuICAgICAgICB3aW5kb3dFcnJvciArPSBlcnJvcjtcclxuICAgICAgICB3aW5kb3dTYW1wbGVzKys7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IGF2Z0Vycm9yID0gd2luZG93U2FtcGxlcyA+IDAgPyB3aW5kb3dFcnJvciAvIHdpbmRvd1NhbXBsZXMgOiBJbmZpbml0eTtcclxuICAgICAgd2VpZ2h0cy5zZXQoYHdpbmRvd18ke3dpbmRvd1NpemV9YCwgMSAvICgxICsgYXZnRXJyb3IpKTtcclxuXHJcbiAgICAgIHRvdGFsRXJyb3IgKz0gd2luZG93RXJyb3I7XHJcbiAgICAgIHNhbXBsZUNvdW50ICs9IHdpbmRvd1NhbXBsZXM7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gTm9ybWFsaXplIHdlaWdodHNcclxuICAgIGNvbnN0IHRvdGFsV2VpZ2h0ID0gQXJyYXkuZnJvbSh3ZWlnaHRzLnZhbHVlcygpKS5yZWR1Y2UoKGEsIGIpID0+IGEgKyBiLCAwKTtcclxuICAgIGZvciAoY29uc3QgW2tleSwgd2VpZ2h0XSBvZiB3ZWlnaHRzKSB7XHJcbiAgICAgIHdlaWdodHMuc2V0KGtleSwgd2VpZ2h0IC8gdG90YWxXZWlnaHQpO1xyXG4gICAgfVxyXG5cclxuICAgIGJpYXNlcy5zZXQoJ3RyZW5kX2ZhY3RvcicsIDAuMSk7IC8vIFNpbXBsZSB0cmVuZCBmYWN0b3JcclxuXHJcbiAgICByZXR1cm4geyB3ZWlnaHRzLCBiaWFzZXMgfTtcclxuICB9XHJcblxyXG4gIC8vIFZhbGlkYXRlIG1vZGVsIGFjY3VyYWN5XHJcbiAgYXN5bmMgdmFsaWRhdGVNb2RlbChtb2RlbEtleSwgdmFsaWRhdGlvblNldCkge1xyXG4gICAgY29uc3QgbW9kZWwgPSB0aGlzLnByZWRpY3Rpb25Nb2RlbHMuZ2V0KG1vZGVsS2V5KTtcclxuICAgIGlmICghdmFsaWRhdGlvblNldCB8fCB2YWxpZGF0aW9uU2V0Lmxlbmd0aCA9PT0gMCkgcmV0dXJuIDA7XHJcblxyXG4gICAgbGV0IGNvcnJlY3RQcmVkaWN0aW9ucyA9IDA7XHJcbiAgICBsZXQgdG90YWxFcnJvciA9IDA7XHJcblxyXG4gICAgZm9yIChjb25zdCBzYW1wbGUgb2YgdmFsaWRhdGlvblNldCkge1xyXG4gICAgICBjb25zdCBwcmVkaWN0aW9uID0gYXdhaXQgdGhpcy5tYWtlU2luZ2xlUHJlZGljdGlvbihtb2RlbEtleSwgc2FtcGxlLmZlYXR1cmVzKTtcclxuXHJcbiAgICAgIGlmIChtb2RlbC50eXBlID09PSAnY2xhc3NpZmljYXRpb24nKSB7XHJcbiAgICAgICAgLy8gRm9yIGNsYXNzaWZpY2F0aW9uLCBjaGVjayBpZiBwcmVkaWN0aW9uIG1hdGNoZXMgdGFyZ2V0XHJcbiAgICAgICAgaWYgKHByZWRpY3Rpb24udmFsdWUgPT09IHNhbXBsZS50YXJnZXQpIHtcclxuICAgICAgICAgIGNvcnJlY3RQcmVkaWN0aW9ucysrO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBGb3IgcmVncmVzc2lvbiwgY2FsY3VsYXRlIG1lYW4gYWJzb2x1dGUgZXJyb3JcclxuICAgICAgICBjb25zdCBlcnJvciA9IE1hdGguYWJzKHByZWRpY3Rpb24udmFsdWUgLSBzYW1wbGUudGFyZ2V0KTtcclxuICAgICAgICB0b3RhbEVycm9yICs9IGVycm9yO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKG1vZGVsLnR5cGUgPT09ICdjbGFzc2lmaWNhdGlvbicpIHtcclxuICAgICAgcmV0dXJuIGNvcnJlY3RQcmVkaWN0aW9ucyAvIHZhbGlkYXRpb25TZXQubGVuZ3RoO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy8gQ29udmVydCBNQUUgdG8gYWNjdXJhY3kgc2NvcmUgKGludmVyc2UgcmVsYXRpb25zaGlwKVxyXG4gICAgICBjb25zdCBtYWUgPSB0b3RhbEVycm9yIC8gdmFsaWRhdGlvblNldC5sZW5ndGg7XHJcbiAgICAgIHJldHVybiBNYXRoLm1heCgwLCAxIC0gbWFlIC8gMTAwKTsgLy8gTm9ybWFsaXplIHRvIDAtMSByYW5nZVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gTWFrZSBzaW5nbGUgcHJlZGljdGlvblxyXG4gIGFzeW5jIG1ha2VTaW5nbGVQcmVkaWN0aW9uKG1vZGVsS2V5LCBmZWF0dXJlcykge1xyXG4gICAgY29uc3QgbW9kZWwgPSB0aGlzLnByZWRpY3Rpb25Nb2RlbHMuZ2V0KG1vZGVsS2V5KTtcclxuXHJcbiAgICBpZiAoIW1vZGVsLmlzUmVhZHkpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBNb2RlbCAke21vZGVsS2V5fSBpcyBub3QgcmVhZHkgZm9yIHByZWRpY3Rpb25zYCk7XHJcbiAgICB9XHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgLy8gTm9ybWFsaXplIGZlYXR1cmVzXHJcbiAgICAgIGNvbnN0IG5vcm1hbGl6ZWRGZWF0dXJlcyA9IHRoaXMubm9ybWFsaXplRmVhdHVyZXMoZmVhdHVyZXMsIG1vZGVsLm5vcm1hbGl6ZXJzKTtcclxuXHJcbiAgICAgIC8vIE1ha2UgcHJlZGljdGlvbiBiYXNlZCBvbiBtb2RlbCB0eXBlXHJcbiAgICAgIGxldCBwcmVkaWN0aW9uO1xyXG4gICAgICBzd2l0Y2ggKG1vZGVsLnR5cGUpIHtcclxuICAgICAgICBjYXNlICdyZWdyZXNzaW9uJzpcclxuICAgICAgICAgIHByZWRpY3Rpb24gPSBhd2FpdCB0aGlzLnByZWRpY3RSZWdyZXNzaW9uKG1vZGVsLCBub3JtYWxpemVkRmVhdHVyZXMpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAnY2xhc3NpZmljYXRpb24nOlxyXG4gICAgICAgICAgcHJlZGljdGlvbiA9IGF3YWl0IHRoaXMucHJlZGljdENsYXNzaWZpY2F0aW9uKG1vZGVsLCBub3JtYWxpemVkRmVhdHVyZXMpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAndGltZV9zZXJpZXMnOlxyXG4gICAgICAgICAgcHJlZGljdGlvbiA9IGF3YWl0IHRoaXMucHJlZGljdFRpbWVTZXJpZXMobW9kZWwsIG5vcm1hbGl6ZWRGZWF0dXJlcywgZmVhdHVyZXMpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBtb2RlbCB0eXBlOiAke21vZGVsLnR5cGV9YCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgdmFsdWU6IHByZWRpY3Rpb24udmFsdWUsXHJcbiAgICAgICAgY29uZmlkZW5jZTogcHJlZGljdGlvbi5jb25maWRlbmNlIHx8IDAuNSxcclxuICAgICAgICBtb2RlbEtleSxcclxuICAgICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXHJcbiAgICAgICAgZmVhdHVyZXM6IE9iamVjdC5rZXlzKGZlYXR1cmVzKSxcclxuICAgICAgfTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIG1ha2luZyBwcmVkaWN0aW9uIHdpdGggJHttb2RlbEtleX06YCwgZXJyb3IpO1xyXG4gICAgICB0aHJvdyBlcnJvcjtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIFByZWRpY3QgdXNpbmcgcmVncmVzc2lvbiBtb2RlbFxyXG4gIGFzeW5jIHByZWRpY3RSZWdyZXNzaW9uKG1vZGVsLCBub3JtYWxpemVkRmVhdHVyZXMpIHtcclxuICAgIGxldCBwcmVkaWN0aW9uID0gbW9kZWwuYmlhc2VzLmdldCgnYmlhcycpIHx8IDA7XHJcblxyXG4gICAgZm9yIChjb25zdCBbZmVhdHVyZU5hbWUsIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhub3JtYWxpemVkRmVhdHVyZXMpKSB7XHJcbiAgICAgIGNvbnN0IHdlaWdodCA9IG1vZGVsLndlaWdodHMuZ2V0KGZlYXR1cmVOYW1lKSB8fCAwO1xyXG4gICAgICBwcmVkaWN0aW9uICs9IHdlaWdodCAqIHZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIENhbGN1bGF0ZSBjb25maWRlbmNlIGJhc2VkIG9uIGZlYXR1cmUgaW1wb3J0YW5jZSBhbmQgbW9kZWwgYWNjdXJhY3lcclxuICAgIGNvbnN0IGNvbmZpZGVuY2UgPSBNYXRoLm1pbigwLjk1LCBtb2RlbC5hY2N1cmFjeSAqIDAuOCArIDAuMik7XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgdmFsdWU6IHByZWRpY3Rpb24sXHJcbiAgICAgIGNvbmZpZGVuY2UsXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgLy8gUHJlZGljdCB1c2luZyBjbGFzc2lmaWNhdGlvbiBtb2RlbFxyXG4gIGFzeW5jIHByZWRpY3RDbGFzc2lmaWNhdGlvbihtb2RlbCwgbm9ybWFsaXplZEZlYXR1cmVzKSB7XHJcbiAgICBpZiAobW9kZWwud2VpZ2h0cyBpbnN0YW5jZW9mIE1hcCAmJiBtb2RlbC53ZWlnaHRzLnNpemUgPiAxKSB7XHJcbiAgICAgIC8vIE11bHRpY2xhc3MgY2xhc3NpZmljYXRpb25cclxuICAgICAgY29uc3QgY2xhc3NTY29yZXMgPSBuZXcgTWFwKCk7XHJcblxyXG4gICAgICBmb3IgKGNvbnN0IFtjbGFzc05hbWUsIGNsYXNzV2VpZ2h0c10gb2YgbW9kZWwud2VpZ2h0cykge1xyXG4gICAgICAgIGxldCBzY29yZSA9IG1vZGVsLmJpYXNlcy5nZXQoY2xhc3NOYW1lKT8uZ2V0KCdiaWFzJykgfHwgMDtcclxuXHJcbiAgICAgICAgZm9yIChjb25zdCBbZmVhdHVyZU5hbWUsIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhub3JtYWxpemVkRmVhdHVyZXMpKSB7XHJcbiAgICAgICAgICBjb25zdCB3ZWlnaHQgPSBjbGFzc1dlaWdodHMuZ2V0KGZlYXR1cmVOYW1lKSB8fCAwO1xyXG4gICAgICAgICAgc2NvcmUgKz0gd2VpZ2h0ICogdmFsdWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBBcHBseSBzaWdtb2lkIGZvciBwcm9iYWJpbGl0eVxyXG4gICAgICAgIGNvbnN0IHByb2JhYmlsaXR5ID0gMSAvICgxICsgTWF0aC5leHAoLXNjb3JlKSk7XHJcbiAgICAgICAgY2xhc3NTY29yZXMuc2V0KGNsYXNzTmFtZSwgcHJvYmFiaWxpdHkpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBGaW5kIGNsYXNzIHdpdGggaGlnaGVzdCBwcm9iYWJpbGl0eVxyXG4gICAgICBjb25zdCBiZXN0Q2xhc3MgPSBBcnJheS5mcm9tKGNsYXNzU2NvcmVzLmVudHJpZXMoKSkucmVkdWNlKChhLCBiKSA9PiAoYVsxXSA+IGJbMV0gPyBhIDogYikpO1xyXG5cclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICB2YWx1ZTogYmVzdENsYXNzWzBdLFxyXG4gICAgICAgIGNvbmZpZGVuY2U6IGJlc3RDbGFzc1sxXSxcclxuICAgICAgICBwcm9iYWJpbGl0aWVzOiBPYmplY3QuZnJvbUVudHJpZXMoY2xhc3NTY29yZXMpLFxyXG4gICAgICB9O1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy8gQmluYXJ5IGNsYXNzaWZpY2F0aW9uXHJcbiAgICAgIGxldCBzY29yZSA9IG1vZGVsLmJpYXNlcy5nZXQoJ2JpYXMnKSB8fCAwO1xyXG5cclxuICAgICAgZm9yIChjb25zdCBbZmVhdHVyZU5hbWUsIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhub3JtYWxpemVkRmVhdHVyZXMpKSB7XHJcbiAgICAgICAgY29uc3Qgd2VpZ2h0ID0gbW9kZWwud2VpZ2h0cy5nZXQoZmVhdHVyZU5hbWUpIHx8IDA7XHJcbiAgICAgICAgc2NvcmUgKz0gd2VpZ2h0ICogdmFsdWU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IHByb2JhYmlsaXR5ID0gMSAvICgxICsgTWF0aC5leHAoLXNjb3JlKSk7XHJcblxyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIHZhbHVlOiBwcm9iYWJpbGl0eSA+IDAuNSA/IDEgOiAwLFxyXG4gICAgICAgIGNvbmZpZGVuY2U6IE1hdGguYWJzKHByb2JhYmlsaXR5IC0gMC41KSAqIDIsIC8vIENvbnZlcnQgdG8gMC0xIHJhbmdlXHJcbiAgICAgICAgcHJvYmFiaWxpdHksXHJcbiAgICAgIH07XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBQcmVkaWN0IHVzaW5nIHRpbWUgc2VyaWVzIG1vZGVsXHJcbiAgYXN5bmMgcHJlZGljdFRpbWVTZXJpZXMobW9kZWwsIG5vcm1hbGl6ZWRGZWF0dXJlcywgb3JpZ2luYWxGZWF0dXJlcykge1xyXG4gICAgbGV0IHByZWRpY3Rpb24gPSAwO1xyXG4gICAgbGV0IHRvdGFsV2VpZ2h0ID0gMDtcclxuXHJcbiAgICAvLyBVc2Ugd2VpZ2h0ZWQgbW92aW5nIGF2ZXJhZ2VzXHJcbiAgICBmb3IgKGNvbnN0IFt3ZWlnaHRLZXksIHdlaWdodF0gb2YgbW9kZWwud2VpZ2h0cykge1xyXG4gICAgICBpZiAod2VpZ2h0S2V5LnN0YXJ0c1dpdGgoJ3dpbmRvd18nKSkge1xyXG4gICAgICAgIGNvbnN0IHdpbmRvd1NpemUgPSBwYXJzZUludCh3ZWlnaHRLZXkuc3BsaXQoJ18nKVsxXSk7XHJcblxyXG4gICAgICAgIC8vIEZvciBzaW1wbGljaXR5LCB1c2UgY3VycmVudCB2YWx1ZSBhcyBiYXNlXHJcbiAgICAgICAgLy8gSW4gcHJvZHVjdGlvbiwgeW91J2QgdXNlIGFjdHVhbCBoaXN0b3JpY2FsIGRhdGFcclxuICAgICAgICBjb25zdCBjdXJyZW50VmFsdWUgPSBvcmlnaW5hbEZlYXR1cmVzLmhpc3RvcmljYWxHTVAgfHwgb3JpZ2luYWxGZWF0dXJlcy5jdXJyZW50VmFsdWUgfHwgMDtcclxuICAgICAgICBwcmVkaWN0aW9uICs9IHdlaWdodCAqIGN1cnJlbnRWYWx1ZTtcclxuICAgICAgICB0b3RhbFdlaWdodCArPSB3ZWlnaHQ7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBBcHBseSB0cmVuZCBmYWN0b3JcclxuICAgIGNvbnN0IHRyZW5kRmFjdG9yID0gbW9kZWwuYmlhc2VzLmdldCgndHJlbmRfZmFjdG9yJykgfHwgMDtcclxuICAgIHByZWRpY3Rpb24gKj0gMSArIHRyZW5kRmFjdG9yO1xyXG5cclxuICAgIGNvbnN0IGNvbmZpZGVuY2UgPSBNYXRoLm1pbigwLjksIG1vZGVsLmFjY3VyYWN5ICogMC43ICsgMC4zKTtcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB2YWx1ZTogcHJlZGljdGlvbixcclxuICAgICAgY29uZmlkZW5jZSxcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICAvLyBTdGFydCBwcmVkaWN0aW9uIHdvcmtmbG93c1xyXG4gIHN0YXJ0UHJlZGljdGlvbldvcmtmbG93cygpIHtcclxuICAgIC8vIFJlYWwtdGltZSBwcmVkaWN0aW9uIHVwZGF0ZXNcclxuICAgIGNvbnN0IHByZWRpY3Rpb25JbnRlcnZhbCA9IHNldEludGVydmFsKGFzeW5jICgpID0+IHtcclxuICAgICAgYXdhaXQgdGhpcy51cGRhdGVSZWFsVGltZVByZWRpY3Rpb25zKCk7XHJcbiAgICB9LCB0aGlzLnByZWRpY3Rpb25Db25maWcuVVBEQVRFX0lOVEVSVkFMKTtcclxuXHJcbiAgICB0aGlzLmFjdGl2ZUludGVydmFscy5zZXQoJ1BSRURJQ1RJT05TJywgcHJlZGljdGlvbkludGVydmFsKTtcclxuXHJcbiAgICBjb25zb2xlLmxvZygn8J+UriBTdGFydGVkIHByZWRpY3Rpb24gd29ya2Zsb3dzJyk7XHJcbiAgfVxyXG5cclxuICAvLyBVcGRhdGUgcmVhbC10aW1lIHByZWRpY3Rpb25zXHJcbiAgYXN5bmMgdXBkYXRlUmVhbFRpbWVQcmVkaWN0aW9ucygpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgIC8vIEdldCBhY3RpdmUgSVBPcyB0aGF0IG5lZWQgcHJlZGljdGlvbnNcclxuICAgICAgY29uc3QgYWN0aXZlSVBPcyA9IGF3YWl0IHByaXNtYS5pUE8uZmluZE1hbnkoe1xyXG4gICAgICAgIHdoZXJlOiB7XHJcbiAgICAgICAgICBpc0FjdGl2ZTogdHJ1ZSxcclxuICAgICAgICAgIHN0YXR1czogeyBpbjogWyd1cGNvbWluZycsICdvcGVuJywgJ2Nsb3NlZCddIH0sXHJcbiAgICAgICAgfSxcclxuICAgICAgICBpbmNsdWRlOiB7XHJcbiAgICAgICAgICBnbXA6IHsgb3JkZXJCeTogeyB0aW1lc3RhbXA6ICdkZXNjJyB9LCB0YWtlOiAyMCB9LFxyXG4gICAgICAgICAgc3Vic2NyaXB0aW9uOiB7IG9yZGVyQnk6IHsgdGltZXN0YW1wOiAnZGVzYycgfSwgdGFrZTogMjAgfSxcclxuICAgICAgICAgIGFuYWx5dGljczogdHJ1ZSxcclxuICAgICAgICB9LFxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGxldCBwcmVkaWN0aW9uc1VwZGF0ZWQgPSAwO1xyXG5cclxuICAgICAgZm9yIChjb25zdCBpcG8gb2YgYWN0aXZlSVBPcykge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAvLyBVcGRhdGUgcHJlZGljdGlvbnMgZm9yIGVhY2ggbW9kZWxcclxuICAgICAgICAgIGZvciAoY29uc3QgW21vZGVsS2V5LCBtb2RlbF0gb2YgdGhpcy5wcmVkaWN0aW9uTW9kZWxzKSB7XHJcbiAgICAgICAgICAgIGlmIChtb2RlbC5pc1JlYWR5ICYmIG1vZGVsLmVuYWJsZWQpIHtcclxuICAgICAgICAgICAgICBhd2FpdCB0aGlzLnVwZGF0ZUlQT1ByZWRpY3Rpb24obW9kZWxLZXksIGlwbyk7XHJcbiAgICAgICAgICAgICAgcHJlZGljdGlvbnNVcGRhdGVkKys7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgdXBkYXRpbmcgcHJlZGljdGlvbnMgZm9yIElQTyAke2lwby5zeW1ib2x9OmAsIGVycm9yKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnNvbGUubG9nKGDwn5SuIFVwZGF0ZWQgJHtwcmVkaWN0aW9uc1VwZGF0ZWR9IHByZWRpY3Rpb25zIGZvciAke2FjdGl2ZUlQT3MubGVuZ3RofSBJUE9zYCk7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciB1cGRhdGluZyByZWFsLXRpbWUgcHJlZGljdGlvbnM6JywgZXJyb3IpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gVXBkYXRlIHByZWRpY3Rpb24gZm9yIHNwZWNpZmljIElQTyBhbmQgbW9kZWxcclxuICBhc3luYyB1cGRhdGVJUE9QcmVkaWN0aW9uKG1vZGVsS2V5LCBpcG8pIHtcclxuICAgIHRyeSB7XHJcbiAgICAgIC8vIENoZWNrIGNhY2hlIGZpcnN0XHJcbiAgICAgIGNvbnN0IGNhY2hlS2V5ID0gYHByZWRpY3Rpb246JHttb2RlbEtleX06JHtpcG8uaWR9YDtcclxuICAgICAgY29uc3QgY2FjaGVkID0gdGhpcy5wcmVkaWN0aW9uQ2FjaGUuZ2V0KGNhY2hlS2V5KTtcclxuXHJcbiAgICAgIGlmIChjYWNoZWQgJiYgRGF0ZS5ub3coKSAtIGNhY2hlZC50aW1lc3RhbXAgPCB0aGlzLmNhY2hlVFRMW21vZGVsS2V5XSkge1xyXG4gICAgICAgIHJldHVybiBjYWNoZWQucHJlZGljdGlvbjtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gRXh0cmFjdCBmZWF0dXJlcyBmb3IgY3VycmVudCBJUE9cclxuICAgICAgY29uc3QgZmVhdHVyZXMgPSBhd2FpdCB0aGlzLmV4dHJhY3RGZWF0dXJlcyhtb2RlbEtleSwgaXBvKTtcclxuICAgICAgaWYgKCFmZWF0dXJlcykgcmV0dXJuIG51bGw7XHJcblxyXG4gICAgICAvLyBNYWtlIHByZWRpY3Rpb25cclxuICAgICAgY29uc3QgcHJlZGljdGlvbiA9IGF3YWl0IHRoaXMubWFrZVNpbmdsZVByZWRpY3Rpb24obW9kZWxLZXksIGZlYXR1cmVzKTtcclxuXHJcbiAgICAgIC8vIENhY2hlIHByZWRpY3Rpb25cclxuICAgICAgdGhpcy5wcmVkaWN0aW9uQ2FjaGUuc2V0KGNhY2hlS2V5LCB7XHJcbiAgICAgICAgcHJlZGljdGlvbixcclxuICAgICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgLy8gU3RvcmUgcHJlZGljdGlvbiBpbiBkYXRhYmFzZVxyXG4gICAgICBhd2FpdCB0aGlzLnN0b3JlUHJlZGljdGlvbihpcG8uaWQsIG1vZGVsS2V5LCBwcmVkaWN0aW9uKTtcclxuXHJcbiAgICAgIC8vIEJyb2FkY2FzdCBwcmVkaWN0aW9uIHVwZGF0ZVxyXG4gICAgICBhd2FpdCB0aGlzLmJyb2FkY2FzdFByZWRpY3Rpb25VcGRhdGUoaXBvLCBtb2RlbEtleSwgcHJlZGljdGlvbik7XHJcblxyXG4gICAgICByZXR1cm4gcHJlZGljdGlvbjtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIHVwZGF0aW5nIHByZWRpY3Rpb24gZm9yICR7bW9kZWxLZXl9OmAsIGVycm9yKTtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBTdG9yZSBwcmVkaWN0aW9uIGluIGRhdGFiYXNlXHJcbiAgYXN5bmMgc3RvcmVQcmVkaWN0aW9uKGlwb0lkLCBtb2RlbEtleSwgcHJlZGljdGlvbikge1xyXG4gICAgdHJ5IHtcclxuICAgICAgYXdhaXQgcHJpc21hLnByZWRpY3Rpb24udXBzZXJ0KHtcclxuICAgICAgICB3aGVyZToge1xyXG4gICAgICAgICAgaXBvSWRfbW9kZWxUeXBlOiB7XHJcbiAgICAgICAgICAgIGlwb0lkLFxyXG4gICAgICAgICAgICBtb2RlbFR5cGU6IG1vZGVsS2V5LFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICB9LFxyXG4gICAgICAgIHVwZGF0ZToge1xyXG4gICAgICAgICAgcHJlZGljdGVkVmFsdWU6IHByZWRpY3Rpb24udmFsdWUsXHJcbiAgICAgICAgICBjb25maWRlbmNlOiBwcmVkaWN0aW9uLmNvbmZpZGVuY2UsXHJcbiAgICAgICAgICBmZWF0dXJlczogSlNPTi5zdHJpbmdpZnkocHJlZGljdGlvbi5mZWF0dXJlcyksXHJcbiAgICAgICAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKCksXHJcbiAgICAgICAgfSxcclxuICAgICAgICBjcmVhdGU6IHtcclxuICAgICAgICAgIGlwb0lkLFxyXG4gICAgICAgICAgbW9kZWxUeXBlOiBtb2RlbEtleSxcclxuICAgICAgICAgIHByZWRpY3RlZFZhbHVlOiBwcmVkaWN0aW9uLnZhbHVlLFxyXG4gICAgICAgICAgY29uZmlkZW5jZTogcHJlZGljdGlvbi5jb25maWRlbmNlLFxyXG4gICAgICAgICAgZmVhdHVyZXM6IEpTT04uc3RyaW5naWZ5KHByZWRpY3Rpb24uZmVhdHVyZXMpLFxyXG4gICAgICAgICAgY3JlYXRlZEF0OiBuZXcgRGF0ZSgpLFxyXG4gICAgICAgIH0sXHJcbiAgICAgIH0pO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3Igc3RvcmluZyBwcmVkaWN0aW9uOicsIGVycm9yKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIEJyb2FkY2FzdCBwcmVkaWN0aW9uIHVwZGF0ZSB2aWEgV2ViU29ja2V0XHJcbiAgYXN5bmMgYnJvYWRjYXN0UHJlZGljdGlvblVwZGF0ZShpcG8sIG1vZGVsS2V5LCBwcmVkaWN0aW9uKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCB1cGRhdGVEYXRhID0ge1xyXG4gICAgICAgIGlwb0lkOiBpcG8uaWQsXHJcbiAgICAgICAgc3ltYm9sOiBpcG8uc3ltYm9sLFxyXG4gICAgICAgIG1vZGVsVHlwZTogbW9kZWxLZXksXHJcbiAgICAgICAgcHJlZGljdGlvbjogcHJlZGljdGlvbi52YWx1ZSxcclxuICAgICAgICBjb25maWRlbmNlOiBwcmVkaWN0aW9uLmNvbmZpZGVuY2UsXHJcbiAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxyXG4gICAgICAgIGZlYXR1cmVzOiBwcmVkaWN0aW9uLmZlYXR1cmVzLFxyXG4gICAgICB9O1xyXG5cclxuICAgICAgYXdhaXQgd2ViU29ja2V0U2VydmljZS5icm9hZGNhc3RBbmFseXRpY3NVcGRhdGUoaXBvLmlkLCB7XHJcbiAgICAgICAgcHJlZGljdGlvbnM6IHsgW21vZGVsS2V5XTogdXBkYXRlRGF0YSB9LFxyXG4gICAgICAgIHR5cGU6ICdwcmVkaWN0aW9uX3VwZGF0ZScsXHJcbiAgICAgIH0pO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgYnJvYWRjYXN0aW5nIHByZWRpY3Rpb24gdXBkYXRlOicsIGVycm9yKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIFB1YmxpYyBBUEkgbWV0aG9kc1xyXG4gIGFzeW5jIHByZWRpY3RMaXN0aW5nR2FpbihpcG9JZCkge1xyXG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuZ2V0UHJlZGljdGlvbihpcG9JZCwgJ0xJU1RJTkdfR0FJTicpO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgcHJlZGljdEFsbG90bWVudFByb2JhYmlsaXR5KHVzZXJJZCwgaXBvSWQsIGFwcGxpY2F0aW9uRGF0YSkge1xyXG4gICAgY29uc3QgZmVhdHVyZXMgPSB7XHJcbiAgICAgIC4uLmFwcGxpY2F0aW9uRGF0YSxcclxuICAgICAgdXNlckhpc3Rvcnk6IGF3YWl0IHRoaXMuZ2V0VXNlckhpc3RvcnkodXNlcklkKSxcclxuICAgICAgYXBwbGljYXRpb25UaW1lOiBEYXRlLm5vdygpLFxyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5tYWtlU2luZ2xlUHJlZGljdGlvbignQUxMT1RNRU5UX1BST0JBQklMSVRZJywgZmVhdHVyZXMpO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgcHJlZGljdFN1YnNjcmlwdGlvblRyZW5kKGlwb0lkKSB7XHJcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5nZXRQcmVkaWN0aW9uKGlwb0lkLCAnU1VCU0NSSVBUSU9OX1RSRU5EJyk7XHJcbiAgfVxyXG5cclxuICBhc3luYyBwcmVkaWN0R01QUHJpY2UoaXBvSWQsIGhvcml6b24gPSAxKSB7XHJcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5nZXRQcmVkaWN0aW9uKGlwb0lkLCAnR01QX1BSRURJQ1RJT04nKTtcclxuICB9XHJcblxyXG4gIGFzeW5jIHByZWRpY3RNYXJrZXRTZW50aW1lbnQoaXBvSWQpIHtcclxuICAgIHJldHVybiBhd2FpdCB0aGlzLmdldFByZWRpY3Rpb24oaXBvSWQsICdNQVJLRVRfU0VOVElNRU5UJyk7XHJcbiAgfVxyXG5cclxuICBhc3luYyBwcmVkaWN0SVBPU3VjY2VzcyhpcG9JZCkge1xyXG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuZ2V0UHJlZGljdGlvbihpcG9JZCwgJ0lQT19TVUNDRVNTJyk7XHJcbiAgfVxyXG5cclxuICAvLyBHZXQgZW5zZW1ibGUgcHJlZGljdGlvbiBjb21iaW5pbmcgbXVsdGlwbGUgbW9kZWxzXHJcbiAgYXN5bmMgZ2V0RW5zZW1ibGVQcmVkaWN0aW9uKGlwb0lkLCBwcmVkaWN0aW9uVHlwZSkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgcmVsZXZhbnRNb2RlbHMgPSB0aGlzLmdldFJlbGV2YW50TW9kZWxzKHByZWRpY3Rpb25UeXBlKTtcclxuICAgICAgY29uc3QgcHJlZGljdGlvbnMgPSBbXTtcclxuICAgICAgbGV0IHRvdGFsV2VpZ2h0ID0gMDtcclxuXHJcbiAgICAgIGZvciAoY29uc3QgbW9kZWxLZXkgb2YgcmVsZXZhbnRNb2RlbHMpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgY29uc3QgcHJlZGljdGlvbiA9IGF3YWl0IHRoaXMuZ2V0UHJlZGljdGlvbihpcG9JZCwgbW9kZWxLZXkpO1xyXG4gICAgICAgICAgaWYgKHByZWRpY3Rpb24gJiYgcHJlZGljdGlvbi5jb25maWRlbmNlID4gdGhpcy5wcmVkaWN0aW9uQ29uZmlnLkNPTkZJREVOQ0VfVEhSRVNIT0xEKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHdlaWdodCA9IHRoaXMuZW5zZW1ibGVXZWlnaHRzLmdldChtb2RlbEtleSkgKiBwcmVkaWN0aW9uLmNvbmZpZGVuY2U7XHJcbiAgICAgICAgICAgIHByZWRpY3Rpb25zLnB1c2goeyBwcmVkaWN0aW9uLCB3ZWlnaHQgfSk7XHJcbiAgICAgICAgICAgIHRvdGFsV2VpZ2h0ICs9IHdlaWdodDtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgY29uc29sZS53YXJuKGBNb2RlbCAke21vZGVsS2V5fSBmYWlsZWQ6YCwgZXJyb3IubWVzc2FnZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAocHJlZGljdGlvbnMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyB2YWxpZCBwcmVkaWN0aW9ucyBhdmFpbGFibGUnKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQ2FsY3VsYXRlIHdlaWdodGVkIGF2ZXJhZ2VcclxuICAgICAgbGV0IGVuc2VtYmxlVmFsdWUgPSAwO1xyXG4gICAgICBsZXQgZW5zZW1ibGVDb25maWRlbmNlID0gMDtcclxuXHJcbiAgICAgIGZvciAoY29uc3QgeyBwcmVkaWN0aW9uLCB3ZWlnaHQgfSBvZiBwcmVkaWN0aW9ucykge1xyXG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRXZWlnaHQgPSB3ZWlnaHQgLyB0b3RhbFdlaWdodDtcclxuICAgICAgICBlbnNlbWJsZVZhbHVlICs9IHByZWRpY3Rpb24udmFsdWUgKiBub3JtYWxpemVkV2VpZ2h0O1xyXG4gICAgICAgIGVuc2VtYmxlQ29uZmlkZW5jZSArPSBwcmVkaWN0aW9uLmNvbmZpZGVuY2UgKiBub3JtYWxpemVkV2VpZ2h0O1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIHZhbHVlOiBlbnNlbWJsZVZhbHVlLFxyXG4gICAgICAgIGNvbmZpZGVuY2U6IGVuc2VtYmxlQ29uZmlkZW5jZSxcclxuICAgICAgICBtb2RlbENvdW50OiBwcmVkaWN0aW9ucy5sZW5ndGgsXHJcbiAgICAgICAgbW9kZWxzOiBwcmVkaWN0aW9ucy5tYXAoKHApID0+IHAucHJlZGljdGlvbi5tb2RlbEtleSksXHJcbiAgICAgICAgZW5zZW1ibGU6IHRydWUsXHJcbiAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxyXG4gICAgICB9O1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZ2V0dGluZyBlbnNlbWJsZSBwcmVkaWN0aW9uOicsIGVycm9yKTtcclxuICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBHZXQgcHJlZGljdGlvbiBmcm9tIGNhY2hlIG9yIGdlbmVyYXRlIG5ldyBvbmVcclxuICBhc3luYyBnZXRQcmVkaWN0aW9uKGlwb0lkLCBtb2RlbEtleSkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgY2FjaGVLZXkgPSBgcHJlZGljdGlvbjoke21vZGVsS2V5fToke2lwb0lkfWA7XHJcbiAgICAgIGNvbnN0IGNhY2hlZCA9IHRoaXMucHJlZGljdGlvbkNhY2hlLmdldChjYWNoZUtleSk7XHJcblxyXG4gICAgICBpZiAoY2FjaGVkICYmIERhdGUubm93KCkgLSBjYWNoZWQudGltZXN0YW1wIDwgdGhpcy5jYWNoZVRUTFttb2RlbEtleV0pIHtcclxuICAgICAgICByZXR1cm4gY2FjaGVkLnByZWRpY3Rpb247XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIEdldCBJUE8gZGF0YVxyXG4gICAgICBjb25zdCBpcG8gPSBhd2FpdCBwcmlzbWEuaVBPLmZpbmRVbmlxdWUoe1xyXG4gICAgICAgIHdoZXJlOiB7IGlkOiBpcG9JZCB9LFxyXG4gICAgICAgIGluY2x1ZGU6IHtcclxuICAgICAgICAgIGdtcDogeyBvcmRlckJ5OiB7IHRpbWVzdGFtcDogJ2Rlc2MnIH0sIHRha2U6IDIwIH0sXHJcbiAgICAgICAgICBzdWJzY3JpcHRpb246IHsgb3JkZXJCeTogeyB0aW1lc3RhbXA6ICdkZXNjJyB9LCB0YWtlOiAyMCB9LFxyXG4gICAgICAgICAgYW5hbHl0aWNzOiB0cnVlLFxyXG4gICAgICAgIH0sXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgaWYgKCFpcG8pIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYElQTyBub3QgZm91bmQ6ICR7aXBvSWR9YCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLnVwZGF0ZUlQT1ByZWRpY3Rpb24obW9kZWxLZXksIGlwbyk7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBnZXR0aW5nIHByZWRpY3Rpb24gZm9yICR7bW9kZWxLZXl9OmAsIGVycm9yKTtcclxuICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBIZWxwZXIgbWV0aG9kc1xyXG4gIGNhbGN1bGF0ZU5vcm1hbGl6ZXJzKHRyYWluU2V0KSB7XHJcbiAgICBjb25zdCBub3JtYWxpemVycyA9IG5ldyBNYXAoKTtcclxuICAgIGNvbnN0IGZlYXR1cmVOYW1lcyA9IE9iamVjdC5rZXlzKHRyYWluU2V0WzBdLmZlYXR1cmVzKTtcclxuXHJcbiAgICBmb3IgKGNvbnN0IGZlYXR1cmVOYW1lIG9mIGZlYXR1cmVOYW1lcykge1xyXG4gICAgICBjb25zdCB2YWx1ZXMgPSB0cmFpblNldFxyXG4gICAgICAgIC5tYXAoKHNhbXBsZSkgPT4gc2FtcGxlLmZlYXR1cmVzW2ZlYXR1cmVOYW1lXSlcclxuICAgICAgICAuZmlsdGVyKCh2KSA9PiB2ICE9PSBudWxsICYmIHYgIT09IHVuZGVmaW5lZCk7XHJcblxyXG4gICAgICBpZiAodmFsdWVzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICBjb25zdCBtaW4gPSBNYXRoLm1pbiguLi52YWx1ZXMpO1xyXG4gICAgICAgIGNvbnN0IG1heCA9IE1hdGgubWF4KC4uLnZhbHVlcyk7XHJcbiAgICAgICAgY29uc3QgbWVhbiA9IHZhbHVlcy5yZWR1Y2UoKGEsIGIpID0+IGEgKyBiLCAwKSAvIHZhbHVlcy5sZW5ndGg7XHJcbiAgICAgICAgY29uc3Qgc3RkID0gTWF0aC5zcXJ0KFxyXG4gICAgICAgICAgdmFsdWVzLnJlZHVjZSgoc3VtLCB2YWwpID0+IHN1bSArIE1hdGgucG93KHZhbCAtIG1lYW4sIDIpLCAwKSAvIHZhbHVlcy5sZW5ndGhcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICBub3JtYWxpemVycy5zZXQoZmVhdHVyZU5hbWUsIHsgbWluLCBtYXgsIG1lYW4sIHN0ZCB9KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBub3JtYWxpemVycztcclxuICB9XHJcblxyXG4gIG5vcm1hbGl6ZUZlYXR1cmVzKGZlYXR1cmVzLCBub3JtYWxpemVycykge1xyXG4gICAgY29uc3Qgbm9ybWFsaXplZCA9IHt9O1xyXG5cclxuICAgIGZvciAoY29uc3QgW2ZlYXR1cmVOYW1lLCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoZmVhdHVyZXMpKSB7XHJcbiAgICAgIGNvbnN0IG5vcm0gPSBub3JtYWxpemVycy5nZXQoZmVhdHVyZU5hbWUpO1xyXG4gICAgICBpZiAobm9ybSAmJiB2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgLy8gWi1zY29yZSBub3JtYWxpemF0aW9uXHJcbiAgICAgICAgbm9ybWFsaXplZFtmZWF0dXJlTmFtZV0gPSBub3JtLnN0ZCA+IDAgPyAodmFsdWUgLSBub3JtLm1lYW4pIC8gbm9ybS5zdGQgOiAwO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIG5vcm1hbGl6ZWRbZmVhdHVyZU5hbWVdID0gMDtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBub3JtYWxpemVkO1xyXG4gIH1cclxuXHJcbiAgZXh0cmFjdEJhc2ljRmVhdHVyZShmZWF0dXJlTmFtZSwgaXBvKSB7XHJcbiAgICBzd2l0Y2ggKGZlYXR1cmVOYW1lKSB7XHJcbiAgICAgIGNhc2UgJ2xvdFNpemUnOlxyXG4gICAgICAgIHJldHVybiBpcG8ubG90U2l6ZSB8fCAwO1xyXG4gICAgICBjYXNlICdmYWNlVmFsdWUnOlxyXG4gICAgICAgIHJldHVybiBpcG8uZmFjZVZhbHVlIHx8IDA7XHJcbiAgICAgIGNhc2UgJ21pblByaWNlJzpcclxuICAgICAgICByZXR1cm4gaXBvLm1pblByaWNlIHx8IDA7XHJcbiAgICAgIGNhc2UgJ21heFByaWNlJzpcclxuICAgICAgICByZXR1cm4gaXBvLm1heFByaWNlIHx8IDA7XHJcbiAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBUYXJnZXQgZXh0cmFjdGlvbiBtZXRob2RzXHJcbiAgY2FsY3VsYXRlTGlzdGluZ0dhaW4oaXBvKSB7XHJcbiAgICBpZiAoIWlwby5saXN0aW5nUHJpY2UgfHwgIWlwby5tYXhQcmljZSkgcmV0dXJuIG51bGw7XHJcbiAgICByZXR1cm4gKChpcG8ubGlzdGluZ1ByaWNlIC0gaXBvLm1heFByaWNlKSAvIGlwby5tYXhQcmljZSkgKiAxMDA7XHJcbiAgfVxyXG5cclxuICBnZXRBbGxvdG1lbnRTdGF0dXMoaXBvKSB7XHJcbiAgICAvLyBUaGlzIHdvdWxkIGNvbWUgZnJvbSBhY3R1YWwgYWxsb3RtZW50IGRhdGFcclxuICAgIHJldHVybiBNYXRoLnJhbmRvbSgpID4gMC4zID8gJ2FsbG90dGVkJyA6ICdub3RfYWxsb3R0ZWQnO1xyXG4gIH1cclxuXHJcbiAgZ2V0RmluYWxTdWJzY3JpcHRpb25SYXRpbyhpcG8pIHtcclxuICAgIGNvbnN0IGZpbmFsU3ViID1cclxuICAgICAgaXBvLnN1YnNjcmlwdGlvbj8uZmluZCgocykgPT4gcy5jYXRlZ29yeSA9PT0gJ09WRVJBTEwnKSB8fCBpcG8uc3Vic2NyaXB0aW9uPy5bMF07XHJcbiAgICByZXR1cm4gZmluYWxTdWI/LnN1YnNjcmlwdGlvblJhdGlvIHx8IDA7XHJcbiAgfVxyXG5cclxuICBnZXROZXh0R01QVmFsdWUoaXBvKSB7XHJcbiAgICBjb25zdCBnbXBWYWx1ZXMgPSBpcG8uZ21wPy5tYXAoKGcpID0+IGcudmFsdWUpIHx8IFtdO1xyXG4gICAgcmV0dXJuIGdtcFZhbHVlcy5sZW5ndGggPiAwID8gZ21wVmFsdWVzWzBdIDogMDtcclxuICB9XHJcblxyXG4gIGdldFNlbnRpbWVudFNjb3JlKGlwbykge1xyXG4gICAgLy8gTW9jayBzZW50aW1lbnQgLSBpbiBwcm9kdWN0aW9uLCBhbmFseXplIG5ld3Mvc29jaWFsIG1lZGlhXHJcbiAgICByZXR1cm4gTWF0aC5yYW5kb20oKSAqIDIgLSAxOyAvLyAtMSB0byAxXHJcbiAgfVxyXG5cclxuICBnZXRJUE9TdWNjZXNzQ2F0ZWdvcnkoaXBvKSB7XHJcbiAgICBjb25zdCBnYWluID0gdGhpcy5jYWxjdWxhdGVMaXN0aW5nR2FpbihpcG8pO1xyXG4gICAgaWYgKGdhaW4gPT09IG51bGwpIHJldHVybiAndW5rbm93bic7XHJcbiAgICBpZiAoZ2FpbiA+IDIwKSByZXR1cm4gJ2hpZ2hseV9zdWNjZXNzZnVsJztcclxuICAgIGlmIChnYWluID4gMCkgcmV0dXJuICdzdWNjZXNzZnVsJztcclxuICAgIHJldHVybiAndW5zdWNjZXNzZnVsJztcclxuICB9XHJcblxyXG4gIHZhbGlkYXRlVHJhaW5pbmdEYXRhKHRyYWluaW5nU2V0LCBtb2RlbCkge1xyXG4gICAgcmV0dXJuIHRyYWluaW5nU2V0LmZpbHRlcigoc2FtcGxlKSA9PiB7XHJcbiAgICAgIC8vIFJlbW92ZSBzYW1wbGVzIHdpdGggbWlzc2luZyBjcml0aWNhbCBmZWF0dXJlc1xyXG4gICAgICBjb25zdCBmZWF0dXJlcyA9IHNhbXBsZS5mZWF0dXJlcztcclxuICAgICAgY29uc3QgcmVxdWlyZWRGZWF0dXJlcyA9IG1vZGVsLmZlYXR1cmVzLnNsaWNlKDAsIDUpOyAvLyBUb3AgNSBjcml0aWNhbCBmZWF0dXJlc1xyXG5cclxuICAgICAgcmV0dXJuIHJlcXVpcmVkRmVhdHVyZXMuZXZlcnkoXHJcbiAgICAgICAgKGZlYXR1cmUpID0+XHJcbiAgICAgICAgICBmZWF0dXJlc1tmZWF0dXJlXSAhPT0gbnVsbCAmJiBmZWF0dXJlc1tmZWF0dXJlXSAhPT0gdW5kZWZpbmVkICYmICFpc05hTihmZWF0dXJlc1tmZWF0dXJlXSlcclxuICAgICAgKTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgZ2V0UmVsZXZhbnRNb2RlbHMocHJlZGljdGlvblR5cGUpIHtcclxuICAgIGNvbnN0IG1vZGVsR3JvdXBzID0ge1xyXG4gICAgICBsaXN0aW5nX3BlcmZvcm1hbmNlOiBbJ0xJU1RJTkdfR0FJTicsICdHTVBfUFJFRElDVElPTicsICdNQVJLRVRfU0VOVElNRU5UJ10sXHJcbiAgICAgIHN1YnNjcmlwdGlvbl9hbmFseXNpczogWydTVUJTQ1JJUFRJT05fVFJFTkQnLCAnTUFSS0VUX1NFTlRJTUVOVCddLFxyXG4gICAgICBhbGxvdG1lbnRfY2hhbmNlczogWydBTExPVE1FTlRfUFJPQkFCSUxJVFknLCAnU1VCU0NSSVBUSU9OX1RSRU5EJ10sXHJcbiAgICAgIG92ZXJhbGxfc3VjY2VzczogWydJUE9fU1VDQ0VTUycsICdMSVNUSU5HX0dBSU4nLCAnTUFSS0VUX1NFTlRJTUVOVCddLFxyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gbW9kZWxHcm91cHNbcHJlZGljdGlvblR5cGVdIHx8IFtwcmVkaWN0aW9uVHlwZV07XHJcbiAgfVxyXG5cclxuICBhc3luYyBnZXRVc2VySGlzdG9yeSh1c2VySWQpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IGFwcGxpY2F0aW9ucyA9IGF3YWl0IHByaXNtYS51c2VyQXBwbGljYXRpb24uZmluZE1hbnkoe1xyXG4gICAgICAgIHdoZXJlOiB7IHVzZXJJZCB9LFxyXG4gICAgICAgIGluY2x1ZGU6IHsgaXBvOiB0cnVlIH0sXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICB0b3RhbEFwcGxpY2F0aW9uczogYXBwbGljYXRpb25zLmxlbmd0aCxcclxuICAgICAgICBhbGxvdHRlZENvdW50OiBhcHBsaWNhdGlvbnMuZmlsdGVyKChhKSA9PiBhLmFsbG90bWVudFN0YXR1cyA9PT0gJ2FsbG90dGVkJykubGVuZ3RoLFxyXG4gICAgICAgIGF2ZXJhZ2VBbW91bnQ6XHJcbiAgICAgICAgICBhcHBsaWNhdGlvbnMucmVkdWNlKChzdW0sIGEpID0+IHN1bSArIChhLmFtb3VudCB8fCAwKSwgMCkgLyBhcHBsaWNhdGlvbnMubGVuZ3RoLFxyXG4gICAgICAgIHJlY2VudEFjdGl2aXR5OlxyXG4gICAgICAgICAgYXBwbGljYXRpb25zLmxlbmd0aCA+IDBcclxuICAgICAgICAgICAgPyBEYXRlLm5vdygpIC0gbmV3IERhdGUoYXBwbGljYXRpb25zWzBdLnN1Ym1pdHRlZEF0KS5nZXRUaW1lKClcclxuICAgICAgICAgICAgOiAwLFxyXG4gICAgICB9O1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICB0b3RhbEFwcGxpY2F0aW9uczogMCxcclxuICAgICAgICBhbGxvdHRlZENvdW50OiAwLFxyXG4gICAgICAgIGF2ZXJhZ2VBbW91bnQ6IDAsXHJcbiAgICAgICAgcmVjZW50QWN0aXZpdHk6IDAsXHJcbiAgICAgIH07XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICB1cGRhdGVFbnNlbWJsZVdlaWdodChtb2RlbEtleSwgYWNjdXJhY3kpIHtcclxuICAgIGNvbnN0IGN1cnJlbnRXZWlnaHQgPSB0aGlzLmVuc2VtYmxlV2VpZ2h0cy5nZXQobW9kZWxLZXkpO1xyXG4gICAgY29uc3QgbmV3V2VpZ2h0ID0gY3VycmVudFdlaWdodCAqIDAuNyArIGFjY3VyYWN5ICogMC4zOyAvLyBXZWlnaHRlZCB1cGRhdGVcclxuICAgIHRoaXMuZW5zZW1ibGVXZWlnaHRzLnNldChtb2RlbEtleSwgbmV3V2VpZ2h0KTtcclxuXHJcbiAgICAvLyBOb3JtYWxpemUgd2VpZ2h0c1xyXG4gICAgY29uc3QgdG90YWxXZWlnaHQgPSBBcnJheS5mcm9tKHRoaXMuZW5zZW1ibGVXZWlnaHRzLnZhbHVlcygpKS5yZWR1Y2UoKGEsIGIpID0+IGEgKyBiLCAwKTtcclxuICAgIGZvciAoY29uc3QgW2tleSwgd2VpZ2h0XSBvZiB0aGlzLmVuc2VtYmxlV2VpZ2h0cykge1xyXG4gICAgICB0aGlzLmVuc2VtYmxlV2VpZ2h0cy5zZXQoa2V5LCB3ZWlnaHQgLyB0b3RhbFdlaWdodCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBNb2RlbCBwZXJzaXN0ZW5jZVxyXG4gIGFzeW5jIHNhdmVNb2RlbChtb2RlbEtleSwgbW9kZWwpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IG1vZGVsRGF0YSA9IHtcclxuICAgICAgICBtb2RlbEtleSxcclxuICAgICAgICB3ZWlnaHRzOiBPYmplY3QuZnJvbUVudHJpZXMobW9kZWwud2VpZ2h0cyksXHJcbiAgICAgICAgYmlhc2VzOiBPYmplY3QuZnJvbUVudHJpZXMobW9kZWwuYmlhc2VzKSxcclxuICAgICAgICBub3JtYWxpemVyczogT2JqZWN0LmZyb21FbnRyaWVzKG1vZGVsLm5vcm1hbGl6ZXJzKSxcclxuICAgICAgICBhY2N1cmFjeTogbW9kZWwuYWNjdXJhY3ksXHJcbiAgICAgICAgc2FtcGxlQ291bnQ6IG1vZGVsLnNhbXBsZUNvdW50LFxyXG4gICAgICAgIGxhc3RUcmFpbmVkOiBtb2RlbC5sYXN0VHJhaW5lZCxcclxuICAgICAgfTtcclxuXHJcbiAgICAgIGF3YWl0IGNhY2hlLnNldChcclxuICAgICAgICBjYWNoZS5rZXkoJ01PREVMJywgYHNhdmVkOiR7bW9kZWxLZXl9YCksXHJcbiAgICAgICAgbW9kZWxEYXRhLFxyXG4gICAgICAgIDcgKiAyNCAqIDYwICogNjAgLy8gNyBkYXlzXHJcbiAgICAgICk7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBzYXZpbmcgbW9kZWwgJHttb2RlbEtleX06YCwgZXJyb3IpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgYXN5bmMgbG9hZFNhdmVkTW9kZWwobW9kZWxLZXkpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IG1vZGVsRGF0YSA9IGF3YWl0IGNhY2hlLmdldChjYWNoZS5rZXkoJ01PREVMJywgYHNhdmVkOiR7bW9kZWxLZXl9YCkpO1xyXG5cclxuICAgICAgaWYgKG1vZGVsRGF0YSkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICB3ZWlnaHRzOiBuZXcgTWFwKE9iamVjdC5lbnRyaWVzKG1vZGVsRGF0YS53ZWlnaHRzKSksXHJcbiAgICAgICAgICBiaWFzZXM6IG5ldyBNYXAoT2JqZWN0LmVudHJpZXMobW9kZWxEYXRhLmJpYXNlcykpLFxyXG4gICAgICAgICAgbm9ybWFsaXplcnM6IG5ldyBNYXAoT2JqZWN0LmVudHJpZXMobW9kZWxEYXRhLm5vcm1hbGl6ZXJzKSksXHJcbiAgICAgICAgICBhY2N1cmFjeTogbW9kZWxEYXRhLmFjY3VyYWN5LFxyXG4gICAgICAgICAgc2FtcGxlQ291bnQ6IG1vZGVsRGF0YS5zYW1wbGVDb3VudCxcclxuICAgICAgICAgIGxhc3RUcmFpbmVkOiBuZXcgRGF0ZShtb2RlbERhdGEubGFzdFRyYWluZWQpLFxyXG4gICAgICAgIH07XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgbG9hZGluZyBtb2RlbCAke21vZGVsS2V5fTpgLCBlcnJvcik7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gTW9kZWwgdHJhaW5pbmcgc2NoZWR1bGVyXHJcbiAgc3RhcnRNb2RlbFRyYWluaW5nKCkge1xyXG4gICAgY29uc3QgdHJhaW5pbmdJbnRlcnZhbCA9IHNldEludGVydmFsKGFzeW5jICgpID0+IHtcclxuICAgICAgYXdhaXQgdGhpcy5zY2hlZHVsZWRNb2RlbFRyYWluaW5nKCk7XHJcbiAgICB9LCB0aGlzLnByZWRpY3Rpb25Db25maWcuVFJBSU5JTkdfSU5URVJWQUwpO1xyXG5cclxuICAgIHRoaXMuYWN0aXZlSW50ZXJ2YWxzLnNldCgnVFJBSU5JTkcnLCB0cmFpbmluZ0ludGVydmFsKTtcclxuXHJcbiAgICBjb25zb2xlLmxvZygn8J+OryBTdGFydGVkIG1vZGVsIHRyYWluaW5nIHNjaGVkdWxlcicpO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgc2NoZWR1bGVkTW9kZWxUcmFpbmluZygpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKCfwn5SEIFJ1bm5pbmcgc2NoZWR1bGVkIG1vZGVsIHRyYWluaW5nLi4uJyk7XHJcblxyXG4gICAgICAvLyBSZWxvYWQgdHJhaW5pbmcgZGF0YVxyXG4gICAgICBhd2FpdCB0aGlzLmxvYWRUcmFpbmluZ0RhdGEoKTtcclxuXHJcbiAgICAgIC8vIFRyYWluIG1vZGVscyB0aGF0IG5lZWQgdXBkYXRlc1xyXG4gICAgICBmb3IgKGNvbnN0IFttb2RlbEtleSwgbW9kZWxdIG9mIHRoaXMucHJlZGljdGlvbk1vZGVscykge1xyXG4gICAgICAgIGlmIChtb2RlbC5lbmFibGVkICYmIHRoaXMuc2hvdWxkUmV0cmFpbk1vZGVsKG1vZGVsKSkge1xyXG4gICAgICAgICAgYXdhaXQgdGhpcy50cmFpbk1vZGVsKG1vZGVsS2V5KTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMucGVyZm9ybWFuY2UudG90YWxUcmFpbmluZ1Nlc3Npb25zKys7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbiBzY2hlZHVsZWQgbW9kZWwgdHJhaW5pbmc6JywgZXJyb3IpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgc2hvdWxkUmV0cmFpbk1vZGVsKG1vZGVsKSB7XHJcbiAgICBpZiAoIW1vZGVsLmxhc3RUcmFpbmVkKSByZXR1cm4gdHJ1ZTtcclxuXHJcbiAgICBjb25zdCBkYXlzU2luY2VUcmFpbmluZyA9IChEYXRlLm5vdygpIC0gbW9kZWwubGFzdFRyYWluZWQuZ2V0VGltZSgpKSAvICgxMDAwICogNjAgKiA2MCAqIDI0KTtcclxuICAgIGNvbnN0IHRyYWluaW5nRGF0YVNpemUgPSB0aGlzLnRyYWluaW5nRGF0YS5nZXQobW9kZWwubmFtZSk/Lmxlbmd0aCB8fCAwO1xyXG5cclxuICAgIC8vIFJldHJhaW4gaWY6XHJcbiAgICAvLyAtIE1vZGVsIGhhc24ndCBiZWVuIHRyYWluZWQgaW4gNyBkYXlzXHJcbiAgICAvLyAtIFRyYWluaW5nIGRhdGEgaGFzIGdyb3duIHNpZ25pZmljYW50bHlcclxuICAgIC8vIC0gTW9kZWwgYWNjdXJhY3kgaXMgYmVsb3cgdGhyZXNob2xkXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICBkYXlzU2luY2VUcmFpbmluZyA+IDcgfHwgdHJhaW5pbmdEYXRhU2l6ZSA+IG1vZGVsLnNhbXBsZUNvdW50ICogMS4yIHx8IG1vZGVsLmFjY3VyYWN5IDwgMC42XHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgLy8gQWNjdXJhY3kgbW9uaXRvcmluZ1xyXG4gIHN0YXJ0QWNjdXJhY3lNb25pdG9yaW5nKCkge1xyXG4gICAgY29uc3QgYWNjdXJhY3lJbnRlcnZhbCA9IHNldEludGVydmFsKGFzeW5jICgpID0+IHtcclxuICAgICAgYXdhaXQgdGhpcy5jaGVja1ByZWRpY3Rpb25BY2N1cmFjeSgpO1xyXG4gICAgfSwgdGhpcy5wcmVkaWN0aW9uQ29uZmlnLkFDQ1VSQUNZX0NIRUNLX0lOVEVSVkFMKTtcclxuXHJcbiAgICB0aGlzLmFjdGl2ZUludGVydmFscy5zZXQoJ0FDQ1VSQUNZX0NIRUNLJywgYWNjdXJhY3lJbnRlcnZhbCk7XHJcblxyXG4gICAgY29uc29sZS5sb2coJ/Cfk4ogU3RhcnRlZCBhY2N1cmFjeSBtb25pdG9yaW5nJyk7XHJcbiAgfVxyXG5cclxuICBhc3luYyBjaGVja1ByZWRpY3Rpb25BY2N1cmFjeSgpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKCfwn5OKIENoZWNraW5nIHByZWRpY3Rpb24gYWNjdXJhY3kuLi4nKTtcclxuXHJcbiAgICAgIC8vIEdldCByZWNlbnQgcHJlZGljdGlvbnMgd2l0aCBhY3R1YWwgb3V0Y29tZXNcclxuICAgICAgY29uc3QgcmVjZW50UHJlZGljdGlvbnMgPSBhd2FpdCBwcmlzbWEucHJlZGljdGlvbi5maW5kTWFueSh7XHJcbiAgICAgICAgd2hlcmU6IHtcclxuICAgICAgICAgIGNyZWF0ZWRBdDoge1xyXG4gICAgICAgICAgICBndGU6IG5ldyBEYXRlKERhdGUubm93KCkgLSA3ICogMjQgKiA2MCAqIDYwICogMTAwMCksIC8vIExhc3QgNyBkYXlzXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaW5jbHVkZToge1xyXG4gICAgICAgICAgaXBvOiB7XHJcbiAgICAgICAgICAgIHNlbGVjdDogeyBsaXN0aW5nUHJpY2U6IHRydWUsIG1heFByaWNlOiB0cnVlLCBzdGF0dXM6IHRydWUgfSxcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgfSxcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBjb25zdCBhY2N1cmFjeUJ5TW9kZWwgPSBuZXcgTWFwKCk7XHJcblxyXG4gICAgICBmb3IgKGNvbnN0IHByZWRpY3Rpb24gb2YgcmVjZW50UHJlZGljdGlvbnMpIHtcclxuICAgICAgICBpZiAocHJlZGljdGlvbi5pcG8uc3RhdHVzID09PSAnbGlzdGVkJyAmJiBwcmVkaWN0aW9uLmlwby5saXN0aW5nUHJpY2UpIHtcclxuICAgICAgICAgIGNvbnN0IGFjdHVhbEdhaW4gPSB0aGlzLmNhbGN1bGF0ZUxpc3RpbmdHYWluKHByZWRpY3Rpb24uaXBvKTtcclxuXHJcbiAgICAgICAgICBpZiAoYWN0dWFsR2FpbiAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBjb25zdCBlcnJvciA9IE1hdGguYWJzKHByZWRpY3Rpb24ucHJlZGljdGVkVmFsdWUgLSBhY3R1YWxHYWluKTtcclxuICAgICAgICAgICAgY29uc3QgYWNjdXJhY3kgPSBNYXRoLm1heCgwLCAxIC0gZXJyb3IgLyAxMDApOyAvLyBDb252ZXJ0IHRvIDAtMSByYW5nZVxyXG5cclxuICAgICAgICAgICAgaWYgKCFhY2N1cmFjeUJ5TW9kZWwuaGFzKHByZWRpY3Rpb24ubW9kZWxUeXBlKSkge1xyXG4gICAgICAgICAgICAgIGFjY3VyYWN5QnlNb2RlbC5zZXQocHJlZGljdGlvbi5tb2RlbFR5cGUsIFtdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBhY2N1cmFjeUJ5TW9kZWwuZ2V0KHByZWRpY3Rpb24ubW9kZWxUeXBlKS5wdXNoKGFjY3VyYWN5KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFVwZGF0ZSBtb2RlbCBhY2N1cmFjaWVzXHJcbiAgICAgIGZvciAoY29uc3QgW21vZGVsS2V5LCBhY2N1cmFjaWVzXSBvZiBhY2N1cmFjeUJ5TW9kZWwpIHtcclxuICAgICAgICBjb25zdCBhdmdBY2N1cmFjeSA9IGFjY3VyYWNpZXMucmVkdWNlKChhLCBiKSA9PiBhICsgYiwgMCkgLyBhY2N1cmFjaWVzLmxlbmd0aDtcclxuICAgICAgICBjb25zdCBtb2RlbCA9IHRoaXMucHJlZGljdGlvbk1vZGVscy5nZXQobW9kZWxLZXkpO1xyXG4gICAgICAgIGlmIChtb2RlbCkge1xyXG4gICAgICAgICAgbW9kZWwuYWNjdXJhY3kgPSBhdmdBY2N1cmFjeTtcclxuICAgICAgICAgIHRoaXMudXBkYXRlRW5zZW1ibGVXZWlnaHQobW9kZWxLZXksIGF2Z0FjY3VyYWN5KTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMucGVyZm9ybWFuY2UubGFzdEFjY3VyYWN5Q2hlY2sgPSBEYXRlLm5vdygpO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgY2hlY2tpbmcgcHJlZGljdGlvbiBhY2N1cmFjeTonLCBlcnJvcik7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBQZXJmb3JtYW5jZSBtb25pdG9yaW5nXHJcbiAgc3RhcnRQZXJmb3JtYW5jZU1vbml0b3JpbmcoKSB7XHJcbiAgICBjb25zdCBwZXJmb3JtYW5jZUludGVydmFsID0gc2V0SW50ZXJ2YWwoXHJcbiAgICAgICgpID0+IHtcclxuICAgICAgICB0aGlzLmxvZ1BlcmZvcm1hbmNlTWV0cmljcygpO1xyXG4gICAgICB9LFxyXG4gICAgICA1ICogNjAgKiAxMDAwXHJcbiAgICApOyAvLyBFdmVyeSA1IG1pbnV0ZXNcclxuXHJcbiAgICB0aGlzLmFjdGl2ZUludGVydmFscy5zZXQoJ1BFUkZPUk1BTkNFJywgcGVyZm9ybWFuY2VJbnRlcnZhbCk7XHJcblxyXG4gICAgY29uc29sZS5sb2coJ/Cfk4ogU3RhcnRlZCBwcmVkaWN0aW9uIHBlcmZvcm1hbmNlIG1vbml0b3JpbmcnKTtcclxuICB9XHJcblxyXG4gIHVwZGF0ZVRyYWluaW5nTWV0cmljcyh0cmFpbmluZ1RpbWUpIHtcclxuICAgIHRoaXMucGVyZm9ybWFuY2UuYXZlcmFnZVRyYWluaW5nVGltZSA9XHJcbiAgICAgICh0aGlzLnBlcmZvcm1hbmNlLmF2ZXJhZ2VUcmFpbmluZ1RpbWUgKiB0aGlzLnBlcmZvcm1hbmNlLnRvdGFsVHJhaW5pbmdTZXNzaW9ucyArXHJcbiAgICAgICAgdHJhaW5pbmdUaW1lKSAvXHJcbiAgICAgICh0aGlzLnBlcmZvcm1hbmNlLnRvdGFsVHJhaW5pbmdTZXNzaW9ucyArIDEpO1xyXG4gIH1cclxuXHJcbiAgbG9nUGVyZm9ybWFuY2VNZXRyaWNzKCkge1xyXG4gICAgY29uc3QgbWV0cmljcyA9IHRoaXMuZ2V0UGVyZm9ybWFuY2VNZXRyaWNzKCk7XHJcbiAgICBjb25zb2xlLmxvZygn8J+TiiBQcmVkaWN0aW9uIFNlcnZpY2UgUGVyZm9ybWFuY2U6JywgbWV0cmljcyk7XHJcblxyXG4gICAgLy8gU3RvcmUgbWV0cmljcyBpbiBjYWNoZVxyXG4gICAgY2FjaGUuc2V0KCdwcmVkaWN0aW9uX3NlcnZpY2VfbWV0cmljcycsIG1ldHJpY3MsIDMwMCk7XHJcbiAgfVxyXG5cclxuICBnZXRQZXJmb3JtYW5jZU1ldHJpY3MoKSB7XHJcbiAgICBjb25zdCBvdmVyYWxsQWNjdXJhY3kgPSB0aGlzLmdldE92ZXJhbGxBY2N1cmFjeSgpO1xyXG4gICAgY29uc3QgbW9kZWxTdGF0dXMgPSB7fTtcclxuXHJcbiAgICBmb3IgKGNvbnN0IFttb2RlbEtleSwgbW9kZWxdIG9mIHRoaXMucHJlZGljdGlvbk1vZGVscykge1xyXG4gICAgICBtb2RlbFN0YXR1c1ttb2RlbEtleV0gPSB7XHJcbiAgICAgICAgYWNjdXJhY3k6IG1vZGVsLmFjY3VyYWN5LFxyXG4gICAgICAgIGlzUmVhZHk6IG1vZGVsLmlzUmVhZHksXHJcbiAgICAgICAgc2FtcGxlQ291bnQ6IG1vZGVsLnNhbXBsZUNvdW50LFxyXG4gICAgICAgIGxhc3RUcmFpbmVkOiBtb2RlbC5sYXN0VHJhaW5lZD8udG9JU09TdHJpbmcoKSxcclxuICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB0b3RhbFByZWRpY3Rpb25zOiB0aGlzLnBlcmZvcm1hbmNlLnRvdGFsUHJlZGljdGlvbnMsXHJcbiAgICAgIG92ZXJhbGxBY2N1cmFjeTogYCR7KG92ZXJhbGxBY2N1cmFjeSAqIDEwMCkudG9GaXhlZCgyKX0lYCxcclxuICAgICAgdG90YWxUcmFpbmluZ1Nlc3Npb25zOiB0aGlzLnBlcmZvcm1hbmNlLnRvdGFsVHJhaW5pbmdTZXNzaW9ucyxcclxuICAgICAgYXZlcmFnZVRyYWluaW5nVGltZTogTWF0aC5yb3VuZCh0aGlzLnBlcmZvcm1hbmNlLmF2ZXJhZ2VUcmFpbmluZ1RpbWUpLFxyXG4gICAgICBtb2RlbFVwZGF0ZXM6IHRoaXMucGVyZm9ybWFuY2UubW9kZWxVcGRhdGVzLFxyXG4gICAgICBhY3RpdmVQcmVkaWN0aW9uczogdGhpcy5wcmVkaWN0aW9uQ2FjaGUuc2l6ZSxcclxuICAgICAgbW9kZWxTdGF0dXMsXHJcbiAgICAgIGxhc3RBY2N1cmFjeUNoZWNrOiB0aGlzLnBlcmZvcm1hbmNlLmxhc3RBY2N1cmFjeUNoZWNrXHJcbiAgICAgICAgPyBuZXcgRGF0ZSh0aGlzLnBlcmZvcm1hbmNlLmxhc3RBY2N1cmFjeUNoZWNrKS50b0lTT1N0cmluZygpXHJcbiAgICAgICAgOiBudWxsLFxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIGdldE92ZXJhbGxBY2N1cmFjeSgpIHtcclxuICAgIGNvbnN0IGFjY3VyYWNpZXMgPSBBcnJheS5mcm9tKHRoaXMucHJlZGljdGlvbk1vZGVscy52YWx1ZXMoKSlcclxuICAgICAgLmZpbHRlcigobW9kZWwpID0+IG1vZGVsLmlzUmVhZHkpXHJcbiAgICAgIC5tYXAoKG1vZGVsKSA9PiBtb2RlbC5hY2N1cmFjeSk7XHJcblxyXG4gICAgcmV0dXJuIGFjY3VyYWNpZXMubGVuZ3RoID4gMCA/IGFjY3VyYWNpZXMucmVkdWNlKChhLCBiKSA9PiBhICsgYiwgMCkgLyBhY2N1cmFjaWVzLmxlbmd0aCA6IDA7XHJcbiAgfVxyXG5cclxuICAvLyBNYWludGVuYW5jZSB0YXNrc1xyXG4gIHN0YXJ0TWFpbnRlbmFuY2VUYXNrcygpIHtcclxuICAgIGNvbnN0IG1haW50ZW5hbmNlSW50ZXJ2YWwgPSBzZXRJbnRlcnZhbChcclxuICAgICAgKCkgPT4ge1xyXG4gICAgICAgIHRoaXMucGVyZm9ybU1haW50ZW5hbmNlKCk7XHJcbiAgICAgIH0sXHJcbiAgICAgIDYwICogNjAgKiAxMDAwXHJcbiAgICApOyAvLyBFdmVyeSBob3VyXHJcblxyXG4gICAgdGhpcy5hY3RpdmVJbnRlcnZhbHMuc2V0KCdNQUlOVEVOQU5DRScsIG1haW50ZW5hbmNlSW50ZXJ2YWwpO1xyXG5cclxuICAgIGNvbnNvbGUubG9nKCfwn6e5IFN0YXJ0ZWQgcHJlZGljdGlvbiBzZXJ2aWNlIG1haW50ZW5hbmNlIHRhc2tzJyk7XHJcbiAgfVxyXG5cclxuICBwZXJmb3JtTWFpbnRlbmFuY2UoKSB7XHJcbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xyXG5cclxuICAgIC8vIENsZWFuIHVwIG9sZCBjYWNoZWQgcHJlZGljdGlvbnNcclxuICAgIGZvciAoY29uc3QgW2NhY2hlS2V5LCBkYXRhXSBvZiB0aGlzLnByZWRpY3Rpb25DYWNoZSkge1xyXG4gICAgICBjb25zdCBtb2RlbEtleSA9IGNhY2hlS2V5LnNwbGl0KCc6JylbMV07XHJcbiAgICAgIGNvbnN0IHR0bCA9IHRoaXMuY2FjaGVUVExbbW9kZWxLZXldIHx8IDMwICogNjAgKiAxMDAwO1xyXG5cclxuICAgICAgaWYgKG5vdyAtIGRhdGEudGltZXN0YW1wID4gdHRsICogMikge1xyXG4gICAgICAgIC8vIEtlZXAgZm9yIDJ4IFRUTFxyXG4gICAgICAgIHRoaXMucHJlZGljdGlvbkNhY2hlLmRlbGV0ZShjYWNoZUtleSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBDbGVhbiB1cCBvbGQgbW9kZWwgdHJhaW5pbmcgaGlzdG9yeVxyXG4gICAgZm9yIChjb25zdCBtb2RlbCBvZiB0aGlzLnByZWRpY3Rpb25Nb2RlbHMudmFsdWVzKCkpIHtcclxuICAgICAgaWYgKG1vZGVsLnRyYWluaW5nSGlzdG9yeS5sZW5ndGggPiAxMDApIHtcclxuICAgICAgICBtb2RlbC50cmFpbmluZ0hpc3RvcnkgPSBtb2RlbC50cmFpbmluZ0hpc3Rvcnkuc2xpY2UoLTUwKTsgLy8gS2VlcCBsYXN0IDUwXHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBjb25zb2xlLmxvZygn8J+nuSBQcmVkaWN0aW9uIHNlcnZpY2UgbWFpbnRlbmFuY2UgY29tcGxldGVkJyk7XHJcbiAgfVxyXG5cclxuICAvLyBTZXJ2aWNlIHN0YXR1cyBhbmQgaGVhbHRoIGNoZWNrXHJcbiAgZ2V0U3RhdHVzKCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgaXNSdW5uaW5nOiB0aGlzLmlzUnVubmluZyxcclxuICAgICAgbW9kZWxzOiBPYmplY3Qua2V5cyh0aGlzLm1vZGVscykubGVuZ3RoLFxyXG4gICAgICByZWFkeU1vZGVsczogQXJyYXkuZnJvbSh0aGlzLnByZWRpY3Rpb25Nb2RlbHMudmFsdWVzKCkpLmZpbHRlcigobSkgPT4gbS5pc1JlYWR5KS5sZW5ndGgsXHJcbiAgICAgIHBlcmZvcm1hbmNlOiB0aGlzLmdldFBlcmZvcm1hbmNlTWV0cmljcygpLFxyXG4gICAgICBhY3RpdmVQcmVkaWN0aW9uczogdGhpcy5wcmVkaWN0aW9uQ2FjaGUuc2l6ZSxcclxuICAgICAgZW5zZW1ibGVXZWlnaHRzOiBPYmplY3QuZnJvbUVudHJpZXModGhpcy5lbnNlbWJsZVdlaWdodHMpLFxyXG4gICAgICBhY3RpdmVJbnRlcnZhbHM6IHRoaXMuYWN0aXZlSW50ZXJ2YWxzLnNpemUsXHJcbiAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIGFzeW5jIGhlYWx0aENoZWNrKCkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgLy8gQ2hlY2sgbW9kZWwgcmVhZGluZXNzXHJcbiAgICAgIGNvbnN0IHJlYWR5TW9kZWxzID0gQXJyYXkuZnJvbSh0aGlzLnByZWRpY3Rpb25Nb2RlbHMudmFsdWVzKCkpLmZpbHRlcihcclxuICAgICAgICAobSkgPT4gbS5pc1JlYWR5XHJcbiAgICAgICkubGVuZ3RoO1xyXG4gICAgICBjb25zdCB0b3RhbE1vZGVscyA9IHRoaXMucHJlZGljdGlvbk1vZGVscy5zaXplO1xyXG5cclxuICAgICAgLy8gQ2hlY2sgZGF0YWJhc2UgY29ubmVjdGl2aXR5XHJcbiAgICAgIGNvbnN0IGRiQ2hlY2sgPSBhd2FpdCBwcmlzbWEucHJlZGljdGlvbi5maW5kRmlyc3QoKTtcclxuXHJcbiAgICAgIC8vIENoZWNrIGNhY2hlIGNvbm5lY3Rpdml0eVxyXG4gICAgICBjb25zdCBjYWNoZUNoZWNrID0gYXdhaXQgY2FjaGUuaGVhbHRoQ2hlY2soKTtcclxuXHJcbiAgICAgIGNvbnN0IGlzSGVhbHRoeSA9XHJcbiAgICAgICAgdGhpcy5pc1J1bm5pbmcgJiZcclxuICAgICAgICByZWFkeU1vZGVscyA+IDAgJiZcclxuICAgICAgICBkYkNoZWNrICE9PSB1bmRlZmluZWQgJiZcclxuICAgICAgICBjYWNoZUNoZWNrLnN0YXR1cyA9PT0gJ2hlYWx0aHknO1xyXG5cclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBzdGF0dXM6IGlzSGVhbHRoeSA/ICdoZWFsdGh5JyA6ICdkZWdyYWRlZCcsXHJcbiAgICAgICAgaXNSdW5uaW5nOiB0aGlzLmlzUnVubmluZyxcclxuICAgICAgICBkYXRhYmFzZTogZGJDaGVjayAhPT0gdW5kZWZpbmVkID8gJ2Nvbm5lY3RlZCcgOiAnZGlzY29ubmVjdGVkJyxcclxuICAgICAgICBjYWNoZTogY2FjaGVDaGVjay5zdGF0dXMsXHJcbiAgICAgICAgbW9kZWxzOiB7XHJcbiAgICAgICAgICB0b3RhbDogdG90YWxNb2RlbHMsXHJcbiAgICAgICAgICByZWFkeTogcmVhZHlNb2RlbHMsXHJcbiAgICAgICAgICByZWFkaW5lc3M6IGAke3JlYWR5TW9kZWxzfS8ke3RvdGFsTW9kZWxzfWAsXHJcbiAgICAgICAgfSxcclxuICAgICAgICBwZXJmb3JtYW5jZTogdGhpcy5nZXRQZXJmb3JtYW5jZU1ldHJpY3MoKSxcclxuICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcclxuICAgICAgfTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgc3RhdHVzOiAndW5oZWFsdGh5JyxcclxuICAgICAgICBlcnJvcjogZXJyb3IubWVzc2FnZSxcclxuICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcclxuICAgICAgfTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIFN0b3Agc2VydmljZSBncmFjZWZ1bGx5XHJcbiAgYXN5bmMgc3RvcCgpIHtcclxuICAgIGNvbnNvbGUubG9nKCfwn5uRIFN0b3BwaW5nIFByZWRpY3Rpb24gU2VydmljZS4uLicpO1xyXG5cclxuICAgIHRoaXMuaXNSdW5uaW5nID0gZmFsc2U7XHJcblxyXG4gICAgLy8gQ2xlYXIgYWxsIGFjdGl2ZSBpbnRlcnZhbHNcclxuICAgIGZvciAoY29uc3QgW25hbWUsIGludGVydmFsSWRdIG9mIHRoaXMuYWN0aXZlSW50ZXJ2YWxzKSB7XHJcbiAgICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWxJZCk7XHJcbiAgICAgIGNvbnNvbGUubG9nKGDij7nvuI8gIFN0b3BwZWQgJHtuYW1lfSBpbnRlcnZhbGApO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuYWN0aXZlSW50ZXJ2YWxzLmNsZWFyKCk7XHJcblxyXG4gICAgLy8gU2F2ZSBhbGwgbW9kZWxzXHJcbiAgICBmb3IgKGNvbnN0IFttb2RlbEtleSwgbW9kZWxdIG9mIHRoaXMucHJlZGljdGlvbk1vZGVscykge1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGlmIChtb2RlbC5pc1JlYWR5KSB7XHJcbiAgICAgICAgICBhd2FpdCB0aGlzLnNhdmVNb2RlbChtb2RlbEtleSwgbW9kZWwpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBzYXZpbmcgbW9kZWwgJHttb2RlbEtleX06YCwgZXJyb3IpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQnJvYWRjYXN0IHNodXRkb3duIG5vdGlmaWNhdGlvblxyXG4gICAgdHJ5IHtcclxuICAgICAgYXdhaXQgd2ViU29ja2V0U2VydmljZS5icm9hZGNhc3RTeXN0ZW1TdGF0dXMoXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgdHlwZTogJ3ByZWRpY3Rpb25fc2VydmljZV9zaHV0ZG93bicsXHJcbiAgICAgICAgICBtZXNzYWdlOiAnUHJlZGljdGlvbiBzZXJ2aWNlIGhhcyBiZWVuIHN0b3BwZWQnLFxyXG4gICAgICAgICAgZmluYWxNZXRyaWNzOiB0aGlzLmdldFBlcmZvcm1hbmNlTWV0cmljcygpLFxyXG4gICAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgeyBwcmlvcml0eTogJ2hpZ2gnIH1cclxuICAgICAgKTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGJyb2FkY2FzdGluZyBzaHV0ZG93bjonLCBlcnJvcik7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ2xlYXIgZGF0YSBzdHJ1Y3R1cmVzXHJcbiAgICB0aGlzLnByZWRpY3Rpb25Nb2RlbHMuY2xlYXIoKTtcclxuICAgIHRoaXMudHJhaW5pbmdEYXRhLmNsZWFyKCk7XHJcbiAgICB0aGlzLm1vZGVsQWNjdXJhY3kuY2xlYXIoKTtcclxuICAgIHRoaXMuYWN0aXZlUHJlZGljdGlvbnMuY2xlYXIoKTtcclxuICAgIHRoaXMucHJlZGljdGlvbkNhY2hlLmNsZWFyKCk7XHJcbiAgICB0aGlzLmZlYXR1cmVQcm9jZXNzb3JzLmNsZWFyKCk7XHJcbiAgICB0aGlzLmVuc2VtYmxlV2VpZ2h0cy5jbGVhcigpO1xyXG5cclxuICAgIGNvbnNvbGUubG9nKCfinIUgUHJlZGljdGlvbiBTZXJ2aWNlIHN0b3BwZWQgZ3JhY2VmdWxseScpO1xyXG4gICAgY29uc29sZS5sb2coJ/Cfk4ogRmluYWwgUGVyZm9ybWFuY2UgTWV0cmljczonLCB0aGlzLmdldFBlcmZvcm1hbmNlTWV0cmljcygpKTtcclxuICB9XHJcbn1cclxuXHJcbi8vIEV4cG9ydCBzaW5nbGV0b24gaW5zdGFuY2VcclxuZXhwb3J0IGNvbnN0IHByZWRpY3Rpb25TZXJ2aWNlID0gbmV3IFByZWRpY3Rpb25TZXJ2aWNlKCk7XHJcblxyXG4vLyBBdXRvLXN0YXJ0IGlmIG5vdCBpbiB0ZXN0IGVudmlyb25tZW50XHJcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Rlc3QnICYmIHByb2Nlc3MuZW52LkFVVE9fU1RBUlRfUFJFRElDVElPTl9TRVJWSUNFICE9PSAnZmFsc2UnKSB7XHJcbiAgcHJlZGljdGlvblNlcnZpY2Uuc3RhcnQoKS5jYXRjaCgoZXJyb3IpID0+IHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBhdXRvLXN0YXJ0IFByZWRpY3Rpb24gU2VydmljZTonLCBlcnJvcik7XHJcbiAgICBwcm9jZXNzLmV4aXQoMSk7XHJcbiAgfSk7XHJcbn1cclxuXHJcbi8vIEdyYWNlZnVsIHNodXRkb3duIGhhbmRsZXJzXHJcbmNvbnN0IGdyYWNlZnVsU2h1dGRvd24gPSBhc3luYyAoc2lnbmFsKSA9PiB7XHJcbiAgY29uc29sZS5sb2coYPCfm5EgUmVjZWl2ZWQgJHtzaWduYWx9LCBzaHV0dGluZyBkb3duIFByZWRpY3Rpb24gU2VydmljZSBncmFjZWZ1bGx5Li4uYCk7XHJcbiAgdHJ5IHtcclxuICAgIGF3YWl0IHByZWRpY3Rpb25TZXJ2aWNlLnN0b3AoKTtcclxuICAgIHByb2Nlc3MuZXhpdCgwKTtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZHVyaW5nIGdyYWNlZnVsIHNodXRkb3duOicsIGVycm9yKTtcclxuICAgIHByb2Nlc3MuZXhpdCgxKTtcclxuICB9XHJcbn07XHJcblxyXG5wcm9jZXNzLm9uKCdTSUdURVJNJywgKCkgPT4gZ3JhY2VmdWxTaHV0ZG93bignU0lHVEVSTScpKTtcclxucHJvY2Vzcy5vbignU0lHSU5UJywgKCkgPT4gZ3JhY2VmdWxTaHV0ZG93bignU0lHSU5UJykpO1xyXG5wcm9jZXNzLm9uKCdTSUdRVUlUJywgKCkgPT4gZ3JhY2VmdWxTaHV0ZG93bignU0lHUVVJVCcpKTtcclxuXHJcbi8vIEV4cG9ydCBhZGRpdGlvbmFsIHV0aWxpdGllc1xyXG5leHBvcnQgY29uc3Qge1xyXG4gIHByZWRpY3RMaXN0aW5nR2FpbixcclxuICBwcmVkaWN0QWxsb3RtZW50UHJvYmFiaWxpdHksXHJcbiAgcHJlZGljdFN1YnNjcmlwdGlvblRyZW5kLFxyXG4gIHByZWRpY3RHTVBQcmljZSxcclxuICBwcmVkaWN0TWFya2V0U2VudGltZW50LFxyXG4gIHByZWRpY3RJUE9TdWNjZXNzLFxyXG4gIGdldEVuc2VtYmxlUHJlZGljdGlvbixcclxufSA9IHByZWRpY3Rpb25TZXJ2aWNlO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgcHJlZGljdGlvblNlcnZpY2U7XHJcbiJdLCJuYW1lcyI6WyJjYWNoZSIsInByaXNtYSIsIndlYlNvY2tldFNlcnZpY2UiLCJhbmFseXRpY3NTZXJ2aWNlIiwiUHJlZGljdGlvblNlcnZpY2UiLCJjb25zdHJ1Y3RvciIsImlzUnVubmluZyIsInByZWRpY3Rpb25Nb2RlbHMiLCJNYXAiLCJ0cmFpbmluZ0RhdGEiLCJtb2RlbEFjY3VyYWN5IiwiYWN0aXZlUHJlZGljdGlvbnMiLCJwcmVkaWN0aW9uQ29uZmlnIiwiVVBEQVRFX0lOVEVSVkFMIiwiVFJBSU5JTkdfSU5URVJWQUwiLCJBQ0NVUkFDWV9DSEVDS19JTlRFUlZBTCIsIk1JTl9UUkFJTklOR19EQVRBIiwiQ09ORklERU5DRV9USFJFU0hPTEQiLCJQUkVESUNUSU9OX0hPUklaT04iLCJNQVhfUkVUUklFUyIsIm1vZGVscyIsIkxJU1RJTkdfR0FJTiIsIm5hbWUiLCJ0eXBlIiwiZmVhdHVyZXMiLCJ0YXJnZXQiLCJhY2N1cmFjeSIsImxhc3RUcmFpbmVkIiwic2FtcGxlQ291bnQiLCJlbmFibGVkIiwiQUxMT1RNRU5UX1BST0JBQklMSVRZIiwiU1VCU0NSSVBUSU9OX1RSRU5EIiwiR01QX1BSRURJQ1RJT04iLCJNQVJLRVRfU0VOVElNRU5UIiwiSVBPX1NVQ0NFU1MiLCJwZXJmb3JtYW5jZSIsInRvdGFsUHJlZGljdGlvbnMiLCJhY2N1cmF0ZVByZWRpY3Rpb25zIiwidG90YWxUcmFpbmluZ1Nlc3Npb25zIiwiYXZlcmFnZVRyYWluaW5nVGltZSIsImF2ZXJhZ2VQcmVkaWN0aW9uVGltZSIsIm1vZGVsVXBkYXRlcyIsImxhc3RBY2N1cmFjeUNoZWNrIiwicHJlZGljdGlvbkNhY2hlIiwiY2FjaGVUVEwiLCJhY3RpdmVJbnRlcnZhbHMiLCJmZWF0dXJlUHJvY2Vzc29ycyIsImluaXRpYWxpemVGZWF0dXJlUHJvY2Vzc29ycyIsImVuc2VtYmxlV2VpZ2h0cyIsImluaXRpYWxpemVFbnNlbWJsZVdlaWdodHMiLCJjb25zb2xlIiwibG9nIiwic3RhcnQiLCJpbml0aWFsaXplUHJlZGljdGlvbk1vZGVscyIsImxvYWRUcmFpbmluZ0RhdGEiLCJ0cmFpbkFsbE1vZGVscyIsInN0YXJ0UHJlZGljdGlvbldvcmtmbG93cyIsInN0YXJ0TW9kZWxUcmFpbmluZyIsInN0YXJ0QWNjdXJhY3lNb25pdG9yaW5nIiwic3RhcnRQZXJmb3JtYW5jZU1vbml0b3JpbmciLCJzdGFydE1haW50ZW5hbmNlVGFza3MiLCJPYmplY3QiLCJrZXlzIiwibGVuZ3RoIiwiYnJvYWRjYXN0U3lzdGVtU3RhdHVzIiwiZ2V0T3ZlcmFsbEFjY3VyYWN5IiwidGltZXN0YW1wIiwiRGF0ZSIsIm5vdyIsImVycm9yIiwibW9kZWxLZXkiLCJtb2RlbENvbmZpZyIsImVudHJpZXMiLCJtb2RlbCIsIndlaWdodHMiLCJiaWFzZXMiLCJub3JtYWxpemVycyIsImZlYXR1cmVJbXBvcnRhbmNlIiwidHJhaW5pbmdIaXN0b3J5IiwicHJlZGljdGlvbnMiLCJsYXN0UHJlZGljdGlvbiIsImlzUmVhZHkiLCJzYXZlZE1vZGVsIiwibG9hZFNhdmVkTW9kZWwiLCJhc3NpZ24iLCJzZXQiLCJzaXplIiwiaXBvcyIsImlQTyIsImZpbmRNYW55Iiwid2hlcmUiLCJzdGF0dXMiLCJsaXN0aW5nRGF0ZSIsIm5vdCIsImluY2x1ZGUiLCJnbXBEYXRhIiwib3JkZXJCeSIsInN1YnNjcmlwdGlvbkRhdGEiLCJhbGxvdG1lbnREYXRhIiwiYW5hbHl0aWNzIiwid2F0Y2hsaXN0cyIsImFsZXJ0cyIsInRyYWluaW5nU2V0IiwicHJlcGFyZVRyYWluaW5nRGF0YSIsImdldCIsImlwbyIsImV4dHJhY3RGZWF0dXJlcyIsImV4dHJhY3RUYXJnZXQiLCJ1bmRlZmluZWQiLCJwdXNoIiwiaWQiLCJzeW1ib2wiLCJtZXRhZGF0YSIsImlzc3VlU2l6ZSIsInNlY3RvciIsInJlZ2lzdHJhciIsInZhbGlkYXRlVHJhaW5pbmdEYXRhIiwiZmVhdHVyZU5hbWUiLCJwcm9jZXNzb3IiLCJleHRyYWN0QmFzaWNGZWF0dXJlIiwiY2FsY3VsYXRlTGlzdGluZ0dhaW4iLCJnZXRBbGxvdG1lbnRTdGF0dXMiLCJnZXRGaW5hbFN1YnNjcmlwdGlvblJhdGlvIiwiZ2V0TmV4dEdNUFZhbHVlIiwiZ2V0U2VudGltZW50U2NvcmUiLCJnZXRJUE9TdWNjZXNzQ2F0ZWdvcnkiLCJnbXBWYWx1ZXMiLCJnbXAiLCJtYXAiLCJnIiwidmFsdWUiLCJyZWR1Y2UiLCJhIiwiYiIsIm1lYW4iLCJ2YXJpYW5jZSIsInN1bSIsInZhbCIsIk1hdGgiLCJwb3ciLCJzcXJ0IiwicmVjZW50QXZnIiwic2xpY2UiLCJvbGRlckF2ZyIsImxhdGVzdCIsInN1YnNjcmlwdGlvbiIsInN1YnNjcmlwdGlvblJhdGlvIiwicWliU3ViIiwiZmluZCIsInMiLCJjYXRlZ29yeSIsInJldGFpbFN1YiIsIm9wZW5EYXRlIiwiY2VpbCIsInJhbmRvbSIsIk51bWJlciIsIm1heFByaWNlIiwibWluUHJpY2UiLCJtb2RlbENvdW50IiwiYmFzZVdlaWdodCIsInRyYWluTW9kZWwiLCJzdGFydFRpbWUiLCJ3YXJuIiwic3BsaXRJbmRleCIsImZsb29yIiwidHJhaW5TZXQiLCJ2YWxpZGF0aW9uU2V0IiwiY2FsY3VsYXRlTm9ybWFsaXplcnMiLCJ0cmFpbmVkV2VpZ2h0cyIsInRyYWluUmVncmVzc2lvbk1vZGVsIiwidHJhaW5DbGFzc2lmaWNhdGlvbk1vZGVsIiwidHJhaW5UaW1lU2VyaWVzTW9kZWwiLCJFcnJvciIsInZhbGlkYXRlTW9kZWwiLCJ0cmFpbmluZ1RpbWUiLCJzYXZlTW9kZWwiLCJ1cGRhdGVFbnNlbWJsZVdlaWdodCIsInVwZGF0ZVRyYWluaW5nTWV0cmljcyIsInRvRml4ZWQiLCJmZWF0dXJlTmFtZXMiLCJtIiwibiIsImZvckVhY2giLCJiaWFzIiwibGVhcm5pbmdSYXRlIiwiZXBvY2hzIiwiZXBvY2giLCJ0b3RhbExvc3MiLCJncmFkaWVudHMiLCJiaWFzR3JhZGllbnQiLCJzYW1wbGUiLCJub3JtYWxpemVkRmVhdHVyZXMiLCJub3JtYWxpemVGZWF0dXJlcyIsInByZWRpY3Rpb24iLCJjdXJyZW50V2VpZ2h0IiwiYXZnTG9zcyIsImNsYXNzZXMiLCJTZXQiLCJudW1DbGFzc2VzIiwidHJhaW5CaW5hcnlDbGFzc2lmaWVyIiwiY2xhc3NpZmllcldlaWdodHMiLCJjbGFzc2lmaWVyQmlhc2VzIiwidGFyZ2V0Q2xhc3MiLCJiaW5hcnlUcmFpblNldCIsInoiLCJleHAiLCJ3aW5kb3dTaXplcyIsInRvdGFsRXJyb3IiLCJ3aW5kb3dTaXplIiwid2luZG93RXJyb3IiLCJ3aW5kb3dTYW1wbGVzIiwiaSIsImhpc3RvcmljYWxWYWx1ZXMiLCJtb3ZpbmdBdmVyYWdlIiwiYWN0dWFsVmFsdWUiLCJhYnMiLCJhdmdFcnJvciIsIkluZmluaXR5IiwidG90YWxXZWlnaHQiLCJBcnJheSIsImZyb20iLCJ2YWx1ZXMiLCJrZXkiLCJ3ZWlnaHQiLCJjb3JyZWN0UHJlZGljdGlvbnMiLCJtYWtlU2luZ2xlUHJlZGljdGlvbiIsIm1hZSIsIm1heCIsInByZWRpY3RSZWdyZXNzaW9uIiwicHJlZGljdENsYXNzaWZpY2F0aW9uIiwicHJlZGljdFRpbWVTZXJpZXMiLCJjb25maWRlbmNlIiwibWluIiwiY2xhc3NTY29yZXMiLCJjbGFzc05hbWUiLCJjbGFzc1dlaWdodHMiLCJzY29yZSIsInByb2JhYmlsaXR5IiwiYmVzdENsYXNzIiwicHJvYmFiaWxpdGllcyIsImZyb21FbnRyaWVzIiwib3JpZ2luYWxGZWF0dXJlcyIsIndlaWdodEtleSIsInN0YXJ0c1dpdGgiLCJwYXJzZUludCIsInNwbGl0IiwiY3VycmVudFZhbHVlIiwiaGlzdG9yaWNhbEdNUCIsInRyZW5kRmFjdG9yIiwicHJlZGljdGlvbkludGVydmFsIiwic2V0SW50ZXJ2YWwiLCJ1cGRhdGVSZWFsVGltZVByZWRpY3Rpb25zIiwiYWN0aXZlSVBPcyIsImlzQWN0aXZlIiwiaW4iLCJ0YWtlIiwicHJlZGljdGlvbnNVcGRhdGVkIiwidXBkYXRlSVBPUHJlZGljdGlvbiIsImNhY2hlS2V5IiwiY2FjaGVkIiwic3RvcmVQcmVkaWN0aW9uIiwiYnJvYWRjYXN0UHJlZGljdGlvblVwZGF0ZSIsImlwb0lkIiwidXBzZXJ0IiwiaXBvSWRfbW9kZWxUeXBlIiwibW9kZWxUeXBlIiwidXBkYXRlIiwicHJlZGljdGVkVmFsdWUiLCJKU09OIiwic3RyaW5naWZ5IiwidXBkYXRlZEF0IiwiY3JlYXRlIiwiY3JlYXRlZEF0IiwidXBkYXRlRGF0YSIsImJyb2FkY2FzdEFuYWx5dGljc1VwZGF0ZSIsInByZWRpY3RMaXN0aW5nR2FpbiIsImdldFByZWRpY3Rpb24iLCJwcmVkaWN0QWxsb3RtZW50UHJvYmFiaWxpdHkiLCJ1c2VySWQiLCJhcHBsaWNhdGlvbkRhdGEiLCJ1c2VySGlzdG9yeSIsImdldFVzZXJIaXN0b3J5IiwiYXBwbGljYXRpb25UaW1lIiwicHJlZGljdFN1YnNjcmlwdGlvblRyZW5kIiwicHJlZGljdEdNUFByaWNlIiwiaG9yaXpvbiIsInByZWRpY3RNYXJrZXRTZW50aW1lbnQiLCJwcmVkaWN0SVBPU3VjY2VzcyIsImdldEVuc2VtYmxlUHJlZGljdGlvbiIsInByZWRpY3Rpb25UeXBlIiwicmVsZXZhbnRNb2RlbHMiLCJnZXRSZWxldmFudE1vZGVscyIsIm1lc3NhZ2UiLCJlbnNlbWJsZVZhbHVlIiwiZW5zZW1ibGVDb25maWRlbmNlIiwibm9ybWFsaXplZFdlaWdodCIsInAiLCJlbnNlbWJsZSIsImZpbmRVbmlxdWUiLCJmaWx0ZXIiLCJ2Iiwic3RkIiwibm9ybWFsaXplZCIsIm5vcm0iLCJsb3RTaXplIiwiZmFjZVZhbHVlIiwibGlzdGluZ1ByaWNlIiwiZmluYWxTdWIiLCJnYWluIiwicmVxdWlyZWRGZWF0dXJlcyIsImV2ZXJ5IiwiZmVhdHVyZSIsImlzTmFOIiwibW9kZWxHcm91cHMiLCJsaXN0aW5nX3BlcmZvcm1hbmNlIiwic3Vic2NyaXB0aW9uX2FuYWx5c2lzIiwiYWxsb3RtZW50X2NoYW5jZXMiLCJvdmVyYWxsX3N1Y2Nlc3MiLCJhcHBsaWNhdGlvbnMiLCJ1c2VyQXBwbGljYXRpb24iLCJ0b3RhbEFwcGxpY2F0aW9ucyIsImFsbG90dGVkQ291bnQiLCJhbGxvdG1lbnRTdGF0dXMiLCJhdmVyYWdlQW1vdW50IiwiYW1vdW50IiwicmVjZW50QWN0aXZpdHkiLCJzdWJtaXR0ZWRBdCIsImdldFRpbWUiLCJuZXdXZWlnaHQiLCJtb2RlbERhdGEiLCJ0cmFpbmluZ0ludGVydmFsIiwic2NoZWR1bGVkTW9kZWxUcmFpbmluZyIsInNob3VsZFJldHJhaW5Nb2RlbCIsImRheXNTaW5jZVRyYWluaW5nIiwidHJhaW5pbmdEYXRhU2l6ZSIsImFjY3VyYWN5SW50ZXJ2YWwiLCJjaGVja1ByZWRpY3Rpb25BY2N1cmFjeSIsInJlY2VudFByZWRpY3Rpb25zIiwiZ3RlIiwic2VsZWN0IiwiYWNjdXJhY3lCeU1vZGVsIiwiYWN0dWFsR2FpbiIsImhhcyIsImFjY3VyYWNpZXMiLCJhdmdBY2N1cmFjeSIsInBlcmZvcm1hbmNlSW50ZXJ2YWwiLCJsb2dQZXJmb3JtYW5jZU1ldHJpY3MiLCJtZXRyaWNzIiwiZ2V0UGVyZm9ybWFuY2VNZXRyaWNzIiwib3ZlcmFsbEFjY3VyYWN5IiwibW9kZWxTdGF0dXMiLCJ0b0lTT1N0cmluZyIsInJvdW5kIiwibWFpbnRlbmFuY2VJbnRlcnZhbCIsInBlcmZvcm1NYWludGVuYW5jZSIsImRhdGEiLCJ0dGwiLCJkZWxldGUiLCJnZXRTdGF0dXMiLCJyZWFkeU1vZGVscyIsImhlYWx0aENoZWNrIiwidG90YWxNb2RlbHMiLCJkYkNoZWNrIiwiZmluZEZpcnN0IiwiY2FjaGVDaGVjayIsImlzSGVhbHRoeSIsImRhdGFiYXNlIiwidG90YWwiLCJyZWFkeSIsInJlYWRpbmVzcyIsInN0b3AiLCJpbnRlcnZhbElkIiwiY2xlYXJJbnRlcnZhbCIsImNsZWFyIiwiZmluYWxNZXRyaWNzIiwicHJpb3JpdHkiLCJwcmVkaWN0aW9uU2VydmljZSIsInByb2Nlc3MiLCJlbnYiLCJBVVRPX1NUQVJUX1BSRURJQ1RJT05fU0VSVklDRSIsImNhdGNoIiwiZXhpdCIsImdyYWNlZnVsU2h1dGRvd24iLCJzaWduYWwiLCJvbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./src/services/prediction-service.js\n");

/***/ })

};
;

// load runtime
var __webpack_require__ = require("../../../webpack-runtime.js");
__webpack_require__.C(exports);
var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
var __webpack_exports__ = __webpack_require__.X(0, ["vendor-chunks/next","vendor-chunks/@upstash","vendor-chunks/object-assign","vendor-chunks/ms","vendor-chunks/uncrypto","vendor-chunks/engine.io","vendor-chunks/socket.io","vendor-chunks/socket.io-adapter","vendor-chunks/socket.io-parser","vendor-chunks/engine.io-parser","vendor-chunks/cookie","vendor-chunks/cors","vendor-chunks/@socket.io","vendor-chunks/vary","vendor-chunks/supports-color","vendor-chunks/base64id","vendor-chunks/has-flag"], () => (__webpack_exec__("(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fipos%2Froute&page=%2Fapi%2Fipos%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fipos%2Froute.js&appDir=C%3A%5CUsers%5Chp%5COneDrive%5CDesktop%5CIPOs%5Cipo-tracker%5Csrc%5Capp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=C%3A%5CUsers%5Chp%5COneDrive%5CDesktop%5CIPOs%5Cipo-tracker&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D!")));
module.exports = __webpack_exports__;

})();